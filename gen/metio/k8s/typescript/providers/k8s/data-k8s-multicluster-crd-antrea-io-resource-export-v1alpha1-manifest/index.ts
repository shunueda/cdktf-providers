// https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestConfig extends cdktf.TerraformMetaArguments {
  /**
  * Data that helps uniquely identify this object. See https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#metadata DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#metadata}
  */
  readonly metadata: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadata;
  /**
  * ResourceExportSpec defines the desired state of ResourceExport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#spec DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#spec}
  */
  readonly spec?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpec;
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#annotations DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadataToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadataToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfos {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#gateway_ip DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#gateway_ip}
  */
  readonly gatewayIp?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfosToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfos | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gateway_ip: cdktf.stringToTerraform(struct!.gatewayIp),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfosToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfos | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gateway_ip: {
      value: cdktf.stringToHclTerraform(struct!.gatewayIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfosOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfos | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gatewayIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayIp = this._gatewayIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfos | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gatewayIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gatewayIp = value.gatewayIp;
    }
  }

  // gateway_ip - computed: false, optional: true, required: false
  private _gatewayIp?: string; 
  public get gatewayIp() {
    return this.getStringAttribute('gateway_ip');
  }
  public set gatewayIp(value: string) {
    this._gatewayIp = value;
  }
  public resetGatewayIp() {
    this._gatewayIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayIpInput() {
    return this._gatewayIp;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfosList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfos[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfosOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfosOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuard {
  /**
  * Public key of the WireGuard tunnel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#public_key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#public_key}
  */
  readonly publicKey?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuardToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    public_key: cdktf.stringToTerraform(struct!.publicKey),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuardToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    public_key: {
      value: cdktf.stringToHclTerraform(struct!.publicKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._publicKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.publicKey = this._publicKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._publicKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._publicKey = value.publicKey;
    }
  }

  // public_key - computed: false, optional: true, required: false
  private _publicKey?: string; 
  public get publicKey() {
    return this.getStringAttribute('public_key');
  }
  public set publicKey(value: string) {
    this._publicKey = value;
  }
  public resetPublicKey() {
    this._publicKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publicKeyInput() {
    return this._publicKey;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfo {
  /**
  * ClusterID of the member cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#cluster_id DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#cluster_id}
  */
  readonly clusterId?: string;
  /**
  * GatewayInfos has information of Gateways
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#gateway_infos DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#gateway_infos}
  */
  readonly gatewayInfos?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfos[] | cdktf.IResolvable;
  /**
  * PodCIDRs is the Pod IP address CIDRs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#pod_cidrs DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#pod_cidrs}
  */
  readonly podCidrs?: string[];
  /**
  * ServiceCIDR is the IP ranges used by Service ClusterIP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service_cidr DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service_cidr}
  */
  readonly serviceCidr?: string;
  /**
  * WireGuardInfo includes information of a WireGuard tunnel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#wire_guard DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#wire_guard}
  */
  readonly wireGuard?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuard;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_id: cdktf.stringToTerraform(struct!.clusterId),
    gateway_infos: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfosToTerraform, false)(struct!.gatewayInfos),
    pod_cidrs: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.podCidrs),
    service_cidr: cdktf.stringToTerraform(struct!.serviceCidr),
    wire_guard: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuardToTerraform(struct!.wireGuard),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gateway_infos: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfosToHclTerraform, false)(struct!.gatewayInfos),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfosList",
    },
    pod_cidrs: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.podCidrs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    service_cidr: {
      value: cdktf.stringToHclTerraform(struct!.serviceCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wire_guard: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuardToHclTerraform(struct!.wireGuard),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuard",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._gatewayInfos?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayInfos = this._gatewayInfos?.internalValue;
    }
    if (this._podCidrs !== undefined) {
      hasAnyValues = true;
      internalValueResult.podCidrs = this._podCidrs;
    }
    if (this._serviceCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceCidr = this._serviceCidr;
    }
    if (this._wireGuard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wireGuard = this._wireGuard?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterId = undefined;
      this._gatewayInfos.internalValue = undefined;
      this._podCidrs = undefined;
      this._serviceCidr = undefined;
      this._wireGuard.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterId = value.clusterId;
      this._gatewayInfos.internalValue = value.gatewayInfos;
      this._podCidrs = value.podCidrs;
      this._serviceCidr = value.serviceCidr;
      this._wireGuard.internalValue = value.wireGuard;
    }
  }

  // cluster_id - computed: false, optional: true, required: false
  private _clusterId?: string; 
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }
  public set clusterId(value: string) {
    this._clusterId = value;
  }
  public resetClusterId() {
    this._clusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // gateway_infos - computed: false, optional: true, required: false
  private _gatewayInfos = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfosList(this, "gateway_infos", false);
  public get gatewayInfos() {
    return this._gatewayInfos;
  }
  public putGatewayInfos(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoGatewayInfos[] | cdktf.IResolvable) {
    this._gatewayInfos.internalValue = value;
  }
  public resetGatewayInfos() {
    this._gatewayInfos.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayInfosInput() {
    return this._gatewayInfos.internalValue;
  }

  // pod_cidrs - computed: false, optional: true, required: false
  private _podCidrs?: string[]; 
  public get podCidrs() {
    return this.getListAttribute('pod_cidrs');
  }
  public set podCidrs(value: string[]) {
    this._podCidrs = value;
  }
  public resetPodCidrs() {
    this._podCidrs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podCidrsInput() {
    return this._podCidrs;
  }

  // service_cidr - computed: false, optional: true, required: false
  private _serviceCidr?: string; 
  public get serviceCidr() {
    return this.getStringAttribute('service_cidr');
  }
  public set serviceCidr(value: string) {
    this._serviceCidr = value;
  }
  public resetServiceCidr() {
    this._serviceCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceCidrInput() {
    return this._serviceCidr;
  }

  // wire_guard - computed: false, optional: true, required: false
  private _wireGuard = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuardOutputReference(this, "wire_guard");
  public get wireGuard() {
    return this._wireGuard;
  }
  public putWireGuard(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoWireGuard) {
    this._wireGuard.internalValue = value;
  }
  public resetWireGuard() {
    this._wireGuard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wireGuardInput() {
    return this._wireGuard.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedTo {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelector;
  /**
  * Group is the name of the ClusterGroup which can be set as an AppliedTo in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in AppliedTo fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelector;
  /**
  * Select Nodes in cluster as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelector;
  /**
  * Select a certain Service which matches the NamespacedName. A Service can only be set in either policy level AppliedTo field in a policy that only has ingress rules or rule level AppliedTo field in an ingress rule. Only a NodePort Service can be referred by this field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service}
  */
  readonly service?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToService;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    group: cdktf.stringToTerraform(struct!.group),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorToTerraform(struct!.namespaceSelector),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorToTerraform(struct!.podSelector),
    service: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceToTerraform(struct!.service),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelector",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelector",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelector",
    },
    service: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToService",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._group = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._service.internalValue = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._group = value.group;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._service.internalValue = value.service;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedTo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedTo {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelector;
  /**
  * Group is the name of the ClusterGroup which can be set as an AppliedTo in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in AppliedTo fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelector;
  /**
  * Select Nodes in cluster as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelector;
  /**
  * Select a certain Service which matches the NamespacedName. A Service can only be set in either policy level AppliedTo field in a policy that only has ingress rules or rule level AppliedTo field in an ingress rule. Only a NodePort Service can be referred by this field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service}
  */
  readonly service?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToService;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    group: cdktf.stringToTerraform(struct!.group),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorToTerraform(struct!.namespaceSelector),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorToTerraform(struct!.podSelector),
    service: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceToTerraform(struct!.service),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelector",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelector",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelector",
    },
    service: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToService",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._group = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._service.internalValue = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._group = value.group;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._service.internalValue = value.service;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedTo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlock {
  /**
  * CIDR is a string representing the IP Block Valid examples are '192.168.1.0/24'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#cidr DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#cidr}
  */
  readonly cidr: string;
  /**
  * except is a slice of CIDRs that should not be included within an IPBlock Valid examples are '192.168.1.0/28' or '2001:db8::/64' Except values will be rejected if they are outside the cidr range
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#except DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#except}
  */
  readonly except?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlockToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr: cdktf.stringToTerraform(struct!.cidr),
    except: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.except),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlockToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr: {
      value: cdktf.stringToHclTerraform(struct!.cidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    except: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.except),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidr = this._cidr;
    }
    if (this._except !== undefined) {
      hasAnyValues = true;
      internalValueResult.except = this._except;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidr = undefined;
      this._except = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidr = value.cidr;
      this._except = value.except;
    }
  }

  // cidr - computed: false, optional: false, required: true
  private _cidr?: string; 
  public get cidr() {
    return this.getStringAttribute('cidr');
  }
  public set cidr(value: string) {
    this._cidr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrInput() {
    return this._cidr;
  }

  // except - computed: false, optional: true, required: false
  private _except?: string[]; 
  public get except() {
    return this.getListAttribute('except');
  }
  public set except(value: string[]) {
    this._except = value;
  }
  public resetExcept() {
    this._except = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptInput() {
    return this._except;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaces {
  /**
  * Selects from the same Namespace of the appliedTo workloads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match}
  */
  readonly match?: string;
  /**
  * Selects Namespaces that share the same values for the given set of label keys with the appliedTo Namespace. Namespaces must have all the label keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#same_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#same_labels}
  */
  readonly sameLabels?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespacesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match: cdktf.stringToTerraform(struct!.match),
    same_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sameLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespacesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match: {
      value: cdktf.stringToHclTerraform(struct!.match),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    same_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sameLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespacesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaces | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._sameLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sameLabels = this._sameLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaces | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._match = undefined;
      this._sameLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._match = value.match;
      this._sameLabels = value.sameLabels;
    }
  }

  // match - computed: false, optional: true, required: false
  private _match?: string; 
  public get match() {
    return this.getStringAttribute('match');
  }
  public set match(value: string) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // same_labels - computed: false, optional: true, required: false
  private _sameLabels?: string[]; 
  public get sameLabels() {
    return this.getListAttribute('same_labels');
  }
  public set sameLabels(value: string[]) {
    this._sameLabels = value;
  }
  public resetSameLabels() {
    this._sameLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sameLabelsInput() {
    return this._sameLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFrom {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelector;
  /**
  * Restrict egress access to the Fully Qualified Domain Names prescribed by name or by wildcard match patterns. This field can only be set for NetworkPolicyPeer of egress rules. Supported formats are: Exact FQDNs such as 'google.com'. Wildcard expressions such as '*wayfair.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#fqdn DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#fqdn}
  */
  readonly fqdn?: string;
  /**
  * Group is the name of the ClusterGroup which can be set within an Ingress or Egress rule in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * IPBlock describes the IPAddresses/IPBlocks that is matched in to/from. IPBlock cannot be set as part of the AppliedTo field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ip_block DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ip_block}
  */
  readonly ipBlock?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlock;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in To/From fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelector;
  /**
  * Select Pod/ExternalEntity from Namespaces matched by specific criteria. Current supported criteria is match: Self, which selects from the same Namespace of the appliedTo workloads. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. This field can only be set when NetworkPolicyPeer is created for ClusterNetworkPolicy ingress/egress rules. Cannot be set with NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespaces DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaces;
  /**
  * Select certain Nodes which match the label selector. A NodeSelector cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelector;
  /**
  * Define scope of the Pod/NamespaceSelector(s) of this peer. Can only be used in ingress NetworkPolicyPeers. Defaults to 'Cluster'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in To/From fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    group: cdktf.stringToTerraform(struct!.group),
    ip_block: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlockToTerraform(struct!.ipBlock),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespacesToTerraform(struct!.namespaces),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorToTerraform(struct!.podSelector),
    scope: cdktf.stringToTerraform(struct!.scope),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelector",
    },
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_block: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlockToHclTerraform(struct!.ipBlock),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlock",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelector",
    },
    namespaces: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespacesToHclTerraform(struct!.namespaces),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaces",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelector",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._ipBlock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipBlock = this._ipBlock?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._fqdn = undefined;
      this._group = undefined;
      this._ipBlock.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._scope = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._fqdn = value.fqdn;
      this._group = value.group;
      this._ipBlock.internalValue = value.ipBlock;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces.internalValue = value.namespaces;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._scope = value.scope;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // ip_block - computed: false, optional: true, required: false
  private _ipBlock = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlockOutputReference(this, "ip_block");
  public get ipBlock() {
    return this._ipBlock;
  }
  public putIpBlock(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromIpBlock) {
    this._ipBlock.internalValue = value;
  }
  public resetIpBlock() {
    this._ipBlock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipBlockInput() {
    return this._ipBlock.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespacesOutputReference(this, "namespaces");
  public get namespaces() {
    return this._namespaces;
  }
  public putNamespaces(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNamespaces) {
    this._namespaces.internalValue = value;
  }
  public resetNamespaces() {
    this._namespaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFrom[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttp {
  /**
  * Host represents the hostname present in the URI or the HTTP Host header to match. It does not contain the port associated with the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#host DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#host}
  */
  readonly host?: string;
  /**
  * Method represents the HTTP method to match. It could be GET, POST, PUT, HEAD, DELETE, TRACE, OPTIONS, CONNECT and PATCH.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#method DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#method}
  */
  readonly method?: string;
  /**
  * Path represents the URI path to match (Ex. '/index.html', '/admin').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#path DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    method: cdktf.stringToTerraform(struct!.method),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._method = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._method = value.method;
      this._path = value.path;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTls {
  /**
  * SNI (Server Name Indication) indicates the server domain name in the TLS/SSL hello message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#sni DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#sni}
  */
  readonly sni?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTlsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sni: cdktf.stringToTerraform(struct!.sni),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTlsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sni = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sni = value.sni;
    }
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7Protocols {
  /**
  * HTTPProtocol matches HTTP requests with specific host, method, and path. All fields could be used alone or together. If all fields are not provided, it matches all HTTP requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#http DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#http}
  */
  readonly http?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttp;
  /**
  * TLSProtocol matches TLS handshake packets with specific SNI. If the field is not provided, this matches all TLS handshake packets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#tls DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#tls}
  */
  readonly tls?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTls;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7Protocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttpToTerraform(struct!.http),
    tls: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTlsToTerraform(struct!.tls),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7Protocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttpToHclTerraform(struct!.http),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttp",
    },
    tls: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7Protocols | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._http?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.http = this._http?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7Protocols | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._http.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._http.internalValue = value.http;
      this._tls.internalValue = value.tls;
    }
  }

  // http - computed: false, optional: true, required: false
  private _http = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttpOutputReference(this, "http");
  public get http() {
    return this._http;
  }
  public putHttp(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsHttp) {
    this._http.internalValue = value;
  }
  public resetHttp() {
    this._http.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpInput() {
    return this._http.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7Protocols[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPorts {
  /**
  * EndPort defines the end of the port range, inclusive. It can only be specified when a numerical 'port' is specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#end_port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#end_port}
  */
  readonly endPort?: number;
  /**
  * The port on the given protocol. This can be either a numerical or named port on a Pod. If this field is not provided, this matches all port names and numbers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#port}
  */
  readonly port?: string;
  /**
  * The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field defaults to TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#protocol DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * SourceEndPort defines the end of the source port range, inclusive. It can only be specified when 'sourcePort' is specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#source_end_port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#source_end_port}
  */
  readonly sourceEndPort?: number;
  /**
  * The source port on the given protocol. This can only be a numerical port. If this field is not provided, rule matches all source ports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#source_port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#source_port}
  */
  readonly sourcePort?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPortsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end_port: cdktf.numberToTerraform(struct!.endPort),
    port: cdktf.stringToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    source_end_port: cdktf.numberToTerraform(struct!.sourceEndPort),
    source_port: cdktf.numberToTerraform(struct!.sourcePort),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPortsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end_port: {
      value: cdktf.numberToHclTerraform(struct!.endPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_end_port: {
      value: cdktf.numberToHclTerraform(struct!.sourceEndPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_port: {
      value: cdktf.numberToHclTerraform(struct!.sourcePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.endPort = this._endPort;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._sourceEndPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceEndPort = this._sourceEndPort;
    }
    if (this._sourcePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourcePort = this._sourcePort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endPort = undefined;
      this._port = undefined;
      this._protocol = undefined;
      this._sourceEndPort = undefined;
      this._sourcePort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endPort = value.endPort;
      this._port = value.port;
      this._protocol = value.protocol;
      this._sourceEndPort = value.sourceEndPort;
      this._sourcePort = value.sourcePort;
    }
  }

  // end_port - computed: false, optional: true, required: false
  private _endPort?: number; 
  public get endPort() {
    return this.getNumberAttribute('end_port');
  }
  public set endPort(value: number) {
    this._endPort = value;
  }
  public resetEndPort() {
    this._endPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endPortInput() {
    return this._endPort;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // source_end_port - computed: false, optional: true, required: false
  private _sourceEndPort?: number; 
  public get sourceEndPort() {
    return this.getNumberAttribute('source_end_port');
  }
  public set sourceEndPort(value: number) {
    this._sourceEndPort = value;
  }
  public resetSourceEndPort() {
    this._sourceEndPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceEndPortInput() {
    return this._sourceEndPort;
  }

  // source_port - computed: false, optional: true, required: false
  private _sourcePort?: number; 
  public get sourcePort() {
    return this.getNumberAttribute('source_port');
  }
  public set sourcePort(value: number) {
    this._sourcePort = value;
  }
  public resetSourcePort() {
    this._sourcePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourcePortInput() {
    return this._sourcePort;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPortsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#icmp_code DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#icmp_code}
  */
  readonly icmpCode?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#icmp_type DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#icmp_type}
  */
  readonly icmpType?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    icmp_code: cdktf.numberToTerraform(struct!.icmpCode),
    icmp_type: cdktf.numberToTerraform(struct!.icmpType),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    icmp_code: {
      value: cdktf.numberToHclTerraform(struct!.icmpCode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    icmp_type: {
      value: cdktf.numberToHclTerraform(struct!.icmpType),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._icmpCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmpCode = this._icmpCode;
    }
    if (this._icmpType !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmpType = this._icmpType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._icmpCode = undefined;
      this._icmpType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._icmpCode = value.icmpCode;
      this._icmpType = value.icmpType;
    }
  }

  // icmp_code - computed: false, optional: true, required: false
  private _icmpCode?: number; 
  public get icmpCode() {
    return this.getNumberAttribute('icmp_code');
  }
  public set icmpCode(value: number) {
    this._icmpCode = value;
  }
  public resetIcmpCode() {
    this._icmpCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpCodeInput() {
    return this._icmpCode;
  }

  // icmp_type - computed: false, optional: true, required: false
  private _icmpType?: number; 
  public get icmpType() {
    return this.getNumberAttribute('icmp_type');
  }
  public set icmpType(value: number) {
    this._icmpType = value;
  }
  public resetIcmpType() {
    this._icmpType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpTypeInput() {
    return this._icmpType;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#group_address DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#group_address}
  */
  readonly groupAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#igmp_type DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#igmp_type}
  */
  readonly igmpType?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    igmp_type: cdktf.numberToTerraform(struct!.igmpType),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    igmp_type: {
      value: cdktf.numberToHclTerraform(struct!.igmpType),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._igmpType !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmpType = this._igmpType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._igmpType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._igmpType = value.igmpType;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // igmp_type - computed: false, optional: true, required: false
  private _igmpType?: number; 
  public get igmpType() {
    return this.getNumberAttribute('igmp_type');
  }
  public set igmpType(value: number) {
    this._igmpType = value;
  }
  public resetIgmpType() {
    this._igmpType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpTypeInput() {
    return this._igmpType;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocols {
  /**
  * ICMPProtocol matches ICMP traffic with specific ICMPType and/or ICMPCode. All fields could be used alone or together. If all fields are not provided, this matches all ICMP traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#icmp DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#icmp}
  */
  readonly icmp?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmp;
  /**
  * IGMPProtocol matches IGMP traffic with IGMPType and GroupAddress. IGMPType must be filled with: IGMPQuery int32 = 0x11 IGMPReportV1 int32 = 0x12 IGMPReportV2 int32 = 0x16 IGMPReportV3 int32 = 0x22 If groupAddress is empty, all groupAddresses will be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#igmp DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#igmp}
  */
  readonly igmp?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmp;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    icmp: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmpToTerraform(struct!.icmp),
    igmp: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmpToTerraform(struct!.igmp),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    icmp: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmpToHclTerraform(struct!.icmp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmp",
    },
    igmp: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmpToHclTerraform(struct!.igmp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocols | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._icmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmp = this._icmp?.internalValue;
    }
    if (this._igmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmp = this._igmp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocols | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._icmp.internalValue = undefined;
      this._igmp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._icmp.internalValue = value.icmp;
      this._igmp.internalValue = value.igmp;
    }
  }

  // icmp - computed: false, optional: true, required: false
  private _icmp = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmpOutputReference(this, "icmp");
  public get icmp() {
    return this._icmp;
  }
  public putIcmp(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIcmp) {
    this._icmp.internalValue = value;
  }
  public resetIcmp() {
    this._icmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpInput() {
    return this._icmp.internalValue;
  }

  // igmp - computed: false, optional: true, required: false
  private _igmp = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmpOutputReference(this, "igmp");
  public get igmp() {
    return this._igmp;
  }
  public putIgmp(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsIgmp) {
    this._igmp.internalValue = value;
  }
  public resetIgmp() {
    this._igmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpInput() {
    return this._igmp.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocols[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlock {
  /**
  * CIDR is a string representing the IP Block Valid examples are '192.168.1.0/24'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#cidr DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#cidr}
  */
  readonly cidr: string;
  /**
  * except is a slice of CIDRs that should not be included within an IPBlock Valid examples are '192.168.1.0/28' or '2001:db8::/64' Except values will be rejected if they are outside the cidr range
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#except DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#except}
  */
  readonly except?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlockToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr: cdktf.stringToTerraform(struct!.cidr),
    except: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.except),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlockToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr: {
      value: cdktf.stringToHclTerraform(struct!.cidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    except: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.except),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidr = this._cidr;
    }
    if (this._except !== undefined) {
      hasAnyValues = true;
      internalValueResult.except = this._except;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidr = undefined;
      this._except = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidr = value.cidr;
      this._except = value.except;
    }
  }

  // cidr - computed: false, optional: false, required: true
  private _cidr?: string; 
  public get cidr() {
    return this.getStringAttribute('cidr');
  }
  public set cidr(value: string) {
    this._cidr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrInput() {
    return this._cidr;
  }

  // except - computed: false, optional: true, required: false
  private _except?: string[]; 
  public get except() {
    return this.getListAttribute('except');
  }
  public set except(value: string[]) {
    this._except = value;
  }
  public resetExcept() {
    this._except = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptInput() {
    return this._except;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaces {
  /**
  * Selects from the same Namespace of the appliedTo workloads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match}
  */
  readonly match?: string;
  /**
  * Selects Namespaces that share the same values for the given set of label keys with the appliedTo Namespace. Namespaces must have all the label keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#same_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#same_labels}
  */
  readonly sameLabels?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespacesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match: cdktf.stringToTerraform(struct!.match),
    same_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sameLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespacesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match: {
      value: cdktf.stringToHclTerraform(struct!.match),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    same_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sameLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespacesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaces | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._sameLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sameLabels = this._sameLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaces | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._match = undefined;
      this._sameLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._match = value.match;
      this._sameLabels = value.sameLabels;
    }
  }

  // match - computed: false, optional: true, required: false
  private _match?: string; 
  public get match() {
    return this.getStringAttribute('match');
  }
  public set match(value: string) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // same_labels - computed: false, optional: true, required: false
  private _sameLabels?: string[]; 
  public get sameLabels() {
    return this.getListAttribute('same_labels');
  }
  public set sameLabels(value: string[]) {
    this._sameLabels = value;
  }
  public resetSameLabels() {
    this._sameLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sameLabelsInput() {
    return this._sameLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressTo {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelector;
  /**
  * Restrict egress access to the Fully Qualified Domain Names prescribed by name or by wildcard match patterns. This field can only be set for NetworkPolicyPeer of egress rules. Supported formats are: Exact FQDNs such as 'google.com'. Wildcard expressions such as '*wayfair.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#fqdn DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#fqdn}
  */
  readonly fqdn?: string;
  /**
  * Group is the name of the ClusterGroup which can be set within an Ingress or Egress rule in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * IPBlock describes the IPAddresses/IPBlocks that is matched in to/from. IPBlock cannot be set as part of the AppliedTo field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ip_block DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ip_block}
  */
  readonly ipBlock?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlock;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in To/From fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelector;
  /**
  * Select Pod/ExternalEntity from Namespaces matched by specific criteria. Current supported criteria is match: Self, which selects from the same Namespace of the appliedTo workloads. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. This field can only be set when NetworkPolicyPeer is created for ClusterNetworkPolicy ingress/egress rules. Cannot be set with NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespaces DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaces;
  /**
  * Select certain Nodes which match the label selector. A NodeSelector cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelector;
  /**
  * Define scope of the Pod/NamespaceSelector(s) of this peer. Can only be used in ingress NetworkPolicyPeers. Defaults to 'Cluster'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in To/From fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    group: cdktf.stringToTerraform(struct!.group),
    ip_block: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlockToTerraform(struct!.ipBlock),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespacesToTerraform(struct!.namespaces),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorToTerraform(struct!.podSelector),
    scope: cdktf.stringToTerraform(struct!.scope),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelector",
    },
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_block: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlockToHclTerraform(struct!.ipBlock),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlock",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelector",
    },
    namespaces: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespacesToHclTerraform(struct!.namespaces),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaces",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelector",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._ipBlock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipBlock = this._ipBlock?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._fqdn = undefined;
      this._group = undefined;
      this._ipBlock.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._scope = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._fqdn = value.fqdn;
      this._group = value.group;
      this._ipBlock.internalValue = value.ipBlock;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces.internalValue = value.namespaces;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._scope = value.scope;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // ip_block - computed: false, optional: true, required: false
  private _ipBlock = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlockOutputReference(this, "ip_block");
  public get ipBlock() {
    return this._ipBlock;
  }
  public putIpBlock(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToIpBlock) {
    this._ipBlock.internalValue = value;
  }
  public resetIpBlock() {
    this._ipBlock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipBlockInput() {
    return this._ipBlock.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespacesOutputReference(this, "namespaces");
  public get namespaces() {
    return this._namespaces;
  }
  public putNamespaces(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNamespaces) {
    this._namespaces.internalValue = value;
  }
  public resetNamespaces() {
    this._namespaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressTo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServices {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServicesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServicesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
      this._scope = value.scope;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServicesList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServicesOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgress {
  /**
  * Action specifies the action to be applied on the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#action DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#action}
  */
  readonly action: string;
  /**
  * Select workloads on which this rule will be applied to. Cannot be set in conjunction with NetworkPolicySpec/ClusterNetworkPolicySpec.AppliedTo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#applied_to DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#applied_to}
  */
  readonly appliedTo?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedTo[] | cdktf.IResolvable;
  /**
  * EnableLogging is used to indicate if agent should generate logs when rules are matched. Should be default to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#enable_logging DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#enable_logging}
  */
  readonly enableLogging?: boolean | cdktf.IResolvable;
  /**
  * Rule is matched if traffic originates from workloads selected by this field. If this field is empty, this rule matches all sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#from DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#from}
  */
  readonly from?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFrom[] | cdktf.IResolvable;
  /**
  * Set of layer 7 protocols matched by the rule. If this field is set, action can only be Allow. When this field is used in a rule, any traffic matching the other layer 3/4 criteria of the rule (typically the 5-tuple) will be forwarded to an application-aware engine for protocol detection and rule enforcement, and the traffic will be allowed if the layer 7 criteria is also matched, otherwise it will be dropped. Therefore, any rules after a layer 7 rule will not be enforced for the traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#l7_protocols DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#l7_protocols}
  */
  readonly l7Protocols?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7Protocols[] | cdktf.IResolvable;
  /**
  * LogLabel is a user-defined arbitrary string which will be printed in the NetworkPolicy logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#log_label DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#log_label}
  */
  readonly logLabel?: string;
  /**
  * Name describes the intention of this rule. Name should be unique within the policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Set of ports and protocols matched by the rule. If this field and Protocols are unset or empty, this rule matches all ports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ports DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ports}
  */
  readonly ports?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPorts[] | cdktf.IResolvable;
  /**
  * Set of protocols matched by the rule. If this field and Ports are unset or empty, this rule matches all protocols supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#protocols DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#protocols}
  */
  readonly protocols?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocols[] | cdktf.IResolvable;
  /**
  * Rule is matched if traffic is intended for workloads selected by this field. This field can't be used with ToServices. If this field and ToServices are both empty or missing this rule matches all destinations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#to DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#to}
  */
  readonly to?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressTo[] | cdktf.IResolvable;
  /**
  * Rule is matched if traffic is intended for a Service listed in this field. Currently, only ClusterIP types Services are supported in this field. When scope is set to ClusterSet, it matches traffic intended for a multi-cluster Service listed in this field. Service name and Namespace provided should match the original exported Service. This field can only be used when AntreaProxy is enabled. This field can't be used with To or Ports. If this field and To are both empty or missing, this rule matches all destinations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#to_services DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#to_services}
  */
  readonly toServices?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServices[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    applied_to: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToToTerraform, false)(struct!.appliedTo),
    enable_logging: cdktf.booleanToTerraform(struct!.enableLogging),
    from: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromToTerraform, false)(struct!.from),
    l7_protocols: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsToTerraform, false)(struct!.l7Protocols),
    log_label: cdktf.stringToTerraform(struct!.logLabel),
    name: cdktf.stringToTerraform(struct!.name),
    ports: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPortsToTerraform, false)(struct!.ports),
    protocols: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsToTerraform, false)(struct!.protocols),
    to: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToToTerraform, false)(struct!.to),
    to_services: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServicesToTerraform, false)(struct!.toServices),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    applied_to: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToToHclTerraform, false)(struct!.appliedTo),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToList",
    },
    enable_logging: {
      value: cdktf.booleanToHclTerraform(struct!.enableLogging),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    from: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromToHclTerraform, false)(struct!.from),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromList",
    },
    l7_protocols: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsToHclTerraform, false)(struct!.l7Protocols),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsList",
    },
    log_label: {
      value: cdktf.stringToHclTerraform(struct!.logLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPortsList",
    },
    protocols: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsToHclTerraform, false)(struct!.protocols),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsList",
    },
    to: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToToHclTerraform, false)(struct!.to),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToList",
    },
    to_services: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServicesToHclTerraform, false)(struct!.toServices),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._appliedTo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliedTo = this._appliedTo?.internalValue;
    }
    if (this._enableLogging !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLogging = this._enableLogging;
    }
    if (this._from?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.from = this._from?.internalValue;
    }
    if (this._l7Protocols?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.l7Protocols = this._l7Protocols?.internalValue;
    }
    if (this._logLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLabel = this._logLabel;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    if (this._protocols?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocols = this._protocols?.internalValue;
    }
    if (this._to?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.to = this._to?.internalValue;
    }
    if (this._toServices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.toServices = this._toServices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._appliedTo.internalValue = undefined;
      this._enableLogging = undefined;
      this._from.internalValue = undefined;
      this._l7Protocols.internalValue = undefined;
      this._logLabel = undefined;
      this._name = undefined;
      this._ports.internalValue = undefined;
      this._protocols.internalValue = undefined;
      this._to.internalValue = undefined;
      this._toServices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._appliedTo.internalValue = value.appliedTo;
      this._enableLogging = value.enableLogging;
      this._from.internalValue = value.from;
      this._l7Protocols.internalValue = value.l7Protocols;
      this._logLabel = value.logLabel;
      this._name = value.name;
      this._ports.internalValue = value.ports;
      this._protocols.internalValue = value.protocols;
      this._to.internalValue = value.to;
      this._toServices.internalValue = value.toServices;
    }
  }

  // action - computed: false, optional: false, required: true
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // applied_to - computed: false, optional: true, required: false
  private _appliedTo = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedToList(this, "applied_to", false);
  public get appliedTo() {
    return this._appliedTo;
  }
  public putAppliedTo(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressAppliedTo[] | cdktf.IResolvable) {
    this._appliedTo.internalValue = value;
  }
  public resetAppliedTo() {
    this._appliedTo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliedToInput() {
    return this._appliedTo.internalValue;
  }

  // enable_logging - computed: false, optional: true, required: false
  private _enableLogging?: boolean | cdktf.IResolvable; 
  public get enableLogging() {
    return this.getBooleanAttribute('enable_logging');
  }
  public set enableLogging(value: boolean | cdktf.IResolvable) {
    this._enableLogging = value;
  }
  public resetEnableLogging() {
    this._enableLogging = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoggingInput() {
    return this._enableLogging;
  }

  // from - computed: false, optional: true, required: false
  private _from = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFromList(this, "from", false);
  public get from() {
    return this._from;
  }
  public putFrom(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressFrom[] | cdktf.IResolvable) {
    this._from.internalValue = value;
  }
  public resetFrom() {
    this._from.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromInput() {
    return this._from.internalValue;
  }

  // l7_protocols - computed: false, optional: true, required: false
  private _l7Protocols = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7ProtocolsList(this, "l7_protocols", false);
  public get l7Protocols() {
    return this._l7Protocols;
  }
  public putL7Protocols(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressL7Protocols[] | cdktf.IResolvable) {
    this._l7Protocols.internalValue = value;
  }
  public resetL7Protocols() {
    this._l7Protocols.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get l7ProtocolsInput() {
    return this._l7Protocols.internalValue;
  }

  // log_label - computed: false, optional: true, required: false
  private _logLabel?: string; 
  public get logLabel() {
    return this.getStringAttribute('log_label');
  }
  public set logLabel(value: string) {
    this._logLabel = value;
  }
  public resetLogLabel() {
    this._logLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLabelInput() {
    return this._logLabel;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }

  // protocols - computed: false, optional: true, required: false
  private _protocols = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocolsList(this, "protocols", false);
  public get protocols() {
    return this._protocols;
  }
  public putProtocols(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressProtocols[] | cdktf.IResolvable) {
    this._protocols.internalValue = value;
  }
  public resetProtocols() {
    this._protocols.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolsInput() {
    return this._protocols.internalValue;
  }

  // to - computed: false, optional: true, required: false
  private _to = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToList(this, "to", false);
  public get to() {
    return this._to;
  }
  public putTo(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressTo[] | cdktf.IResolvable) {
    this._to.internalValue = value;
  }
  public resetTo() {
    this._to.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toInput() {
    return this._to.internalValue;
  }

  // to_services - computed: false, optional: true, required: false
  private _toServices = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServicesList(this, "to_services", false);
  public get toServices() {
    return this._toServices;
  }
  public putToServices(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToServices[] | cdktf.IResolvable) {
    this._toServices.internalValue = value;
  }
  public resetToServices() {
    this._toServices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toServicesInput() {
    return this._toServices.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgress[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedTo {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelector;
  /**
  * Group is the name of the ClusterGroup which can be set as an AppliedTo in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in AppliedTo fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelector;
  /**
  * Select Nodes in cluster as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelector;
  /**
  * Select a certain Service which matches the NamespacedName. A Service can only be set in either policy level AppliedTo field in a policy that only has ingress rules or rule level AppliedTo field in an ingress rule. Only a NodePort Service can be referred by this field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service}
  */
  readonly service?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToService;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    group: cdktf.stringToTerraform(struct!.group),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorToTerraform(struct!.namespaceSelector),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorToTerraform(struct!.podSelector),
    service: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceToTerraform(struct!.service),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelector",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelector",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelector",
    },
    service: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToService",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._group = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._service.internalValue = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._group = value.group;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._service.internalValue = value.service;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedTo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlock {
  /**
  * CIDR is a string representing the IP Block Valid examples are '192.168.1.0/24'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#cidr DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#cidr}
  */
  readonly cidr: string;
  /**
  * except is a slice of CIDRs that should not be included within an IPBlock Valid examples are '192.168.1.0/28' or '2001:db8::/64' Except values will be rejected if they are outside the cidr range
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#except DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#except}
  */
  readonly except?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlockToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr: cdktf.stringToTerraform(struct!.cidr),
    except: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.except),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlockToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr: {
      value: cdktf.stringToHclTerraform(struct!.cidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    except: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.except),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidr = this._cidr;
    }
    if (this._except !== undefined) {
      hasAnyValues = true;
      internalValueResult.except = this._except;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidr = undefined;
      this._except = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidr = value.cidr;
      this._except = value.except;
    }
  }

  // cidr - computed: false, optional: false, required: true
  private _cidr?: string; 
  public get cidr() {
    return this.getStringAttribute('cidr');
  }
  public set cidr(value: string) {
    this._cidr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrInput() {
    return this._cidr;
  }

  // except - computed: false, optional: true, required: false
  private _except?: string[]; 
  public get except() {
    return this.getListAttribute('except');
  }
  public set except(value: string[]) {
    this._except = value;
  }
  public resetExcept() {
    this._except = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptInput() {
    return this._except;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaces {
  /**
  * Selects from the same Namespace of the appliedTo workloads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match}
  */
  readonly match?: string;
  /**
  * Selects Namespaces that share the same values for the given set of label keys with the appliedTo Namespace. Namespaces must have all the label keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#same_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#same_labels}
  */
  readonly sameLabels?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespacesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match: cdktf.stringToTerraform(struct!.match),
    same_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sameLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespacesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match: {
      value: cdktf.stringToHclTerraform(struct!.match),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    same_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sameLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespacesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaces | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._sameLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sameLabels = this._sameLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaces | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._match = undefined;
      this._sameLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._match = value.match;
      this._sameLabels = value.sameLabels;
    }
  }

  // match - computed: false, optional: true, required: false
  private _match?: string; 
  public get match() {
    return this.getStringAttribute('match');
  }
  public set match(value: string) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // same_labels - computed: false, optional: true, required: false
  private _sameLabels?: string[]; 
  public get sameLabels() {
    return this.getListAttribute('same_labels');
  }
  public set sameLabels(value: string[]) {
    this._sameLabels = value;
  }
  public resetSameLabels() {
    this._sameLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sameLabelsInput() {
    return this._sameLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFrom {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelector;
  /**
  * Restrict egress access to the Fully Qualified Domain Names prescribed by name or by wildcard match patterns. This field can only be set for NetworkPolicyPeer of egress rules. Supported formats are: Exact FQDNs such as 'google.com'. Wildcard expressions such as '*wayfair.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#fqdn DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#fqdn}
  */
  readonly fqdn?: string;
  /**
  * Group is the name of the ClusterGroup which can be set within an Ingress or Egress rule in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * IPBlock describes the IPAddresses/IPBlocks that is matched in to/from. IPBlock cannot be set as part of the AppliedTo field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ip_block DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ip_block}
  */
  readonly ipBlock?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlock;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in To/From fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelector;
  /**
  * Select Pod/ExternalEntity from Namespaces matched by specific criteria. Current supported criteria is match: Self, which selects from the same Namespace of the appliedTo workloads. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. This field can only be set when NetworkPolicyPeer is created for ClusterNetworkPolicy ingress/egress rules. Cannot be set with NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespaces DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaces;
  /**
  * Select certain Nodes which match the label selector. A NodeSelector cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelector;
  /**
  * Define scope of the Pod/NamespaceSelector(s) of this peer. Can only be used in ingress NetworkPolicyPeers. Defaults to 'Cluster'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in To/From fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    group: cdktf.stringToTerraform(struct!.group),
    ip_block: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlockToTerraform(struct!.ipBlock),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespacesToTerraform(struct!.namespaces),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorToTerraform(struct!.podSelector),
    scope: cdktf.stringToTerraform(struct!.scope),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelector",
    },
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_block: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlockToHclTerraform(struct!.ipBlock),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlock",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelector",
    },
    namespaces: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespacesToHclTerraform(struct!.namespaces),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaces",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelector",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._ipBlock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipBlock = this._ipBlock?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._fqdn = undefined;
      this._group = undefined;
      this._ipBlock.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._scope = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._fqdn = value.fqdn;
      this._group = value.group;
      this._ipBlock.internalValue = value.ipBlock;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces.internalValue = value.namespaces;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._scope = value.scope;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // ip_block - computed: false, optional: true, required: false
  private _ipBlock = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlockOutputReference(this, "ip_block");
  public get ipBlock() {
    return this._ipBlock;
  }
  public putIpBlock(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromIpBlock) {
    this._ipBlock.internalValue = value;
  }
  public resetIpBlock() {
    this._ipBlock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipBlockInput() {
    return this._ipBlock.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespacesOutputReference(this, "namespaces");
  public get namespaces() {
    return this._namespaces;
  }
  public putNamespaces(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNamespaces) {
    this._namespaces.internalValue = value;
  }
  public resetNamespaces() {
    this._namespaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFrom[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttp {
  /**
  * Host represents the hostname present in the URI or the HTTP Host header to match. It does not contain the port associated with the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#host DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#host}
  */
  readonly host?: string;
  /**
  * Method represents the HTTP method to match. It could be GET, POST, PUT, HEAD, DELETE, TRACE, OPTIONS, CONNECT and PATCH.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#method DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#method}
  */
  readonly method?: string;
  /**
  * Path represents the URI path to match (Ex. '/index.html', '/admin').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#path DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    method: cdktf.stringToTerraform(struct!.method),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._method = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._method = value.method;
      this._path = value.path;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTls {
  /**
  * SNI (Server Name Indication) indicates the server domain name in the TLS/SSL hello message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#sni DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#sni}
  */
  readonly sni?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTlsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sni: cdktf.stringToTerraform(struct!.sni),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTlsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sni = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sni = value.sni;
    }
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7Protocols {
  /**
  * HTTPProtocol matches HTTP requests with specific host, method, and path. All fields could be used alone or together. If all fields are not provided, it matches all HTTP requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#http DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#http}
  */
  readonly http?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttp;
  /**
  * TLSProtocol matches TLS handshake packets with specific SNI. If the field is not provided, this matches all TLS handshake packets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#tls DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#tls}
  */
  readonly tls?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTls;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7Protocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttpToTerraform(struct!.http),
    tls: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTlsToTerraform(struct!.tls),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7Protocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttpToHclTerraform(struct!.http),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttp",
    },
    tls: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7Protocols | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._http?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.http = this._http?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7Protocols | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._http.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._http.internalValue = value.http;
      this._tls.internalValue = value.tls;
    }
  }

  // http - computed: false, optional: true, required: false
  private _http = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttpOutputReference(this, "http");
  public get http() {
    return this._http;
  }
  public putHttp(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsHttp) {
    this._http.internalValue = value;
  }
  public resetHttp() {
    this._http.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpInput() {
    return this._http.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7Protocols[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPorts {
  /**
  * EndPort defines the end of the port range, inclusive. It can only be specified when a numerical 'port' is specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#end_port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#end_port}
  */
  readonly endPort?: number;
  /**
  * The port on the given protocol. This can be either a numerical or named port on a Pod. If this field is not provided, this matches all port names and numbers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#port}
  */
  readonly port?: string;
  /**
  * The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field defaults to TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#protocol DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * SourceEndPort defines the end of the source port range, inclusive. It can only be specified when 'sourcePort' is specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#source_end_port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#source_end_port}
  */
  readonly sourceEndPort?: number;
  /**
  * The source port on the given protocol. This can only be a numerical port. If this field is not provided, rule matches all source ports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#source_port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#source_port}
  */
  readonly sourcePort?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPortsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end_port: cdktf.numberToTerraform(struct!.endPort),
    port: cdktf.stringToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    source_end_port: cdktf.numberToTerraform(struct!.sourceEndPort),
    source_port: cdktf.numberToTerraform(struct!.sourcePort),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPortsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end_port: {
      value: cdktf.numberToHclTerraform(struct!.endPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_end_port: {
      value: cdktf.numberToHclTerraform(struct!.sourceEndPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_port: {
      value: cdktf.numberToHclTerraform(struct!.sourcePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.endPort = this._endPort;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._sourceEndPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceEndPort = this._sourceEndPort;
    }
    if (this._sourcePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourcePort = this._sourcePort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endPort = undefined;
      this._port = undefined;
      this._protocol = undefined;
      this._sourceEndPort = undefined;
      this._sourcePort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endPort = value.endPort;
      this._port = value.port;
      this._protocol = value.protocol;
      this._sourceEndPort = value.sourceEndPort;
      this._sourcePort = value.sourcePort;
    }
  }

  // end_port - computed: false, optional: true, required: false
  private _endPort?: number; 
  public get endPort() {
    return this.getNumberAttribute('end_port');
  }
  public set endPort(value: number) {
    this._endPort = value;
  }
  public resetEndPort() {
    this._endPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endPortInput() {
    return this._endPort;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // source_end_port - computed: false, optional: true, required: false
  private _sourceEndPort?: number; 
  public get sourceEndPort() {
    return this.getNumberAttribute('source_end_port');
  }
  public set sourceEndPort(value: number) {
    this._sourceEndPort = value;
  }
  public resetSourceEndPort() {
    this._sourceEndPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceEndPortInput() {
    return this._sourceEndPort;
  }

  // source_port - computed: false, optional: true, required: false
  private _sourcePort?: number; 
  public get sourcePort() {
    return this.getNumberAttribute('source_port');
  }
  public set sourcePort(value: number) {
    this._sourcePort = value;
  }
  public resetSourcePort() {
    this._sourcePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourcePortInput() {
    return this._sourcePort;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPortsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#icmp_code DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#icmp_code}
  */
  readonly icmpCode?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#icmp_type DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#icmp_type}
  */
  readonly icmpType?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    icmp_code: cdktf.numberToTerraform(struct!.icmpCode),
    icmp_type: cdktf.numberToTerraform(struct!.icmpType),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    icmp_code: {
      value: cdktf.numberToHclTerraform(struct!.icmpCode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    icmp_type: {
      value: cdktf.numberToHclTerraform(struct!.icmpType),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._icmpCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmpCode = this._icmpCode;
    }
    if (this._icmpType !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmpType = this._icmpType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._icmpCode = undefined;
      this._icmpType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._icmpCode = value.icmpCode;
      this._icmpType = value.icmpType;
    }
  }

  // icmp_code - computed: false, optional: true, required: false
  private _icmpCode?: number; 
  public get icmpCode() {
    return this.getNumberAttribute('icmp_code');
  }
  public set icmpCode(value: number) {
    this._icmpCode = value;
  }
  public resetIcmpCode() {
    this._icmpCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpCodeInput() {
    return this._icmpCode;
  }

  // icmp_type - computed: false, optional: true, required: false
  private _icmpType?: number; 
  public get icmpType() {
    return this.getNumberAttribute('icmp_type');
  }
  public set icmpType(value: number) {
    this._icmpType = value;
  }
  public resetIcmpType() {
    this._icmpType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpTypeInput() {
    return this._icmpType;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#group_address DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#group_address}
  */
  readonly groupAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#igmp_type DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#igmp_type}
  */
  readonly igmpType?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    igmp_type: cdktf.numberToTerraform(struct!.igmpType),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    igmp_type: {
      value: cdktf.numberToHclTerraform(struct!.igmpType),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._igmpType !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmpType = this._igmpType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._igmpType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._igmpType = value.igmpType;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // igmp_type - computed: false, optional: true, required: false
  private _igmpType?: number; 
  public get igmpType() {
    return this.getNumberAttribute('igmp_type');
  }
  public set igmpType(value: number) {
    this._igmpType = value;
  }
  public resetIgmpType() {
    this._igmpType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpTypeInput() {
    return this._igmpType;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocols {
  /**
  * ICMPProtocol matches ICMP traffic with specific ICMPType and/or ICMPCode. All fields could be used alone or together. If all fields are not provided, this matches all ICMP traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#icmp DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#icmp}
  */
  readonly icmp?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmp;
  /**
  * IGMPProtocol matches IGMP traffic with IGMPType and GroupAddress. IGMPType must be filled with: IGMPQuery int32 = 0x11 IGMPReportV1 int32 = 0x12 IGMPReportV2 int32 = 0x16 IGMPReportV3 int32 = 0x22 If groupAddress is empty, all groupAddresses will be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#igmp DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#igmp}
  */
  readonly igmp?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmp;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    icmp: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmpToTerraform(struct!.icmp),
    igmp: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmpToTerraform(struct!.igmp),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    icmp: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmpToHclTerraform(struct!.icmp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmp",
    },
    igmp: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmpToHclTerraform(struct!.igmp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocols | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._icmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmp = this._icmp?.internalValue;
    }
    if (this._igmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmp = this._igmp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocols | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._icmp.internalValue = undefined;
      this._igmp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._icmp.internalValue = value.icmp;
      this._igmp.internalValue = value.igmp;
    }
  }

  // icmp - computed: false, optional: true, required: false
  private _icmp = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmpOutputReference(this, "icmp");
  public get icmp() {
    return this._icmp;
  }
  public putIcmp(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIcmp) {
    this._icmp.internalValue = value;
  }
  public resetIcmp() {
    this._icmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpInput() {
    return this._icmp.internalValue;
  }

  // igmp - computed: false, optional: true, required: false
  private _igmp = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmpOutputReference(this, "igmp");
  public get igmp() {
    return this._igmp;
  }
  public putIgmp(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsIgmp) {
    this._igmp.internalValue = value;
  }
  public resetIgmp() {
    this._igmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpInput() {
    return this._igmp.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocols[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlock {
  /**
  * CIDR is a string representing the IP Block Valid examples are '192.168.1.0/24'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#cidr DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#cidr}
  */
  readonly cidr: string;
  /**
  * except is a slice of CIDRs that should not be included within an IPBlock Valid examples are '192.168.1.0/28' or '2001:db8::/64' Except values will be rejected if they are outside the cidr range
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#except DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#except}
  */
  readonly except?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlockToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr: cdktf.stringToTerraform(struct!.cidr),
    except: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.except),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlockToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr: {
      value: cdktf.stringToHclTerraform(struct!.cidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    except: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.except),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidr = this._cidr;
    }
    if (this._except !== undefined) {
      hasAnyValues = true;
      internalValueResult.except = this._except;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidr = undefined;
      this._except = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidr = value.cidr;
      this._except = value.except;
    }
  }

  // cidr - computed: false, optional: false, required: true
  private _cidr?: string; 
  public get cidr() {
    return this.getStringAttribute('cidr');
  }
  public set cidr(value: string) {
    this._cidr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrInput() {
    return this._cidr;
  }

  // except - computed: false, optional: true, required: false
  private _except?: string[]; 
  public get except() {
    return this.getListAttribute('except');
  }
  public set except(value: string[]) {
    this._except = value;
  }
  public resetExcept() {
    this._except = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptInput() {
    return this._except;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaces {
  /**
  * Selects from the same Namespace of the appliedTo workloads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match}
  */
  readonly match?: string;
  /**
  * Selects Namespaces that share the same values for the given set of label keys with the appliedTo Namespace. Namespaces must have all the label keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#same_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#same_labels}
  */
  readonly sameLabels?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespacesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match: cdktf.stringToTerraform(struct!.match),
    same_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sameLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespacesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match: {
      value: cdktf.stringToHclTerraform(struct!.match),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    same_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sameLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespacesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaces | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._sameLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sameLabels = this._sameLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaces | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._match = undefined;
      this._sameLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._match = value.match;
      this._sameLabels = value.sameLabels;
    }
  }

  // match - computed: false, optional: true, required: false
  private _match?: string; 
  public get match() {
    return this.getStringAttribute('match');
  }
  public set match(value: string) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // same_labels - computed: false, optional: true, required: false
  private _sameLabels?: string[]; 
  public get sameLabels() {
    return this.getListAttribute('same_labels');
  }
  public set sameLabels(value: string[]) {
    this._sameLabels = value;
  }
  public resetSameLabels() {
    this._sameLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sameLabelsInput() {
    return this._sameLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressTo {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelector;
  /**
  * Restrict egress access to the Fully Qualified Domain Names prescribed by name or by wildcard match patterns. This field can only be set for NetworkPolicyPeer of egress rules. Supported formats are: Exact FQDNs such as 'google.com'. Wildcard expressions such as '*wayfair.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#fqdn DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#fqdn}
  */
  readonly fqdn?: string;
  /**
  * Group is the name of the ClusterGroup which can be set within an Ingress or Egress rule in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * IPBlock describes the IPAddresses/IPBlocks that is matched in to/from. IPBlock cannot be set as part of the AppliedTo field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ip_block DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ip_block}
  */
  readonly ipBlock?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlock;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in To/From fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelector;
  /**
  * Select Pod/ExternalEntity from Namespaces matched by specific criteria. Current supported criteria is match: Self, which selects from the same Namespace of the appliedTo workloads. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. This field can only be set when NetworkPolicyPeer is created for ClusterNetworkPolicy ingress/egress rules. Cannot be set with NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespaces DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaces;
  /**
  * Select certain Nodes which match the label selector. A NodeSelector cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelector;
  /**
  * Define scope of the Pod/NamespaceSelector(s) of this peer. Can only be used in ingress NetworkPolicyPeers. Defaults to 'Cluster'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in To/From fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    group: cdktf.stringToTerraform(struct!.group),
    ip_block: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlockToTerraform(struct!.ipBlock),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespacesToTerraform(struct!.namespaces),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorToTerraform(struct!.podSelector),
    scope: cdktf.stringToTerraform(struct!.scope),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelector",
    },
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_block: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlockToHclTerraform(struct!.ipBlock),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlock",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelector",
    },
    namespaces: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespacesToHclTerraform(struct!.namespaces),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaces",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelector",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._ipBlock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipBlock = this._ipBlock?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._fqdn = undefined;
      this._group = undefined;
      this._ipBlock.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._scope = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._fqdn = value.fqdn;
      this._group = value.group;
      this._ipBlock.internalValue = value.ipBlock;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces.internalValue = value.namespaces;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._scope = value.scope;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // ip_block - computed: false, optional: true, required: false
  private _ipBlock = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlockOutputReference(this, "ip_block");
  public get ipBlock() {
    return this._ipBlock;
  }
  public putIpBlock(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToIpBlock) {
    this._ipBlock.internalValue = value;
  }
  public resetIpBlock() {
    this._ipBlock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipBlockInput() {
    return this._ipBlock.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespacesOutputReference(this, "namespaces");
  public get namespaces() {
    return this._namespaces;
  }
  public putNamespaces(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNamespaces) {
    this._namespaces.internalValue = value;
  }
  public resetNamespaces() {
    this._namespaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressTo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServices {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServicesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServicesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
      this._scope = value.scope;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServicesList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServicesOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngress {
  /**
  * Action specifies the action to be applied on the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#action DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#action}
  */
  readonly action: string;
  /**
  * Select workloads on which this rule will be applied to. Cannot be set in conjunction with NetworkPolicySpec/ClusterNetworkPolicySpec.AppliedTo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#applied_to DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#applied_to}
  */
  readonly appliedTo?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedTo[] | cdktf.IResolvable;
  /**
  * EnableLogging is used to indicate if agent should generate logs when rules are matched. Should be default to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#enable_logging DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#enable_logging}
  */
  readonly enableLogging?: boolean | cdktf.IResolvable;
  /**
  * Rule is matched if traffic originates from workloads selected by this field. If this field is empty, this rule matches all sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#from DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#from}
  */
  readonly from?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFrom[] | cdktf.IResolvable;
  /**
  * Set of layer 7 protocols matched by the rule. If this field is set, action can only be Allow. When this field is used in a rule, any traffic matching the other layer 3/4 criteria of the rule (typically the 5-tuple) will be forwarded to an application-aware engine for protocol detection and rule enforcement, and the traffic will be allowed if the layer 7 criteria is also matched, otherwise it will be dropped. Therefore, any rules after a layer 7 rule will not be enforced for the traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#l7_protocols DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#l7_protocols}
  */
  readonly l7Protocols?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7Protocols[] | cdktf.IResolvable;
  /**
  * LogLabel is a user-defined arbitrary string which will be printed in the NetworkPolicy logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#log_label DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#log_label}
  */
  readonly logLabel?: string;
  /**
  * Name describes the intention of this rule. Name should be unique within the policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Set of ports and protocols matched by the rule. If this field and Protocols are unset or empty, this rule matches all ports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ports DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ports}
  */
  readonly ports?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPorts[] | cdktf.IResolvable;
  /**
  * Set of protocols matched by the rule. If this field and Ports are unset or empty, this rule matches all protocols supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#protocols DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#protocols}
  */
  readonly protocols?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocols[] | cdktf.IResolvable;
  /**
  * Rule is matched if traffic is intended for workloads selected by this field. This field can't be used with ToServices. If this field and ToServices are both empty or missing this rule matches all destinations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#to DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#to}
  */
  readonly to?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressTo[] | cdktf.IResolvable;
  /**
  * Rule is matched if traffic is intended for a Service listed in this field. Currently, only ClusterIP types Services are supported in this field. When scope is set to ClusterSet, it matches traffic intended for a multi-cluster Service listed in this field. Service name and Namespace provided should match the original exported Service. This field can only be used when AntreaProxy is enabled. This field can't be used with To or Ports. If this field and To are both empty or missing, this rule matches all destinations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#to_services DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#to_services}
  */
  readonly toServices?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServices[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    applied_to: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToToTerraform, false)(struct!.appliedTo),
    enable_logging: cdktf.booleanToTerraform(struct!.enableLogging),
    from: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromToTerraform, false)(struct!.from),
    l7_protocols: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsToTerraform, false)(struct!.l7Protocols),
    log_label: cdktf.stringToTerraform(struct!.logLabel),
    name: cdktf.stringToTerraform(struct!.name),
    ports: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPortsToTerraform, false)(struct!.ports),
    protocols: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsToTerraform, false)(struct!.protocols),
    to: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToToTerraform, false)(struct!.to),
    to_services: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServicesToTerraform, false)(struct!.toServices),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    applied_to: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToToHclTerraform, false)(struct!.appliedTo),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToList",
    },
    enable_logging: {
      value: cdktf.booleanToHclTerraform(struct!.enableLogging),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    from: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromToHclTerraform, false)(struct!.from),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromList",
    },
    l7_protocols: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsToHclTerraform, false)(struct!.l7Protocols),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsList",
    },
    log_label: {
      value: cdktf.stringToHclTerraform(struct!.logLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPortsList",
    },
    protocols: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsToHclTerraform, false)(struct!.protocols),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsList",
    },
    to: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToToHclTerraform, false)(struct!.to),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToList",
    },
    to_services: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServicesToHclTerraform, false)(struct!.toServices),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._appliedTo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliedTo = this._appliedTo?.internalValue;
    }
    if (this._enableLogging !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLogging = this._enableLogging;
    }
    if (this._from?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.from = this._from?.internalValue;
    }
    if (this._l7Protocols?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.l7Protocols = this._l7Protocols?.internalValue;
    }
    if (this._logLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLabel = this._logLabel;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    if (this._protocols?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocols = this._protocols?.internalValue;
    }
    if (this._to?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.to = this._to?.internalValue;
    }
    if (this._toServices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.toServices = this._toServices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._appliedTo.internalValue = undefined;
      this._enableLogging = undefined;
      this._from.internalValue = undefined;
      this._l7Protocols.internalValue = undefined;
      this._logLabel = undefined;
      this._name = undefined;
      this._ports.internalValue = undefined;
      this._protocols.internalValue = undefined;
      this._to.internalValue = undefined;
      this._toServices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._appliedTo.internalValue = value.appliedTo;
      this._enableLogging = value.enableLogging;
      this._from.internalValue = value.from;
      this._l7Protocols.internalValue = value.l7Protocols;
      this._logLabel = value.logLabel;
      this._name = value.name;
      this._ports.internalValue = value.ports;
      this._protocols.internalValue = value.protocols;
      this._to.internalValue = value.to;
      this._toServices.internalValue = value.toServices;
    }
  }

  // action - computed: false, optional: false, required: true
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // applied_to - computed: false, optional: true, required: false
  private _appliedTo = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedToList(this, "applied_to", false);
  public get appliedTo() {
    return this._appliedTo;
  }
  public putAppliedTo(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressAppliedTo[] | cdktf.IResolvable) {
    this._appliedTo.internalValue = value;
  }
  public resetAppliedTo() {
    this._appliedTo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliedToInput() {
    return this._appliedTo.internalValue;
  }

  // enable_logging - computed: false, optional: true, required: false
  private _enableLogging?: boolean | cdktf.IResolvable; 
  public get enableLogging() {
    return this.getBooleanAttribute('enable_logging');
  }
  public set enableLogging(value: boolean | cdktf.IResolvable) {
    this._enableLogging = value;
  }
  public resetEnableLogging() {
    this._enableLogging = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoggingInput() {
    return this._enableLogging;
  }

  // from - computed: false, optional: true, required: false
  private _from = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFromList(this, "from", false);
  public get from() {
    return this._from;
  }
  public putFrom(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressFrom[] | cdktf.IResolvable) {
    this._from.internalValue = value;
  }
  public resetFrom() {
    this._from.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromInput() {
    return this._from.internalValue;
  }

  // l7_protocols - computed: false, optional: true, required: false
  private _l7Protocols = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7ProtocolsList(this, "l7_protocols", false);
  public get l7Protocols() {
    return this._l7Protocols;
  }
  public putL7Protocols(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressL7Protocols[] | cdktf.IResolvable) {
    this._l7Protocols.internalValue = value;
  }
  public resetL7Protocols() {
    this._l7Protocols.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get l7ProtocolsInput() {
    return this._l7Protocols.internalValue;
  }

  // log_label - computed: false, optional: true, required: false
  private _logLabel?: string; 
  public get logLabel() {
    return this.getStringAttribute('log_label');
  }
  public set logLabel(value: string) {
    this._logLabel = value;
  }
  public resetLogLabel() {
    this._logLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLabelInput() {
    return this._logLabel;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }

  // protocols - computed: false, optional: true, required: false
  private _protocols = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocolsList(this, "protocols", false);
  public get protocols() {
    return this._protocols;
  }
  public putProtocols(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressProtocols[] | cdktf.IResolvable) {
    this._protocols.internalValue = value;
  }
  public resetProtocols() {
    this._protocols.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolsInput() {
    return this._protocols.internalValue;
  }

  // to - computed: false, optional: true, required: false
  private _to = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToList(this, "to", false);
  public get to() {
    return this._to;
  }
  public putTo(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressTo[] | cdktf.IResolvable) {
    this._to.internalValue = value;
  }
  public resetTo() {
    this._to.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toInput() {
    return this._to.internalValue;
  }

  // to_services - computed: false, optional: true, required: false
  private _toServices = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServicesList(this, "to_services", false);
  public get toServices() {
    return this._toServices;
  }
  public putToServices(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToServices[] | cdktf.IResolvable) {
    this._toServices.internalValue = value;
  }
  public resetToServices() {
    this._toServices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toServicesInput() {
    return this._toServices.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngress[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicy {
  /**
  * Select workloads on which the rules will be applied to. Cannot be set in conjunction with AppliedTo in each rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#applied_to DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#applied_to}
  */
  readonly appliedTo?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedTo[] | cdktf.IResolvable;
  /**
  * Set of egress rules evaluated based on the order in which they are set. Currently Egress rule supports setting the 'To' field but not the 'From' field within a Rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#egress DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#egress}
  */
  readonly egress?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgress[] | cdktf.IResolvable;
  /**
  * Set of ingress rules evaluated based on the order in which they are set. Currently Ingress rule supports setting the 'From' field but not the 'To' field within a Rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ingress DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ingress}
  */
  readonly ingress?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngress[] | cdktf.IResolvable;
  /**
  * Priority specfies the order of the ClusterNetworkPolicy relative to other AntreaClusterNetworkPolicies.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#priority DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#priority}
  */
  readonly priority: number;
  /**
  * Tier specifies the tier to which this ClusterNetworkPolicy belongs to. The ClusterNetworkPolicy order will be determined based on the combination of the Tier's Priority and the ClusterNetworkPolicy's own Priority. If not specified, this policy will be created in the Application Tier right above the K8s NetworkPolicy which resides at the bottom.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#tier DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#tier}
  */
  readonly tier?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applied_to: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToToTerraform, false)(struct!.appliedTo),
    egress: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToTerraform, false)(struct!.egress),
    ingress: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToTerraform, false)(struct!.ingress),
    priority: cdktf.numberToTerraform(struct!.priority),
    tier: cdktf.stringToTerraform(struct!.tier),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applied_to: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToToHclTerraform, false)(struct!.appliedTo),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToList",
    },
    egress: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressToHclTerraform, false)(struct!.egress),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressList",
    },
    ingress: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressToHclTerraform, false)(struct!.ingress),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressList",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tier: {
      value: cdktf.stringToHclTerraform(struct!.tier),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliedTo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliedTo = this._appliedTo?.internalValue;
    }
    if (this._egress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.egress = this._egress?.internalValue;
    }
    if (this._ingress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingress = this._ingress?.internalValue;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._tier !== undefined) {
      hasAnyValues = true;
      internalValueResult.tier = this._tier;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliedTo.internalValue = undefined;
      this._egress.internalValue = undefined;
      this._ingress.internalValue = undefined;
      this._priority = undefined;
      this._tier = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliedTo.internalValue = value.appliedTo;
      this._egress.internalValue = value.egress;
      this._ingress.internalValue = value.ingress;
      this._priority = value.priority;
      this._tier = value.tier;
    }
  }

  // applied_to - computed: false, optional: true, required: false
  private _appliedTo = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedToList(this, "applied_to", false);
  public get appliedTo() {
    return this._appliedTo;
  }
  public putAppliedTo(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyAppliedTo[] | cdktf.IResolvable) {
    this._appliedTo.internalValue = value;
  }
  public resetAppliedTo() {
    this._appliedTo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliedToInput() {
    return this._appliedTo.internalValue;
  }

  // egress - computed: false, optional: true, required: false
  private _egress = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgressList(this, "egress", false);
  public get egress() {
    return this._egress;
  }
  public putEgress(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyEgress[] | cdktf.IResolvable) {
    this._egress.internalValue = value;
  }
  public resetEgress() {
    this._egress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressInput() {
    return this._egress.internalValue;
  }

  // ingress - computed: false, optional: true, required: false
  private _ingress = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngressList(this, "ingress", false);
  public get ingress() {
    return this._ingress;
  }
  public putIngress(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyIngress[] | cdktf.IResolvable) {
    this._ingress.internalValue = value;
  }
  public resetIngress() {
    this._ingress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressInput() {
    return this._ingress.internalValue;
  }

  // priority - computed: false, optional: false, required: true
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // tier - computed: false, optional: true, required: false
  private _tier?: string; 
  public get tier() {
    return this.getStringAttribute('tier');
  }
  public set tier(value: string) {
    this._tier = value;
  }
  public resetTier() {
    this._tier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tierInput() {
    return this._tier;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#api_version DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: 'spec.containers{name}' (where 'name' refers to the name of the container that triggered the event) or if no container name is specified 'spec.containers[2]' (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#field_path DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#field_path}
  */
  readonly fieldPath?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#kind DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#resource_version DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#resource_version}
  */
  readonly resourceVersion?: string;
  /**
  * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#uid DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#uid}
  */
  readonly uid?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    resource_version: cdktf.stringToTerraform(struct!.resourceVersion),
    uid: cdktf.stringToTerraform(struct!.uid),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_version: {
      value: cdktf.stringToHclTerraform(struct!.resourceVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uid: {
      value: cdktf.stringToHclTerraform(struct!.uid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._resourceVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceVersion = this._resourceVersion;
    }
    if (this._uid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._resourceVersion = undefined;
      this._uid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._resourceVersion = value.resourceVersion;
      this._uid = value.uid;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: true, required: false
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  public resetFieldPath() {
    this._fieldPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // resource_version - computed: false, optional: true, required: false
  private _resourceVersion?: string; 
  public get resourceVersion() {
    return this.getStringAttribute('resource_version');
  }
  public set resourceVersion(value: string) {
    this._resourceVersion = value;
  }
  public resetResourceVersion() {
    this._resourceVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceVersionInput() {
    return this._resourceVersion;
  }

  // uid - computed: false, optional: true, required: false
  private _uid?: string; 
  public get uid() {
    return this.getStringAttribute('uid');
  }
  public set uid(value: string) {
    this._uid = value;
  }
  public resetUid() {
    this._uid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddresses {
  /**
  * The Hostname of this endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#hostname DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#hostname}
  */
  readonly hostname?: string;
  /**
  * The IP of this endpoint. May not be loopback (127.0.0.0/8 or ::1), link-local (169.254.0.0/16 or fe80::/10), or link-local multicast (224.0.0.0/24 or ff02::/16).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ip DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ip}
  */
  readonly ip: string;
  /**
  * Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#node_name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#node_name}
  */
  readonly nodeName?: string;
  /**
  * Reference to object providing the endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#target_ref DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#target_ref}
  */
  readonly targetRef?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddresses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostname: cdktf.stringToTerraform(struct!.hostname),
    ip: cdktf.stringToTerraform(struct!.ip),
    node_name: cdktf.stringToTerraform(struct!.nodeName),
    target_ref: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefToTerraform(struct!.targetRef),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddresses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_name: {
      value: cdktf.stringToHclTerraform(struct!.nodeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_ref: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefToHclTerraform(struct!.targetRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddresses | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    if (this._nodeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeName = this._nodeName;
    }
    if (this._targetRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRef = this._targetRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddresses | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostname = undefined;
      this._ip = undefined;
      this._nodeName = undefined;
      this._targetRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostname = value.hostname;
      this._ip = value.ip;
      this._nodeName = value.nodeName;
      this._targetRef.internalValue = value.targetRef;
    }
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // ip - computed: false, optional: false, required: true
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }

  // node_name - computed: false, optional: true, required: false
  private _nodeName?: string; 
  public get nodeName() {
    return this.getStringAttribute('node_name');
  }
  public set nodeName(value: string) {
    this._nodeName = value;
  }
  public resetNodeName() {
    this._nodeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeNameInput() {
    return this._nodeName;
  }

  // target_ref - computed: false, optional: true, required: false
  private _targetRef = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefOutputReference(this, "target_ref");
  public get targetRef() {
    return this._targetRef;
  }
  public putTargetRef(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef) {
    this._targetRef.internalValue = value;
  }
  public resetTargetRef() {
    this._targetRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRefInput() {
    return this._targetRef.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddresses[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#api_version DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: 'spec.containers{name}' (where 'name' refers to the name of the container that triggered the event) or if no container name is specified 'spec.containers[2]' (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#field_path DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#field_path}
  */
  readonly fieldPath?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#kind DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#resource_version DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#resource_version}
  */
  readonly resourceVersion?: string;
  /**
  * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#uid DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#uid}
  */
  readonly uid?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    resource_version: cdktf.stringToTerraform(struct!.resourceVersion),
    uid: cdktf.stringToTerraform(struct!.uid),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_version: {
      value: cdktf.stringToHclTerraform(struct!.resourceVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uid: {
      value: cdktf.stringToHclTerraform(struct!.uid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._resourceVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceVersion = this._resourceVersion;
    }
    if (this._uid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._resourceVersion = undefined;
      this._uid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._resourceVersion = value.resourceVersion;
      this._uid = value.uid;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: true, required: false
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  public resetFieldPath() {
    this._fieldPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // resource_version - computed: false, optional: true, required: false
  private _resourceVersion?: string; 
  public get resourceVersion() {
    return this.getStringAttribute('resource_version');
  }
  public set resourceVersion(value: string) {
    this._resourceVersion = value;
  }
  public resetResourceVersion() {
    this._resourceVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceVersionInput() {
    return this._resourceVersion;
  }

  // uid - computed: false, optional: true, required: false
  private _uid?: string; 
  public get uid() {
    return this.getStringAttribute('uid');
  }
  public set uid(value: string) {
    this._uid = value;
  }
  public resetUid() {
    this._uid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses {
  /**
  * The Hostname of this endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#hostname DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#hostname}
  */
  readonly hostname?: string;
  /**
  * The IP of this endpoint. May not be loopback (127.0.0.0/8 or ::1), link-local (169.254.0.0/16 or fe80::/10), or link-local multicast (224.0.0.0/24 or ff02::/16).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ip DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ip}
  */
  readonly ip: string;
  /**
  * Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#node_name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#node_name}
  */
  readonly nodeName?: string;
  /**
  * Reference to object providing the endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#target_ref DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#target_ref}
  */
  readonly targetRef?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostname: cdktf.stringToTerraform(struct!.hostname),
    ip: cdktf.stringToTerraform(struct!.ip),
    node_name: cdktf.stringToTerraform(struct!.nodeName),
    target_ref: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefToTerraform(struct!.targetRef),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_name: {
      value: cdktf.stringToHclTerraform(struct!.nodeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_ref: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefToHclTerraform(struct!.targetRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    if (this._nodeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeName = this._nodeName;
    }
    if (this._targetRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRef = this._targetRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostname = undefined;
      this._ip = undefined;
      this._nodeName = undefined;
      this._targetRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostname = value.hostname;
      this._ip = value.ip;
      this._nodeName = value.nodeName;
      this._targetRef.internalValue = value.targetRef;
    }
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // ip - computed: false, optional: false, required: true
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }

  // node_name - computed: false, optional: true, required: false
  private _nodeName?: string; 
  public get nodeName() {
    return this.getStringAttribute('node_name');
  }
  public set nodeName(value: string) {
    this._nodeName = value;
  }
  public resetNodeName() {
    this._nodeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeNameInput() {
    return this._nodeName;
  }

  // target_ref - computed: false, optional: true, required: false
  private _targetRef = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefOutputReference(this, "target_ref");
  public get targetRef() {
    return this._targetRef;
  }
  public putTargetRef(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef) {
    this._targetRef.internalValue = value;
  }
  public resetTargetRef() {
    this._targetRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRefInput() {
    return this._targetRef.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPorts {
  /**
  * The application protocol for this port. This is used as a hint for implementations to offer richer behavior for protocols that they understand. This field follows standard Kubernetes label syntax. Valid values are either: * Un-prefixed protocol names - reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). * Kubernetes-defined prefixed names: * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior- * 'kubernetes.io/ws' - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455 * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455 * Other protocols should use implementation-defined prefixed names such as mycompany.com/my-custom-protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#app_protocol DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#app_protocol}
  */
  readonly appProtocol?: string;
  /**
  * The name of this port. This must match the 'name' field in the corresponding ServicePort. Must be a DNS_LABEL. Optional only if one port is defined.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * The port number of the endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#port}
  */
  readonly port: number;
  /**
  * The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#protocol DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#protocol}
  */
  readonly protocol?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPortsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_protocol: cdktf.stringToTerraform(struct!.appProtocol),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPortsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_protocol: {
      value: cdktf.stringToHclTerraform(struct!.appProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.appProtocol = this._appProtocol;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appProtocol = undefined;
      this._name = undefined;
      this._port = undefined;
      this._protocol = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appProtocol = value.appProtocol;
      this._name = value.name;
      this._port = value.port;
      this._protocol = value.protocol;
    }
  }

  // app_protocol - computed: false, optional: true, required: false
  private _appProtocol?: string; 
  public get appProtocol() {
    return this.getStringAttribute('app_protocol');
  }
  public set appProtocol(value: string) {
    this._appProtocol = value;
  }
  public resetAppProtocol() {
    this._appProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appProtocolInput() {
    return this._appProtocol;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPortsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsets {
  /**
  * IP addresses which offer the related ports that are marked as ready. These endpoints should be considered safe for load balancers and clients to utilize.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#addresses DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#addresses}
  */
  readonly addresses?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddresses[] | cdktf.IResolvable;
  /**
  * IP addresses which offer the related ports but are not currently marked as ready because they have not yet finished starting, have recently failed a readiness check, or have recently failed a liveness check.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#not_ready_addresses DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#not_ready_addresses}
  */
  readonly notReadyAddresses?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses[] | cdktf.IResolvable;
  /**
  * Port numbers available on the related IP addresses.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ports DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ports}
  */
  readonly ports?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPorts[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    addresses: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesToTerraform, false)(struct!.addresses),
    not_ready_addresses: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesToTerraform, false)(struct!.notReadyAddresses),
    ports: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPortsToTerraform, false)(struct!.ports),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    addresses: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesToHclTerraform, false)(struct!.addresses),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesList",
    },
    not_ready_addresses: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesToHclTerraform, false)(struct!.notReadyAddresses),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesList",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPortsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addresses?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addresses = this._addresses?.internalValue;
    }
    if (this._notReadyAddresses?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.notReadyAddresses = this._notReadyAddresses?.internalValue;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addresses.internalValue = undefined;
      this._notReadyAddresses.internalValue = undefined;
      this._ports.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addresses.internalValue = value.addresses;
      this._notReadyAddresses.internalValue = value.notReadyAddresses;
      this._ports.internalValue = value.ports;
    }
  }

  // addresses - computed: false, optional: true, required: false
  private _addresses = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddressesList(this, "addresses", false);
  public get addresses() {
    return this._addresses;
  }
  public putAddresses(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsAddresses[] | cdktf.IResolvable) {
    this._addresses.internalValue = value;
  }
  public resetAddresses() {
    this._addresses.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressesInput() {
    return this._addresses.internalValue;
  }

  // not_ready_addresses - computed: false, optional: true, required: false
  private _notReadyAddresses = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesList(this, "not_ready_addresses", false);
  public get notReadyAddresses() {
    return this._notReadyAddresses;
  }
  public putNotReadyAddresses(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses[] | cdktf.IResolvable) {
    this._notReadyAddresses.internalValue = value;
  }
  public resetNotReadyAddresses() {
    this._notReadyAddresses.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get notReadyAddressesInput() {
    return this._notReadyAddresses.internalValue;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpoints {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#subsets DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#subsets}
  */
  readonly subsets?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsets[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    subsets: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsToTerraform, false)(struct!.subsets),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    subsets: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsToHclTerraform, false)(struct!.subsets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._subsets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsets = this._subsets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._subsets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._subsets.internalValue = value.subsets;
    }
  }

  // subsets - computed: false, optional: true, required: false
  private _subsets = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsetsList(this, "subsets", false);
  public get subsets() {
    return this._subsets;
  }
  public putSubsets(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsSubsets[] | cdktf.IResolvable) {
    this._subsets.internalValue = value;
  }
  public resetSubsets() {
    this._subsets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsetsInput() {
    return this._subsets.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpoints {
  /**
  * IP associated with this endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ip DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ip}
  */
  readonly ip?: string;
  /**
  * Name identifies this endpoint. Could be the network interface name in case of VMs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpointsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ip: cdktf.stringToTerraform(struct!.ip),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpointsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ip = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ip = value.ip;
      this._name = value.name;
    }
  }

  // ip - computed: false, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpointsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPorts {
  /**
  * Name associated with the Port.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * The port on the given protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field defaults to TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#protocol DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#protocol}
  */
  readonly protocol?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPortsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPortsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._port = undefined;
      this._protocol = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._port = value.port;
      this._protocol = value.protocol;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPortsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpec {
  /**
  * Endpoints is a list of external endpoints associated with this entity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#endpoints DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#endpoints}
  */
  readonly endpoints?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpoints[] | cdktf.IResolvable;
  /**
  * ExternalNode is the opaque identifier of the agent/controller responsible for additional processing or handling of this external entity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_node DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_node}
  */
  readonly externalNode?: string;
  /**
  * Ports maintain the list of named ports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ports DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ports}
  */
  readonly ports?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPorts[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoints: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpointsToTerraform, false)(struct!.endpoints),
    external_node: cdktf.stringToTerraform(struct!.externalNode),
    ports: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPortsToTerraform, false)(struct!.ports),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpointsList",
    },
    external_node: {
      value: cdktf.stringToHclTerraform(struct!.externalNode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPortsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._externalNode !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalNode = this._externalNode;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoints.internalValue = undefined;
      this._externalNode = undefined;
      this._ports.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoints.internalValue = value.endpoints;
      this._externalNode = value.externalNode;
      this._ports.internalValue = value.ports;
    }
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // external_node - computed: false, optional: true, required: false
  private _externalNode?: string; 
  public get externalNode() {
    return this.getStringAttribute('external_node');
  }
  public set externalNode(value: string) {
    this._externalNode = value;
  }
  public resetExternalNode() {
    this._externalNode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalNodeInput() {
    return this._externalNode;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntity {
  /**
  * ExternalEntitySpec defines the desired state for ExternalEntity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_entity_spec DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_entity_spec}
  */
  readonly externalEntitySpec?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpec;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_spec: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecToTerraform(struct!.externalEntitySpec),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_spec: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecToHclTerraform(struct!.externalEntitySpec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySpec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySpec = this._externalEntitySpec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySpec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySpec.internalValue = value.externalEntitySpec;
    }
  }

  // external_entity_spec - computed: false, optional: true, required: false
  private _externalEntitySpec = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpecOutputReference(this, "external_entity_spec");
  public get externalEntitySpec() {
    return this._externalEntitySpec;
  }
  public putExternalEntitySpec(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityExternalEntitySpec) {
    this._externalEntitySpec.internalValue = value;
  }
  public resetExternalEntitySpec() {
    this._externalEntitySpec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySpecInput() {
    return this._externalEntitySpec.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#normalized_label DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#normalized_label}
  */
  readonly normalizedLabel?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentityToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    normalized_label: cdktf.stringToTerraform(struct!.normalizedLabel),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentityToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    normalized_label: {
      value: cdktf.stringToHclTerraform(struct!.normalizedLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._normalizedLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalizedLabel = this._normalizedLabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._normalizedLabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._normalizedLabel = value.normalizedLabel;
    }
  }

  // normalized_label - computed: false, optional: true, required: false
  private _normalizedLabel?: string; 
  public get normalizedLabel() {
    return this.getStringAttribute('normalized_label');
  }
  public set normalizedLabel(value: string) {
    this._normalizedLabel = value;
  }
  public resetNormalizedLabel() {
    this._normalizedLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalizedLabelInput() {
    return this._normalizedLabel;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRaw {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#data DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#data}
  */
  readonly data?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRawToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRaw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data: cdktf.stringToTerraform(struct!.data),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRawToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRaw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data: {
      value: cdktf.stringToHclTerraform(struct!.data),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRawOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRaw | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._data !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRaw | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._data = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._data = value.data;
    }
  }

  // data - computed: false, optional: true, required: false
  private _data?: string; 
  public get data() {
    return this.getStringAttribute('data');
  }
  public set data(value: string) {
    this._data = value;
  }
  public resetData() {
    this._data = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPorts {
  /**
  * The application protocol for this port. This is used as a hint for implementations to offer richer behavior for protocols that they understand. This field follows standard Kubernetes label syntax. Valid values are either: * Un-prefixed protocol names - reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). * Kubernetes-defined prefixed names: * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior- * 'kubernetes.io/ws' - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455 * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455 * Other protocols should use implementation-defined prefixed names such as mycompany.com/my-custom-protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#app_protocol DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#app_protocol}
  */
  readonly appProtocol?: string;
  /**
  * The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * The port on each node on which this service is exposed when type is NodePort or LoadBalancer. Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail. If not specified, a port will be allocated if this Service requires one. If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#node_port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#node_port}
  */
  readonly nodePort?: number;
  /**
  * The port that will be exposed by this service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#port}
  */
  readonly port: number;
  /**
  * The IP protocol for this port. Supports 'TCP', 'UDP', and 'SCTP'. Default is TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#protocol DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#target_port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#target_port}
  */
  readonly targetPort?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPortsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_protocol: cdktf.stringToTerraform(struct!.appProtocol),
    name: cdktf.stringToTerraform(struct!.name),
    node_port: cdktf.numberToTerraform(struct!.nodePort),
    port: cdktf.numberToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    target_port: cdktf.stringToTerraform(struct!.targetPort),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPortsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_protocol: {
      value: cdktf.stringToHclTerraform(struct!.appProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_port: {
      value: cdktf.numberToHclTerraform(struct!.nodePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_port: {
      value: cdktf.stringToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.appProtocol = this._appProtocol;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._nodePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodePort = this._nodePort;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appProtocol = undefined;
      this._name = undefined;
      this._nodePort = undefined;
      this._port = undefined;
      this._protocol = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appProtocol = value.appProtocol;
      this._name = value.name;
      this._nodePort = value.nodePort;
      this._port = value.port;
      this._protocol = value.protocol;
      this._targetPort = value.targetPort;
    }
  }

  // app_protocol - computed: false, optional: true, required: false
  private _appProtocol?: string; 
  public get appProtocol() {
    return this.getStringAttribute('app_protocol');
  }
  public set appProtocol(value: string) {
    this._appProtocol = value;
  }
  public resetAppProtocol() {
    this._appProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appProtocolInput() {
    return this._appProtocol;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // node_port - computed: false, optional: true, required: false
  private _nodePort?: number; 
  public get nodePort() {
    return this.getNumberAttribute('node_port');
  }
  public set nodePort(value: number) {
    this._nodePort = value;
  }
  public resetNodePort() {
    this._nodePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodePortInput() {
    return this._nodePort;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // target_port - computed: false, optional: true, required: false
  private _targetPort?: string; 
  public get targetPort() {
    return this.getStringAttribute('target_port');
  }
  public set targetPort(value: string) {
    this._targetPort = value;
  }
  public resetTargetPort() {
    this._targetPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPortsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIp {
  /**
  * timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == 'ClientIP'. Default value is 10800(for 3 hours).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#timeout_seconds DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#timeout_seconds}
  */
  readonly timeoutSeconds?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    timeout_seconds: cdktf.numberToTerraform(struct!.timeoutSeconds),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    timeout_seconds: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._timeoutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSeconds = this._timeoutSeconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._timeoutSeconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._timeoutSeconds = value.timeoutSeconds;
    }
  }

  // timeout_seconds - computed: false, optional: true, required: false
  private _timeoutSeconds?: number; 
  public get timeoutSeconds() {
    return this.getNumberAttribute('timeout_seconds');
  }
  public set timeoutSeconds(value: number) {
    this._timeoutSeconds = value;
  }
  public resetTimeoutSeconds() {
    this._timeoutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecondsInput() {
    return this._timeoutSeconds;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfig {
  /**
  * clientIP contains the configurations of Client IP based session affinity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#client_ip DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#client_ip}
  */
  readonly clientIp?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIp;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_ip: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIpToTerraform(struct!.clientIp),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_ip: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIpToHclTerraform(struct!.clientIp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientIp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientIp = this._clientIp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientIp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientIp.internalValue = value.clientIp;
    }
  }

  // client_ip - computed: false, optional: true, required: false
  private _clientIp = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIpOutputReference(this, "client_ip");
  public get clientIp() {
    return this._clientIp;
  }
  public putClientIp(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigClientIp) {
    this._clientIp.internalValue = value;
  }
  public resetClientIp() {
    this._clientIp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIpInput() {
    return this._clientIp.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpec {
  /**
  * allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer. Default is 'true'. It may be set to 'false' if the cluster load-balancer does not rely on NodePorts. If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#allocate_load_balancer_node_ports DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#allocate_load_balancer_node_ports}
  */
  readonly allocateLoadBalancerNodePorts?: boolean | cdktf.IResolvable;
  /**
  * ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above). Valid values are 'None', empty string (''), or a valid IP address. Setting this to 'None' makes a 'headless service' (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. If this field is not specified, it will be initialized from the clusterIP field. If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#cluster_i_ps DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#cluster_i_ps}
  */
  readonly clusterIPs?: string[];
  /**
  * clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above). Valid values are 'None', empty string (''), or a valid IP address. Setting this to 'None' makes a 'headless service' (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#cluster_ip DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#cluster_ip}
  */
  readonly clusterIp?: string;
  /**
  * externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_i_ps DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_i_ps}
  */
  readonly externalIPs?: string[];
  /**
  * externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved. Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires 'type' to be 'ExternalName'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_name}
  */
  readonly externalName?: string;
  /**
  * externalTrafficPolicy describes how nodes distribute service traffic they receive on one of the Service's 'externally-facing' addresses (NodePorts, ExternalIPs, and LoadBalancer IPs). If set to 'Local', the proxy will configure the service in a way that assumes that external load balancers will take care of balancing the service traffic between nodes, and so each node will deliver traffic only to the node-local endpoints of the service, without masquerading the client source IP. (Traffic mistakenly sent to a node with no endpoints will be dropped.) The default value, 'Cluster', uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features). Note that traffic sent to an External IP or LoadBalancer IP from within the cluster will always get 'Cluster' semantics, but clients sending to a NodePort from within the cluster may need to take traffic policy into account when picking a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_traffic_policy DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_traffic_policy}
  */
  readonly externalTrafficPolicy?: string;
  /**
  * healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used. If not specified, a value will be automatically allocated. External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not. If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type). This field cannot be updated once set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#health_check_node_port DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#health_check_node_port}
  */
  readonly healthCheckNodePort?: number;
  /**
  * InternalTrafficPolicy describes how nodes distribute service traffic they receive on the ClusterIP. If set to 'Local', the proxy will assume that pods only want to talk to endpoints of the service on the same node as the pod, dropping the traffic if there are no local endpoints. The default value, 'Cluster', uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#internal_traffic_policy DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#internal_traffic_policy}
  */
  readonly internalTrafficPolicy?: string;
  /**
  * IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are 'IPv4' and 'IPv6'. This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to 'headless' services. This field will be wiped when updating a Service to type ExternalName. This field may hold a maximum of two entries (dual-stack families, in either order). These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ip_families DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ip_families}
  */
  readonly ipFamilies?: string[];
  /**
  * IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be 'SingleStack' (a single IP family), 'PreferDualStack' (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or 'RequireDualStack' (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ip_family_policy DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ip_family_policy}
  */
  readonly ipFamilyPolicy?: string;
  /**
  * loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. 'internal-vip' or 'example.com/internal-vip'. Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#load_balancer_class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#load_balancer_class}
  */
  readonly loadBalancerClass?: string;
  /**
  * Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations. Using it is non-portable and it may not support dual-stack. Users are encouraged to use implementation-specific annotations when available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#load_balancer_ip DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#load_balancer_ip}
  */
  readonly loadBalancerIp?: string;
  /**
  * If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature.' More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#load_balancer_source_ranges DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#load_balancer_source_ranges}
  */
  readonly loadBalancerSourceRanges?: string[];
  /**
  * The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#ports DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#ports}
  */
  readonly ports?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPorts[] | cdktf.IResolvable;
  /**
  * publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered 'ready' even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#publish_not_ready_addresses DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#publish_not_ready_addresses}
  */
  readonly publishNotReadyAddresses?: boolean | cdktf.IResolvable;
  /**
  * Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#selector DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#selector}
  */
  readonly selector?: { [key: string]: string };
  /**
  * Supports 'ClientIP' and 'None'. Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#session_affinity DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#session_affinity}
  */
  readonly sessionAffinity?: string;
  /**
  * sessionAffinityConfig contains the configurations of session affinity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#session_affinity_config DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#session_affinity_config}
  */
  readonly sessionAffinityConfig?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfig;
  /**
  * TrafficDistribution offers a way to express preferences for how traffic is distributed to Service endpoints. Implementations can use this field as a hint, but are not required to guarantee strict adherence. If the field is not set, the implementation will apply its default routing strategy. If set to 'PreferClose', implementations should prioritize endpoints that are topologically close (e.g., same zone). This is an alpha field and requires enabling ServiceTrafficDistribution feature.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#traffic_distribution DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#traffic_distribution}
  */
  readonly trafficDistribution?: string;
  /**
  * type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. 'ClusterIP' allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is 'None', no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. 'NodePort' builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. 'LoadBalancer' builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. 'ExternalName' aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#type DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#type}
  */
  readonly type?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allocate_load_balancer_node_ports: cdktf.booleanToTerraform(struct!.allocateLoadBalancerNodePorts),
    cluster_i_ps: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.clusterIPs),
    cluster_ip: cdktf.stringToTerraform(struct!.clusterIp),
    external_i_ps: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.externalIPs),
    external_name: cdktf.stringToTerraform(struct!.externalName),
    external_traffic_policy: cdktf.stringToTerraform(struct!.externalTrafficPolicy),
    health_check_node_port: cdktf.numberToTerraform(struct!.healthCheckNodePort),
    internal_traffic_policy: cdktf.stringToTerraform(struct!.internalTrafficPolicy),
    ip_families: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ipFamilies),
    ip_family_policy: cdktf.stringToTerraform(struct!.ipFamilyPolicy),
    load_balancer_class: cdktf.stringToTerraform(struct!.loadBalancerClass),
    load_balancer_ip: cdktf.stringToTerraform(struct!.loadBalancerIp),
    load_balancer_source_ranges: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.loadBalancerSourceRanges),
    ports: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPortsToTerraform, false)(struct!.ports),
    publish_not_ready_addresses: cdktf.booleanToTerraform(struct!.publishNotReadyAddresses),
    selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.selector),
    session_affinity: cdktf.stringToTerraform(struct!.sessionAffinity),
    session_affinity_config: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigToTerraform(struct!.sessionAffinityConfig),
    traffic_distribution: cdktf.stringToTerraform(struct!.trafficDistribution),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allocate_load_balancer_node_ports: {
      value: cdktf.booleanToHclTerraform(struct!.allocateLoadBalancerNodePorts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    cluster_i_ps: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.clusterIPs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    cluster_ip: {
      value: cdktf.stringToHclTerraform(struct!.clusterIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_i_ps: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.externalIPs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    external_name: {
      value: cdktf.stringToHclTerraform(struct!.externalName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_traffic_policy: {
      value: cdktf.stringToHclTerraform(struct!.externalTrafficPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    health_check_node_port: {
      value: cdktf.numberToHclTerraform(struct!.healthCheckNodePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    internal_traffic_policy: {
      value: cdktf.stringToHclTerraform(struct!.internalTrafficPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_families: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ipFamilies),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ip_family_policy: {
      value: cdktf.stringToHclTerraform(struct!.ipFamilyPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancer_class: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancerClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancer_ip: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancerIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancer_source_ranges: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.loadBalancerSourceRanges),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPortsList",
    },
    publish_not_ready_addresses: {
      value: cdktf.booleanToHclTerraform(struct!.publishNotReadyAddresses),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.selector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    session_affinity: {
      value: cdktf.stringToHclTerraform(struct!.sessionAffinity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_affinity_config: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigToHclTerraform(struct!.sessionAffinityConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfig",
    },
    traffic_distribution: {
      value: cdktf.stringToHclTerraform(struct!.trafficDistribution),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allocateLoadBalancerNodePorts !== undefined) {
      hasAnyValues = true;
      internalValueResult.allocateLoadBalancerNodePorts = this._allocateLoadBalancerNodePorts;
    }
    if (this._clusterIPs !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterIPs = this._clusterIPs;
    }
    if (this._clusterIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterIp = this._clusterIp;
    }
    if (this._externalIPs !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalIPs = this._externalIPs;
    }
    if (this._externalName !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalName = this._externalName;
    }
    if (this._externalTrafficPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalTrafficPolicy = this._externalTrafficPolicy;
    }
    if (this._healthCheckNodePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthCheckNodePort = this._healthCheckNodePort;
    }
    if (this._internalTrafficPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.internalTrafficPolicy = this._internalTrafficPolicy;
    }
    if (this._ipFamilies !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipFamilies = this._ipFamilies;
    }
    if (this._ipFamilyPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipFamilyPolicy = this._ipFamilyPolicy;
    }
    if (this._loadBalancerClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerClass = this._loadBalancerClass;
    }
    if (this._loadBalancerIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerIp = this._loadBalancerIp;
    }
    if (this._loadBalancerSourceRanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerSourceRanges = this._loadBalancerSourceRanges;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    if (this._publishNotReadyAddresses !== undefined) {
      hasAnyValues = true;
      internalValueResult.publishNotReadyAddresses = this._publishNotReadyAddresses;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._sessionAffinity !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionAffinity = this._sessionAffinity;
    }
    if (this._sessionAffinityConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionAffinityConfig = this._sessionAffinityConfig?.internalValue;
    }
    if (this._trafficDistribution !== undefined) {
      hasAnyValues = true;
      internalValueResult.trafficDistribution = this._trafficDistribution;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allocateLoadBalancerNodePorts = undefined;
      this._clusterIPs = undefined;
      this._clusterIp = undefined;
      this._externalIPs = undefined;
      this._externalName = undefined;
      this._externalTrafficPolicy = undefined;
      this._healthCheckNodePort = undefined;
      this._internalTrafficPolicy = undefined;
      this._ipFamilies = undefined;
      this._ipFamilyPolicy = undefined;
      this._loadBalancerClass = undefined;
      this._loadBalancerIp = undefined;
      this._loadBalancerSourceRanges = undefined;
      this._ports.internalValue = undefined;
      this._publishNotReadyAddresses = undefined;
      this._selector = undefined;
      this._sessionAffinity = undefined;
      this._sessionAffinityConfig.internalValue = undefined;
      this._trafficDistribution = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allocateLoadBalancerNodePorts = value.allocateLoadBalancerNodePorts;
      this._clusterIPs = value.clusterIPs;
      this._clusterIp = value.clusterIp;
      this._externalIPs = value.externalIPs;
      this._externalName = value.externalName;
      this._externalTrafficPolicy = value.externalTrafficPolicy;
      this._healthCheckNodePort = value.healthCheckNodePort;
      this._internalTrafficPolicy = value.internalTrafficPolicy;
      this._ipFamilies = value.ipFamilies;
      this._ipFamilyPolicy = value.ipFamilyPolicy;
      this._loadBalancerClass = value.loadBalancerClass;
      this._loadBalancerIp = value.loadBalancerIp;
      this._loadBalancerSourceRanges = value.loadBalancerSourceRanges;
      this._ports.internalValue = value.ports;
      this._publishNotReadyAddresses = value.publishNotReadyAddresses;
      this._selector = value.selector;
      this._sessionAffinity = value.sessionAffinity;
      this._sessionAffinityConfig.internalValue = value.sessionAffinityConfig;
      this._trafficDistribution = value.trafficDistribution;
      this._type = value.type;
    }
  }

  // allocate_load_balancer_node_ports - computed: false, optional: true, required: false
  private _allocateLoadBalancerNodePorts?: boolean | cdktf.IResolvable; 
  public get allocateLoadBalancerNodePorts() {
    return this.getBooleanAttribute('allocate_load_balancer_node_ports');
  }
  public set allocateLoadBalancerNodePorts(value: boolean | cdktf.IResolvable) {
    this._allocateLoadBalancerNodePorts = value;
  }
  public resetAllocateLoadBalancerNodePorts() {
    this._allocateLoadBalancerNodePorts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allocateLoadBalancerNodePortsInput() {
    return this._allocateLoadBalancerNodePorts;
  }

  // cluster_i_ps - computed: false, optional: true, required: false
  private _clusterIPs?: string[]; 
  public get clusterIPs() {
    return this.getListAttribute('cluster_i_ps');
  }
  public set clusterIPs(value: string[]) {
    this._clusterIPs = value;
  }
  public resetClusterIPs() {
    this._clusterIPs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIPsInput() {
    return this._clusterIPs;
  }

  // cluster_ip - computed: false, optional: true, required: false
  private _clusterIp?: string; 
  public get clusterIp() {
    return this.getStringAttribute('cluster_ip');
  }
  public set clusterIp(value: string) {
    this._clusterIp = value;
  }
  public resetClusterIp() {
    this._clusterIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIpInput() {
    return this._clusterIp;
  }

  // external_i_ps - computed: false, optional: true, required: false
  private _externalIPs?: string[]; 
  public get externalIPs() {
    return this.getListAttribute('external_i_ps');
  }
  public set externalIPs(value: string[]) {
    this._externalIPs = value;
  }
  public resetExternalIPs() {
    this._externalIPs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIPsInput() {
    return this._externalIPs;
  }

  // external_name - computed: false, optional: true, required: false
  private _externalName?: string; 
  public get externalName() {
    return this.getStringAttribute('external_name');
  }
  public set externalName(value: string) {
    this._externalName = value;
  }
  public resetExternalName() {
    this._externalName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalNameInput() {
    return this._externalName;
  }

  // external_traffic_policy - computed: false, optional: true, required: false
  private _externalTrafficPolicy?: string; 
  public get externalTrafficPolicy() {
    return this.getStringAttribute('external_traffic_policy');
  }
  public set externalTrafficPolicy(value: string) {
    this._externalTrafficPolicy = value;
  }
  public resetExternalTrafficPolicy() {
    this._externalTrafficPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalTrafficPolicyInput() {
    return this._externalTrafficPolicy;
  }

  // health_check_node_port - computed: false, optional: true, required: false
  private _healthCheckNodePort?: number; 
  public get healthCheckNodePort() {
    return this.getNumberAttribute('health_check_node_port');
  }
  public set healthCheckNodePort(value: number) {
    this._healthCheckNodePort = value;
  }
  public resetHealthCheckNodePort() {
    this._healthCheckNodePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthCheckNodePortInput() {
    return this._healthCheckNodePort;
  }

  // internal_traffic_policy - computed: false, optional: true, required: false
  private _internalTrafficPolicy?: string; 
  public get internalTrafficPolicy() {
    return this.getStringAttribute('internal_traffic_policy');
  }
  public set internalTrafficPolicy(value: string) {
    this._internalTrafficPolicy = value;
  }
  public resetInternalTrafficPolicy() {
    this._internalTrafficPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get internalTrafficPolicyInput() {
    return this._internalTrafficPolicy;
  }

  // ip_families - computed: false, optional: true, required: false
  private _ipFamilies?: string[]; 
  public get ipFamilies() {
    return this.getListAttribute('ip_families');
  }
  public set ipFamilies(value: string[]) {
    this._ipFamilies = value;
  }
  public resetIpFamilies() {
    this._ipFamilies = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipFamiliesInput() {
    return this._ipFamilies;
  }

  // ip_family_policy - computed: false, optional: true, required: false
  private _ipFamilyPolicy?: string; 
  public get ipFamilyPolicy() {
    return this.getStringAttribute('ip_family_policy');
  }
  public set ipFamilyPolicy(value: string) {
    this._ipFamilyPolicy = value;
  }
  public resetIpFamilyPolicy() {
    this._ipFamilyPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipFamilyPolicyInput() {
    return this._ipFamilyPolicy;
  }

  // load_balancer_class - computed: false, optional: true, required: false
  private _loadBalancerClass?: string; 
  public get loadBalancerClass() {
    return this.getStringAttribute('load_balancer_class');
  }
  public set loadBalancerClass(value: string) {
    this._loadBalancerClass = value;
  }
  public resetLoadBalancerClass() {
    this._loadBalancerClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerClassInput() {
    return this._loadBalancerClass;
  }

  // load_balancer_ip - computed: false, optional: true, required: false
  private _loadBalancerIp?: string; 
  public get loadBalancerIp() {
    return this.getStringAttribute('load_balancer_ip');
  }
  public set loadBalancerIp(value: string) {
    this._loadBalancerIp = value;
  }
  public resetLoadBalancerIp() {
    this._loadBalancerIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerIpInput() {
    return this._loadBalancerIp;
  }

  // load_balancer_source_ranges - computed: false, optional: true, required: false
  private _loadBalancerSourceRanges?: string[]; 
  public get loadBalancerSourceRanges() {
    return this.getListAttribute('load_balancer_source_ranges');
  }
  public set loadBalancerSourceRanges(value: string[]) {
    this._loadBalancerSourceRanges = value;
  }
  public resetLoadBalancerSourceRanges() {
    this._loadBalancerSourceRanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerSourceRangesInput() {
    return this._loadBalancerSourceRanges;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }

  // publish_not_ready_addresses - computed: false, optional: true, required: false
  private _publishNotReadyAddresses?: boolean | cdktf.IResolvable; 
  public get publishNotReadyAddresses() {
    return this.getBooleanAttribute('publish_not_ready_addresses');
  }
  public set publishNotReadyAddresses(value: boolean | cdktf.IResolvable) {
    this._publishNotReadyAddresses = value;
  }
  public resetPublishNotReadyAddresses() {
    this._publishNotReadyAddresses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publishNotReadyAddressesInput() {
    return this._publishNotReadyAddresses;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: { [key: string]: string }; 
  public get selector() {
    return this.getStringMapAttribute('selector');
  }
  public set selector(value: { [key: string]: string }) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // session_affinity - computed: false, optional: true, required: false
  private _sessionAffinity?: string; 
  public get sessionAffinity() {
    return this.getStringAttribute('session_affinity');
  }
  public set sessionAffinity(value: string) {
    this._sessionAffinity = value;
  }
  public resetSessionAffinity() {
    this._sessionAffinity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionAffinityInput() {
    return this._sessionAffinity;
  }

  // session_affinity_config - computed: false, optional: true, required: false
  private _sessionAffinityConfig = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfigOutputReference(this, "session_affinity_config");
  public get sessionAffinityConfig() {
    return this._sessionAffinityConfig;
  }
  public putSessionAffinityConfig(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecSessionAffinityConfig) {
    this._sessionAffinityConfig.internalValue = value;
  }
  public resetSessionAffinityConfig() {
    this._sessionAffinityConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionAffinityConfigInput() {
    return this._sessionAffinityConfig.internalValue;
  }

  // traffic_distribution - computed: false, optional: true, required: false
  private _trafficDistribution?: string; 
  public get trafficDistribution() {
    return this.getStringAttribute('traffic_distribution');
  }
  public set trafficDistribution(value: string) {
    this._trafficDistribution = value;
  }
  public resetTrafficDistribution() {
    this._trafficDistribution = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trafficDistributionInput() {
    return this._trafficDistribution;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecService {
  /**
  * ServiceSpec describes the attributes that a user creates on a service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service_spec DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service_spec}
  */
  readonly serviceSpec?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpec;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    service_spec: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecToTerraform(struct!.serviceSpec),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    service_spec: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecToHclTerraform(struct!.serviceSpec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._serviceSpec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceSpec = this._serviceSpec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._serviceSpec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._serviceSpec.internalValue = value.serviceSpec;
    }
  }

  // service_spec - computed: false, optional: true, required: false
  private _serviceSpec = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpecOutputReference(this, "service_spec");
  public get serviceSpec() {
    return this._serviceSpec;
  }
  public putServiceSpec(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceServiceSpec) {
    this._serviceSpec.internalValue = value;
  }
  public resetServiceSpec() {
    this._serviceSpec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceSpecInput() {
    return this._serviceSpec.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpec {
  /**
  * ClusterID specifies the member cluster this resource exported from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#cluster_id DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#cluster_id}
  */
  readonly clusterId?: string;
  /**
  * If exported resource is ClusterInfo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#cluster_info DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#cluster_info}
  */
  readonly clusterInfo?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfo;
  /**
  * If exported resource is AntreaClusterNetworkPolicy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#cluster_network_policy DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#cluster_network_policy}
  */
  readonly clusterNetworkPolicy?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicy;
  /**
  * If exported resource is Endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#endpoints DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#endpoints}
  */
  readonly endpoints?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpoints;
  /**
  * If exported resource is ExternalEntity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#external_entity DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#external_entity}
  */
  readonly externalEntity?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntity;
  /**
  * Kind of exported resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#kind DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * If exported resource is LabelIdentity of a cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#label_identity DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#label_identity}
  */
  readonly labelIdentity?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentity;
  /**
  * Name of exported resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of exported resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * If exported resource kind is unknown.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#raw DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#raw}
  */
  readonly raw?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRaw;
  /**
  * If exported resource is Service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#service DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest#service}
  */
  readonly service?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecService;
}

export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_id: cdktf.stringToTerraform(struct!.clusterId),
    cluster_info: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoToTerraform(struct!.clusterInfo),
    cluster_network_policy: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyToTerraform(struct!.clusterNetworkPolicy),
    endpoints: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsToTerraform(struct!.endpoints),
    external_entity: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityToTerraform(struct!.externalEntity),
    kind: cdktf.stringToTerraform(struct!.kind),
    label_identity: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentityToTerraform(struct!.labelIdentity),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    raw: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRawToTerraform(struct!.raw),
    service: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceToTerraform(struct!.service),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_info: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoToHclTerraform(struct!.clusterInfo),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfo",
    },
    cluster_network_policy: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyToHclTerraform(struct!.clusterNetworkPolicy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicy",
    },
    endpoints: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsToHclTerraform(struct!.endpoints),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpoints",
    },
    external_entity: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityToHclTerraform(struct!.externalEntity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntity",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_identity: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentityToHclTerraform(struct!.labelIdentity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentity",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    raw: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRawToHclTerraform(struct!.raw),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRaw",
    },
    service: {
      value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecService",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._clusterInfo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterInfo = this._clusterInfo?.internalValue;
    }
    if (this._clusterNetworkPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterNetworkPolicy = this._clusterNetworkPolicy?.internalValue;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._externalEntity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntity = this._externalEntity?.internalValue;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._labelIdentity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelIdentity = this._labelIdentity?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._raw?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.raw = this._raw?.internalValue;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterId = undefined;
      this._clusterInfo.internalValue = undefined;
      this._clusterNetworkPolicy.internalValue = undefined;
      this._endpoints.internalValue = undefined;
      this._externalEntity.internalValue = undefined;
      this._kind = undefined;
      this._labelIdentity.internalValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._raw.internalValue = undefined;
      this._service.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterId = value.clusterId;
      this._clusterInfo.internalValue = value.clusterInfo;
      this._clusterNetworkPolicy.internalValue = value.clusterNetworkPolicy;
      this._endpoints.internalValue = value.endpoints;
      this._externalEntity.internalValue = value.externalEntity;
      this._kind = value.kind;
      this._labelIdentity.internalValue = value.labelIdentity;
      this._name = value.name;
      this._namespace = value.namespace;
      this._raw.internalValue = value.raw;
      this._service.internalValue = value.service;
    }
  }

  // cluster_id - computed: false, optional: true, required: false
  private _clusterId?: string; 
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }
  public set clusterId(value: string) {
    this._clusterId = value;
  }
  public resetClusterId() {
    this._clusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // cluster_info - computed: false, optional: true, required: false
  private _clusterInfo = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfoOutputReference(this, "cluster_info");
  public get clusterInfo() {
    return this._clusterInfo;
  }
  public putClusterInfo(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterInfo) {
    this._clusterInfo.internalValue = value;
  }
  public resetClusterInfo() {
    this._clusterInfo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInfoInput() {
    return this._clusterInfo.internalValue;
  }

  // cluster_network_policy - computed: false, optional: true, required: false
  private _clusterNetworkPolicy = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicyOutputReference(this, "cluster_network_policy");
  public get clusterNetworkPolicy() {
    return this._clusterNetworkPolicy;
  }
  public putClusterNetworkPolicy(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecClusterNetworkPolicy) {
    this._clusterNetworkPolicy.internalValue = value;
  }
  public resetClusterNetworkPolicy() {
    this._clusterNetworkPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNetworkPolicyInput() {
    return this._clusterNetworkPolicy.internalValue;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpointsOutputReference(this, "endpoints");
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecEndpoints) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // external_entity - computed: false, optional: true, required: false
  private _externalEntity = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntityOutputReference(this, "external_entity");
  public get externalEntity() {
    return this._externalEntity;
  }
  public putExternalEntity(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecExternalEntity) {
    this._externalEntity.internalValue = value;
  }
  public resetExternalEntity() {
    this._externalEntity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntityInput() {
    return this._externalEntity.internalValue;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // label_identity - computed: false, optional: true, required: false
  private _labelIdentity = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentityOutputReference(this, "label_identity");
  public get labelIdentity() {
    return this._labelIdentity;
  }
  public putLabelIdentity(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecLabelIdentity) {
    this._labelIdentity.internalValue = value;
  }
  public resetLabelIdentity() {
    this._labelIdentity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelIdentityInput() {
    return this._labelIdentity.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // raw - computed: false, optional: true, required: false
  private _raw = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRawOutputReference(this, "raw");
  public get raw() {
    return this._raw;
  }
  public putRaw(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecRaw) {
    this._raw.internalValue = value;
  }
  public resetRaw() {
    this._raw.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rawInput() {
    return this._raw.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest k8s_multicluster_crd_antrea_io_resource_export_v1alpha1_manifest}
*/
export class DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest extends cdktf.TerraformDataSource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "k8s_multicluster_crd_antrea_io_resource_export_v1alpha1_manifest";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest to import
  * @param importFromId The id of the existing DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest that should be imported. Refer to the {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1Manifest to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "k8s_multicluster_crd_antrea_io_resource_export_v1alpha1_manifest", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/metio/k8s/2025.12.8/docs/data-sources/multicluster_crd_antrea_io_resource_export_v1alpha1_manifest k8s_multicluster_crd_antrea_io_resource_export_v1alpha1_manifest} Data Source
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestConfig
  */
  public constructor(scope: Construct, id: string, config: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestConfig) {
    super(scope, id, {
      terraformResourceType: 'k8s_multicluster_crd_antrea_io_resource_export_v1alpha1_manifest',
      terraformGeneratorMetadata: {
        providerName: 'k8s',
        providerVersion: '2025.12.8',
        providerVersionConstraint: '2025.12.8'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._metadata.internalValue = config.metadata;
    this._spec.internalValue = config.spec;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // metadata - computed: false, optional: false, required: true
  private _metadata = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadata) {
    this._metadata.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }

  // yaml - computed: true, optional: false, required: false
  public get yaml() {
    return this.getStringAttribute('yaml');
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      metadata: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadataToTerraform(this._metadata.internalValue),
      spec: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecToTerraform(this._spec.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      metadata: {
        value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadataToHclTerraform(this._metadata.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestMetadata",
      },
      spec: {
        value: dataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpecToHclTerraform(this._spec.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceExportV1Alpha1ManifestSpec",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
