import * as cdktf from 'cdktf';
import { DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBody,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBodyToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBodyToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBodyOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValues,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesList,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractors,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractorsToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractorsToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractorsOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeaders,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParameters,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParametersToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParametersToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParametersOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAws,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAwsToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAwsToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAwsOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzure,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzureToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzureToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzureOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpc,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsul,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsulToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsulToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsulOutputReference } from './structs400'
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#override_empty DataK8SGatewaySoloIoGatewayV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tmpl DataK8SGatewaySoloIoGatewayV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_keys DataK8SGatewaySoloIoGatewayV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeys;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#advanced_templates DataK8SGatewaySoloIoGatewayV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_metadata_values DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#escape_characters DataK8SGatewaySoloIoGatewayV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extractors DataK8SGatewaySoloIoGatewayV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_append DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_error_on_parse DataK8SGatewaySoloIoGatewayV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_extractors_to_body DataK8SGatewaySoloIoGatewayV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_json_keys DataK8SGatewaySoloIoGatewayV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parse_body_behavior DataK8SGatewaySoloIoGatewayV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#passthrough DataK8SGatewaySoloIoGatewayV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractors",
    },
    headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRest {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#function_name DataK8SGatewaySoloIoGatewayV1Manifest#function_name}
  */
  readonly functionName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parameters DataK8SGatewaySoloIoGatewayV1Manifest#parameters}
  */
  readonly parameters?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParameters;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_transformation DataK8SGatewaySoloIoGatewayV1Manifest#response_transformation}
  */
  readonly responseTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    function_name: cdktf.stringToTerraform(struct!.functionName),
    parameters: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParametersToTerraform(struct!.parameters),
    response_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationToTerraform(struct!.responseTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    function_name: {
      value: cdktf.stringToHclTerraform(struct!.functionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parameters: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParametersToHclTerraform(struct!.parameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParameters",
    },
    response_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationToHclTerraform(struct!.responseTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._functionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.functionName = this._functionName;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    if (this._responseTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTransformation = this._responseTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._functionName = undefined;
      this._parameters.internalValue = undefined;
      this._responseTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._functionName = value.functionName;
      this._parameters.internalValue = value.parameters;
      this._responseTransformation.internalValue = value.responseTransformation;
    }
  }

  // function_name - computed: false, optional: true, required: false
  private _functionName?: string; 
  public get functionName() {
    return this.getStringAttribute('function_name');
  }
  public set functionName(value: string) {
    this._functionName = value;
  }
  public resetFunctionName() {
    this._functionName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionNameInput() {
    return this._functionName;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParametersOutputReference(this, "parameters");
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParameters) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }

  // response_transformation - computed: false, optional: true, required: false
  private _responseTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationOutputReference(this, "response_transformation");
  public get responseTransformation() {
    return this._responseTransformation;
  }
  public putResponseTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformation) {
    this._responseTransformation.internalValue = value;
  }
  public resetResponseTransformation() {
    this._responseTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTransformationInput() {
    return this._responseTransformation.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpec {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#aws DataK8SGatewaySoloIoGatewayV1Manifest#aws}
  */
  readonly aws?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAws;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#azure DataK8SGatewaySoloIoGatewayV1Manifest#azure}
  */
  readonly azure?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzure;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#grpc DataK8SGatewaySoloIoGatewayV1Manifest#grpc}
  */
  readonly grpc?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpc;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#rest DataK8SGatewaySoloIoGatewayV1Manifest#rest}
  */
  readonly rest?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRest;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAwsToTerraform(struct!.aws),
    azure: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzureToTerraform(struct!.azure),
    grpc: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcToTerraform(struct!.grpc),
    rest: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestToTerraform(struct!.rest),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAwsToHclTerraform(struct!.aws),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAws",
    },
    azure: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzureToHclTerraform(struct!.azure),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzure",
    },
    grpc: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcToHclTerraform(struct!.grpc),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpc",
    },
    rest: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestToHclTerraform(struct!.rest),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aws?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aws = this._aws?.internalValue;
    }
    if (this._azure?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azure = this._azure?.internalValue;
    }
    if (this._grpc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpc = this._grpc?.internalValue;
    }
    if (this._rest?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rest = this._rest?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aws.internalValue = undefined;
      this._azure.internalValue = undefined;
      this._grpc.internalValue = undefined;
      this._rest.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aws.internalValue = value.aws;
      this._azure.internalValue = value.azure;
      this._grpc.internalValue = value.grpc;
      this._rest.internalValue = value.rest;
    }
  }

  // aws - computed: false, optional: true, required: false
  private _aws = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAwsOutputReference(this, "aws");
  public get aws() {
    return this._aws;
  }
  public putAws(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAws) {
    this._aws.internalValue = value;
  }
  public resetAws() {
    this._aws.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsInput() {
    return this._aws.internalValue;
  }

  // azure - computed: false, optional: true, required: false
  private _azure = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzureOutputReference(this, "azure");
  public get azure() {
    return this._azure;
  }
  public putAzure(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzure) {
    this._azure.internalValue = value;
  }
  public resetAzure() {
    this._azure.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureInput() {
    return this._azure.internalValue;
  }

  // grpc - computed: false, optional: true, required: false
  private _grpc = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcOutputReference(this, "grpc");
  public get grpc() {
    return this._grpc;
  }
  public putGrpc(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpc) {
    this._grpc.internalValue = value;
  }
  public resetGrpc() {
    this._grpc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcInput() {
    return this._grpc.internalValue;
  }

  // rest - computed: false, optional: true, required: false
  private _rest = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestOutputReference(this, "rest");
  public get rest() {
    return this._rest;
  }
  public putRest(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRest) {
    this._rest.internalValue = value;
  }
  public resetRest() {
    this._rest.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get restInput() {
    return this._rest.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKube {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#port DataK8SGatewaySoloIoGatewayV1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ref DataK8SGatewaySoloIoGatewayV1Manifest#ref}
  */
  readonly ref?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRef;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKube | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    port: cdktf.numberToTerraform(struct!.port),
    ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRefToTerraform(struct!.ref),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKube | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRefToHclTerraform(struct!.ref),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKube | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._ref?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKube | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._port = undefined;
      this._ref.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._port = value.port;
      this._ref.internalValue = value.ref;
    }
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // ref - computed: false, optional: true, required: false
  private _ref = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRefOutputReference(this, "ref");
  public get ref() {
    return this._ref;
  }
  public putRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeRef) {
    this._ref.internalValue = value;
  }
  public resetRef() {
    this._ref.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubset {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#values DataK8SGatewaySoloIoGatewayV1Manifest#values}
  */
  readonly values?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubsetToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubset | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    values: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.values),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubsetToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubset | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    values: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.values),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubsetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubset | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubset | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._values = value.values;
    }
  }

  // values - computed: false, optional: true, required: false
  private _values?: { [key: string]: string }; 
  public get values() {
    return this.getStringMapAttribute('values');
  }
  public set values(value: { [key: string]: string }) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstream {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstreamToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstream | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstreamToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstream | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstreamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstream | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstream | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestination {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#consul DataK8SGatewaySoloIoGatewayV1Manifest#consul}
  */
  readonly consul?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsul;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#destination_spec DataK8SGatewaySoloIoGatewayV1Manifest#destination_spec}
  */
  readonly destinationSpec?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpec;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#kube DataK8SGatewaySoloIoGatewayV1Manifest#kube}
  */
  readonly kube?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKube;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subset DataK8SGatewaySoloIoGatewayV1Manifest#subset}
  */
  readonly subset?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubset;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#upstream DataK8SGatewaySoloIoGatewayV1Manifest#upstream}
  */
  readonly upstream?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstream;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestination | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    consul: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsulToTerraform(struct!.consul),
    destination_spec: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecToTerraform(struct!.destinationSpec),
    kube: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeToTerraform(struct!.kube),
    subset: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubsetToTerraform(struct!.subset),
    upstream: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstreamToTerraform(struct!.upstream),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestination | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    consul: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsulToHclTerraform(struct!.consul),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsul",
    },
    destination_spec: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecToHclTerraform(struct!.destinationSpec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpec",
    },
    kube: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeToHclTerraform(struct!.kube),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKube",
    },
    subset: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubsetToHclTerraform(struct!.subset),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubset",
    },
    upstream: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstreamToHclTerraform(struct!.upstream),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstream",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestination | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._consul?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.consul = this._consul?.internalValue;
    }
    if (this._destinationSpec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationSpec = this._destinationSpec?.internalValue;
    }
    if (this._kube?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kube = this._kube?.internalValue;
    }
    if (this._subset?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subset = this._subset?.internalValue;
    }
    if (this._upstream?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upstream = this._upstream?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestination | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._consul.internalValue = undefined;
      this._destinationSpec.internalValue = undefined;
      this._kube.internalValue = undefined;
      this._subset.internalValue = undefined;
      this._upstream.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._consul.internalValue = value.consul;
      this._destinationSpec.internalValue = value.destinationSpec;
      this._kube.internalValue = value.kube;
      this._subset.internalValue = value.subset;
      this._upstream.internalValue = value.upstream;
    }
  }

  // consul - computed: false, optional: true, required: false
  private _consul = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsulOutputReference(this, "consul");
  public get consul() {
    return this._consul;
  }
  public putConsul(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsul) {
    this._consul.internalValue = value;
  }
  public resetConsul() {
    this._consul.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consulInput() {
    return this._consul.internalValue;
  }

  // destination_spec - computed: false, optional: true, required: false
  private _destinationSpec = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecOutputReference(this, "destination_spec");
  public get destinationSpec() {
    return this._destinationSpec;
  }
  public putDestinationSpec(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpec) {
    this._destinationSpec.internalValue = value;
  }
  public resetDestinationSpec() {
    this._destinationSpec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationSpecInput() {
    return this._destinationSpec.internalValue;
  }

  // kube - computed: false, optional: true, required: false
  private _kube = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKubeOutputReference(this, "kube");
  public get kube() {
    return this._kube;
  }
  public putKube(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationKube) {
    this._kube.internalValue = value;
  }
  public resetKube() {
    this._kube.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeInput() {
    return this._kube.internalValue;
  }

  // subset - computed: false, optional: true, required: false
  private _subset = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubsetOutputReference(this, "subset");
  public get subset() {
    return this._subset;
  }
  public putSubset(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationSubset) {
    this._subset.internalValue = value;
  }
  public resetSubset() {
    this._subset.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsetInput() {
    return this._subset.internalValue;
  }

  // upstream - computed: false, optional: true, required: false
  private _upstream = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstreamOutputReference(this, "upstream");
  public get upstream() {
    return this._upstream;
  }
  public putUpstream(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationUpstream) {
    this._upstream.internalValue = value;
  }
  public resetUpstream() {
    this._upstream.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upstreamInput() {
    return this._upstream.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBuffer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_request_bytes DataK8SGatewaySoloIoGatewayV1Manifest#max_request_bytes}
  */
  readonly maxRequestBytes?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBufferToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBuffer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_request_bytes: cdktf.numberToTerraform(struct!.maxRequestBytes),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBufferToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBuffer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_request_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBufferOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBuffer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxRequestBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestBytes = this._maxRequestBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBuffer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxRequestBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxRequestBytes = value.maxRequestBytes;
    }
  }

  // max_request_bytes - computed: false, optional: true, required: false
  private _maxRequestBytes?: number; 
  public get maxRequestBytes() {
    return this.getNumberAttribute('max_request_bytes');
  }
  public set maxRequestBytes(value: number) {
    this._maxRequestBytes = value;
  }
  public resetMaxRequestBytes() {
    this._maxRequestBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestBytesInput() {
    return this._maxRequestBytes;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRoute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#buffer DataK8SGatewaySoloIoGatewayV1Manifest#buffer}
  */
  readonly buffer?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBuffer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disabled DataK8SGatewaySoloIoGatewayV1Manifest#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBufferToTerraform(struct!.buffer),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBufferToHclTerraform(struct!.buffer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBuffer",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._buffer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.buffer = this._buffer?.internalValue;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._buffer.internalValue = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._buffer.internalValue = value.buffer;
      this._disabled = value.disabled;
    }
  }

  // buffer - computed: false, optional: true, required: false
  private _buffer = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBufferOutputReference(this, "buffer");
  public get buffer() {
    return this._buffer;
  }
  public putBuffer(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsBufferPerRouteBuffer) {
    this._buffer.internalValue = value;
  }
  public resetBuffer() {
    this._buffer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferInput() {
    return this._buffer.internalValue;
  }

  // disabled - computed: false, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOrigins {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#exact DataK8SGatewaySoloIoGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_case DataK8SGatewaySoloIoGatewayV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix DataK8SGatewaySoloIoGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#safe_regex DataK8SGatewaySoloIoGatewayV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#suffix DataK8SGatewaySoloIoGatewayV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOrigins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOrigins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOrigins | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOrigins | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#denominator DataK8SGatewaySoloIoGatewayV1Manifest#denominator}
  */
  readonly denominator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#numerator DataK8SGatewaySoloIoGatewayV1Manifest#numerator}
  */
  readonly numerator?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    denominator: cdktf.stringToTerraform(struct!.denominator),
    numerator: cdktf.numberToTerraform(struct!.numerator),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    denominator: {
      value: cdktf.stringToHclTerraform(struct!.denominator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numerator: {
      value: cdktf.numberToHclTerraform(struct!.numerator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denominator !== undefined) {
      hasAnyValues = true;
      internalValueResult.denominator = this._denominator;
    }
    if (this._numerator !== undefined) {
      hasAnyValues = true;
      internalValueResult.numerator = this._numerator;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denominator = undefined;
      this._numerator = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denominator = value.denominator;
      this._numerator = value.numerator;
    }
  }

  // denominator - computed: false, optional: true, required: false
  private _denominator?: string; 
  public get denominator() {
    return this.getStringAttribute('denominator');
  }
  public set denominator(value: string) {
    this._denominator = value;
  }
  public resetDenominator() {
    this._denominator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denominatorInput() {
    return this._denominator;
  }

  // numerator - computed: false, optional: true, required: false
  private _numerator?: number; 
  public get numerator() {
    return this.getNumberAttribute('numerator');
  }
  public set numerator(value: number) {
    this._numerator = value;
  }
  public resetNumerator() {
    this._numerator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numeratorInput() {
    return this._numerator;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabled {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#default_value DataK8SGatewaySoloIoGatewayV1Manifest#default_value}
  */
  readonly defaultValue?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValue;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#runtime_key DataK8SGatewaySoloIoGatewayV1Manifest#runtime_key}
  */
  readonly runtimeKey?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValueToTerraform(struct!.defaultValue),
    runtime_key: cdktf.stringToTerraform(struct!.runtimeKey),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValueToHclTerraform(struct!.defaultValue),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValue",
    },
    runtime_key: {
      value: cdktf.stringToHclTerraform(struct!.runtimeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabled | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue?.internalValue;
    }
    if (this._runtimeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeKey = this._runtimeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabled | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = undefined;
      this._runtimeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = value.defaultValue;
      this._runtimeKey = value.runtimeKey;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValueOutputReference(this, "default_value");
  public get defaultValue() {
    return this._defaultValue;
  }
  public putDefaultValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledDefaultValue) {
    this._defaultValue.internalValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue.internalValue;
  }

  // runtime_key - computed: false, optional: true, required: false
  private _runtimeKey?: string; 
  public get runtimeKey() {
    return this.getStringAttribute('runtime_key');
  }
  public set runtimeKey(value: string) {
    this._runtimeKey = value;
  }
  public resetRuntimeKey() {
    this._runtimeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeKeyInput() {
    return this._runtimeKey;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#denominator DataK8SGatewaySoloIoGatewayV1Manifest#denominator}
  */
  readonly denominator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#numerator DataK8SGatewaySoloIoGatewayV1Manifest#numerator}
  */
  readonly numerator?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    denominator: cdktf.stringToTerraform(struct!.denominator),
    numerator: cdktf.numberToTerraform(struct!.numerator),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    denominator: {
      value: cdktf.stringToHclTerraform(struct!.denominator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numerator: {
      value: cdktf.numberToHclTerraform(struct!.numerator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denominator !== undefined) {
      hasAnyValues = true;
      internalValueResult.denominator = this._denominator;
    }
    if (this._numerator !== undefined) {
      hasAnyValues = true;
      internalValueResult.numerator = this._numerator;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denominator = undefined;
      this._numerator = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denominator = value.denominator;
      this._numerator = value.numerator;
    }
  }

  // denominator - computed: false, optional: true, required: false
  private _denominator?: string; 
  public get denominator() {
    return this.getStringAttribute('denominator');
  }
  public set denominator(value: string) {
    this._denominator = value;
  }
  public resetDenominator() {
    this._denominator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denominatorInput() {
    return this._denominator;
  }

  // numerator - computed: false, optional: true, required: false
  private _numerator?: number; 
  public get numerator() {
    return this.getNumberAttribute('numerator');
  }
  public set numerator(value: number) {
    this._numerator = value;
  }
  public resetNumerator() {
    this._numerator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numeratorInput() {
    return this._numerator;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabled {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#default_value DataK8SGatewaySoloIoGatewayV1Manifest#default_value}
  */
  readonly defaultValue?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValue;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#runtime_key DataK8SGatewaySoloIoGatewayV1Manifest#runtime_key}
  */
  readonly runtimeKey?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValueToTerraform(struct!.defaultValue),
    runtime_key: cdktf.stringToTerraform(struct!.runtimeKey),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValueToHclTerraform(struct!.defaultValue),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValue",
    },
    runtime_key: {
      value: cdktf.stringToHclTerraform(struct!.runtimeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabled | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue?.internalValue;
    }
    if (this._runtimeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeKey = this._runtimeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabled | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = undefined;
      this._runtimeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = value.defaultValue;
      this._runtimeKey = value.runtimeKey;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValueOutputReference(this, "default_value");
  public get defaultValue() {
    return this._defaultValue;
  }
  public putDefaultValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledDefaultValue) {
    this._defaultValue.internalValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue.internalValue;
  }

  // runtime_key - computed: false, optional: true, required: false
  private _runtimeKey?: string; 
  public get runtimeKey() {
    return this.getStringAttribute('runtime_key');
  }
  public set runtimeKey(value: string) {
    this._runtimeKey = value;
  }
  public resetRuntimeKey() {
    this._runtimeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeKeyInput() {
    return this._runtimeKey;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#additional_origins DataK8SGatewaySoloIoGatewayV1Manifest#additional_origins}
  */
  readonly additionalOrigins?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#filter_enabled DataK8SGatewaySoloIoGatewayV1Manifest#filter_enabled}
  */
  readonly filterEnabled?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabled;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#shadow_enabled DataK8SGatewaySoloIoGatewayV1Manifest#shadow_enabled}
  */
  readonly shadowEnabled?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabled;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_origins: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsToTerraform, false)(struct!.additionalOrigins),
    filter_enabled: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledToTerraform(struct!.filterEnabled),
    shadow_enabled: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledToTerraform(struct!.shadowEnabled),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_origins: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsToHclTerraform, false)(struct!.additionalOrigins),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsList",
    },
    filter_enabled: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledToHclTerraform(struct!.filterEnabled),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabled",
    },
    shadow_enabled: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledToHclTerraform(struct!.shadowEnabled),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabled",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalOrigins?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalOrigins = this._additionalOrigins?.internalValue;
    }
    if (this._filterEnabled?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterEnabled = this._filterEnabled?.internalValue;
    }
    if (this._shadowEnabled?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.shadowEnabled = this._shadowEnabled?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalOrigins.internalValue = undefined;
      this._filterEnabled.internalValue = undefined;
      this._shadowEnabled.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalOrigins.internalValue = value.additionalOrigins;
      this._filterEnabled.internalValue = value.filterEnabled;
      this._shadowEnabled.internalValue = value.shadowEnabled;
    }
  }

  // additional_origins - computed: false, optional: true, required: false
  private _additionalOrigins = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOriginsList(this, "additional_origins", false);
  public get additionalOrigins() {
    return this._additionalOrigins;
  }
  public putAdditionalOrigins(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable) {
    this._additionalOrigins.internalValue = value;
  }
  public resetAdditionalOrigins() {
    this._additionalOrigins.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalOriginsInput() {
    return this._additionalOrigins.internalValue;
  }

  // filter_enabled - computed: false, optional: true, required: false
  private _filterEnabled = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabledOutputReference(this, "filter_enabled");
  public get filterEnabled() {
    return this._filterEnabled;
  }
  public putFilterEnabled(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfFilterEnabled) {
    this._filterEnabled.internalValue = value;
  }
  public resetFilterEnabled() {
    this._filterEnabled.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterEnabledInput() {
    return this._filterEnabled.internalValue;
  }

  // shadow_enabled - computed: false, optional: true, required: false
  private _shadowEnabled = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabledOutputReference(this, "shadow_enabled");
  public get shadowEnabled() {
    return this._shadowEnabled;
  }
  public putShadowEnabled(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsCsrfShadowEnabled) {
    this._shadowEnabled.internalValue = value;
  }
  public resetShadowEnabled() {
    this._shadowEnabled.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shadowEnabledInput() {
    return this._shadowEnabled.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#context_extensions DataK8SGatewaySoloIoGatewayV1Manifest#context_extensions}
  */
  readonly contextExtensions?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuthToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context_extensions: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.contextExtensions),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuthToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context_extensions: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.contextExtensions),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._contextExtensions !== undefined) {
      hasAnyValues = true;
      internalValueResult.contextExtensions = this._contextExtensions;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._contextExtensions = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._contextExtensions = value.contextExtensions;
      this._name = value.name;
    }
  }

  // context_extensions - computed: false, optional: true, required: false
  private _contextExtensions?: { [key: string]: string }; 
  public get contextExtensions() {
    return this.getStringMapAttribute('context_extensions');
  }
  public set contextExtensions(value: { [key: string]: string }) {
    this._contextExtensions = value;
  }
  public resetContextExtensions() {
    this._contextExtensions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextExtensionsInput() {
    return this._contextExtensions;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#config_ref DataK8SGatewaySoloIoGatewayV1Manifest#config_ref}
  */
  readonly configRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#custom_auth DataK8SGatewaySoloIoGatewayV1Manifest#custom_auth}
  */
  readonly customAuth?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disable DataK8SGatewaySoloIoGatewayV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRefToTerraform(struct!.configRef),
    custom_auth: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuthToTerraform(struct!.customAuth),
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRefToHclTerraform(struct!.configRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRef",
    },
    custom_auth: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuthToHclTerraform(struct!.customAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuth",
    },
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configRef = this._configRef?.internalValue;
    }
    if (this._customAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customAuth = this._customAuth?.internalValue;
    }
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configRef.internalValue = undefined;
      this._customAuth.internalValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configRef.internalValue = value.configRef;
      this._customAuth.internalValue = value.customAuth;
      this._disable = value.disable;
    }
  }

  // config_ref - computed: false, optional: true, required: false
  private _configRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRefOutputReference(this, "config_ref");
  public get configRef() {
    return this._configRef;
  }
  public putConfigRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthConfigRef) {
    this._configRef.internalValue = value;
  }
  public resetConfigRef() {
    this._configRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configRefInput() {
    return this._configRef.internalValue;
  }

  // custom_auth - computed: false, optional: true, required: false
  private _customAuth = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuthOutputReference(this, "custom_auth");
  public get customAuth() {
    return this._customAuth;
  }
  public putCustomAuth(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtauthCustomAuth) {
    this._customAuth.internalValue = value;
  }
  public resetCustomAuth() {
    this._customAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customAuthInput() {
    return this._customAuth.internalValue;
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtensions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#configs DataK8SGatewaySoloIoGatewayV1Manifest#configs}
  */
  readonly configs?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtensionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtensions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    configs: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.configs),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtensionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtensions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    configs: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.configs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtensionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtensions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configs !== undefined) {
      hasAnyValues = true;
      internalValueResult.configs = this._configs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsExtensions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configs = value.configs;
    }
  }

  // configs - computed: false, optional: true, required: false
  private _configs?: { [key: string]: string }; 
  public get configs() {
    return this.getStringMapAttribute('configs');
  }
  public set configs(value: { [key: string]: string }) {
    this._configs = value;
  }
  public resetConfigs() {
    this._configs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configsInput() {
    return this._configs;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAdd {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#append DataK8SGatewaySoloIoGatewayV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_secret_ref DataK8SGatewaySoloIoGatewayV1Manifest#header_secret_ref}
  */
  readonly headerSecretRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    header: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderToTerraform(struct!.header),
    header_secret_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToTerraform(struct!.headerSecretRef),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    header: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderToHclTerraform(struct!.header),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeader",
    },
    header_secret_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToHclTerraform(struct!.headerSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._header?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header?.internalValue;
    }
    if (this._headerSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerSecretRef = this._headerSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._header.internalValue = undefined;
      this._headerSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._header.internalValue = value.header;
      this._headerSecretRef.internalValue = value.headerSecretRef;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // header - computed: false, optional: true, required: false
  private _header = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderOutputReference(this, "header");
  public get header() {
    return this._header;
  }
  public putHeader(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeader) {
    this._header.internalValue = value;
  }
  public resetHeader() {
    this._header.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header.internalValue;
  }

  // header_secret_ref - computed: false, optional: true, required: false
  private _headerSecretRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefOutputReference(this, "header_secret_ref");
  public get headerSecretRef() {
    return this._headerSecretRef;
  }
  public putHeaderSecretRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef) {
    this._headerSecretRef.internalValue = value;
  }
  public resetHeaderSecretRef() {
    this._headerSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerSecretRefInput() {
    return this._headerSecretRef.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAdd[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeaderToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeaderToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAdd {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#append DataK8SGatewaySoloIoGatewayV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeader;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    header: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeaderToTerraform(struct!.header),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    header: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeaderToHclTerraform(struct!.header),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeader",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._header?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._header.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._header.internalValue = value.header;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // header - computed: false, optional: true, required: false
  private _header = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeaderOutputReference(this, "header");
  public get header() {
    return this._header;
  }
  public putHeader(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddHeader) {
    this._header.internalValue = value;
  }
  public resetHeader() {
    this._header.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAdd[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_headers_to_add DataK8SGatewaySoloIoGatewayV1Manifest#request_headers_to_add}
  */
  readonly requestHeadersToAdd?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAdd[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#request_headers_to_remove}
  */
  readonly requestHeadersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_headers_to_add DataK8SGatewaySoloIoGatewayV1Manifest#response_headers_to_add}
  */
  readonly responseHeadersToAdd?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAdd[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#response_headers_to_remove}
  */
  readonly responseHeadersToRemove?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request_headers_to_add: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddToTerraform, false)(struct!.requestHeadersToAdd),
    request_headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestHeadersToRemove),
    response_headers_to_add: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddToTerraform, false)(struct!.responseHeadersToAdd),
    response_headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.responseHeadersToRemove),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request_headers_to_add: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddToHclTerraform, false)(struct!.requestHeadersToAdd),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddList",
    },
    request_headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestHeadersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    response_headers_to_add: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddToHclTerraform, false)(struct!.responseHeadersToAdd),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddList",
    },
    response_headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.responseHeadersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestHeadersToAdd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersToAdd = this._requestHeadersToAdd?.internalValue;
    }
    if (this._requestHeadersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersToRemove = this._requestHeadersToRemove;
    }
    if (this._responseHeadersToAdd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeadersToAdd = this._responseHeadersToAdd?.internalValue;
    }
    if (this._responseHeadersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeadersToRemove = this._responseHeadersToRemove;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestHeadersToAdd.internalValue = undefined;
      this._requestHeadersToRemove = undefined;
      this._responseHeadersToAdd.internalValue = undefined;
      this._responseHeadersToRemove = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestHeadersToAdd.internalValue = value.requestHeadersToAdd;
      this._requestHeadersToRemove = value.requestHeadersToRemove;
      this._responseHeadersToAdd.internalValue = value.responseHeadersToAdd;
      this._responseHeadersToRemove = value.responseHeadersToRemove;
    }
  }

  // request_headers_to_add - computed: false, optional: true, required: false
  private _requestHeadersToAdd = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAddList(this, "request_headers_to_add", false);
  public get requestHeadersToAdd() {
    return this._requestHeadersToAdd;
  }
  public putRequestHeadersToAdd(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationRequestHeadersToAdd[] | cdktf.IResolvable) {
    this._requestHeadersToAdd.internalValue = value;
  }
  public resetRequestHeadersToAdd() {
    this._requestHeadersToAdd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersToAddInput() {
    return this._requestHeadersToAdd.internalValue;
  }

  // request_headers_to_remove - computed: false, optional: true, required: false
  private _requestHeadersToRemove?: string[]; 
  public get requestHeadersToRemove() {
    return this.getListAttribute('request_headers_to_remove');
  }
  public set requestHeadersToRemove(value: string[]) {
    this._requestHeadersToRemove = value;
  }
  public resetRequestHeadersToRemove() {
    this._requestHeadersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersToRemoveInput() {
    return this._requestHeadersToRemove;
  }

  // response_headers_to_add - computed: false, optional: true, required: false
  private _responseHeadersToAdd = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAddList(this, "response_headers_to_add", false);
  public get responseHeadersToAdd() {
    return this._responseHeadersToAdd;
  }
  public putResponseHeadersToAdd(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsHeaderManipulationResponseHeadersToAdd[] | cdktf.IResolvable) {
    this._responseHeadersToAdd.internalValue = value;
  }
  public resetResponseHeadersToAdd() {
    this._responseHeadersToAdd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeadersToAddInput() {
    return this._responseHeadersToAdd.internalValue;
  }

  // response_headers_to_remove - computed: false, optional: true, required: false
  private _responseHeadersToRemove?: string[]; 
  public get responseHeadersToRemove() {
    return this.getListAttribute('response_headers_to_remove');
  }
  public set responseHeadersToRemove(value: string[]) {
    this._responseHeadersToRemove = value;
  }
  public resetResponseHeadersToRemove() {
    this._responseHeadersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeadersToRemoveInput() {
    return this._responseHeadersToRemove;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#invert_match DataK8SGatewaySoloIoGatewayV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeadersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParametersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParametersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParametersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParametersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcher {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#case_sensitive DataK8SGatewaySoloIoGatewayV1Manifest#case_sensitive}
  */
  readonly caseSensitive?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#connect_matcher DataK8SGatewaySoloIoGatewayV1Manifest#connect_matcher}
  */
  readonly connectMatcher?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#exact DataK8SGatewaySoloIoGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#methods DataK8SGatewaySoloIoGatewayV1Manifest#methods}
  */
  readonly methods?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix DataK8SGatewaySoloIoGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#query_parameters DataK8SGatewaySoloIoGatewayV1Manifest#query_parameters}
  */
  readonly queryParameters?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParameters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    case_sensitive: cdktf.booleanToTerraform(struct!.caseSensitive),
    connect_matcher: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectMatcher),
    exact: cdktf.stringToTerraform(struct!.exact),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeadersToTerraform, false)(struct!.headers),
    methods: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.methods),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    query_parameters: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParametersToTerraform, false)(struct!.queryParameters),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    case_sensitive: {
      value: cdktf.booleanToHclTerraform(struct!.caseSensitive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connect_matcher: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectMatcher),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeadersList",
    },
    methods: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.methods),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query_parameters: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParametersToHclTerraform, false)(struct!.queryParameters),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParametersList",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcher | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caseSensitive !== undefined) {
      hasAnyValues = true;
      internalValueResult.caseSensitive = this._caseSensitive;
    }
    if (this._connectMatcher !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectMatcher = this._connectMatcher;
    }
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._methods !== undefined) {
      hasAnyValues = true;
      internalValueResult.methods = this._methods;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._queryParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParameters = this._queryParameters?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcher | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caseSensitive = undefined;
      this._connectMatcher = undefined;
      this._exact = undefined;
      this._headers.internalValue = undefined;
      this._methods = undefined;
      this._prefix = undefined;
      this._queryParameters.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caseSensitive = value.caseSensitive;
      this._connectMatcher = value.connectMatcher;
      this._exact = value.exact;
      this._headers.internalValue = value.headers;
      this._methods = value.methods;
      this._prefix = value.prefix;
      this._queryParameters.internalValue = value.queryParameters;
      this._regex = value.regex;
    }
  }

  // case_sensitive - computed: false, optional: true, required: false
  private _caseSensitive?: boolean | cdktf.IResolvable; 
  public get caseSensitive() {
    return this.getBooleanAttribute('case_sensitive');
  }
  public set caseSensitive(value: boolean | cdktf.IResolvable) {
    this._caseSensitive = value;
  }
  public resetCaseSensitive() {
    this._caseSensitive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caseSensitiveInput() {
    return this._caseSensitive;
  }

  // connect_matcher - computed: false, optional: true, required: false
  private _connectMatcher?: { [key: string]: string }; 
  public get connectMatcher() {
    return this.getStringMapAttribute('connect_matcher');
  }
  public set connectMatcher(value: { [key: string]: string }) {
    this._connectMatcher = value;
  }
  public resetConnectMatcher() {
    this._connectMatcher = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectMatcherInput() {
    return this._connectMatcher;
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // methods - computed: false, optional: true, required: false
  private _methods?: string[]; 
  public get methods() {
    return this.getListAttribute('methods');
  }
  public set methods(value: string[]) {
    this._methods = value;
  }
  public resetMethods() {
    this._methods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodsInput() {
    return this._methods;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // query_parameters - computed: false, optional: true, required: false
  private _queryParameters = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParametersList(this, "query_parameters", false);
  public get queryParameters() {
    return this._queryParameters;
  }
  public putQueryParameters(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherQueryParameters[] | cdktf.IResolvable) {
    this._queryParameters.internalValue = value;
  }
  public resetQueryParameters() {
    this._queryParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParametersInput() {
    return this._queryParameters.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransform {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#add_request_metadata DataK8SGatewaySoloIoGatewayV1Manifest#add_request_metadata}
  */
  readonly addRequestMetadata?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransformToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_request_metadata: cdktf.booleanToTerraform(struct!.addRequestMetadata),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransformToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_request_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.addRequestMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransformOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRequestMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRequestMetadata = this._addRequestMetadata;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRequestMetadata = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRequestMetadata = value.addRequestMetadata;
    }
  }

  // add_request_metadata - computed: false, optional: true, required: false
  private _addRequestMetadata?: boolean | cdktf.IResolvable; 
  public get addRequestMetadata() {
    return this.getBooleanAttribute('add_request_metadata');
  }
  public set addRequestMetadata(value: boolean | cdktf.IResolvable) {
    this._addRequestMetadata = value;
  }
  public resetAddRequestMetadata() {
    this._addRequestMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRequestMetadataInput() {
    return this._addRequestMetadata;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_to_proto DataK8SGatewaySoloIoGatewayV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#metadata_namespace DataK8SGatewaySoloIoGatewayV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mode DataK8SGatewaySoloIoGatewayV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#replacement_text DataK8SGatewaySoloIoGatewayV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractorsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractorsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#override_empty DataK8SGatewaySoloIoGatewayV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tmpl DataK8SGatewaySoloIoGatewayV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_keys DataK8SGatewaySoloIoGatewayV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#advanced_templates DataK8SGatewaySoloIoGatewayV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_metadata_values DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#escape_characters DataK8SGatewaySoloIoGatewayV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extractors DataK8SGatewaySoloIoGatewayV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_append DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_error_on_parse DataK8SGatewaySoloIoGatewayV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_extractors_to_body DataK8SGatewaySoloIoGatewayV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_json_keys DataK8SGatewaySoloIoGatewayV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parse_body_behavior DataK8SGatewaySoloIoGatewayV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#passthrough DataK8SGatewaySoloIoGatewayV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractors",
    },
    headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#non_xml_transform DataK8SGatewaySoloIoGatewayV1Manifest#non_xml_transform}
  */
  readonly nonXmlTransform?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#set_content_type DataK8SGatewaySoloIoGatewayV1Manifest#set_content_type}
  */
  readonly setContentType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt DataK8SGatewaySoloIoGatewayV1Manifest#xslt}
  */
  readonly xslt?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    non_xml_transform: cdktf.booleanToTerraform(struct!.nonXmlTransform),
    set_content_type: cdktf.stringToTerraform(struct!.setContentType),
    xslt: cdktf.stringToTerraform(struct!.xslt),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    non_xml_transform: {
      value: cdktf.booleanToHclTerraform(struct!.nonXmlTransform),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    set_content_type: {
      value: cdktf.stringToHclTerraform(struct!.setContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xslt: {
      value: cdktf.stringToHclTerraform(struct!.xslt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nonXmlTransform !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonXmlTransform = this._nonXmlTransform;
    }
    if (this._setContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.setContentType = this._setContentType;
    }
    if (this._xslt !== undefined) {
      hasAnyValues = true;
      internalValueResult.xslt = this._xslt;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nonXmlTransform = undefined;
      this._setContentType = undefined;
      this._xslt = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nonXmlTransform = value.nonXmlTransform;
      this._setContentType = value.setContentType;
      this._xslt = value.xslt;
    }
  }

  // non_xml_transform - computed: false, optional: true, required: false
  private _nonXmlTransform?: boolean | cdktf.IResolvable; 
  public get nonXmlTransform() {
    return this.getBooleanAttribute('non_xml_transform');
  }
  public set nonXmlTransform(value: boolean | cdktf.IResolvable) {
    this._nonXmlTransform = value;
  }
  public resetNonXmlTransform() {
    this._nonXmlTransform = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonXmlTransformInput() {
    return this._nonXmlTransform;
  }

  // set_content_type - computed: false, optional: true, required: false
  private _setContentType?: string; 
  public get setContentType() {
    return this.getStringAttribute('set_content_type');
  }
  public set setContentType(value: string) {
    this._setContentType = value;
  }
  public resetSetContentType() {
    this._setContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setContentTypeInput() {
    return this._setContentType;
  }

  // xslt - computed: false, optional: true, required: false
  private _xslt?: string; 
  public get xslt() {
    return this.getStringAttribute('xslt');
  }
  public set xslt(value: string) {
    this._xslt = value;
  }
  public resetXslt() {
    this._xslt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltInput() {
    return this._xslt;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_body_transform DataK8SGatewaySoloIoGatewayV1Manifest#header_body_transform}
  */
  readonly headerBodyTransform?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransform;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#log_request_response_info DataK8SGatewaySoloIoGatewayV1Manifest#log_request_response_info}
  */
  readonly logRequestResponseInfo?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transformation_template DataK8SGatewaySoloIoGatewayV1Manifest#transformation_template}
  */
  readonly transformationTemplate?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt_transformation DataK8SGatewaySoloIoGatewayV1Manifest#xslt_transformation}
  */
  readonly xsltTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header_body_transform: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransformToTerraform(struct!.headerBodyTransform),
    log_request_response_info: cdktf.booleanToTerraform(struct!.logRequestResponseInfo),
    transformation_template: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateToTerraform(struct!.transformationTemplate),
    xslt_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformationToTerraform(struct!.xsltTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header_body_transform: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransformToHclTerraform(struct!.headerBodyTransform),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransform",
    },
    log_request_response_info: {
      value: cdktf.booleanToHclTerraform(struct!.logRequestResponseInfo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    transformation_template: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateToHclTerraform(struct!.transformationTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplate",
    },
    xslt_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformationToHclTerraform(struct!.xsltTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headerBodyTransform?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerBodyTransform = this._headerBodyTransform?.internalValue;
    }
    if (this._logRequestResponseInfo !== undefined) {
      hasAnyValues = true;
      internalValueResult.logRequestResponseInfo = this._logRequestResponseInfo;
    }
    if (this._transformationTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformationTemplate = this._transformationTemplate?.internalValue;
    }
    if (this._xsltTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xsltTransformation = this._xsltTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = undefined;
      this._logRequestResponseInfo = undefined;
      this._transformationTemplate.internalValue = undefined;
      this._xsltTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = value.headerBodyTransform;
      this._logRequestResponseInfo = value.logRequestResponseInfo;
      this._transformationTemplate.internalValue = value.transformationTemplate;
      this._xsltTransformation.internalValue = value.xsltTransformation;
    }
  }

  // header_body_transform - computed: false, optional: true, required: false
  private _headerBodyTransform = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransformOutputReference(this, "header_body_transform");
  public get headerBodyTransform() {
    return this._headerBodyTransform;
  }
  public putHeaderBodyTransform(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationHeaderBodyTransform) {
    this._headerBodyTransform.internalValue = value;
  }
  public resetHeaderBodyTransform() {
    this._headerBodyTransform.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerBodyTransformInput() {
    return this._headerBodyTransform.internalValue;
  }

  // log_request_response_info - computed: false, optional: true, required: false
  private _logRequestResponseInfo?: boolean | cdktf.IResolvable; 
  public get logRequestResponseInfo() {
    return this.getBooleanAttribute('log_request_response_info');
  }
  public set logRequestResponseInfo(value: boolean | cdktf.IResolvable) {
    this._logRequestResponseInfo = value;
  }
  public resetLogRequestResponseInfo() {
    this._logRequestResponseInfo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logRequestResponseInfoInput() {
    return this._logRequestResponseInfo;
  }

  // transformation_template - computed: false, optional: true, required: false
  private _transformationTemplate = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplateOutputReference(this, "transformation_template");
  public get transformationTemplate() {
    return this._transformationTemplate;
  }
  public putTransformationTemplate(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationTransformationTemplate) {
    this._transformationTemplate.internalValue = value;
  }
  public resetTransformationTemplate() {
    this._transformationTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationTemplateInput() {
    return this._transformationTemplate.internalValue;
  }

  // xslt_transformation - computed: false, optional: true, required: false
  private _xsltTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformationOutputReference(this, "xslt_transformation");
  public get xsltTransformation() {
    return this._xsltTransformation;
  }
  public putXsltTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationXsltTransformation) {
    this._xsltTransformation.internalValue = value;
  }
  public resetXsltTransformation() {
    this._xsltTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltTransformationInput() {
    return this._xsltTransformation.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransform {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#add_request_metadata DataK8SGatewaySoloIoGatewayV1Manifest#add_request_metadata}
  */
  readonly addRequestMetadata?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransformToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_request_metadata: cdktf.booleanToTerraform(struct!.addRequestMetadata),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_request_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.addRequestMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransformOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRequestMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRequestMetadata = this._addRequestMetadata;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRequestMetadata = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRequestMetadata = value.addRequestMetadata;
    }
  }

  // add_request_metadata - computed: false, optional: true, required: false
  private _addRequestMetadata?: boolean | cdktf.IResolvable; 
  public get addRequestMetadata() {
    return this.getBooleanAttribute('add_request_metadata');
  }
  public set addRequestMetadata(value: boolean | cdktf.IResolvable) {
    this._addRequestMetadata = value;
  }
  public resetAddRequestMetadata() {
    this._addRequestMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRequestMetadataInput() {
    return this._addRequestMetadata;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_to_proto DataK8SGatewaySoloIoGatewayV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#metadata_namespace DataK8SGatewaySoloIoGatewayV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mode DataK8SGatewaySoloIoGatewayV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#replacement_text DataK8SGatewaySoloIoGatewayV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractorsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractorsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#override_empty DataK8SGatewaySoloIoGatewayV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tmpl DataK8SGatewaySoloIoGatewayV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_keys DataK8SGatewaySoloIoGatewayV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#advanced_templates DataK8SGatewaySoloIoGatewayV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_metadata_values DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#escape_characters DataK8SGatewaySoloIoGatewayV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extractors DataK8SGatewaySoloIoGatewayV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_append DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_error_on_parse DataK8SGatewaySoloIoGatewayV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_extractors_to_body DataK8SGatewaySoloIoGatewayV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_json_keys DataK8SGatewaySoloIoGatewayV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parse_body_behavior DataK8SGatewaySoloIoGatewayV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#passthrough DataK8SGatewaySoloIoGatewayV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractors",
    },
    headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#non_xml_transform DataK8SGatewaySoloIoGatewayV1Manifest#non_xml_transform}
  */
  readonly nonXmlTransform?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#set_content_type DataK8SGatewaySoloIoGatewayV1Manifest#set_content_type}
  */
  readonly setContentType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt DataK8SGatewaySoloIoGatewayV1Manifest#xslt}
  */
  readonly xslt?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    non_xml_transform: cdktf.booleanToTerraform(struct!.nonXmlTransform),
    set_content_type: cdktf.stringToTerraform(struct!.setContentType),
    xslt: cdktf.stringToTerraform(struct!.xslt),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    non_xml_transform: {
      value: cdktf.booleanToHclTerraform(struct!.nonXmlTransform),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    set_content_type: {
      value: cdktf.stringToHclTerraform(struct!.setContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xslt: {
      value: cdktf.stringToHclTerraform(struct!.xslt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nonXmlTransform !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonXmlTransform = this._nonXmlTransform;
    }
    if (this._setContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.setContentType = this._setContentType;
    }
    if (this._xslt !== undefined) {
      hasAnyValues = true;
      internalValueResult.xslt = this._xslt;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nonXmlTransform = undefined;
      this._setContentType = undefined;
      this._xslt = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nonXmlTransform = value.nonXmlTransform;
      this._setContentType = value.setContentType;
      this._xslt = value.xslt;
    }
  }

  // non_xml_transform - computed: false, optional: true, required: false
  private _nonXmlTransform?: boolean | cdktf.IResolvable; 
  public get nonXmlTransform() {
    return this.getBooleanAttribute('non_xml_transform');
  }
  public set nonXmlTransform(value: boolean | cdktf.IResolvable) {
    this._nonXmlTransform = value;
  }
  public resetNonXmlTransform() {
    this._nonXmlTransform = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonXmlTransformInput() {
    return this._nonXmlTransform;
  }

  // set_content_type - computed: false, optional: true, required: false
  private _setContentType?: string; 
  public get setContentType() {
    return this.getStringAttribute('set_content_type');
  }
  public set setContentType(value: string) {
    this._setContentType = value;
  }
  public resetSetContentType() {
    this._setContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setContentTypeInput() {
    return this._setContentType;
  }

  // xslt - computed: false, optional: true, required: false
  private _xslt?: string; 
  public get xslt() {
    return this.getStringAttribute('xslt');
  }
  public set xslt(value: string) {
    this._xslt = value;
  }
  public resetXslt() {
    this._xslt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltInput() {
    return this._xslt;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_body_transform DataK8SGatewaySoloIoGatewayV1Manifest#header_body_transform}
  */
  readonly headerBodyTransform?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransform;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#log_request_response_info DataK8SGatewaySoloIoGatewayV1Manifest#log_request_response_info}
  */
  readonly logRequestResponseInfo?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transformation_template DataK8SGatewaySoloIoGatewayV1Manifest#transformation_template}
  */
  readonly transformationTemplate?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt_transformation DataK8SGatewaySoloIoGatewayV1Manifest#xslt_transformation}
  */
  readonly xsltTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header_body_transform: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransformToTerraform(struct!.headerBodyTransform),
    log_request_response_info: cdktf.booleanToTerraform(struct!.logRequestResponseInfo),
    transformation_template: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateToTerraform(struct!.transformationTemplate),
    xslt_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformationToTerraform(struct!.xsltTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header_body_transform: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct!.headerBodyTransform),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransform",
    },
    log_request_response_info: {
      value: cdktf.booleanToHclTerraform(struct!.logRequestResponseInfo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    transformation_template: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateToHclTerraform(struct!.transformationTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplate",
    },
    xslt_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformationToHclTerraform(struct!.xsltTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headerBodyTransform?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerBodyTransform = this._headerBodyTransform?.internalValue;
    }
    if (this._logRequestResponseInfo !== undefined) {
      hasAnyValues = true;
      internalValueResult.logRequestResponseInfo = this._logRequestResponseInfo;
    }
    if (this._transformationTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformationTemplate = this._transformationTemplate?.internalValue;
    }
    if (this._xsltTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xsltTransformation = this._xsltTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = undefined;
      this._logRequestResponseInfo = undefined;
      this._transformationTemplate.internalValue = undefined;
      this._xsltTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = value.headerBodyTransform;
      this._logRequestResponseInfo = value.logRequestResponseInfo;
      this._transformationTemplate.internalValue = value.transformationTemplate;
      this._xsltTransformation.internalValue = value.xsltTransformation;
    }
  }

  // header_body_transform - computed: false, optional: true, required: false
  private _headerBodyTransform = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransformOutputReference(this, "header_body_transform");
  public get headerBodyTransform() {
    return this._headerBodyTransform;
  }
  public putHeaderBodyTransform(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationHeaderBodyTransform) {
    this._headerBodyTransform.internalValue = value;
  }
  public resetHeaderBodyTransform() {
    this._headerBodyTransform.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerBodyTransformInput() {
    return this._headerBodyTransform.internalValue;
  }

  // log_request_response_info - computed: false, optional: true, required: false
  private _logRequestResponseInfo?: boolean | cdktf.IResolvable; 
  public get logRequestResponseInfo() {
    return this.getBooleanAttribute('log_request_response_info');
  }
  public set logRequestResponseInfo(value: boolean | cdktf.IResolvable) {
    this._logRequestResponseInfo = value;
  }
  public resetLogRequestResponseInfo() {
    this._logRequestResponseInfo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logRequestResponseInfoInput() {
    return this._logRequestResponseInfo;
  }

  // transformation_template - computed: false, optional: true, required: false
  private _transformationTemplate = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplateOutputReference(this, "transformation_template");
  public get transformationTemplate() {
    return this._transformationTemplate;
  }
  public putTransformationTemplate(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationTransformationTemplate) {
    this._transformationTemplate.internalValue = value;
  }
  public resetTransformationTemplate() {
    this._transformationTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationTemplateInput() {
    return this._transformationTemplate.internalValue;
  }

  // xslt_transformation - computed: false, optional: true, required: false
  private _xsltTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformationOutputReference(this, "xslt_transformation");
  public get xsltTransformation() {
    return this._xsltTransformation;
  }
  public putXsltTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationXsltTransformation) {
    this._xsltTransformation.internalValue = value;
  }
  public resetXsltTransformation() {
    this._xsltTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltTransformationInput() {
    return this._xsltTransformation.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransforms {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#clear_route_cache DataK8SGatewaySoloIoGatewayV1Manifest#clear_route_cache}
  */
  readonly clearRouteCache?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#matcher DataK8SGatewaySoloIoGatewayV1Manifest#matcher}
  */
  readonly matcher?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcher;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_transformation DataK8SGatewaySoloIoGatewayV1Manifest#request_transformation}
  */
  readonly requestTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_transformation DataK8SGatewaySoloIoGatewayV1Manifest#response_transformation}
  */
  readonly responseTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransforms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clear_route_cache: cdktf.booleanToTerraform(struct!.clearRouteCache),
    matcher: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherToTerraform(struct!.matcher),
    request_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationToTerraform(struct!.requestTransformation),
    response_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationToTerraform(struct!.responseTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransforms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clear_route_cache: {
      value: cdktf.booleanToHclTerraform(struct!.clearRouteCache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    matcher: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherToHclTerraform(struct!.matcher),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcher",
    },
    request_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationToHclTerraform(struct!.requestTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformation",
    },
    response_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationToHclTerraform(struct!.responseTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransforms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clearRouteCache !== undefined) {
      hasAnyValues = true;
      internalValueResult.clearRouteCache = this._clearRouteCache;
    }
    if (this._matcher?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matcher = this._matcher?.internalValue;
    }
    if (this._requestTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTransformation = this._requestTransformation?.internalValue;
    }
    if (this._responseTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTransformation = this._responseTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransforms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clearRouteCache = undefined;
      this._matcher.internalValue = undefined;
      this._requestTransformation.internalValue = undefined;
      this._responseTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clearRouteCache = value.clearRouteCache;
      this._matcher.internalValue = value.matcher;
      this._requestTransformation.internalValue = value.requestTransformation;
      this._responseTransformation.internalValue = value.responseTransformation;
    }
  }

  // clear_route_cache - computed: false, optional: true, required: false
  private _clearRouteCache?: boolean | cdktf.IResolvable; 
  public get clearRouteCache() {
    return this.getBooleanAttribute('clear_route_cache');
  }
  public set clearRouteCache(value: boolean | cdktf.IResolvable) {
    this._clearRouteCache = value;
  }
  public resetClearRouteCache() {
    this._clearRouteCache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clearRouteCacheInput() {
    return this._clearRouteCache;
  }

  // matcher - computed: false, optional: true, required: false
  private _matcher = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcherOutputReference(this, "matcher");
  public get matcher() {
    return this._matcher;
  }
  public putMatcher(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsMatcher) {
    this._matcher.internalValue = value;
  }
  public resetMatcher() {
    this._matcher.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matcherInput() {
    return this._matcher.internalValue;
  }

  // request_transformation - computed: false, optional: true, required: false
  private _requestTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformationOutputReference(this, "request_transformation");
  public get requestTransformation() {
    return this._requestTransformation;
  }
  public putRequestTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsRequestTransformation) {
    this._requestTransformation.internalValue = value;
  }
  public resetRequestTransformation() {
    this._requestTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTransformationInput() {
    return this._requestTransformation.internalValue;
  }

  // response_transformation - computed: false, optional: true, required: false
  private _responseTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformationOutputReference(this, "response_transformation");
  public get responseTransformation() {
    return this._responseTransformation;
  }
  public putResponseTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsResponseTransformation) {
    this._responseTransformation.internalValue = value;
  }
  public resetResponseTransformation() {
    this._responseTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTransformationInput() {
    return this._responseTransformation.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransforms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchers {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#invert_match DataK8SGatewaySoloIoGatewayV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransform {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#add_request_metadata DataK8SGatewaySoloIoGatewayV1Manifest#add_request_metadata}
  */
  readonly addRequestMetadata?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransformToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_request_metadata: cdktf.booleanToTerraform(struct!.addRequestMetadata),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_request_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.addRequestMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransformOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRequestMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRequestMetadata = this._addRequestMetadata;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRequestMetadata = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRequestMetadata = value.addRequestMetadata;
    }
  }

  // add_request_metadata - computed: false, optional: true, required: false
  private _addRequestMetadata?: boolean | cdktf.IResolvable; 
  public get addRequestMetadata() {
    return this.getBooleanAttribute('add_request_metadata');
  }
  public set addRequestMetadata(value: boolean | cdktf.IResolvable) {
    this._addRequestMetadata = value;
  }
  public resetAddRequestMetadata() {
    this._addRequestMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRequestMetadataInput() {
    return this._addRequestMetadata;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_to_proto DataK8SGatewaySoloIoGatewayV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#metadata_namespace DataK8SGatewaySoloIoGatewayV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mode DataK8SGatewaySoloIoGatewayV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#replacement_text DataK8SGatewaySoloIoGatewayV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractorsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractorsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#override_empty DataK8SGatewaySoloIoGatewayV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tmpl DataK8SGatewaySoloIoGatewayV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_keys DataK8SGatewaySoloIoGatewayV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#advanced_templates DataK8SGatewaySoloIoGatewayV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_metadata_values DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#escape_characters DataK8SGatewaySoloIoGatewayV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extractors DataK8SGatewaySoloIoGatewayV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_append DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_error_on_parse DataK8SGatewaySoloIoGatewayV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_extractors_to_body DataK8SGatewaySoloIoGatewayV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_json_keys DataK8SGatewaySoloIoGatewayV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parse_body_behavior DataK8SGatewaySoloIoGatewayV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#passthrough DataK8SGatewaySoloIoGatewayV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractors",
    },
    headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#non_xml_transform DataK8SGatewaySoloIoGatewayV1Manifest#non_xml_transform}
  */
  readonly nonXmlTransform?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#set_content_type DataK8SGatewaySoloIoGatewayV1Manifest#set_content_type}
  */
  readonly setContentType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt DataK8SGatewaySoloIoGatewayV1Manifest#xslt}
  */
  readonly xslt?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    non_xml_transform: cdktf.booleanToTerraform(struct!.nonXmlTransform),
    set_content_type: cdktf.stringToTerraform(struct!.setContentType),
    xslt: cdktf.stringToTerraform(struct!.xslt),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    non_xml_transform: {
      value: cdktf.booleanToHclTerraform(struct!.nonXmlTransform),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    set_content_type: {
      value: cdktf.stringToHclTerraform(struct!.setContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xslt: {
      value: cdktf.stringToHclTerraform(struct!.xslt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nonXmlTransform !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonXmlTransform = this._nonXmlTransform;
    }
    if (this._setContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.setContentType = this._setContentType;
    }
    if (this._xslt !== undefined) {
      hasAnyValues = true;
      internalValueResult.xslt = this._xslt;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nonXmlTransform = undefined;
      this._setContentType = undefined;
      this._xslt = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nonXmlTransform = value.nonXmlTransform;
      this._setContentType = value.setContentType;
      this._xslt = value.xslt;
    }
  }

  // non_xml_transform - computed: false, optional: true, required: false
  private _nonXmlTransform?: boolean | cdktf.IResolvable; 
  public get nonXmlTransform() {
    return this.getBooleanAttribute('non_xml_transform');
  }
  public set nonXmlTransform(value: boolean | cdktf.IResolvable) {
    this._nonXmlTransform = value;
  }
  public resetNonXmlTransform() {
    this._nonXmlTransform = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonXmlTransformInput() {
    return this._nonXmlTransform;
  }

  // set_content_type - computed: false, optional: true, required: false
  private _setContentType?: string; 
  public get setContentType() {
    return this.getStringAttribute('set_content_type');
  }
  public set setContentType(value: string) {
    this._setContentType = value;
  }
  public resetSetContentType() {
    this._setContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setContentTypeInput() {
    return this._setContentType;
  }

  // xslt - computed: false, optional: true, required: false
  private _xslt?: string; 
  public get xslt() {
    return this.getStringAttribute('xslt');
  }
  public set xslt(value: string) {
    this._xslt = value;
  }
  public resetXslt() {
    this._xslt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltInput() {
    return this._xslt;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_body_transform DataK8SGatewaySoloIoGatewayV1Manifest#header_body_transform}
  */
  readonly headerBodyTransform?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransform;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#log_request_response_info DataK8SGatewaySoloIoGatewayV1Manifest#log_request_response_info}
  */
  readonly logRequestResponseInfo?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transformation_template DataK8SGatewaySoloIoGatewayV1Manifest#transformation_template}
  */
  readonly transformationTemplate?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt_transformation DataK8SGatewaySoloIoGatewayV1Manifest#xslt_transformation}
  */
  readonly xsltTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header_body_transform: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransformToTerraform(struct!.headerBodyTransform),
    log_request_response_info: cdktf.booleanToTerraform(struct!.logRequestResponseInfo),
    transformation_template: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateToTerraform(struct!.transformationTemplate),
    xslt_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformationToTerraform(struct!.xsltTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header_body_transform: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct!.headerBodyTransform),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransform",
    },
    log_request_response_info: {
      value: cdktf.booleanToHclTerraform(struct!.logRequestResponseInfo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    transformation_template: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateToHclTerraform(struct!.transformationTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplate",
    },
    xslt_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformationToHclTerraform(struct!.xsltTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headerBodyTransform?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerBodyTransform = this._headerBodyTransform?.internalValue;
    }
    if (this._logRequestResponseInfo !== undefined) {
      hasAnyValues = true;
      internalValueResult.logRequestResponseInfo = this._logRequestResponseInfo;
    }
    if (this._transformationTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformationTemplate = this._transformationTemplate?.internalValue;
    }
    if (this._xsltTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xsltTransformation = this._xsltTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = undefined;
      this._logRequestResponseInfo = undefined;
      this._transformationTemplate.internalValue = undefined;
      this._xsltTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = value.headerBodyTransform;
      this._logRequestResponseInfo = value.logRequestResponseInfo;
      this._transformationTemplate.internalValue = value.transformationTemplate;
      this._xsltTransformation.internalValue = value.xsltTransformation;
    }
  }

  // header_body_transform - computed: false, optional: true, required: false
  private _headerBodyTransform = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransformOutputReference(this, "header_body_transform");
  public get headerBodyTransform() {
    return this._headerBodyTransform;
  }
  public putHeaderBodyTransform(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationHeaderBodyTransform) {
    this._headerBodyTransform.internalValue = value;
  }
  public resetHeaderBodyTransform() {
    this._headerBodyTransform.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerBodyTransformInput() {
    return this._headerBodyTransform.internalValue;
  }

  // log_request_response_info - computed: false, optional: true, required: false
  private _logRequestResponseInfo?: boolean | cdktf.IResolvable; 
  public get logRequestResponseInfo() {
    return this.getBooleanAttribute('log_request_response_info');
  }
  public set logRequestResponseInfo(value: boolean | cdktf.IResolvable) {
    this._logRequestResponseInfo = value;
  }
  public resetLogRequestResponseInfo() {
    this._logRequestResponseInfo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logRequestResponseInfoInput() {
    return this._logRequestResponseInfo;
  }

  // transformation_template - computed: false, optional: true, required: false
  private _transformationTemplate = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplateOutputReference(this, "transformation_template");
  public get transformationTemplate() {
    return this._transformationTemplate;
  }
  public putTransformationTemplate(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationTransformationTemplate) {
    this._transformationTemplate.internalValue = value;
  }
  public resetTransformationTemplate() {
    this._transformationTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationTemplateInput() {
    return this._transformationTemplate.internalValue;
  }

  // xslt_transformation - computed: false, optional: true, required: false
  private _xsltTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformationOutputReference(this, "xslt_transformation");
  public get xsltTransformation() {
    return this._xsltTransformation;
  }
  public putXsltTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationXsltTransformation) {
    this._xsltTransformation.internalValue = value;
  }
  public resetXsltTransformation() {
    this._xsltTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltTransformationInput() {
    return this._xsltTransformation.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransforms {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#matchers DataK8SGatewaySoloIoGatewayV1Manifest#matchers}
  */
  readonly matchers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchers[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_code_details DataK8SGatewaySoloIoGatewayV1Manifest#response_code_details}
  */
  readonly responseCodeDetails?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_transformation DataK8SGatewaySoloIoGatewayV1Manifest#response_transformation}
  */
  readonly responseTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransforms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    matchers: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchersToTerraform, false)(struct!.matchers),
    response_code_details: cdktf.stringToTerraform(struct!.responseCodeDetails),
    response_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationToTerraform(struct!.responseTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransforms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    matchers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchersToHclTerraform, false)(struct!.matchers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchersList",
    },
    response_code_details: {
      value: cdktf.stringToHclTerraform(struct!.responseCodeDetails),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationToHclTerraform(struct!.responseTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransforms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchers = this._matchers?.internalValue;
    }
    if (this._responseCodeDetails !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseCodeDetails = this._responseCodeDetails;
    }
    if (this._responseTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTransformation = this._responseTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransforms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchers.internalValue = undefined;
      this._responseCodeDetails = undefined;
      this._responseTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchers.internalValue = value.matchers;
      this._responseCodeDetails = value.responseCodeDetails;
      this._responseTransformation.internalValue = value.responseTransformation;
    }
  }

  // matchers - computed: false, optional: true, required: false
  private _matchers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchersList(this, "matchers", false);
  public get matchers() {
    return this._matchers;
  }
  public putMatchers(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsMatchers[] | cdktf.IResolvable) {
    this._matchers.internalValue = value;
  }
  public resetMatchers() {
    this._matchers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchersInput() {
    return this._matchers.internalValue;
  }

  // response_code_details - computed: false, optional: true, required: false
  private _responseCodeDetails?: string; 
  public get responseCodeDetails() {
    return this.getStringAttribute('response_code_details');
  }
  public set responseCodeDetails(value: string) {
    this._responseCodeDetails = value;
  }
  public resetResponseCodeDetails() {
    this._responseCodeDetails = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseCodeDetailsInput() {
    return this._responseCodeDetails;
  }

  // response_transformation - computed: false, optional: true, required: false
  private _responseTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformationOutputReference(this, "response_transformation");
  public get responseTransformation() {
    return this._responseTransformation;
  }
  public putResponseTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsResponseTransformation) {
    this._responseTransformation.internalValue = value;
  }
  public resetResponseTransformation() {
    this._responseTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTransformationInput() {
    return this._responseTransformation.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransforms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarly {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_transforms DataK8SGatewaySoloIoGatewayV1Manifest#request_transforms}
  */
  readonly requestTransforms?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransforms[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_transforms DataK8SGatewaySoloIoGatewayV1Manifest#response_transforms}
  */
  readonly responseTransforms?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransforms[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarly | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request_transforms: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsToTerraform, false)(struct!.requestTransforms),
    response_transforms: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsToTerraform, false)(struct!.responseTransforms),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarly | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request_transforms: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsToHclTerraform, false)(struct!.requestTransforms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsList",
    },
    response_transforms: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsToHclTerraform, false)(struct!.responseTransforms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarly | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestTransforms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTransforms = this._requestTransforms?.internalValue;
    }
    if (this._responseTransforms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTransforms = this._responseTransforms?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarly | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestTransforms.internalValue = undefined;
      this._responseTransforms.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestTransforms.internalValue = value.requestTransforms;
      this._responseTransforms.internalValue = value.responseTransforms;
    }
  }

  // request_transforms - computed: false, optional: true, required: false
  private _requestTransforms = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransformsList(this, "request_transforms", false);
  public get requestTransforms() {
    return this._requestTransforms;
  }
  public putRequestTransforms(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyRequestTransforms[] | cdktf.IResolvable) {
    this._requestTransforms.internalValue = value;
  }
  public resetRequestTransforms() {
    this._requestTransforms.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTransformsInput() {
    return this._requestTransforms.internalValue;
  }

  // response_transforms - computed: false, optional: true, required: false
  private _responseTransforms = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransformsList(this, "response_transforms", false);
  public get responseTransforms() {
    return this._responseTransforms;
  }
  public putResponseTransforms(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsEarlyResponseTransforms[] | cdktf.IResolvable) {
    this._responseTransforms.internalValue = value;
  }
  public resetResponseTransforms() {
    this._responseTransforms.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTransformsInput() {
    return this._responseTransforms.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#invert_match DataK8SGatewaySoloIoGatewayV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeadersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParametersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParametersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParametersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParametersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcher {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#case_sensitive DataK8SGatewaySoloIoGatewayV1Manifest#case_sensitive}
  */
  readonly caseSensitive?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#connect_matcher DataK8SGatewaySoloIoGatewayV1Manifest#connect_matcher}
  */
  readonly connectMatcher?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#exact DataK8SGatewaySoloIoGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#methods DataK8SGatewaySoloIoGatewayV1Manifest#methods}
  */
  readonly methods?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix DataK8SGatewaySoloIoGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#query_parameters DataK8SGatewaySoloIoGatewayV1Manifest#query_parameters}
  */
  readonly queryParameters?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParameters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    case_sensitive: cdktf.booleanToTerraform(struct!.caseSensitive),
    connect_matcher: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectMatcher),
    exact: cdktf.stringToTerraform(struct!.exact),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeadersToTerraform, false)(struct!.headers),
    methods: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.methods),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    query_parameters: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParametersToTerraform, false)(struct!.queryParameters),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    case_sensitive: {
      value: cdktf.booleanToHclTerraform(struct!.caseSensitive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connect_matcher: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectMatcher),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeadersList",
    },
    methods: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.methods),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query_parameters: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParametersToHclTerraform, false)(struct!.queryParameters),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParametersList",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcher | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caseSensitive !== undefined) {
      hasAnyValues = true;
      internalValueResult.caseSensitive = this._caseSensitive;
    }
    if (this._connectMatcher !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectMatcher = this._connectMatcher;
    }
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._methods !== undefined) {
      hasAnyValues = true;
      internalValueResult.methods = this._methods;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._queryParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParameters = this._queryParameters?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcher | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caseSensitive = undefined;
      this._connectMatcher = undefined;
      this._exact = undefined;
      this._headers.internalValue = undefined;
      this._methods = undefined;
      this._prefix = undefined;
      this._queryParameters.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caseSensitive = value.caseSensitive;
      this._connectMatcher = value.connectMatcher;
      this._exact = value.exact;
      this._headers.internalValue = value.headers;
      this._methods = value.methods;
      this._prefix = value.prefix;
      this._queryParameters.internalValue = value.queryParameters;
      this._regex = value.regex;
    }
  }

  // case_sensitive - computed: false, optional: true, required: false
  private _caseSensitive?: boolean | cdktf.IResolvable; 
  public get caseSensitive() {
    return this.getBooleanAttribute('case_sensitive');
  }
  public set caseSensitive(value: boolean | cdktf.IResolvable) {
    this._caseSensitive = value;
  }
  public resetCaseSensitive() {
    this._caseSensitive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caseSensitiveInput() {
    return this._caseSensitive;
  }

  // connect_matcher - computed: false, optional: true, required: false
  private _connectMatcher?: { [key: string]: string }; 
  public get connectMatcher() {
    return this.getStringMapAttribute('connect_matcher');
  }
  public set connectMatcher(value: { [key: string]: string }) {
    this._connectMatcher = value;
  }
  public resetConnectMatcher() {
    this._connectMatcher = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectMatcherInput() {
    return this._connectMatcher;
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // methods - computed: false, optional: true, required: false
  private _methods?: string[]; 
  public get methods() {
    return this.getListAttribute('methods');
  }
  public set methods(value: string[]) {
    this._methods = value;
  }
  public resetMethods() {
    this._methods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodsInput() {
    return this._methods;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // query_parameters - computed: false, optional: true, required: false
  private _queryParameters = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParametersList(this, "query_parameters", false);
  public get queryParameters() {
    return this._queryParameters;
  }
  public putQueryParameters(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherQueryParameters[] | cdktf.IResolvable) {
    this._queryParameters.internalValue = value;
  }
  public resetQueryParameters() {
    this._queryParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParametersInput() {
    return this._queryParameters.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransform {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#add_request_metadata DataK8SGatewaySoloIoGatewayV1Manifest#add_request_metadata}
  */
  readonly addRequestMetadata?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransformToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_request_metadata: cdktf.booleanToTerraform(struct!.addRequestMetadata),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransformToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_request_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.addRequestMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransformOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRequestMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRequestMetadata = this._addRequestMetadata;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRequestMetadata = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRequestMetadata = value.addRequestMetadata;
    }
  }

  // add_request_metadata - computed: false, optional: true, required: false
  private _addRequestMetadata?: boolean | cdktf.IResolvable; 
  public get addRequestMetadata() {
    return this.getBooleanAttribute('add_request_metadata');
  }
  public set addRequestMetadata(value: boolean | cdktf.IResolvable) {
    this._addRequestMetadata = value;
  }
  public resetAddRequestMetadata() {
    this._addRequestMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRequestMetadataInput() {
    return this._addRequestMetadata;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_to_proto DataK8SGatewaySoloIoGatewayV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#metadata_namespace DataK8SGatewaySoloIoGatewayV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mode DataK8SGatewaySoloIoGatewayV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#replacement_text DataK8SGatewaySoloIoGatewayV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractorsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractorsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#override_empty DataK8SGatewaySoloIoGatewayV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tmpl DataK8SGatewaySoloIoGatewayV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_keys DataK8SGatewaySoloIoGatewayV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#advanced_templates DataK8SGatewaySoloIoGatewayV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_metadata_values DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#escape_characters DataK8SGatewaySoloIoGatewayV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extractors DataK8SGatewaySoloIoGatewayV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_append DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_error_on_parse DataK8SGatewaySoloIoGatewayV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_extractors_to_body DataK8SGatewaySoloIoGatewayV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_json_keys DataK8SGatewaySoloIoGatewayV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parse_body_behavior DataK8SGatewaySoloIoGatewayV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#passthrough DataK8SGatewaySoloIoGatewayV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractors",
    },
    headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#non_xml_transform DataK8SGatewaySoloIoGatewayV1Manifest#non_xml_transform}
  */
  readonly nonXmlTransform?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#set_content_type DataK8SGatewaySoloIoGatewayV1Manifest#set_content_type}
  */
  readonly setContentType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt DataK8SGatewaySoloIoGatewayV1Manifest#xslt}
  */
  readonly xslt?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    non_xml_transform: cdktf.booleanToTerraform(struct!.nonXmlTransform),
    set_content_type: cdktf.stringToTerraform(struct!.setContentType),
    xslt: cdktf.stringToTerraform(struct!.xslt),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    non_xml_transform: {
      value: cdktf.booleanToHclTerraform(struct!.nonXmlTransform),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    set_content_type: {
      value: cdktf.stringToHclTerraform(struct!.setContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xslt: {
      value: cdktf.stringToHclTerraform(struct!.xslt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nonXmlTransform !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonXmlTransform = this._nonXmlTransform;
    }
    if (this._setContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.setContentType = this._setContentType;
    }
    if (this._xslt !== undefined) {
      hasAnyValues = true;
      internalValueResult.xslt = this._xslt;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nonXmlTransform = undefined;
      this._setContentType = undefined;
      this._xslt = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nonXmlTransform = value.nonXmlTransform;
      this._setContentType = value.setContentType;
      this._xslt = value.xslt;
    }
  }

  // non_xml_transform - computed: false, optional: true, required: false
  private _nonXmlTransform?: boolean | cdktf.IResolvable; 
  public get nonXmlTransform() {
    return this.getBooleanAttribute('non_xml_transform');
  }
  public set nonXmlTransform(value: boolean | cdktf.IResolvable) {
    this._nonXmlTransform = value;
  }
  public resetNonXmlTransform() {
    this._nonXmlTransform = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonXmlTransformInput() {
    return this._nonXmlTransform;
  }

  // set_content_type - computed: false, optional: true, required: false
  private _setContentType?: string; 
  public get setContentType() {
    return this.getStringAttribute('set_content_type');
  }
  public set setContentType(value: string) {
    this._setContentType = value;
  }
  public resetSetContentType() {
    this._setContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setContentTypeInput() {
    return this._setContentType;
  }

  // xslt - computed: false, optional: true, required: false
  private _xslt?: string; 
  public get xslt() {
    return this.getStringAttribute('xslt');
  }
  public set xslt(value: string) {
    this._xslt = value;
  }
  public resetXslt() {
    this._xslt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltInput() {
    return this._xslt;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_body_transform DataK8SGatewaySoloIoGatewayV1Manifest#header_body_transform}
  */
  readonly headerBodyTransform?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransform;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#log_request_response_info DataK8SGatewaySoloIoGatewayV1Manifest#log_request_response_info}
  */
  readonly logRequestResponseInfo?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transformation_template DataK8SGatewaySoloIoGatewayV1Manifest#transformation_template}
  */
  readonly transformationTemplate?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt_transformation DataK8SGatewaySoloIoGatewayV1Manifest#xslt_transformation}
  */
  readonly xsltTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header_body_transform: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransformToTerraform(struct!.headerBodyTransform),
    log_request_response_info: cdktf.booleanToTerraform(struct!.logRequestResponseInfo),
    transformation_template: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateToTerraform(struct!.transformationTemplate),
    xslt_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformationToTerraform(struct!.xsltTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header_body_transform: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransformToHclTerraform(struct!.headerBodyTransform),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransform",
    },
    log_request_response_info: {
      value: cdktf.booleanToHclTerraform(struct!.logRequestResponseInfo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    transformation_template: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateToHclTerraform(struct!.transformationTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplate",
    },
    xslt_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformationToHclTerraform(struct!.xsltTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headerBodyTransform?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerBodyTransform = this._headerBodyTransform?.internalValue;
    }
    if (this._logRequestResponseInfo !== undefined) {
      hasAnyValues = true;
      internalValueResult.logRequestResponseInfo = this._logRequestResponseInfo;
    }
    if (this._transformationTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformationTemplate = this._transformationTemplate?.internalValue;
    }
    if (this._xsltTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xsltTransformation = this._xsltTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = undefined;
      this._logRequestResponseInfo = undefined;
      this._transformationTemplate.internalValue = undefined;
      this._xsltTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = value.headerBodyTransform;
      this._logRequestResponseInfo = value.logRequestResponseInfo;
      this._transformationTemplate.internalValue = value.transformationTemplate;
      this._xsltTransformation.internalValue = value.xsltTransformation;
    }
  }

  // header_body_transform - computed: false, optional: true, required: false
  private _headerBodyTransform = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransformOutputReference(this, "header_body_transform");
  public get headerBodyTransform() {
    return this._headerBodyTransform;
  }
  public putHeaderBodyTransform(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationHeaderBodyTransform) {
    this._headerBodyTransform.internalValue = value;
  }
  public resetHeaderBodyTransform() {
    this._headerBodyTransform.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerBodyTransformInput() {
    return this._headerBodyTransform.internalValue;
  }

  // log_request_response_info - computed: false, optional: true, required: false
  private _logRequestResponseInfo?: boolean | cdktf.IResolvable; 
  public get logRequestResponseInfo() {
    return this.getBooleanAttribute('log_request_response_info');
  }
  public set logRequestResponseInfo(value: boolean | cdktf.IResolvable) {
    this._logRequestResponseInfo = value;
  }
  public resetLogRequestResponseInfo() {
    this._logRequestResponseInfo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logRequestResponseInfoInput() {
    return this._logRequestResponseInfo;
  }

  // transformation_template - computed: false, optional: true, required: false
  private _transformationTemplate = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplateOutputReference(this, "transformation_template");
  public get transformationTemplate() {
    return this._transformationTemplate;
  }
  public putTransformationTemplate(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationTransformationTemplate) {
    this._transformationTemplate.internalValue = value;
  }
  public resetTransformationTemplate() {
    this._transformationTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationTemplateInput() {
    return this._transformationTemplate.internalValue;
  }

  // xslt_transformation - computed: false, optional: true, required: false
  private _xsltTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformationOutputReference(this, "xslt_transformation");
  public get xsltTransformation() {
    return this._xsltTransformation;
  }
  public putXsltTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationXsltTransformation) {
    this._xsltTransformation.internalValue = value;
  }
  public resetXsltTransformation() {
    this._xsltTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltTransformationInput() {
    return this._xsltTransformation.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransform {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#add_request_metadata DataK8SGatewaySoloIoGatewayV1Manifest#add_request_metadata}
  */
  readonly addRequestMetadata?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransformToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_request_metadata: cdktf.booleanToTerraform(struct!.addRequestMetadata),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_request_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.addRequestMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransformOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRequestMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRequestMetadata = this._addRequestMetadata;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRequestMetadata = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRequestMetadata = value.addRequestMetadata;
    }
  }

  // add_request_metadata - computed: false, optional: true, required: false
  private _addRequestMetadata?: boolean | cdktf.IResolvable; 
  public get addRequestMetadata() {
    return this.getBooleanAttribute('add_request_metadata');
  }
  public set addRequestMetadata(value: boolean | cdktf.IResolvable) {
    this._addRequestMetadata = value;
  }
  public resetAddRequestMetadata() {
    this._addRequestMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRequestMetadataInput() {
    return this._addRequestMetadata;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_to_proto DataK8SGatewaySoloIoGatewayV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#metadata_namespace DataK8SGatewaySoloIoGatewayV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mode DataK8SGatewaySoloIoGatewayV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#replacement_text DataK8SGatewaySoloIoGatewayV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractorsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractorsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#override_empty DataK8SGatewaySoloIoGatewayV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tmpl DataK8SGatewaySoloIoGatewayV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_keys DataK8SGatewaySoloIoGatewayV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#advanced_templates DataK8SGatewaySoloIoGatewayV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_metadata_values DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#escape_characters DataK8SGatewaySoloIoGatewayV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extractors DataK8SGatewaySoloIoGatewayV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_append DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_error_on_parse DataK8SGatewaySoloIoGatewayV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_extractors_to_body DataK8SGatewaySoloIoGatewayV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_json_keys DataK8SGatewaySoloIoGatewayV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parse_body_behavior DataK8SGatewaySoloIoGatewayV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#passthrough DataK8SGatewaySoloIoGatewayV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractors",
    },
    headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#non_xml_transform DataK8SGatewaySoloIoGatewayV1Manifest#non_xml_transform}
  */
  readonly nonXmlTransform?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#set_content_type DataK8SGatewaySoloIoGatewayV1Manifest#set_content_type}
  */
  readonly setContentType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt DataK8SGatewaySoloIoGatewayV1Manifest#xslt}
  */
  readonly xslt?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    non_xml_transform: cdktf.booleanToTerraform(struct!.nonXmlTransform),
    set_content_type: cdktf.stringToTerraform(struct!.setContentType),
    xslt: cdktf.stringToTerraform(struct!.xslt),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    non_xml_transform: {
      value: cdktf.booleanToHclTerraform(struct!.nonXmlTransform),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    set_content_type: {
      value: cdktf.stringToHclTerraform(struct!.setContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xslt: {
      value: cdktf.stringToHclTerraform(struct!.xslt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nonXmlTransform !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonXmlTransform = this._nonXmlTransform;
    }
    if (this._setContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.setContentType = this._setContentType;
    }
    if (this._xslt !== undefined) {
      hasAnyValues = true;
      internalValueResult.xslt = this._xslt;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nonXmlTransform = undefined;
      this._setContentType = undefined;
      this._xslt = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nonXmlTransform = value.nonXmlTransform;
      this._setContentType = value.setContentType;
      this._xslt = value.xslt;
    }
  }

  // non_xml_transform - computed: false, optional: true, required: false
  private _nonXmlTransform?: boolean | cdktf.IResolvable; 
  public get nonXmlTransform() {
    return this.getBooleanAttribute('non_xml_transform');
  }
  public set nonXmlTransform(value: boolean | cdktf.IResolvable) {
    this._nonXmlTransform = value;
  }
  public resetNonXmlTransform() {
    this._nonXmlTransform = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonXmlTransformInput() {
    return this._nonXmlTransform;
  }

  // set_content_type - computed: false, optional: true, required: false
  private _setContentType?: string; 
  public get setContentType() {
    return this.getStringAttribute('set_content_type');
  }
  public set setContentType(value: string) {
    this._setContentType = value;
  }
  public resetSetContentType() {
    this._setContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setContentTypeInput() {
    return this._setContentType;
  }

  // xslt - computed: false, optional: true, required: false
  private _xslt?: string; 
  public get xslt() {
    return this.getStringAttribute('xslt');
  }
  public set xslt(value: string) {
    this._xslt = value;
  }
  public resetXslt() {
    this._xslt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltInput() {
    return this._xslt;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_body_transform DataK8SGatewaySoloIoGatewayV1Manifest#header_body_transform}
  */
  readonly headerBodyTransform?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransform;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#log_request_response_info DataK8SGatewaySoloIoGatewayV1Manifest#log_request_response_info}
  */
  readonly logRequestResponseInfo?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transformation_template DataK8SGatewaySoloIoGatewayV1Manifest#transformation_template}
  */
  readonly transformationTemplate?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt_transformation DataK8SGatewaySoloIoGatewayV1Manifest#xslt_transformation}
  */
  readonly xsltTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header_body_transform: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransformToTerraform(struct!.headerBodyTransform),
    log_request_response_info: cdktf.booleanToTerraform(struct!.logRequestResponseInfo),
    transformation_template: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateToTerraform(struct!.transformationTemplate),
    xslt_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformationToTerraform(struct!.xsltTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header_body_transform: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct!.headerBodyTransform),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransform",
    },
    log_request_response_info: {
      value: cdktf.booleanToHclTerraform(struct!.logRequestResponseInfo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    transformation_template: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateToHclTerraform(struct!.transformationTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplate",
    },
    xslt_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformationToHclTerraform(struct!.xsltTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headerBodyTransform?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerBodyTransform = this._headerBodyTransform?.internalValue;
    }
    if (this._logRequestResponseInfo !== undefined) {
      hasAnyValues = true;
      internalValueResult.logRequestResponseInfo = this._logRequestResponseInfo;
    }
    if (this._transformationTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformationTemplate = this._transformationTemplate?.internalValue;
    }
    if (this._xsltTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xsltTransformation = this._xsltTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = undefined;
      this._logRequestResponseInfo = undefined;
      this._transformationTemplate.internalValue = undefined;
      this._xsltTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = value.headerBodyTransform;
      this._logRequestResponseInfo = value.logRequestResponseInfo;
      this._transformationTemplate.internalValue = value.transformationTemplate;
      this._xsltTransformation.internalValue = value.xsltTransformation;
    }
  }

  // header_body_transform - computed: false, optional: true, required: false
  private _headerBodyTransform = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransformOutputReference(this, "header_body_transform");
  public get headerBodyTransform() {
    return this._headerBodyTransform;
  }
  public putHeaderBodyTransform(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationHeaderBodyTransform) {
    this._headerBodyTransform.internalValue = value;
  }
  public resetHeaderBodyTransform() {
    this._headerBodyTransform.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerBodyTransformInput() {
    return this._headerBodyTransform.internalValue;
  }

  // log_request_response_info - computed: false, optional: true, required: false
  private _logRequestResponseInfo?: boolean | cdktf.IResolvable; 
  public get logRequestResponseInfo() {
    return this.getBooleanAttribute('log_request_response_info');
  }
  public set logRequestResponseInfo(value: boolean | cdktf.IResolvable) {
    this._logRequestResponseInfo = value;
  }
  public resetLogRequestResponseInfo() {
    this._logRequestResponseInfo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logRequestResponseInfoInput() {
    return this._logRequestResponseInfo;
  }

  // transformation_template - computed: false, optional: true, required: false
  private _transformationTemplate = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplateOutputReference(this, "transformation_template");
  public get transformationTemplate() {
    return this._transformationTemplate;
  }
  public putTransformationTemplate(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationTransformationTemplate) {
    this._transformationTemplate.internalValue = value;
  }
  public resetTransformationTemplate() {
    this._transformationTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationTemplateInput() {
    return this._transformationTemplate.internalValue;
  }

  // xslt_transformation - computed: false, optional: true, required: false
  private _xsltTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformationOutputReference(this, "xslt_transformation");
  public get xsltTransformation() {
    return this._xsltTransformation;
  }
  public putXsltTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationXsltTransformation) {
    this._xsltTransformation.internalValue = value;
  }
  public resetXsltTransformation() {
    this._xsltTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltTransformationInput() {
    return this._xsltTransformation.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransforms {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#clear_route_cache DataK8SGatewaySoloIoGatewayV1Manifest#clear_route_cache}
  */
  readonly clearRouteCache?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#matcher DataK8SGatewaySoloIoGatewayV1Manifest#matcher}
  */
  readonly matcher?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcher;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_transformation DataK8SGatewaySoloIoGatewayV1Manifest#request_transformation}
  */
  readonly requestTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_transformation DataK8SGatewaySoloIoGatewayV1Manifest#response_transformation}
  */
  readonly responseTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransforms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clear_route_cache: cdktf.booleanToTerraform(struct!.clearRouteCache),
    matcher: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherToTerraform(struct!.matcher),
    request_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationToTerraform(struct!.requestTransformation),
    response_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationToTerraform(struct!.responseTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransforms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clear_route_cache: {
      value: cdktf.booleanToHclTerraform(struct!.clearRouteCache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    matcher: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherToHclTerraform(struct!.matcher),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcher",
    },
    request_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationToHclTerraform(struct!.requestTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformation",
    },
    response_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationToHclTerraform(struct!.responseTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransforms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clearRouteCache !== undefined) {
      hasAnyValues = true;
      internalValueResult.clearRouteCache = this._clearRouteCache;
    }
    if (this._matcher?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matcher = this._matcher?.internalValue;
    }
    if (this._requestTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTransformation = this._requestTransformation?.internalValue;
    }
    if (this._responseTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTransformation = this._responseTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransforms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clearRouteCache = undefined;
      this._matcher.internalValue = undefined;
      this._requestTransformation.internalValue = undefined;
      this._responseTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clearRouteCache = value.clearRouteCache;
      this._matcher.internalValue = value.matcher;
      this._requestTransformation.internalValue = value.requestTransformation;
      this._responseTransformation.internalValue = value.responseTransformation;
    }
  }

  // clear_route_cache - computed: false, optional: true, required: false
  private _clearRouteCache?: boolean | cdktf.IResolvable; 
  public get clearRouteCache() {
    return this.getBooleanAttribute('clear_route_cache');
  }
  public set clearRouteCache(value: boolean | cdktf.IResolvable) {
    this._clearRouteCache = value;
  }
  public resetClearRouteCache() {
    this._clearRouteCache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clearRouteCacheInput() {
    return this._clearRouteCache;
  }

  // matcher - computed: false, optional: true, required: false
  private _matcher = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcherOutputReference(this, "matcher");
  public get matcher() {
    return this._matcher;
  }
  public putMatcher(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsMatcher) {
    this._matcher.internalValue = value;
  }
  public resetMatcher() {
    this._matcher.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matcherInput() {
    return this._matcher.internalValue;
  }

  // request_transformation - computed: false, optional: true, required: false
  private _requestTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformationOutputReference(this, "request_transformation");
  public get requestTransformation() {
    return this._requestTransformation;
  }
  public putRequestTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsRequestTransformation) {
    this._requestTransformation.internalValue = value;
  }
  public resetRequestTransformation() {
    this._requestTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTransformationInput() {
    return this._requestTransformation.internalValue;
  }

  // response_transformation - computed: false, optional: true, required: false
  private _responseTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformationOutputReference(this, "response_transformation");
  public get responseTransformation() {
    return this._responseTransformation;
  }
  public putResponseTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsResponseTransformation) {
    this._responseTransformation.internalValue = value;
  }
  public resetResponseTransformation() {
    this._responseTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTransformationInput() {
    return this._responseTransformation.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransforms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchers {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#invert_match DataK8SGatewaySoloIoGatewayV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransform {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#add_request_metadata DataK8SGatewaySoloIoGatewayV1Manifest#add_request_metadata}
  */
  readonly addRequestMetadata?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransformToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_request_metadata: cdktf.booleanToTerraform(struct!.addRequestMetadata),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_request_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.addRequestMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransformOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRequestMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRequestMetadata = this._addRequestMetadata;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRequestMetadata = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRequestMetadata = value.addRequestMetadata;
    }
  }

  // add_request_metadata - computed: false, optional: true, required: false
  private _addRequestMetadata?: boolean | cdktf.IResolvable; 
  public get addRequestMetadata() {
    return this.getBooleanAttribute('add_request_metadata');
  }
  public set addRequestMetadata(value: boolean | cdktf.IResolvable) {
    this._addRequestMetadata = value;
  }
  public resetAddRequestMetadata() {
    this._addRequestMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRequestMetadataInput() {
    return this._addRequestMetadata;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_to_proto DataK8SGatewaySoloIoGatewayV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#metadata_namespace DataK8SGatewaySoloIoGatewayV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mode DataK8SGatewaySoloIoGatewayV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#replacement_text DataK8SGatewaySoloIoGatewayV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractorsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractorsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#override_empty DataK8SGatewaySoloIoGatewayV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tmpl DataK8SGatewaySoloIoGatewayV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_keys DataK8SGatewaySoloIoGatewayV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#advanced_templates DataK8SGatewaySoloIoGatewayV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_metadata_values DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#escape_characters DataK8SGatewaySoloIoGatewayV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extractors DataK8SGatewaySoloIoGatewayV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_append DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_error_on_parse DataK8SGatewaySoloIoGatewayV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_extractors_to_body DataK8SGatewaySoloIoGatewayV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_json_keys DataK8SGatewaySoloIoGatewayV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parse_body_behavior DataK8SGatewaySoloIoGatewayV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#passthrough DataK8SGatewaySoloIoGatewayV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractors",
    },
    headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#non_xml_transform DataK8SGatewaySoloIoGatewayV1Manifest#non_xml_transform}
  */
  readonly nonXmlTransform?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#set_content_type DataK8SGatewaySoloIoGatewayV1Manifest#set_content_type}
  */
  readonly setContentType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt DataK8SGatewaySoloIoGatewayV1Manifest#xslt}
  */
  readonly xslt?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    non_xml_transform: cdktf.booleanToTerraform(struct!.nonXmlTransform),
    set_content_type: cdktf.stringToTerraform(struct!.setContentType),
    xslt: cdktf.stringToTerraform(struct!.xslt),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    non_xml_transform: {
      value: cdktf.booleanToHclTerraform(struct!.nonXmlTransform),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    set_content_type: {
      value: cdktf.stringToHclTerraform(struct!.setContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xslt: {
      value: cdktf.stringToHclTerraform(struct!.xslt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nonXmlTransform !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonXmlTransform = this._nonXmlTransform;
    }
    if (this._setContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.setContentType = this._setContentType;
    }
    if (this._xslt !== undefined) {
      hasAnyValues = true;
      internalValueResult.xslt = this._xslt;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nonXmlTransform = undefined;
      this._setContentType = undefined;
      this._xslt = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nonXmlTransform = value.nonXmlTransform;
      this._setContentType = value.setContentType;
      this._xslt = value.xslt;
    }
  }

  // non_xml_transform - computed: false, optional: true, required: false
  private _nonXmlTransform?: boolean | cdktf.IResolvable; 
  public get nonXmlTransform() {
    return this.getBooleanAttribute('non_xml_transform');
  }
  public set nonXmlTransform(value: boolean | cdktf.IResolvable) {
    this._nonXmlTransform = value;
  }
  public resetNonXmlTransform() {
    this._nonXmlTransform = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonXmlTransformInput() {
    return this._nonXmlTransform;
  }

  // set_content_type - computed: false, optional: true, required: false
  private _setContentType?: string; 
  public get setContentType() {
    return this.getStringAttribute('set_content_type');
  }
  public set setContentType(value: string) {
    this._setContentType = value;
  }
  public resetSetContentType() {
    this._setContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setContentTypeInput() {
    return this._setContentType;
  }

  // xslt - computed: false, optional: true, required: false
  private _xslt?: string; 
  public get xslt() {
    return this.getStringAttribute('xslt');
  }
  public set xslt(value: string) {
    this._xslt = value;
  }
  public resetXslt() {
    this._xslt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltInput() {
    return this._xslt;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_body_transform DataK8SGatewaySoloIoGatewayV1Manifest#header_body_transform}
  */
  readonly headerBodyTransform?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransform;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#log_request_response_info DataK8SGatewaySoloIoGatewayV1Manifest#log_request_response_info}
  */
  readonly logRequestResponseInfo?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transformation_template DataK8SGatewaySoloIoGatewayV1Manifest#transformation_template}
  */
  readonly transformationTemplate?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt_transformation DataK8SGatewaySoloIoGatewayV1Manifest#xslt_transformation}
  */
  readonly xsltTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header_body_transform: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransformToTerraform(struct!.headerBodyTransform),
    log_request_response_info: cdktf.booleanToTerraform(struct!.logRequestResponseInfo),
    transformation_template: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateToTerraform(struct!.transformationTemplate),
    xslt_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformationToTerraform(struct!.xsltTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header_body_transform: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct!.headerBodyTransform),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransform",
    },
    log_request_response_info: {
      value: cdktf.booleanToHclTerraform(struct!.logRequestResponseInfo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    transformation_template: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateToHclTerraform(struct!.transformationTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplate",
    },
    xslt_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformationToHclTerraform(struct!.xsltTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headerBodyTransform?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerBodyTransform = this._headerBodyTransform?.internalValue;
    }
    if (this._logRequestResponseInfo !== undefined) {
      hasAnyValues = true;
      internalValueResult.logRequestResponseInfo = this._logRequestResponseInfo;
    }
    if (this._transformationTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformationTemplate = this._transformationTemplate?.internalValue;
    }
    if (this._xsltTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xsltTransformation = this._xsltTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = undefined;
      this._logRequestResponseInfo = undefined;
      this._transformationTemplate.internalValue = undefined;
      this._xsltTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = value.headerBodyTransform;
      this._logRequestResponseInfo = value.logRequestResponseInfo;
      this._transformationTemplate.internalValue = value.transformationTemplate;
      this._xsltTransformation.internalValue = value.xsltTransformation;
    }
  }

  // header_body_transform - computed: false, optional: true, required: false
  private _headerBodyTransform = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransformOutputReference(this, "header_body_transform");
  public get headerBodyTransform() {
    return this._headerBodyTransform;
  }
  public putHeaderBodyTransform(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationHeaderBodyTransform) {
    this._headerBodyTransform.internalValue = value;
  }
  public resetHeaderBodyTransform() {
    this._headerBodyTransform.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerBodyTransformInput() {
    return this._headerBodyTransform.internalValue;
  }

  // log_request_response_info - computed: false, optional: true, required: false
  private _logRequestResponseInfo?: boolean | cdktf.IResolvable; 
  public get logRequestResponseInfo() {
    return this.getBooleanAttribute('log_request_response_info');
  }
  public set logRequestResponseInfo(value: boolean | cdktf.IResolvable) {
    this._logRequestResponseInfo = value;
  }
  public resetLogRequestResponseInfo() {
    this._logRequestResponseInfo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logRequestResponseInfoInput() {
    return this._logRequestResponseInfo;
  }

  // transformation_template - computed: false, optional: true, required: false
  private _transformationTemplate = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplateOutputReference(this, "transformation_template");
  public get transformationTemplate() {
    return this._transformationTemplate;
  }
  public putTransformationTemplate(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationTransformationTemplate) {
    this._transformationTemplate.internalValue = value;
  }
  public resetTransformationTemplate() {
    this._transformationTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationTemplateInput() {
    return this._transformationTemplate.internalValue;
  }

  // xslt_transformation - computed: false, optional: true, required: false
  private _xsltTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformationOutputReference(this, "xslt_transformation");
  public get xsltTransformation() {
    return this._xsltTransformation;
  }
  public putXsltTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationXsltTransformation) {
    this._xsltTransformation.internalValue = value;
  }
  public resetXsltTransformation() {
    this._xsltTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltTransformationInput() {
    return this._xsltTransformation.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransforms {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#matchers DataK8SGatewaySoloIoGatewayV1Manifest#matchers}
  */
  readonly matchers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchers[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_code_details DataK8SGatewaySoloIoGatewayV1Manifest#response_code_details}
  */
  readonly responseCodeDetails?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_transformation DataK8SGatewaySoloIoGatewayV1Manifest#response_transformation}
  */
  readonly responseTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransforms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    matchers: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchersToTerraform, false)(struct!.matchers),
    response_code_details: cdktf.stringToTerraform(struct!.responseCodeDetails),
    response_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationToTerraform(struct!.responseTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransforms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    matchers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchersToHclTerraform, false)(struct!.matchers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchersList",
    },
    response_code_details: {
      value: cdktf.stringToHclTerraform(struct!.responseCodeDetails),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationToHclTerraform(struct!.responseTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransforms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchers = this._matchers?.internalValue;
    }
    if (this._responseCodeDetails !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseCodeDetails = this._responseCodeDetails;
    }
    if (this._responseTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTransformation = this._responseTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransforms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchers.internalValue = undefined;
      this._responseCodeDetails = undefined;
      this._responseTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchers.internalValue = value.matchers;
      this._responseCodeDetails = value.responseCodeDetails;
      this._responseTransformation.internalValue = value.responseTransformation;
    }
  }

  // matchers - computed: false, optional: true, required: false
  private _matchers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchersList(this, "matchers", false);
  public get matchers() {
    return this._matchers;
  }
  public putMatchers(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsMatchers[] | cdktf.IResolvable) {
    this._matchers.internalValue = value;
  }
  public resetMatchers() {
    this._matchers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchersInput() {
    return this._matchers.internalValue;
  }

  // response_code_details - computed: false, optional: true, required: false
  private _responseCodeDetails?: string; 
  public get responseCodeDetails() {
    return this.getStringAttribute('response_code_details');
  }
  public set responseCodeDetails(value: string) {
    this._responseCodeDetails = value;
  }
  public resetResponseCodeDetails() {
    this._responseCodeDetails = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseCodeDetailsInput() {
    return this._responseCodeDetails;
  }

  // response_transformation - computed: false, optional: true, required: false
  private _responseTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformationOutputReference(this, "response_transformation");
  public get responseTransformation() {
    return this._responseTransformation;
  }
  public putResponseTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsResponseTransformation) {
    this._responseTransformation.internalValue = value;
  }
  public resetResponseTransformation() {
    this._responseTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTransformationInput() {
    return this._responseTransformation.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransforms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRouting {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_transforms DataK8SGatewaySoloIoGatewayV1Manifest#request_transforms}
  */
  readonly requestTransforms?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransforms[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_transforms DataK8SGatewaySoloIoGatewayV1Manifest#response_transforms}
  */
  readonly responseTransforms?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransforms[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRouting | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request_transforms: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsToTerraform, false)(struct!.requestTransforms),
    response_transforms: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsToTerraform, false)(struct!.responseTransforms),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRouting | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request_transforms: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsToHclTerraform, false)(struct!.requestTransforms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsList",
    },
    response_transforms: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsToHclTerraform, false)(struct!.responseTransforms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRouting | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestTransforms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTransforms = this._requestTransforms?.internalValue;
    }
    if (this._responseTransforms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTransforms = this._responseTransforms?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRouting | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestTransforms.internalValue = undefined;
      this._responseTransforms.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestTransforms.internalValue = value.requestTransforms;
      this._responseTransforms.internalValue = value.responseTransforms;
    }
  }

  // request_transforms - computed: false, optional: true, required: false
  private _requestTransforms = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransformsList(this, "request_transforms", false);
  public get requestTransforms() {
    return this._requestTransforms;
  }
  public putRequestTransforms(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingRequestTransforms[] | cdktf.IResolvable) {
    this._requestTransforms.internalValue = value;
  }
  public resetRequestTransforms() {
    this._requestTransforms.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTransformsInput() {
    return this._requestTransforms.internalValue;
  }

  // response_transforms - computed: false, optional: true, required: false
  private _responseTransforms = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransformsList(this, "response_transforms", false);
  public get responseTransforms() {
    return this._responseTransforms;
  }
  public putResponseTransforms(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsPostRoutingResponseTransforms[] | cdktf.IResolvable) {
    this._responseTransforms.internalValue = value;
  }
  public resetResponseTransforms() {
    this._responseTransforms.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTransformsInput() {
    return this._responseTransforms.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#invert_match DataK8SGatewaySoloIoGatewayV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeadersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParametersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParametersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParametersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParametersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcher {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#case_sensitive DataK8SGatewaySoloIoGatewayV1Manifest#case_sensitive}
  */
  readonly caseSensitive?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#connect_matcher DataK8SGatewaySoloIoGatewayV1Manifest#connect_matcher}
  */
  readonly connectMatcher?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#exact DataK8SGatewaySoloIoGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#methods DataK8SGatewaySoloIoGatewayV1Manifest#methods}
  */
  readonly methods?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix DataK8SGatewaySoloIoGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#query_parameters DataK8SGatewaySoloIoGatewayV1Manifest#query_parameters}
  */
  readonly queryParameters?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParameters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    case_sensitive: cdktf.booleanToTerraform(struct!.caseSensitive),
    connect_matcher: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectMatcher),
    exact: cdktf.stringToTerraform(struct!.exact),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeadersToTerraform, false)(struct!.headers),
    methods: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.methods),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    query_parameters: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParametersToTerraform, false)(struct!.queryParameters),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    case_sensitive: {
      value: cdktf.booleanToHclTerraform(struct!.caseSensitive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connect_matcher: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectMatcher),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeadersList",
    },
    methods: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.methods),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query_parameters: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParametersToHclTerraform, false)(struct!.queryParameters),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParametersList",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcher | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caseSensitive !== undefined) {
      hasAnyValues = true;
      internalValueResult.caseSensitive = this._caseSensitive;
    }
    if (this._connectMatcher !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectMatcher = this._connectMatcher;
    }
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._methods !== undefined) {
      hasAnyValues = true;
      internalValueResult.methods = this._methods;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._queryParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParameters = this._queryParameters?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcher | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caseSensitive = undefined;
      this._connectMatcher = undefined;
      this._exact = undefined;
      this._headers.internalValue = undefined;
      this._methods = undefined;
      this._prefix = undefined;
      this._queryParameters.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caseSensitive = value.caseSensitive;
      this._connectMatcher = value.connectMatcher;
      this._exact = value.exact;
      this._headers.internalValue = value.headers;
      this._methods = value.methods;
      this._prefix = value.prefix;
      this._queryParameters.internalValue = value.queryParameters;
      this._regex = value.regex;
    }
  }

  // case_sensitive - computed: false, optional: true, required: false
  private _caseSensitive?: boolean | cdktf.IResolvable; 
  public get caseSensitive() {
    return this.getBooleanAttribute('case_sensitive');
  }
  public set caseSensitive(value: boolean | cdktf.IResolvable) {
    this._caseSensitive = value;
  }
  public resetCaseSensitive() {
    this._caseSensitive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caseSensitiveInput() {
    return this._caseSensitive;
  }

  // connect_matcher - computed: false, optional: true, required: false
  private _connectMatcher?: { [key: string]: string }; 
  public get connectMatcher() {
    return this.getStringMapAttribute('connect_matcher');
  }
  public set connectMatcher(value: { [key: string]: string }) {
    this._connectMatcher = value;
  }
  public resetConnectMatcher() {
    this._connectMatcher = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectMatcherInput() {
    return this._connectMatcher;
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // methods - computed: false, optional: true, required: false
  private _methods?: string[]; 
  public get methods() {
    return this.getListAttribute('methods');
  }
  public set methods(value: string[]) {
    this._methods = value;
  }
  public resetMethods() {
    this._methods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodsInput() {
    return this._methods;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // query_parameters - computed: false, optional: true, required: false
  private _queryParameters = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParametersList(this, "query_parameters", false);
  public get queryParameters() {
    return this._queryParameters;
  }
  public putQueryParameters(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherQueryParameters[] | cdktf.IResolvable) {
    this._queryParameters.internalValue = value;
  }
  public resetQueryParameters() {
    this._queryParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParametersInput() {
    return this._queryParameters.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransform {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#add_request_metadata DataK8SGatewaySoloIoGatewayV1Manifest#add_request_metadata}
  */
  readonly addRequestMetadata?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransformToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_request_metadata: cdktf.booleanToTerraform(struct!.addRequestMetadata),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransformToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_request_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.addRequestMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransformOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRequestMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRequestMetadata = this._addRequestMetadata;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransform | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRequestMetadata = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRequestMetadata = value.addRequestMetadata;
    }
  }

  // add_request_metadata - computed: false, optional: true, required: false
  private _addRequestMetadata?: boolean | cdktf.IResolvable; 
  public get addRequestMetadata() {
    return this.getBooleanAttribute('add_request_metadata');
  }
  public set addRequestMetadata(value: boolean | cdktf.IResolvable) {
    this._addRequestMetadata = value;
  }
  public resetAddRequestMetadata() {
    this._addRequestMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRequestMetadataInput() {
    return this._addRequestMetadata;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_to_proto DataK8SGatewaySoloIoGatewayV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#metadata_namespace DataK8SGatewaySoloIoGatewayV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mode DataK8SGatewaySoloIoGatewayV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#replacement_text DataK8SGatewaySoloIoGatewayV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractorsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractorsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#override_empty DataK8SGatewaySoloIoGatewayV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tmpl DataK8SGatewaySoloIoGatewayV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_keys DataK8SGatewaySoloIoGatewayV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#advanced_templates DataK8SGatewaySoloIoGatewayV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_metadata_values DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#escape_characters DataK8SGatewaySoloIoGatewayV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extractors DataK8SGatewaySoloIoGatewayV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_append DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_error_on_parse DataK8SGatewaySoloIoGatewayV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_extractors_to_body DataK8SGatewaySoloIoGatewayV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_json_keys DataK8SGatewaySoloIoGatewayV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parse_body_behavior DataK8SGatewaySoloIoGatewayV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#passthrough DataK8SGatewaySoloIoGatewayV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractors",
    },
    headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#non_xml_transform DataK8SGatewaySoloIoGatewayV1Manifest#non_xml_transform}
  */
  readonly nonXmlTransform?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#set_content_type DataK8SGatewaySoloIoGatewayV1Manifest#set_content_type}
  */
  readonly setContentType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt DataK8SGatewaySoloIoGatewayV1Manifest#xslt}
  */
  readonly xslt?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    non_xml_transform: cdktf.booleanToTerraform(struct!.nonXmlTransform),
    set_content_type: cdktf.stringToTerraform(struct!.setContentType),
    xslt: cdktf.stringToTerraform(struct!.xslt),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    non_xml_transform: {
      value: cdktf.booleanToHclTerraform(struct!.nonXmlTransform),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    set_content_type: {
      value: cdktf.stringToHclTerraform(struct!.setContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xslt: {
      value: cdktf.stringToHclTerraform(struct!.xslt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nonXmlTransform !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonXmlTransform = this._nonXmlTransform;
    }
    if (this._setContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.setContentType = this._setContentType;
    }
    if (this._xslt !== undefined) {
      hasAnyValues = true;
      internalValueResult.xslt = this._xslt;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nonXmlTransform = undefined;
      this._setContentType = undefined;
      this._xslt = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nonXmlTransform = value.nonXmlTransform;
      this._setContentType = value.setContentType;
      this._xslt = value.xslt;
    }
  }

  // non_xml_transform - computed: false, optional: true, required: false
  private _nonXmlTransform?: boolean | cdktf.IResolvable; 
  public get nonXmlTransform() {
    return this.getBooleanAttribute('non_xml_transform');
  }
  public set nonXmlTransform(value: boolean | cdktf.IResolvable) {
    this._nonXmlTransform = value;
  }
  public resetNonXmlTransform() {
    this._nonXmlTransform = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonXmlTransformInput() {
    return this._nonXmlTransform;
  }

  // set_content_type - computed: false, optional: true, required: false
  private _setContentType?: string; 
  public get setContentType() {
    return this.getStringAttribute('set_content_type');
  }
  public set setContentType(value: string) {
    this._setContentType = value;
  }
  public resetSetContentType() {
    this._setContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setContentTypeInput() {
    return this._setContentType;
  }

  // xslt - computed: false, optional: true, required: false
  private _xslt?: string; 
  public get xslt() {
    return this.getStringAttribute('xslt');
  }
  public set xslt(value: string) {
    this._xslt = value;
  }
  public resetXslt() {
    this._xslt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltInput() {
    return this._xslt;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_body_transform DataK8SGatewaySoloIoGatewayV1Manifest#header_body_transform}
  */
  readonly headerBodyTransform?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransform;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#log_request_response_info DataK8SGatewaySoloIoGatewayV1Manifest#log_request_response_info}
  */
  readonly logRequestResponseInfo?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transformation_template DataK8SGatewaySoloIoGatewayV1Manifest#transformation_template}
  */
  readonly transformationTemplate?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt_transformation DataK8SGatewaySoloIoGatewayV1Manifest#xslt_transformation}
  */
  readonly xsltTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header_body_transform: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransformToTerraform(struct!.headerBodyTransform),
    log_request_response_info: cdktf.booleanToTerraform(struct!.logRequestResponseInfo),
    transformation_template: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateToTerraform(struct!.transformationTemplate),
    xslt_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformationToTerraform(struct!.xsltTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header_body_transform: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransformToHclTerraform(struct!.headerBodyTransform),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransform",
    },
    log_request_response_info: {
      value: cdktf.booleanToHclTerraform(struct!.logRequestResponseInfo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    transformation_template: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateToHclTerraform(struct!.transformationTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplate",
    },
    xslt_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformationToHclTerraform(struct!.xsltTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headerBodyTransform?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerBodyTransform = this._headerBodyTransform?.internalValue;
    }
    if (this._logRequestResponseInfo !== undefined) {
      hasAnyValues = true;
      internalValueResult.logRequestResponseInfo = this._logRequestResponseInfo;
    }
    if (this._transformationTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformationTemplate = this._transformationTemplate?.internalValue;
    }
    if (this._xsltTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xsltTransformation = this._xsltTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = undefined;
      this._logRequestResponseInfo = undefined;
      this._transformationTemplate.internalValue = undefined;
      this._xsltTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = value.headerBodyTransform;
      this._logRequestResponseInfo = value.logRequestResponseInfo;
      this._transformationTemplate.internalValue = value.transformationTemplate;
      this._xsltTransformation.internalValue = value.xsltTransformation;
    }
  }

  // header_body_transform - computed: false, optional: true, required: false
  private _headerBodyTransform = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransformOutputReference(this, "header_body_transform");
  public get headerBodyTransform() {
    return this._headerBodyTransform;
  }
  public putHeaderBodyTransform(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationHeaderBodyTransform) {
    this._headerBodyTransform.internalValue = value;
  }
  public resetHeaderBodyTransform() {
    this._headerBodyTransform.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerBodyTransformInput() {
    return this._headerBodyTransform.internalValue;
  }

  // log_request_response_info - computed: false, optional: true, required: false
  private _logRequestResponseInfo?: boolean | cdktf.IResolvable; 
  public get logRequestResponseInfo() {
    return this.getBooleanAttribute('log_request_response_info');
  }
  public set logRequestResponseInfo(value: boolean | cdktf.IResolvable) {
    this._logRequestResponseInfo = value;
  }
  public resetLogRequestResponseInfo() {
    this._logRequestResponseInfo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logRequestResponseInfoInput() {
    return this._logRequestResponseInfo;
  }

  // transformation_template - computed: false, optional: true, required: false
  private _transformationTemplate = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplateOutputReference(this, "transformation_template");
  public get transformationTemplate() {
    return this._transformationTemplate;
  }
  public putTransformationTemplate(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationTransformationTemplate) {
    this._transformationTemplate.internalValue = value;
  }
  public resetTransformationTemplate() {
    this._transformationTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationTemplateInput() {
    return this._transformationTemplate.internalValue;
  }

  // xslt_transformation - computed: false, optional: true, required: false
  private _xsltTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformationOutputReference(this, "xslt_transformation");
  public get xsltTransformation() {
    return this._xsltTransformation;
  }
  public putXsltTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationXsltTransformation) {
    this._xsltTransformation.internalValue = value;
  }
  public resetXsltTransformation() {
    this._xsltTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltTransformationInput() {
    return this._xsltTransformation.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransform {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#add_request_metadata DataK8SGatewaySoloIoGatewayV1Manifest#add_request_metadata}
  */
  readonly addRequestMetadata?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransformToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_request_metadata: cdktf.booleanToTerraform(struct!.addRequestMetadata),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_request_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.addRequestMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransformOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRequestMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRequestMetadata = this._addRequestMetadata;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRequestMetadata = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRequestMetadata = value.addRequestMetadata;
    }
  }

  // add_request_metadata - computed: false, optional: true, required: false
  private _addRequestMetadata?: boolean | cdktf.IResolvable; 
  public get addRequestMetadata() {
    return this.getBooleanAttribute('add_request_metadata');
  }
  public set addRequestMetadata(value: boolean | cdktf.IResolvable) {
    this._addRequestMetadata = value;
  }
  public resetAddRequestMetadata() {
    this._addRequestMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRequestMetadataInput() {
    return this._addRequestMetadata;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_to_proto DataK8SGatewaySoloIoGatewayV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#metadata_namespace DataK8SGatewaySoloIoGatewayV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mode DataK8SGatewaySoloIoGatewayV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#replacement_text DataK8SGatewaySoloIoGatewayV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractorsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractorsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#override_empty DataK8SGatewaySoloIoGatewayV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tmpl DataK8SGatewaySoloIoGatewayV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_keys DataK8SGatewaySoloIoGatewayV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#advanced_templates DataK8SGatewaySoloIoGatewayV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_metadata_values DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#escape_characters DataK8SGatewaySoloIoGatewayV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extractors DataK8SGatewaySoloIoGatewayV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_append DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_remove DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_error_on_parse DataK8SGatewaySoloIoGatewayV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_extractors_to_body DataK8SGatewaySoloIoGatewayV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_json_keys DataK8SGatewaySoloIoGatewayV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parse_body_behavior DataK8SGatewaySoloIoGatewayV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#passthrough DataK8SGatewaySoloIoGatewayV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractors",
    },
    headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#non_xml_transform DataK8SGatewaySoloIoGatewayV1Manifest#non_xml_transform}
  */
  readonly nonXmlTransform?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#set_content_type DataK8SGatewaySoloIoGatewayV1Manifest#set_content_type}
  */
  readonly setContentType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt DataK8SGatewaySoloIoGatewayV1Manifest#xslt}
  */
  readonly xslt?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    non_xml_transform: cdktf.booleanToTerraform(struct!.nonXmlTransform),
    set_content_type: cdktf.stringToTerraform(struct!.setContentType),
    xslt: cdktf.stringToTerraform(struct!.xslt),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    non_xml_transform: {
      value: cdktf.booleanToHclTerraform(struct!.nonXmlTransform),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    set_content_type: {
      value: cdktf.stringToHclTerraform(struct!.setContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xslt: {
      value: cdktf.stringToHclTerraform(struct!.xslt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nonXmlTransform !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonXmlTransform = this._nonXmlTransform;
    }
    if (this._setContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.setContentType = this._setContentType;
    }
    if (this._xslt !== undefined) {
      hasAnyValues = true;
      internalValueResult.xslt = this._xslt;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nonXmlTransform = undefined;
      this._setContentType = undefined;
      this._xslt = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nonXmlTransform = value.nonXmlTransform;
      this._setContentType = value.setContentType;
      this._xslt = value.xslt;
    }
  }

  // non_xml_transform - computed: false, optional: true, required: false
  private _nonXmlTransform?: boolean | cdktf.IResolvable; 
  public get nonXmlTransform() {
    return this.getBooleanAttribute('non_xml_transform');
  }
  public set nonXmlTransform(value: boolean | cdktf.IResolvable) {
    this._nonXmlTransform = value;
  }
  public resetNonXmlTransform() {
    this._nonXmlTransform = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonXmlTransformInput() {
    return this._nonXmlTransform;
  }

  // set_content_type - computed: false, optional: true, required: false
  private _setContentType?: string; 
  public get setContentType() {
    return this.getStringAttribute('set_content_type');
  }
  public set setContentType(value: string) {
    this._setContentType = value;
  }
  public resetSetContentType() {
    this._setContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setContentTypeInput() {
    return this._setContentType;
  }

  // xslt - computed: false, optional: true, required: false
  private _xslt?: string; 
  public get xslt() {
    return this.getStringAttribute('xslt');
  }
  public set xslt(value: string) {
    this._xslt = value;
  }
  public resetXslt() {
    this._xslt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltInput() {
    return this._xslt;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_body_transform DataK8SGatewaySoloIoGatewayV1Manifest#header_body_transform}
  */
  readonly headerBodyTransform?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransform;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#log_request_response_info DataK8SGatewaySoloIoGatewayV1Manifest#log_request_response_info}
  */
  readonly logRequestResponseInfo?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transformation_template DataK8SGatewaySoloIoGatewayV1Manifest#transformation_template}
  */
  readonly transformationTemplate?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xslt_transformation DataK8SGatewaySoloIoGatewayV1Manifest#xslt_transformation}
  */
  readonly xsltTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header_body_transform: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransformToTerraform(struct!.headerBodyTransform),
    log_request_response_info: cdktf.booleanToTerraform(struct!.logRequestResponseInfo),
    transformation_template: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateToTerraform(struct!.transformationTemplate),
    xslt_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformationToTerraform(struct!.xsltTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header_body_transform: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct!.headerBodyTransform),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransform",
    },
    log_request_response_info: {
      value: cdktf.booleanToHclTerraform(struct!.logRequestResponseInfo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    transformation_template: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateToHclTerraform(struct!.transformationTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplate",
    },
    xslt_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformationToHclTerraform(struct!.xsltTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headerBodyTransform?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerBodyTransform = this._headerBodyTransform?.internalValue;
    }
    if (this._logRequestResponseInfo !== undefined) {
      hasAnyValues = true;
      internalValueResult.logRequestResponseInfo = this._logRequestResponseInfo;
    }
    if (this._transformationTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformationTemplate = this._transformationTemplate?.internalValue;
    }
    if (this._xsltTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xsltTransformation = this._xsltTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = undefined;
      this._logRequestResponseInfo = undefined;
      this._transformationTemplate.internalValue = undefined;
      this._xsltTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headerBodyTransform.internalValue = value.headerBodyTransform;
      this._logRequestResponseInfo = value.logRequestResponseInfo;
      this._transformationTemplate.internalValue = value.transformationTemplate;
      this._xsltTransformation.internalValue = value.xsltTransformation;
    }
  }

  // header_body_transform - computed: false, optional: true, required: false
  private _headerBodyTransform = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransformOutputReference(this, "header_body_transform");
  public get headerBodyTransform() {
    return this._headerBodyTransform;
  }
  public putHeaderBodyTransform(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationHeaderBodyTransform) {
    this._headerBodyTransform.internalValue = value;
  }
  public resetHeaderBodyTransform() {
    this._headerBodyTransform.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerBodyTransformInput() {
    return this._headerBodyTransform.internalValue;
  }

  // log_request_response_info - computed: false, optional: true, required: false
  private _logRequestResponseInfo?: boolean | cdktf.IResolvable; 
  public get logRequestResponseInfo() {
    return this.getBooleanAttribute('log_request_response_info');
  }
  public set logRequestResponseInfo(value: boolean | cdktf.IResolvable) {
    this._logRequestResponseInfo = value;
  }
  public resetLogRequestResponseInfo() {
    this._logRequestResponseInfo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logRequestResponseInfoInput() {
    return this._logRequestResponseInfo;
  }

  // transformation_template - computed: false, optional: true, required: false
  private _transformationTemplate = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplateOutputReference(this, "transformation_template");
  public get transformationTemplate() {
    return this._transformationTemplate;
  }
  public putTransformationTemplate(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationTransformationTemplate) {
    this._transformationTemplate.internalValue = value;
  }
  public resetTransformationTemplate() {
    this._transformationTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationTemplateInput() {
    return this._transformationTemplate.internalValue;
  }

  // xslt_transformation - computed: false, optional: true, required: false
  private _xsltTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformationOutputReference(this, "xslt_transformation");
  public get xsltTransformation() {
    return this._xsltTransformation;
  }
  public putXsltTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationXsltTransformation) {
    this._xsltTransformation.internalValue = value;
  }
  public resetXsltTransformation() {
    this._xsltTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xsltTransformationInput() {
    return this._xsltTransformation.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransforms {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#clear_route_cache DataK8SGatewaySoloIoGatewayV1Manifest#clear_route_cache}
  */
  readonly clearRouteCache?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#matcher DataK8SGatewaySoloIoGatewayV1Manifest#matcher}
  */
  readonly matcher?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcher;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_transformation DataK8SGatewaySoloIoGatewayV1Manifest#request_transformation}
  */
  readonly requestTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_transformation DataK8SGatewaySoloIoGatewayV1Manifest#response_transformation}
  */
  readonly responseTransformation?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformation;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransforms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clear_route_cache: cdktf.booleanToTerraform(struct!.clearRouteCache),
    matcher: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherToTerraform(struct!.matcher),
    request_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationToTerraform(struct!.requestTransformation),
    response_transformation: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationToTerraform(struct!.responseTransformation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransforms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clear_route_cache: {
      value: cdktf.booleanToHclTerraform(struct!.clearRouteCache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    matcher: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherToHclTerraform(struct!.matcher),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcher",
    },
    request_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationToHclTerraform(struct!.requestTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformation",
    },
    response_transformation: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationToHclTerraform(struct!.responseTransformation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformation",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransforms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clearRouteCache !== undefined) {
      hasAnyValues = true;
      internalValueResult.clearRouteCache = this._clearRouteCache;
    }
    if (this._matcher?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matcher = this._matcher?.internalValue;
    }
    if (this._requestTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTransformation = this._requestTransformation?.internalValue;
    }
    if (this._responseTransformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTransformation = this._responseTransformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransforms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clearRouteCache = undefined;
      this._matcher.internalValue = undefined;
      this._requestTransformation.internalValue = undefined;
      this._responseTransformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clearRouteCache = value.clearRouteCache;
      this._matcher.internalValue = value.matcher;
      this._requestTransformation.internalValue = value.requestTransformation;
      this._responseTransformation.internalValue = value.responseTransformation;
    }
  }

  // clear_route_cache - computed: false, optional: true, required: false
  private _clearRouteCache?: boolean | cdktf.IResolvable; 
  public get clearRouteCache() {
    return this.getBooleanAttribute('clear_route_cache');
  }
  public set clearRouteCache(value: boolean | cdktf.IResolvable) {
    this._clearRouteCache = value;
  }
  public resetClearRouteCache() {
    this._clearRouteCache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clearRouteCacheInput() {
    return this._clearRouteCache;
  }

  // matcher - computed: false, optional: true, required: false
  private _matcher = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcherOutputReference(this, "matcher");
  public get matcher() {
    return this._matcher;
  }
  public putMatcher(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsMatcher) {
    this._matcher.internalValue = value;
  }
  public resetMatcher() {
    this._matcher.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matcherInput() {
    return this._matcher.internalValue;
  }

  // request_transformation - computed: false, optional: true, required: false
  private _requestTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformationOutputReference(this, "request_transformation");
  public get requestTransformation() {
    return this._requestTransformation;
  }
  public putRequestTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsRequestTransformation) {
    this._requestTransformation.internalValue = value;
  }
  public resetRequestTransformation() {
    this._requestTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTransformationInput() {
    return this._requestTransformation.internalValue;
  }

  // response_transformation - computed: false, optional: true, required: false
  private _responseTransformation = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformationOutputReference(this, "response_transformation");
  public get responseTransformation() {
    return this._responseTransformation;
  }
  public putResponseTransformation(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsResponseTransformation) {
    this._responseTransformation.internalValue = value;
  }
  public resetResponseTransformation() {
    this._responseTransformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTransformationInput() {
    return this._responseTransformation.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransforms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularRequestTransformsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchers {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#invert_match DataK8SGatewaySoloIoGatewayV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsMatchersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationHeaderBodyTransform {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#add_request_metadata DataK8SGatewaySoloIoGatewayV1Manifest#add_request_metadata}
  */
  readonly addRequestMetadata?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationHeaderBodyTransformToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_request_metadata: cdktf.booleanToTerraform(struct!.addRequestMetadata),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationHeaderBodyTransformToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_request_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.addRequestMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationHeaderBodyTransformOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRequestMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRequestMetadata = this._addRequestMetadata;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationHeaderBodyTransform | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRequestMetadata = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRequestMetadata = value.addRequestMetadata;
    }
  }

  // add_request_metadata - computed: false, optional: true, required: false
  private _addRequestMetadata?: boolean | cdktf.IResolvable; 
  public get addRequestMetadata() {
    return this.getBooleanAttribute('add_request_metadata');
  }
  public set addRequestMetadata(value: boolean | cdktf.IResolvable) {
    this._addRequestMetadata = value;
  }
  public resetAddRequestMetadata() {
    this._addRequestMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRequestMetadataInput() {
    return this._addRequestMetadata;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationTransformationTemplateBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationTransformationTemplateBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationTransformationTemplateBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationTransformationTemplateBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsOptionsStagedTransformationsRegularResponseTransformsResponseTransformationTransformationTemplateBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
