import * as cdktf from 'cdktf';
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#annotations DataK8SGatewaySoloIoRouteOptionV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#labels DataK8SGatewaySoloIoRouteOptionV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecNamespacedStatuses {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#statuses DataK8SGatewaySoloIoRouteOptionV1Manifest#statuses}
  */
  readonly statuses?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecNamespacedStatusesToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecNamespacedStatuses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    statuses: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.statuses),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecNamespacedStatusesToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecNamespacedStatuses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    statuses: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.statuses),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecNamespacedStatusesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecNamespacedStatuses | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._statuses !== undefined) {
      hasAnyValues = true;
      internalValueResult.statuses = this._statuses;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecNamespacedStatuses | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._statuses = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._statuses = value.statuses;
    }
  }

  // statuses - computed: false, optional: true, required: false
  private _statuses?: { [key: string]: string }; 
  public get statuses() {
    return this.getStringMapAttribute('statuses');
  }
  public set statuses(value: { [key: string]: string }) {
    this._statuses = value;
  }
  public resetStatuses() {
    this._statuses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusesInput() {
    return this._statuses;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaults {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#field DataK8SGatewaySoloIoRouteOptionV1Manifest#field}
  */
  readonly field?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#override DataK8SGatewaySoloIoRouteOptionV1Manifest#override}
  */
  readonly override?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#value DataK8SGatewaySoloIoRouteOptionV1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaultsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    override: cdktf.booleanToTerraform(struct!.override),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaultsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override: {
      value: cdktf.booleanToHclTerraform(struct!.override),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaultsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaults | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._override !== undefined) {
      hasAnyValues = true;
      internalValueResult.override = this._override;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaults | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._override = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._override = value.override;
      this._value = value.value;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  public resetField() {
    this._field = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // override - computed: false, optional: true, required: false
  private _override?: boolean | cdktf.IResolvable; 
  public get override() {
    return this.getBooleanAttribute('override');
  }
  public set override(value: boolean | cdktf.IResolvable) {
    this._override = value;
  }
  public resetOverride() {
    this._override = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideInput() {
    return this._override;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaultsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaults[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaultsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaultsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#content DataK8SGatewaySoloIoRouteOptionV1Manifest#content}
  */
  readonly content?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#role DataK8SGatewaySoloIoRouteOptionV1Manifest#role}
  */
  readonly role?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppendToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content: cdktf.stringToTerraform(struct!.content),
    role: cdktf.stringToTerraform(struct!.role),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppendToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content: {
      value: cdktf.stringToHclTerraform(struct!.content),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._content !== undefined) {
      hasAnyValues = true;
      internalValueResult.content = this._content;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._content = undefined;
      this._role = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._content = value.content;
      this._role = value.role;
    }
  }

  // content - computed: false, optional: true, required: false
  private _content?: string; 
  public get content() {
    return this.getStringAttribute('content');
  }
  public set content(value: string) {
    this._content = value;
  }
  public resetContent() {
    this._content = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentInput() {
    return this._content;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppendOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrepend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#content DataK8SGatewaySoloIoRouteOptionV1Manifest#content}
  */
  readonly content?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#role DataK8SGatewaySoloIoRouteOptionV1Manifest#role}
  */
  readonly role?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrependToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrepend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content: cdktf.stringToTerraform(struct!.content),
    role: cdktf.stringToTerraform(struct!.role),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrependToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrepend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content: {
      value: cdktf.stringToHclTerraform(struct!.content),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrependOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrepend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._content !== undefined) {
      hasAnyValues = true;
      internalValueResult.content = this._content;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrepend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._content = undefined;
      this._role = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._content = value.content;
      this._role = value.role;
    }
  }

  // content - computed: false, optional: true, required: false
  private _content?: string; 
  public get content() {
    return this.getStringAttribute('content');
  }
  public set content(value: string) {
    this._content = value;
  }
  public resetContent() {
    this._content = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentInput() {
    return this._content;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrependList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrepend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrependOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrependOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichment {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#append DataK8SGatewaySoloIoRouteOptionV1Manifest#append}
  */
  readonly append?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prepend DataK8SGatewaySoloIoRouteOptionV1Manifest#prepend}
  */
  readonly prepend?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrepend[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppendToTerraform, false)(struct!.append),
    prepend: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrependToTerraform, false)(struct!.prepend),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppendToHclTerraform, false)(struct!.append),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppendList",
    },
    prepend: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrependToHclTerraform, false)(struct!.prepend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrependList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append?.internalValue;
    }
    if (this._prepend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prepend = this._prepend?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append.internalValue = undefined;
      this._prepend.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append.internalValue = value.append;
      this._prepend.internalValue = value.prepend;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppendList(this, "append", false);
  public get append() {
    return this._append;
  }
  public putAppend(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentAppend[] | cdktf.IResolvable) {
    this._append.internalValue = value;
  }
  public resetAppend() {
    this._append.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append.internalValue;
  }

  // prepend - computed: false, optional: true, required: false
  private _prepend = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrependList(this, "prepend", false);
  public get prepend() {
    return this._prepend;
  }
  public putPrepend(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentPrepend[] | cdktf.IResolvable) {
    this._prepend.internalValue = value;
  }
  public resetPrepend() {
    this._prepend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prependInput() {
    return this._prepend.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponse {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#message DataK8SGatewaySoloIoRouteOptionV1Manifest#message}
  */
  readonly message?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#status_code DataK8SGatewaySoloIoRouteOptionV1Manifest#status_code}
  */
  readonly statusCode?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponseToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    message: cdktf.stringToTerraform(struct!.message),
    status_code: cdktf.numberToTerraform(struct!.statusCode),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponseToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    status_code: {
      value: cdktf.numberToHclTerraform(struct!.statusCode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._statusCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.statusCode = this._statusCode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._message = undefined;
      this._statusCode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._message = value.message;
      this._statusCode = value.statusCode;
    }
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // status_code - computed: false, optional: true, required: false
  private _statusCode?: number; 
  public get statusCode() {
    return this.getNumberAttribute('status_code');
  }
  public set statusCode(value: number) {
    this._statusCode = value;
  }
  public resetStatusCode() {
    this._statusCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusCodeInput() {
    return this._statusCode;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#builtins DataK8SGatewaySoloIoRouteOptionV1Manifest#builtins}
  */
  readonly builtins?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#matches DataK8SGatewaySoloIoRouteOptionV1Manifest#matches}
  */
  readonly matches?: string[];
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegexToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    builtins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.builtins),
    matches: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matches),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegexToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    builtins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.builtins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matches),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._builtins !== undefined) {
      hasAnyValues = true;
      internalValueResult.builtins = this._builtins;
    }
    if (this._matches !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._builtins = undefined;
      this._matches = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._builtins = value.builtins;
      this._matches = value.matches;
    }
  }

  // builtins - computed: false, optional: true, required: false
  private _builtins?: string[]; 
  public get builtins() {
    return this.getListAttribute('builtins');
  }
  public set builtins(value: string[]) {
    this._builtins = value;
  }
  public resetBuiltins() {
    this._builtins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get builtinsInput() {
    return this._builtins;
  }

  // matches - computed: false, optional: true, required: false
  private _matches?: string[]; 
  public get matches() {
    return this.getListAttribute('matches');
  }
  public set matches(value: string[]) {
    this._matches = value;
  }
  public resetMatches() {
    this._matches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#match_type DataK8SGatewaySoloIoRouteOptionV1Manifest#match_type}
  */
  readonly matchType?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    match_type: cdktf.stringToTerraform(struct!.matchType),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match_type: {
      value: cdktf.stringToHclTerraform(struct!.matchType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._matchType !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchType = this._matchType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._matchType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._matchType = value.matchType;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // match_type - computed: false, optional: true, required: false
  private _matchType?: string; 
  public get matchType() {
    return this.getStringAttribute('match_type');
  }
  public set matchType(value: string) {
    this._matchType = value;
  }
  public resetMatchType() {
    this._matchType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchTypeInput() {
    return this._matchType;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhook {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#headers DataK8SGatewaySoloIoRouteOptionV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#host DataK8SGatewaySoloIoRouteOptionV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#port DataK8SGatewaySoloIoRouteOptionV1Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeadersToTerraform, false)(struct!.headers),
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeadersList",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhook | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhook | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequest {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#custom_response DataK8SGatewaySoloIoRouteOptionV1Manifest#custom_response}
  */
  readonly customResponse?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponse;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex DataK8SGatewaySoloIoRouteOptionV1Manifest#regex}
  */
  readonly regex?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#webhook DataK8SGatewaySoloIoRouteOptionV1Manifest#webhook}
  */
  readonly webhook?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhook;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_response: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponseToTerraform(struct!.customResponse),
    regex: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegexToTerraform(struct!.regex),
    webhook: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookToTerraform(struct!.webhook),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_response: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponseToHclTerraform(struct!.customResponse),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponse",
    },
    regex: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegexToHclTerraform(struct!.regex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegex",
    },
    webhook: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookToHclTerraform(struct!.webhook),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhook",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customResponse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customResponse = this._customResponse?.internalValue;
    }
    if (this._regex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex?.internalValue;
    }
    if (this._webhook?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.webhook = this._webhook?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customResponse.internalValue = undefined;
      this._regex.internalValue = undefined;
      this._webhook.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customResponse.internalValue = value.customResponse;
      this._regex.internalValue = value.regex;
      this._webhook.internalValue = value.webhook;
    }
  }

  // custom_response - computed: false, optional: true, required: false
  private _customResponse = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponseOutputReference(this, "custom_response");
  public get customResponse() {
    return this._customResponse;
  }
  public putCustomResponse(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestCustomResponse) {
    this._customResponse.internalValue = value;
  }
  public resetCustomResponse() {
    this._customResponse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customResponseInput() {
    return this._customResponse.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegexOutputReference(this, "regex");
  public get regex() {
    return this._regex;
  }
  public putRegex(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestRegex) {
    this._regex.internalValue = value;
  }
  public resetRegex() {
    this._regex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex.internalValue;
  }

  // webhook - computed: false, optional: true, required: false
  private _webhook = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhookOutputReference(this, "webhook");
  public get webhook() {
    return this._webhook;
  }
  public putWebhook(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestWebhook) {
    this._webhook.internalValue = value;
  }
  public resetWebhook() {
    this._webhook.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webhookInput() {
    return this._webhook.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#builtins DataK8SGatewaySoloIoRouteOptionV1Manifest#builtins}
  */
  readonly builtins?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#matches DataK8SGatewaySoloIoRouteOptionV1Manifest#matches}
  */
  readonly matches?: string[];
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegexToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    builtins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.builtins),
    matches: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matches),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegexToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    builtins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.builtins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matches),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._builtins !== undefined) {
      hasAnyValues = true;
      internalValueResult.builtins = this._builtins;
    }
    if (this._matches !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._builtins = undefined;
      this._matches = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._builtins = value.builtins;
      this._matches = value.matches;
    }
  }

  // builtins - computed: false, optional: true, required: false
  private _builtins?: string[]; 
  public get builtins() {
    return this.getListAttribute('builtins');
  }
  public set builtins(value: string[]) {
    this._builtins = value;
  }
  public resetBuiltins() {
    this._builtins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get builtinsInput() {
    return this._builtins;
  }

  // matches - computed: false, optional: true, required: false
  private _matches?: string[]; 
  public get matches() {
    return this.getListAttribute('matches');
  }
  public set matches(value: string[]) {
    this._matches = value;
  }
  public resetMatches() {
    this._matches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#match_type DataK8SGatewaySoloIoRouteOptionV1Manifest#match_type}
  */
  readonly matchType?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    match_type: cdktf.stringToTerraform(struct!.matchType),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match_type: {
      value: cdktf.stringToHclTerraform(struct!.matchType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._matchType !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchType = this._matchType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._matchType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._matchType = value.matchType;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // match_type - computed: false, optional: true, required: false
  private _matchType?: string; 
  public get matchType() {
    return this.getStringAttribute('match_type');
  }
  public set matchType(value: string) {
    this._matchType = value;
  }
  public resetMatchType() {
    this._matchType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchTypeInput() {
    return this._matchType;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhook {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#headers DataK8SGatewaySoloIoRouteOptionV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#host DataK8SGatewaySoloIoRouteOptionV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#port DataK8SGatewaySoloIoRouteOptionV1Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeadersToTerraform, false)(struct!.headers),
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeadersList",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhook | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhook | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponse {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex DataK8SGatewaySoloIoRouteOptionV1Manifest#regex}
  */
  readonly regex?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#webhook DataK8SGatewaySoloIoRouteOptionV1Manifest#webhook}
  */
  readonly webhook?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhook;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegexToTerraform(struct!.regex),
    webhook: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookToTerraform(struct!.webhook),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegexToHclTerraform(struct!.regex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegex",
    },
    webhook: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookToHclTerraform(struct!.webhook),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhook",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex?.internalValue;
    }
    if (this._webhook?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.webhook = this._webhook?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex.internalValue = undefined;
      this._webhook.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex.internalValue = value.regex;
      this._webhook.internalValue = value.webhook;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegexOutputReference(this, "regex");
  public get regex() {
    return this._regex;
  }
  public putRegex(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseRegex) {
    this._regex.internalValue = value;
  }
  public resetRegex() {
    this._regex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex.internalValue;
  }

  // webhook - computed: false, optional: true, required: false
  private _webhook = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhookOutputReference(this, "webhook");
  public get webhook() {
    return this._webhook;
  }
  public putWebhook(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseWebhook) {
    this._webhook.internalValue = value;
  }
  public resetWebhook() {
    this._webhook.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webhookInput() {
    return this._webhook.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuard {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request DataK8SGatewaySoloIoRouteOptionV1Manifest#request}
  */
  readonly request?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequest;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#response DataK8SGatewaySoloIoRouteOptionV1Manifest#response}
  */
  readonly response?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponse;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestToTerraform(struct!.request),
    response: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseToTerraform(struct!.response),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequest",
    },
    response: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseToHclTerraform(struct!.response),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    if (this._response?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.response = this._response?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._request.internalValue = undefined;
      this._response.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._request.internalValue = value.request;
      this._response.internalValue = value.response;
    }
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }

  // response - computed: false, optional: true, required: false
  private _response = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponseOutputReference(this, "response");
  public get response() {
    return this._response;
  }
  public putResponse(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardResponse) {
    this._response.internalValue = value;
  }
  public resetResponse() {
    this._response.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseInput() {
    return this._response.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgres {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#collection_name DataK8SGatewaySoloIoRouteOptionV1Manifest#collection_name}
  */
  readonly collectionName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#connection_string DataK8SGatewaySoloIoRouteOptionV1Manifest#connection_string}
  */
  readonly connectionString?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgresToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgres | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collection_name: cdktf.stringToTerraform(struct!.collectionName),
    connection_string: cdktf.stringToTerraform(struct!.connectionString),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgresToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgres | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collection_name: {
      value: cdktf.stringToHclTerraform(struct!.collectionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_string: {
      value: cdktf.stringToHclTerraform(struct!.connectionString),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgresOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgres | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectionName = this._collectionName;
    }
    if (this._connectionString !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionString = this._connectionString;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgres | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectionName = undefined;
      this._connectionString = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectionName = value.collectionName;
      this._connectionString = value.connectionString;
    }
  }

  // collection_name - computed: false, optional: true, required: false
  private _collectionName?: string; 
  public get collectionName() {
    return this.getStringAttribute('collection_name');
  }
  public set collectionName(value: string) {
    this._collectionName = value;
  }
  public resetCollectionName() {
    this._collectionName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectionNameInput() {
    return this._collectionName;
  }

  // connection_string - computed: false, optional: true, required: false
  private _connectionString?: string; 
  public get connectionString() {
    return this.getStringAttribute('connection_string');
  }
  public set connectionString(value: string) {
    this._connectionString = value;
  }
  public resetConnectionString() {
    this._connectionString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionStringInput() {
    return this._connectionString;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastore {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#postgres DataK8SGatewaySoloIoRouteOptionV1Manifest#postgres}
  */
  readonly postgres?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgres;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastoreToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    postgres: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgresToTerraform(struct!.postgres),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastoreToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    postgres: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgresToHclTerraform(struct!.postgres),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgres",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._postgres?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgres = this._postgres?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._postgres.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._postgres.internalValue = value.postgres;
    }
  }

  // postgres - computed: false, optional: true, required: false
  private _postgres = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgresOutputReference(this, "postgres");
  public get postgres() {
    return this._postgres;
  }
  public putPostgres(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastorePostgres) {
    this._postgres.internalValue = value;
  }
  public resetPostgres() {
    this._postgres.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresInput() {
    return this._postgres.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#inline DataK8SGatewaySoloIoRouteOptionV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#secret_ref DataK8SGatewaySoloIoRouteOptionV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#api_version DataK8SGatewaySoloIoRouteOptionV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#auth_token DataK8SGatewaySoloIoRouteOptionV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#deployment_name DataK8SGatewaySoloIoRouteOptionV1Manifest#deployment_name}
  */
  readonly deploymentName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#endpoint DataK8SGatewaySoloIoRouteOptionV1Manifest#endpoint}
  */
  readonly endpoint?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    auth_token: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenToTerraform(struct!.authToken),
    deployment_name: cdktf.stringToTerraform(struct!.deploymentName),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_token: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthToken",
    },
    deployment_name: {
      value: cdktf.stringToHclTerraform(struct!.deploymentName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._deploymentName !== undefined) {
      hasAnyValues = true;
      internalValueResult.deploymentName = this._deploymentName;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._authToken.internalValue = undefined;
      this._deploymentName = undefined;
      this._endpoint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._authToken.internalValue = value.authToken;
      this._deploymentName = value.deploymentName;
      this._endpoint = value.endpoint;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // deployment_name - computed: false, optional: true, required: false
  private _deploymentName?: string; 
  public get deploymentName() {
    return this.getStringAttribute('deployment_name');
  }
  public set deploymentName(value: string) {
    this._deploymentName = value;
  }
  public resetDeploymentName() {
    this._deploymentName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentNameInput() {
    return this._deploymentName;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#inline DataK8SGatewaySoloIoRouteOptionV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#secret_ref DataK8SGatewaySoloIoRouteOptionV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#auth_token DataK8SGatewaySoloIoRouteOptionV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthToken;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenToTerraform(struct!.authToken),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken.internalValue = value.authToken;
    }
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbedding {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#azure_openai DataK8SGatewaySoloIoRouteOptionV1Manifest#azure_openai}
  */
  readonly azureOpenai?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenai;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#openai DataK8SGatewaySoloIoRouteOptionV1Manifest#openai}
  */
  readonly openai?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenai;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbedding | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    azure_openai: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiToTerraform(struct!.azureOpenai),
    openai: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiToTerraform(struct!.openai),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbedding | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    azure_openai: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiToHclTerraform(struct!.azureOpenai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenai",
    },
    openai: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiToHclTerraform(struct!.openai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenai",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbedding | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._azureOpenai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureOpenai = this._azureOpenai?.internalValue;
    }
    if (this._openai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openai = this._openai?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbedding | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._azureOpenai.internalValue = undefined;
      this._openai.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._azureOpenai.internalValue = value.azureOpenai;
      this._openai.internalValue = value.openai;
    }
  }

  // azure_openai - computed: false, optional: true, required: false
  private _azureOpenai = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenaiOutputReference(this, "azure_openai");
  public get azureOpenai() {
    return this._azureOpenai;
  }
  public putAzureOpenai(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingAzureOpenai) {
    this._azureOpenai.internalValue = value;
  }
  public resetAzureOpenai() {
    this._azureOpenai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureOpenaiInput() {
    return this._azureOpenai.internalValue;
  }

  // openai - computed: false, optional: true, required: false
  private _openai = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenaiOutputReference(this, "openai");
  public get openai() {
    return this._openai;
  }
  public putOpenai(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOpenai) {
    this._openai.internalValue = value;
  }
  public resetOpenai() {
    this._openai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openaiInput() {
    return this._openai.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRag {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#datastore DataK8SGatewaySoloIoRouteOptionV1Manifest#datastore}
  */
  readonly datastore?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastore;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#embedding DataK8SGatewaySoloIoRouteOptionV1Manifest#embedding}
  */
  readonly embedding?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbedding;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prompt_template DataK8SGatewaySoloIoRouteOptionV1Manifest#prompt_template}
  */
  readonly promptTemplate?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRag | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    datastore: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastoreToTerraform(struct!.datastore),
    embedding: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingToTerraform(struct!.embedding),
    prompt_template: cdktf.stringToTerraform(struct!.promptTemplate),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRag | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    datastore: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastoreToHclTerraform(struct!.datastore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastore",
    },
    embedding: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingToHclTerraform(struct!.embedding),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbedding",
    },
    prompt_template: {
      value: cdktf.stringToHclTerraform(struct!.promptTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRag | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._datastore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.datastore = this._datastore?.internalValue;
    }
    if (this._embedding?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.embedding = this._embedding?.internalValue;
    }
    if (this._promptTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.promptTemplate = this._promptTemplate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRag | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._datastore.internalValue = undefined;
      this._embedding.internalValue = undefined;
      this._promptTemplate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._datastore.internalValue = value.datastore;
      this._embedding.internalValue = value.embedding;
      this._promptTemplate = value.promptTemplate;
    }
  }

  // datastore - computed: false, optional: true, required: false
  private _datastore = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastoreOutputReference(this, "datastore");
  public get datastore() {
    return this._datastore;
  }
  public putDatastore(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagDatastore) {
    this._datastore.internalValue = value;
  }
  public resetDatastore() {
    this._datastore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datastoreInput() {
    return this._datastore.internalValue;
  }

  // embedding - computed: false, optional: true, required: false
  private _embedding = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbeddingOutputReference(this, "embedding");
  public get embedding() {
    return this._embedding;
  }
  public putEmbedding(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagEmbedding) {
    this._embedding.internalValue = value;
  }
  public resetEmbedding() {
    this._embedding.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get embeddingInput() {
    return this._embedding.internalValue;
  }

  // prompt_template - computed: false, optional: true, required: false
  private _promptTemplate?: string; 
  public get promptTemplate() {
    return this.getStringAttribute('prompt_template');
  }
  public set promptTemplate(value: string) {
    this._promptTemplate = value;
  }
  public resetPromptTemplate() {
    this._promptTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get promptTemplateInput() {
    return this._promptTemplate;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedis {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#connection_string DataK8SGatewaySoloIoRouteOptionV1Manifest#connection_string}
  */
  readonly connectionString?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#score_threshold DataK8SGatewaySoloIoRouteOptionV1Manifest#score_threshold}
  */
  readonly scoreThreshold?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedisToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_string: cdktf.stringToTerraform(struct!.connectionString),
    score_threshold: cdktf.numberToTerraform(struct!.scoreThreshold),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedisToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_string: {
      value: cdktf.stringToHclTerraform(struct!.connectionString),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    score_threshold: {
      value: cdktf.numberToHclTerraform(struct!.scoreThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedis | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionString !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionString = this._connectionString;
    }
    if (this._scoreThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.scoreThreshold = this._scoreThreshold;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedis | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionString = undefined;
      this._scoreThreshold = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionString = value.connectionString;
      this._scoreThreshold = value.scoreThreshold;
    }
  }

  // connection_string - computed: false, optional: true, required: false
  private _connectionString?: string; 
  public get connectionString() {
    return this.getStringAttribute('connection_string');
  }
  public set connectionString(value: string) {
    this._connectionString = value;
  }
  public resetConnectionString() {
    this._connectionString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionStringInput() {
    return this._connectionString;
  }

  // score_threshold - computed: false, optional: true, required: false
  private _scoreThreshold?: number; 
  public get scoreThreshold() {
    return this.getNumberAttribute('score_threshold');
  }
  public set scoreThreshold(value: number) {
    this._scoreThreshold = value;
  }
  public resetScoreThreshold() {
    this._scoreThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scoreThresholdInput() {
    return this._scoreThreshold;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#grpc_port DataK8SGatewaySoloIoRouteOptionV1Manifest#grpc_port}
  */
  readonly grpcPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#host DataK8SGatewaySoloIoRouteOptionV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#http_port DataK8SGatewaySoloIoRouteOptionV1Manifest#http_port}
  */
  readonly httpPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#insecure DataK8SGatewaySoloIoRouteOptionV1Manifest#insecure}
  */
  readonly insecure?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviateToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    grpc_port: cdktf.numberToTerraform(struct!.grpcPort),
    host: cdktf.stringToTerraform(struct!.host),
    http_port: cdktf.numberToTerraform(struct!.httpPort),
    insecure: cdktf.booleanToTerraform(struct!.insecure),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviateToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    grpc_port: {
      value: cdktf.numberToHclTerraform(struct!.grpcPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_port: {
      value: cdktf.numberToHclTerraform(struct!.httpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    insecure: {
      value: cdktf.booleanToHclTerraform(struct!.insecure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._grpcPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcPort = this._grpcPort;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPort = this._httpPort;
    }
    if (this._insecure !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecure = this._insecure;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._grpcPort = undefined;
      this._host = undefined;
      this._httpPort = undefined;
      this._insecure = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._grpcPort = value.grpcPort;
      this._host = value.host;
      this._httpPort = value.httpPort;
      this._insecure = value.insecure;
    }
  }

  // grpc_port - computed: false, optional: true, required: false
  private _grpcPort?: number; 
  public get grpcPort() {
    return this.getNumberAttribute('grpc_port');
  }
  public set grpcPort(value: number) {
    this._grpcPort = value;
  }
  public resetGrpcPort() {
    this._grpcPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcPortInput() {
    return this._grpcPort;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_port - computed: false, optional: true, required: false
  private _httpPort?: number; 
  public get httpPort() {
    return this.getNumberAttribute('http_port');
  }
  public set httpPort(value: number) {
    this._httpPort = value;
  }
  public resetHttpPort() {
    this._httpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPortInput() {
    return this._httpPort;
  }

  // insecure - computed: false, optional: true, required: false
  private _insecure?: boolean | cdktf.IResolvable; 
  public get insecure() {
    return this.getBooleanAttribute('insecure');
  }
  public set insecure(value: boolean | cdktf.IResolvable) {
    this._insecure = value;
  }
  public resetInsecure() {
    this._insecure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureInput() {
    return this._insecure;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastore {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#redis DataK8SGatewaySoloIoRouteOptionV1Manifest#redis}
  */
  readonly redis?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedis;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#weaviate DataK8SGatewaySoloIoRouteOptionV1Manifest#weaviate}
  */
  readonly weaviate?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviate;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    redis: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedisToTerraform(struct!.redis),
    weaviate: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviateToTerraform(struct!.weaviate),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    redis: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedisToHclTerraform(struct!.redis),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedis",
    },
    weaviate: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviateToHclTerraform(struct!.weaviate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._redis?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.redis = this._redis?.internalValue;
    }
    if (this._weaviate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.weaviate = this._weaviate?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._redis.internalValue = undefined;
      this._weaviate.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._redis.internalValue = value.redis;
      this._weaviate.internalValue = value.weaviate;
    }
  }

  // redis - computed: false, optional: true, required: false
  private _redis = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedisOutputReference(this, "redis");
  public get redis() {
    return this._redis;
  }
  public putRedis(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreRedis) {
    this._redis.internalValue = value;
  }
  public resetRedis() {
    this._redis.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redisInput() {
    return this._redis.internalValue;
  }

  // weaviate - computed: false, optional: true, required: false
  private _weaviate = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviateOutputReference(this, "weaviate");
  public get weaviate() {
    return this._weaviate;
  }
  public putWeaviate(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreWeaviate) {
    this._weaviate.internalValue = value;
  }
  public resetWeaviate() {
    this._weaviate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weaviateInput() {
    return this._weaviate.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#inline DataK8SGatewaySoloIoRouteOptionV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#secret_ref DataK8SGatewaySoloIoRouteOptionV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#api_version DataK8SGatewaySoloIoRouteOptionV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#auth_token DataK8SGatewaySoloIoRouteOptionV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#deployment_name DataK8SGatewaySoloIoRouteOptionV1Manifest#deployment_name}
  */
  readonly deploymentName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#endpoint DataK8SGatewaySoloIoRouteOptionV1Manifest#endpoint}
  */
  readonly endpoint?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    auth_token: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenToTerraform(struct!.authToken),
    deployment_name: cdktf.stringToTerraform(struct!.deploymentName),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_token: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken",
    },
    deployment_name: {
      value: cdktf.stringToHclTerraform(struct!.deploymentName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._deploymentName !== undefined) {
      hasAnyValues = true;
      internalValueResult.deploymentName = this._deploymentName;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._authToken.internalValue = undefined;
      this._deploymentName = undefined;
      this._endpoint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._authToken.internalValue = value.authToken;
      this._deploymentName = value.deploymentName;
      this._endpoint = value.endpoint;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // deployment_name - computed: false, optional: true, required: false
  private _deploymentName?: string; 
  public get deploymentName() {
    return this.getStringAttribute('deployment_name');
  }
  public set deploymentName(value: string) {
    this._deploymentName = value;
  }
  public resetDeploymentName() {
    this._deploymentName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentNameInput() {
    return this._deploymentName;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#inline DataK8SGatewaySoloIoRouteOptionV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#secret_ref DataK8SGatewaySoloIoRouteOptionV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#auth_token DataK8SGatewaySoloIoRouteOptionV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthToken;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenToTerraform(struct!.authToken),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken.internalValue = value.authToken;
    }
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbedding {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#azure_openai DataK8SGatewaySoloIoRouteOptionV1Manifest#azure_openai}
  */
  readonly azureOpenai?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenai;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#openai DataK8SGatewaySoloIoRouteOptionV1Manifest#openai}
  */
  readonly openai?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenai;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbedding | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    azure_openai: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiToTerraform(struct!.azureOpenai),
    openai: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiToTerraform(struct!.openai),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbedding | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    azure_openai: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiToHclTerraform(struct!.azureOpenai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenai",
    },
    openai: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiToHclTerraform(struct!.openai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenai",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbedding | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._azureOpenai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureOpenai = this._azureOpenai?.internalValue;
    }
    if (this._openai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openai = this._openai?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbedding | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._azureOpenai.internalValue = undefined;
      this._openai.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._azureOpenai.internalValue = value.azureOpenai;
      this._openai.internalValue = value.openai;
    }
  }

  // azure_openai - computed: false, optional: true, required: false
  private _azureOpenai = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenaiOutputReference(this, "azure_openai");
  public get azureOpenai() {
    return this._azureOpenai;
  }
  public putAzureOpenai(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingAzureOpenai) {
    this._azureOpenai.internalValue = value;
  }
  public resetAzureOpenai() {
    this._azureOpenai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureOpenaiInput() {
    return this._azureOpenai.internalValue;
  }

  // openai - computed: false, optional: true, required: false
  private _openai = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenaiOutputReference(this, "openai");
  public get openai() {
    return this._openai;
  }
  public putOpenai(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOpenai) {
    this._openai.internalValue = value;
  }
  public resetOpenai() {
    this._openai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openaiInput() {
    return this._openai.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCache {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#datastore DataK8SGatewaySoloIoRouteOptionV1Manifest#datastore}
  */
  readonly datastore?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastore;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#embedding DataK8SGatewaySoloIoRouteOptionV1Manifest#embedding}
  */
  readonly embedding?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbedding;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#mode DataK8SGatewaySoloIoRouteOptionV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#ttl DataK8SGatewaySoloIoRouteOptionV1Manifest#ttl}
  */
  readonly ttl?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    datastore: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreToTerraform(struct!.datastore),
    embedding: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingToTerraform(struct!.embedding),
    mode: cdktf.stringToTerraform(struct!.mode),
    ttl: cdktf.numberToTerraform(struct!.ttl),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    datastore: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreToHclTerraform(struct!.datastore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastore",
    },
    embedding: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingToHclTerraform(struct!.embedding),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbedding",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ttl: {
      value: cdktf.numberToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._datastore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.datastore = this._datastore?.internalValue;
    }
    if (this._embedding?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.embedding = this._embedding?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._datastore.internalValue = undefined;
      this._embedding.internalValue = undefined;
      this._mode = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._datastore.internalValue = value.datastore;
      this._embedding.internalValue = value.embedding;
      this._mode = value.mode;
      this._ttl = value.ttl;
    }
  }

  // datastore - computed: false, optional: true, required: false
  private _datastore = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastoreOutputReference(this, "datastore");
  public get datastore() {
    return this._datastore;
  }
  public putDatastore(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheDatastore) {
    this._datastore.internalValue = value;
  }
  public resetDatastore() {
    this._datastore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datastoreInput() {
    return this._datastore.internalValue;
  }

  // embedding - computed: false, optional: true, required: false
  private _embedding = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbeddingOutputReference(this, "embedding");
  public get embedding() {
    return this._embedding;
  }
  public putEmbedding(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheEmbedding) {
    this._embedding.internalValue = value;
  }
  public resetEmbedding() {
    this._embedding.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get embeddingInput() {
    return this._embedding.internalValue;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: number; 
  public get ttl() {
    return this.getNumberAttribute('ttl');
  }
  public set ttl(value: number) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAi {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#defaults DataK8SGatewaySoloIoRouteOptionV1Manifest#defaults}
  */
  readonly defaults?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaults[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prompt_enrichment DataK8SGatewaySoloIoRouteOptionV1Manifest#prompt_enrichment}
  */
  readonly promptEnrichment?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichment;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prompt_guard DataK8SGatewaySoloIoRouteOptionV1Manifest#prompt_guard}
  */
  readonly promptGuard?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuard;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#rag DataK8SGatewaySoloIoRouteOptionV1Manifest#rag}
  */
  readonly rag?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRag;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#route_type DataK8SGatewaySoloIoRouteOptionV1Manifest#route_type}
  */
  readonly routeType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#semantic_cache DataK8SGatewaySoloIoRouteOptionV1Manifest#semantic_cache}
  */
  readonly semanticCache?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCache;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    defaults: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaultsToTerraform, false)(struct!.defaults),
    prompt_enrichment: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentToTerraform(struct!.promptEnrichment),
    prompt_guard: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardToTerraform(struct!.promptGuard),
    rag: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagToTerraform(struct!.rag),
    route_type: cdktf.stringToTerraform(struct!.routeType),
    semantic_cache: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheToTerraform(struct!.semanticCache),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    defaults: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaultsToHclTerraform, false)(struct!.defaults),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaultsList",
    },
    prompt_enrichment: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentToHclTerraform(struct!.promptEnrichment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichment",
    },
    prompt_guard: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardToHclTerraform(struct!.promptGuard),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuard",
    },
    rag: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagToHclTerraform(struct!.rag),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRag",
    },
    route_type: {
      value: cdktf.stringToHclTerraform(struct!.routeType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    semantic_cache: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheToHclTerraform(struct!.semanticCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCache",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaults?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaults = this._defaults?.internalValue;
    }
    if (this._promptEnrichment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.promptEnrichment = this._promptEnrichment?.internalValue;
    }
    if (this._promptGuard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.promptGuard = this._promptGuard?.internalValue;
    }
    if (this._rag?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rag = this._rag?.internalValue;
    }
    if (this._routeType !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeType = this._routeType;
    }
    if (this._semanticCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.semanticCache = this._semanticCache?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaults.internalValue = undefined;
      this._promptEnrichment.internalValue = undefined;
      this._promptGuard.internalValue = undefined;
      this._rag.internalValue = undefined;
      this._routeType = undefined;
      this._semanticCache.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaults.internalValue = value.defaults;
      this._promptEnrichment.internalValue = value.promptEnrichment;
      this._promptGuard.internalValue = value.promptGuard;
      this._rag.internalValue = value.rag;
      this._routeType = value.routeType;
      this._semanticCache.internalValue = value.semanticCache;
    }
  }

  // defaults - computed: false, optional: true, required: false
  private _defaults = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaultsList(this, "defaults", false);
  public get defaults() {
    return this._defaults;
  }
  public putDefaults(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiDefaults[] | cdktf.IResolvable) {
    this._defaults.internalValue = value;
  }
  public resetDefaults() {
    this._defaults.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultsInput() {
    return this._defaults.internalValue;
  }

  // prompt_enrichment - computed: false, optional: true, required: false
  private _promptEnrichment = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichmentOutputReference(this, "prompt_enrichment");
  public get promptEnrichment() {
    return this._promptEnrichment;
  }
  public putPromptEnrichment(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptEnrichment) {
    this._promptEnrichment.internalValue = value;
  }
  public resetPromptEnrichment() {
    this._promptEnrichment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get promptEnrichmentInput() {
    return this._promptEnrichment.internalValue;
  }

  // prompt_guard - computed: false, optional: true, required: false
  private _promptGuard = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuardOutputReference(this, "prompt_guard");
  public get promptGuard() {
    return this._promptGuard;
  }
  public putPromptGuard(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiPromptGuard) {
    this._promptGuard.internalValue = value;
  }
  public resetPromptGuard() {
    this._promptGuard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get promptGuardInput() {
    return this._promptGuard.internalValue;
  }

  // rag - computed: false, optional: true, required: false
  private _rag = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRagOutputReference(this, "rag");
  public get rag() {
    return this._rag;
  }
  public putRag(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiRag) {
    this._rag.internalValue = value;
  }
  public resetRag() {
    this._rag.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ragInput() {
    return this._rag.internalValue;
  }

  // route_type - computed: false, optional: true, required: false
  private _routeType?: string; 
  public get routeType() {
    return this.getStringAttribute('route_type');
  }
  public set routeType(value: string) {
    this._routeType = value;
  }
  public resetRouteType() {
    this._routeType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTypeInput() {
    return this._routeType;
  }

  // semantic_cache - computed: false, optional: true, required: false
  private _semanticCache = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCacheOutputReference(this, "semantic_cache");
  public get semanticCache() {
    return this._semanticCache;
  }
  public putSemanticCache(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsAiSemanticCache) {
    this._semanticCache.internalValue = value;
  }
  public resetSemanticCache() {
    this._semanticCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get semanticCacheInput() {
    return this._semanticCache.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBuffer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#max_request_bytes DataK8SGatewaySoloIoRouteOptionV1Manifest#max_request_bytes}
  */
  readonly maxRequestBytes?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBufferToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBuffer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_request_bytes: cdktf.numberToTerraform(struct!.maxRequestBytes),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBufferToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBuffer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_request_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBufferOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBuffer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxRequestBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestBytes = this._maxRequestBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBuffer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxRequestBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxRequestBytes = value.maxRequestBytes;
    }
  }

  // max_request_bytes - computed: false, optional: true, required: false
  private _maxRequestBytes?: number; 
  public get maxRequestBytes() {
    return this.getNumberAttribute('max_request_bytes');
  }
  public set maxRequestBytes(value: number) {
    this._maxRequestBytes = value;
  }
  public resetMaxRequestBytes() {
    this._maxRequestBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestBytesInput() {
    return this._maxRequestBytes;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRoute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#buffer DataK8SGatewaySoloIoRouteOptionV1Manifest#buffer}
  */
  readonly buffer?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBuffer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#disabled DataK8SGatewaySoloIoRouteOptionV1Manifest#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBufferToTerraform(struct!.buffer),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBufferToHclTerraform(struct!.buffer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBuffer",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._buffer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.buffer = this._buffer?.internalValue;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._buffer.internalValue = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._buffer.internalValue = value.buffer;
      this._disabled = value.disabled;
    }
  }

  // buffer - computed: false, optional: true, required: false
  private _buffer = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBufferOutputReference(this, "buffer");
  public get buffer() {
    return this._buffer;
  }
  public putBuffer(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsBufferPerRouteBuffer) {
    this._buffer.internalValue = value;
  }
  public resetBuffer() {
    this._buffer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferInput() {
    return this._buffer.internalValue;
  }

  // disabled - computed: false, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#allow_credentials DataK8SGatewaySoloIoRouteOptionV1Manifest#allow_credentials}
  */
  readonly allowCredentials?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#allow_headers DataK8SGatewaySoloIoRouteOptionV1Manifest#allow_headers}
  */
  readonly allowHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#allow_methods DataK8SGatewaySoloIoRouteOptionV1Manifest#allow_methods}
  */
  readonly allowMethods?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#allow_origin DataK8SGatewaySoloIoRouteOptionV1Manifest#allow_origin}
  */
  readonly allowOrigin?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#allow_origin_regex DataK8SGatewaySoloIoRouteOptionV1Manifest#allow_origin_regex}
  */
  readonly allowOriginRegex?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#disable_for_route DataK8SGatewaySoloIoRouteOptionV1Manifest#disable_for_route}
  */
  readonly disableForRoute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#expose_headers DataK8SGatewaySoloIoRouteOptionV1Manifest#expose_headers}
  */
  readonly exposeHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#max_age DataK8SGatewaySoloIoRouteOptionV1Manifest#max_age}
  */
  readonly maxAge?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCorsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_credentials: cdktf.booleanToTerraform(struct!.allowCredentials),
    allow_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowHeaders),
    allow_methods: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowMethods),
    allow_origin: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowOrigin),
    allow_origin_regex: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowOriginRegex),
    disable_for_route: cdktf.booleanToTerraform(struct!.disableForRoute),
    expose_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.exposeHeaders),
    max_age: cdktf.stringToTerraform(struct!.maxAge),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCorsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_credentials: {
      value: cdktf.booleanToHclTerraform(struct!.allowCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allow_methods: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowMethods),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allow_origin: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowOrigin),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allow_origin_regex: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowOriginRegex),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disable_for_route: {
      value: cdktf.booleanToHclTerraform(struct!.disableForRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    expose_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.exposeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_age: {
      value: cdktf.stringToHclTerraform(struct!.maxAge),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowCredentials = this._allowCredentials;
    }
    if (this._allowHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowHeaders = this._allowHeaders;
    }
    if (this._allowMethods !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowMethods = this._allowMethods;
    }
    if (this._allowOrigin !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowOrigin = this._allowOrigin;
    }
    if (this._allowOriginRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowOriginRegex = this._allowOriginRegex;
    }
    if (this._disableForRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableForRoute = this._disableForRoute;
    }
    if (this._exposeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposeHeaders = this._exposeHeaders;
    }
    if (this._maxAge !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxAge = this._maxAge;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowCredentials = undefined;
      this._allowHeaders = undefined;
      this._allowMethods = undefined;
      this._allowOrigin = undefined;
      this._allowOriginRegex = undefined;
      this._disableForRoute = undefined;
      this._exposeHeaders = undefined;
      this._maxAge = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowCredentials = value.allowCredentials;
      this._allowHeaders = value.allowHeaders;
      this._allowMethods = value.allowMethods;
      this._allowOrigin = value.allowOrigin;
      this._allowOriginRegex = value.allowOriginRegex;
      this._disableForRoute = value.disableForRoute;
      this._exposeHeaders = value.exposeHeaders;
      this._maxAge = value.maxAge;
    }
  }

  // allow_credentials - computed: false, optional: true, required: false
  private _allowCredentials?: boolean | cdktf.IResolvable; 
  public get allowCredentials() {
    return this.getBooleanAttribute('allow_credentials');
  }
  public set allowCredentials(value: boolean | cdktf.IResolvable) {
    this._allowCredentials = value;
  }
  public resetAllowCredentials() {
    this._allowCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowCredentialsInput() {
    return this._allowCredentials;
  }

  // allow_headers - computed: false, optional: true, required: false
  private _allowHeaders?: string[]; 
  public get allowHeaders() {
    return this.getListAttribute('allow_headers');
  }
  public set allowHeaders(value: string[]) {
    this._allowHeaders = value;
  }
  public resetAllowHeaders() {
    this._allowHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowHeadersInput() {
    return this._allowHeaders;
  }

  // allow_methods - computed: false, optional: true, required: false
  private _allowMethods?: string[]; 
  public get allowMethods() {
    return this.getListAttribute('allow_methods');
  }
  public set allowMethods(value: string[]) {
    this._allowMethods = value;
  }
  public resetAllowMethods() {
    this._allowMethods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowMethodsInput() {
    return this._allowMethods;
  }

  // allow_origin - computed: false, optional: true, required: false
  private _allowOrigin?: string[]; 
  public get allowOrigin() {
    return this.getListAttribute('allow_origin');
  }
  public set allowOrigin(value: string[]) {
    this._allowOrigin = value;
  }
  public resetAllowOrigin() {
    this._allowOrigin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowOriginInput() {
    return this._allowOrigin;
  }

  // allow_origin_regex - computed: false, optional: true, required: false
  private _allowOriginRegex?: string[]; 
  public get allowOriginRegex() {
    return this.getListAttribute('allow_origin_regex');
  }
  public set allowOriginRegex(value: string[]) {
    this._allowOriginRegex = value;
  }
  public resetAllowOriginRegex() {
    this._allowOriginRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowOriginRegexInput() {
    return this._allowOriginRegex;
  }

  // disable_for_route - computed: false, optional: true, required: false
  private _disableForRoute?: boolean | cdktf.IResolvable; 
  public get disableForRoute() {
    return this.getBooleanAttribute('disable_for_route');
  }
  public set disableForRoute(value: boolean | cdktf.IResolvable) {
    this._disableForRoute = value;
  }
  public resetDisableForRoute() {
    this._disableForRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableForRouteInput() {
    return this._disableForRoute;
  }

  // expose_headers - computed: false, optional: true, required: false
  private _exposeHeaders?: string[]; 
  public get exposeHeaders() {
    return this.getListAttribute('expose_headers');
  }
  public set exposeHeaders(value: string[]) {
    this._exposeHeaders = value;
  }
  public resetExposeHeaders() {
    this._exposeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposeHeadersInput() {
    return this._exposeHeaders;
  }

  // max_age - computed: false, optional: true, required: false
  private _maxAge?: string; 
  public get maxAge() {
    return this.getStringAttribute('max_age');
  }
  public set maxAge(value: string) {
    this._maxAge = value;
  }
  public resetMaxAge() {
    this._maxAge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxAgeInput() {
    return this._maxAge;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#max_program_size DataK8SGatewaySoloIoRouteOptionV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#google_re2 DataK8SGatewaySoloIoRouteOptionV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex DataK8SGatewaySoloIoRouteOptionV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOrigins {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#exact DataK8SGatewaySoloIoRouteOptionV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#ignore_case DataK8SGatewaySoloIoRouteOptionV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prefix DataK8SGatewaySoloIoRouteOptionV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#safe_regex DataK8SGatewaySoloIoRouteOptionV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#suffix DataK8SGatewaySoloIoRouteOptionV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOrigins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOrigins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOrigins | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOrigins | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#denominator DataK8SGatewaySoloIoRouteOptionV1Manifest#denominator}
  */
  readonly denominator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#numerator DataK8SGatewaySoloIoRouteOptionV1Manifest#numerator}
  */
  readonly numerator?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValueToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    denominator: cdktf.stringToTerraform(struct!.denominator),
    numerator: cdktf.numberToTerraform(struct!.numerator),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValueToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    denominator: {
      value: cdktf.stringToHclTerraform(struct!.denominator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numerator: {
      value: cdktf.numberToHclTerraform(struct!.numerator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denominator !== undefined) {
      hasAnyValues = true;
      internalValueResult.denominator = this._denominator;
    }
    if (this._numerator !== undefined) {
      hasAnyValues = true;
      internalValueResult.numerator = this._numerator;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denominator = undefined;
      this._numerator = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denominator = value.denominator;
      this._numerator = value.numerator;
    }
  }

  // denominator - computed: false, optional: true, required: false
  private _denominator?: string; 
  public get denominator() {
    return this.getStringAttribute('denominator');
  }
  public set denominator(value: string) {
    this._denominator = value;
  }
  public resetDenominator() {
    this._denominator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denominatorInput() {
    return this._denominator;
  }

  // numerator - computed: false, optional: true, required: false
  private _numerator?: number; 
  public get numerator() {
    return this.getNumberAttribute('numerator');
  }
  public set numerator(value: number) {
    this._numerator = value;
  }
  public resetNumerator() {
    this._numerator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numeratorInput() {
    return this._numerator;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabled {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#default_value DataK8SGatewaySoloIoRouteOptionV1Manifest#default_value}
  */
  readonly defaultValue?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValue;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#runtime_key DataK8SGatewaySoloIoRouteOptionV1Manifest#runtime_key}
  */
  readonly runtimeKey?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValueToTerraform(struct!.defaultValue),
    runtime_key: cdktf.stringToTerraform(struct!.runtimeKey),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValueToHclTerraform(struct!.defaultValue),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValue",
    },
    runtime_key: {
      value: cdktf.stringToHclTerraform(struct!.runtimeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabled | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue?.internalValue;
    }
    if (this._runtimeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeKey = this._runtimeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabled | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = undefined;
      this._runtimeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = value.defaultValue;
      this._runtimeKey = value.runtimeKey;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValueOutputReference(this, "default_value");
  public get defaultValue() {
    return this._defaultValue;
  }
  public putDefaultValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledDefaultValue) {
    this._defaultValue.internalValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue.internalValue;
  }

  // runtime_key - computed: false, optional: true, required: false
  private _runtimeKey?: string; 
  public get runtimeKey() {
    return this.getStringAttribute('runtime_key');
  }
  public set runtimeKey(value: string) {
    this._runtimeKey = value;
  }
  public resetRuntimeKey() {
    this._runtimeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeKeyInput() {
    return this._runtimeKey;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#denominator DataK8SGatewaySoloIoRouteOptionV1Manifest#denominator}
  */
  readonly denominator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#numerator DataK8SGatewaySoloIoRouteOptionV1Manifest#numerator}
  */
  readonly numerator?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValueToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    denominator: cdktf.stringToTerraform(struct!.denominator),
    numerator: cdktf.numberToTerraform(struct!.numerator),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValueToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    denominator: {
      value: cdktf.stringToHclTerraform(struct!.denominator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numerator: {
      value: cdktf.numberToHclTerraform(struct!.numerator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denominator !== undefined) {
      hasAnyValues = true;
      internalValueResult.denominator = this._denominator;
    }
    if (this._numerator !== undefined) {
      hasAnyValues = true;
      internalValueResult.numerator = this._numerator;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denominator = undefined;
      this._numerator = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denominator = value.denominator;
      this._numerator = value.numerator;
    }
  }

  // denominator - computed: false, optional: true, required: false
  private _denominator?: string; 
  public get denominator() {
    return this.getStringAttribute('denominator');
  }
  public set denominator(value: string) {
    this._denominator = value;
  }
  public resetDenominator() {
    this._denominator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denominatorInput() {
    return this._denominator;
  }

  // numerator - computed: false, optional: true, required: false
  private _numerator?: number; 
  public get numerator() {
    return this.getNumberAttribute('numerator');
  }
  public set numerator(value: number) {
    this._numerator = value;
  }
  public resetNumerator() {
    this._numerator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numeratorInput() {
    return this._numerator;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabled {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#default_value DataK8SGatewaySoloIoRouteOptionV1Manifest#default_value}
  */
  readonly defaultValue?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValue;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#runtime_key DataK8SGatewaySoloIoRouteOptionV1Manifest#runtime_key}
  */
  readonly runtimeKey?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValueToTerraform(struct!.defaultValue),
    runtime_key: cdktf.stringToTerraform(struct!.runtimeKey),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValueToHclTerraform(struct!.defaultValue),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValue",
    },
    runtime_key: {
      value: cdktf.stringToHclTerraform(struct!.runtimeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabled | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue?.internalValue;
    }
    if (this._runtimeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeKey = this._runtimeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabled | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = undefined;
      this._runtimeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = value.defaultValue;
      this._runtimeKey = value.runtimeKey;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValueOutputReference(this, "default_value");
  public get defaultValue() {
    return this._defaultValue;
  }
  public putDefaultValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledDefaultValue) {
    this._defaultValue.internalValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue.internalValue;
  }

  // runtime_key - computed: false, optional: true, required: false
  private _runtimeKey?: string; 
  public get runtimeKey() {
    return this.getStringAttribute('runtime_key');
  }
  public set runtimeKey(value: string) {
    this._runtimeKey = value;
  }
  public resetRuntimeKey() {
    this._runtimeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeKeyInput() {
    return this._runtimeKey;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#additional_origins DataK8SGatewaySoloIoRouteOptionV1Manifest#additional_origins}
  */
  readonly additionalOrigins?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#filter_enabled DataK8SGatewaySoloIoRouteOptionV1Manifest#filter_enabled}
  */
  readonly filterEnabled?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabled;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#shadow_enabled DataK8SGatewaySoloIoRouteOptionV1Manifest#shadow_enabled}
  */
  readonly shadowEnabled?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabled;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_origins: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsToTerraform, false)(struct!.additionalOrigins),
    filter_enabled: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledToTerraform(struct!.filterEnabled),
    shadow_enabled: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledToTerraform(struct!.shadowEnabled),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_origins: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsToHclTerraform, false)(struct!.additionalOrigins),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsList",
    },
    filter_enabled: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledToHclTerraform(struct!.filterEnabled),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabled",
    },
    shadow_enabled: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledToHclTerraform(struct!.shadowEnabled),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabled",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalOrigins?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalOrigins = this._additionalOrigins?.internalValue;
    }
    if (this._filterEnabled?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterEnabled = this._filterEnabled?.internalValue;
    }
    if (this._shadowEnabled?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.shadowEnabled = this._shadowEnabled?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalOrigins.internalValue = undefined;
      this._filterEnabled.internalValue = undefined;
      this._shadowEnabled.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalOrigins.internalValue = value.additionalOrigins;
      this._filterEnabled.internalValue = value.filterEnabled;
      this._shadowEnabled.internalValue = value.shadowEnabled;
    }
  }

  // additional_origins - computed: false, optional: true, required: false
  private _additionalOrigins = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOriginsList(this, "additional_origins", false);
  public get additionalOrigins() {
    return this._additionalOrigins;
  }
  public putAdditionalOrigins(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable) {
    this._additionalOrigins.internalValue = value;
  }
  public resetAdditionalOrigins() {
    this._additionalOrigins.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalOriginsInput() {
    return this._additionalOrigins.internalValue;
  }

  // filter_enabled - computed: false, optional: true, required: false
  private _filterEnabled = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabledOutputReference(this, "filter_enabled");
  public get filterEnabled() {
    return this._filterEnabled;
  }
  public putFilterEnabled(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfFilterEnabled) {
    this._filterEnabled.internalValue = value;
  }
  public resetFilterEnabled() {
    this._filterEnabled.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterEnabledInput() {
    return this._filterEnabled.internalValue;
  }

  // shadow_enabled - computed: false, optional: true, required: false
  private _shadowEnabled = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabledOutputReference(this, "shadow_enabled");
  public get shadowEnabled() {
    return this._shadowEnabled;
  }
  public putShadowEnabled(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsCsrfShadowEnabled) {
    this._shadowEnabled.internalValue = value;
  }
  public resetShadowEnabled() {
    this._shadowEnabled.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shadowEnabledInput() {
    return this._shadowEnabled.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercent {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#value DataK8SGatewaySoloIoRouteOptionV1Manifest#value}
  */
  readonly value?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercentToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercentToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex DataK8SGatewaySoloIoRouteOptionV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#subgroup DataK8SGatewaySoloIoRouteOptionV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
      this._subgroup = value.subgroup;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#mask_char DataK8SGatewaySoloIoRouteOptionV1Manifest#mask_char}
  */
  readonly maskChar?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#percent DataK8SGatewaySoloIoRouteOptionV1Manifest#percent}
  */
  readonly percent?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercent;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex DataK8SGatewaySoloIoRouteOptionV1Manifest#regex}
  */
  readonly regex?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex_actions DataK8SGatewaySoloIoRouteOptionV1Manifest#regex_actions}
  */
  readonly regexActions?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActions[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mask_char: cdktf.stringToTerraform(struct!.maskChar),
    name: cdktf.stringToTerraform(struct!.name),
    percent: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercentToTerraform(struct!.percent),
    regex: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regex),
    regex_actions: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActionsToTerraform, false)(struct!.regexActions),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mask_char: {
      value: cdktf.stringToHclTerraform(struct!.maskChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    percent: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercentToHclTerraform(struct!.percent),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercent",
    },
    regex: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regex),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    regex_actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActionsToHclTerraform, false)(struct!.regexActions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maskChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.maskChar = this._maskChar;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._percent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._regexActions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexActions = this._regexActions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maskChar = undefined;
      this._name = undefined;
      this._percent.internalValue = undefined;
      this._regex = undefined;
      this._regexActions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maskChar = value.maskChar;
      this._name = value.name;
      this._percent.internalValue = value.percent;
      this._regex = value.regex;
      this._regexActions.internalValue = value.regexActions;
    }
  }

  // mask_char - computed: false, optional: true, required: false
  private _maskChar?: string; 
  public get maskChar() {
    return this.getStringAttribute('mask_char');
  }
  public set maskChar(value: string) {
    this._maskChar = value;
  }
  public resetMaskChar() {
    this._maskChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maskCharInput() {
    return this._maskChar;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // percent - computed: false, optional: true, required: false
  private _percent = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercentOutputReference(this, "percent");
  public get percent() {
    return this._percent;
  }
  public putPercent(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionPercent) {
    this._percent.internalValue = value;
  }
  public resetPercent() {
    this._percent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string[]; 
  public get regex() {
    return this.getListAttribute('regex');
  }
  public set regex(value: string[]) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // regex_actions - computed: false, optional: true, required: false
  private _regexActions = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActionsList(this, "regex_actions", false);
  public get regexActions() {
    return this._regexActions;
  }
  public putRegexActions(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionRegexActions[] | cdktf.IResolvable) {
    this._regexActions.internalValue = value;
  }
  public resetRegexActions() {
    this._regexActions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexActionsInput() {
    return this._regexActions.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercent {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#value DataK8SGatewaySoloIoRouteOptionV1Manifest#value}
  */
  readonly value?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercentToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercentToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key_to_mask DataK8SGatewaySoloIoRouteOptionV1Manifest#key_to_mask}
  */
  readonly keyToMask?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#mask_char DataK8SGatewaySoloIoRouteOptionV1Manifest#mask_char}
  */
  readonly maskChar?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#percent DataK8SGatewaySoloIoRouteOptionV1Manifest#percent}
  */
  readonly percent?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercent;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key_to_mask: cdktf.stringToTerraform(struct!.keyToMask),
    mask_char: cdktf.stringToTerraform(struct!.maskChar),
    name: cdktf.stringToTerraform(struct!.name),
    percent: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercentToTerraform(struct!.percent),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key_to_mask: {
      value: cdktf.stringToHclTerraform(struct!.keyToMask),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mask_char: {
      value: cdktf.stringToHclTerraform(struct!.maskChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    percent: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercentToHclTerraform(struct!.percent),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercent",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keyToMask !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyToMask = this._keyToMask;
    }
    if (this._maskChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.maskChar = this._maskChar;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._percent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keyToMask = undefined;
      this._maskChar = undefined;
      this._name = undefined;
      this._percent.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keyToMask = value.keyToMask;
      this._maskChar = value.maskChar;
      this._name = value.name;
      this._percent.internalValue = value.percent;
    }
  }

  // key_to_mask - computed: false, optional: true, required: false
  private _keyToMask?: string; 
  public get keyToMask() {
    return this.getStringAttribute('key_to_mask');
  }
  public set keyToMask(value: string) {
    this._keyToMask = value;
  }
  public resetKeyToMask() {
    this._keyToMask = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyToMaskInput() {
    return this._keyToMask;
  }

  // mask_char - computed: false, optional: true, required: false
  private _maskChar?: string; 
  public get maskChar() {
    return this.getStringAttribute('mask_char');
  }
  public set maskChar(value: string) {
    this._maskChar = value;
  }
  public resetMaskChar() {
    this._maskChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maskCharInput() {
    return this._maskChar;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // percent - computed: false, optional: true, required: false
  private _percent = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercentOutputReference(this, "percent");
  public get percent() {
    return this._percent;
  }
  public putPercent(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionPercent) {
    this._percent.internalValue = value;
  }
  public resetPercent() {
    this._percent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#action_type DataK8SGatewaySoloIoRouteOptionV1Manifest#action_type}
  */
  readonly actionType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#custom_action DataK8SGatewaySoloIoRouteOptionV1Manifest#custom_action}
  */
  readonly customAction?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomAction;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key_value_action DataK8SGatewaySoloIoRouteOptionV1Manifest#key_value_action}
  */
  readonly keyValueAction?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueAction;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#shadow DataK8SGatewaySoloIoRouteOptionV1Manifest#shadow}
  */
  readonly shadow?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action_type: cdktf.stringToTerraform(struct!.actionType),
    custom_action: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionToTerraform(struct!.customAction),
    key_value_action: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionToTerraform(struct!.keyValueAction),
    shadow: cdktf.booleanToTerraform(struct!.shadow),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action_type: {
      value: cdktf.stringToHclTerraform(struct!.actionType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_action: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionToHclTerraform(struct!.customAction),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomAction",
    },
    key_value_action: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionToHclTerraform(struct!.keyValueAction),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueAction",
    },
    shadow: {
      value: cdktf.booleanToHclTerraform(struct!.shadow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actionType !== undefined) {
      hasAnyValues = true;
      internalValueResult.actionType = this._actionType;
    }
    if (this._customAction?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customAction = this._customAction?.internalValue;
    }
    if (this._keyValueAction?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueAction = this._keyValueAction?.internalValue;
    }
    if (this._shadow !== undefined) {
      hasAnyValues = true;
      internalValueResult.shadow = this._shadow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actionType = undefined;
      this._customAction.internalValue = undefined;
      this._keyValueAction.internalValue = undefined;
      this._shadow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actionType = value.actionType;
      this._customAction.internalValue = value.customAction;
      this._keyValueAction.internalValue = value.keyValueAction;
      this._shadow = value.shadow;
    }
  }

  // action_type - computed: false, optional: true, required: false
  private _actionType?: string; 
  public get actionType() {
    return this.getStringAttribute('action_type');
  }
  public set actionType(value: string) {
    this._actionType = value;
  }
  public resetActionType() {
    this._actionType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionTypeInput() {
    return this._actionType;
  }

  // custom_action - computed: false, optional: true, required: false
  private _customAction = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomActionOutputReference(this, "custom_action");
  public get customAction() {
    return this._customAction;
  }
  public putCustomAction(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsCustomAction) {
    this._customAction.internalValue = value;
  }
  public resetCustomAction() {
    this._customAction.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customActionInput() {
    return this._customAction.internalValue;
  }

  // key_value_action - computed: false, optional: true, required: false
  private _keyValueAction = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueActionOutputReference(this, "key_value_action");
  public get keyValueAction() {
    return this._keyValueAction;
  }
  public putKeyValueAction(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsKeyValueAction) {
    this._keyValueAction.internalValue = value;
  }
  public resetKeyValueAction() {
    this._keyValueAction.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueActionInput() {
    return this._keyValueAction.internalValue;
  }

  // shadow - computed: false, optional: true, required: false
  private _shadow?: boolean | cdktf.IResolvable; 
  public get shadow() {
    return this.getBooleanAttribute('shadow');
  }
  public set shadow(value: boolean | cdktf.IResolvable) {
    this._shadow = value;
  }
  public resetShadow() {
    this._shadow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shadowInput() {
    return this._shadow;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#actions DataK8SGatewaySoloIoRouteOptionV1Manifest#actions}
  */
  readonly actions?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#enabled_for DataK8SGatewaySoloIoRouteOptionV1Manifest#enabled_for}
  */
  readonly enabledFor?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    actions: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsToTerraform, false)(struct!.actions),
    enabled_for: cdktf.stringToTerraform(struct!.enabledFor),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsToHclTerraform, false)(struct!.actions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsList",
    },
    enabled_for: {
      value: cdktf.stringToHclTerraform(struct!.enabledFor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.actions = this._actions?.internalValue;
    }
    if (this._enabledFor !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabledFor = this._enabledFor;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actions.internalValue = undefined;
      this._enabledFor = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actions.internalValue = value.actions;
      this._enabledFor = value.enabledFor;
    }
  }

  // actions - computed: false, optional: true, required: false
  private _actions = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActionsList(this, "actions", false);
  public get actions() {
    return this._actions;
  }
  public putActions(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsDlpActions[] | cdktf.IResolvable) {
    this._actions.internalValue = value;
  }
  public resetActions() {
    this._actions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionsInput() {
    return this._actions.internalValue;
  }

  // enabled_for - computed: false, optional: true, required: false
  private _enabledFor?: string; 
  public get enabledFor() {
    return this.getStringAttribute('enabled_for');
  }
  public set enabledFor(value: string) {
    this._enabledFor = value;
  }
  public resetEnabledFor() {
    this._enabledFor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledForInput() {
    return this._enabledFor;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRefToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#value DataK8SGatewaySoloIoRouteOptionV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadataList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadataOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#base_interval DataK8SGatewaySoloIoRouteOptionV1Manifest#base_interval}
  */
  readonly baseInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#max_interval DataK8SGatewaySoloIoRouteOptionV1Manifest#max_interval}
  */
  readonly maxInterval?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_interval: cdktf.stringToTerraform(struct!.baseInterval),
    max_interval: cdktf.stringToTerraform(struct!.maxInterval),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_interval: {
      value: cdktf.stringToHclTerraform(struct!.baseInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_interval: {
      value: cdktf.stringToHclTerraform(struct!.maxInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseInterval = this._baseInterval;
    }
    if (this._maxInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxInterval = this._maxInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseInterval = undefined;
      this._maxInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseInterval = value.baseInterval;
      this._maxInterval = value.maxInterval;
    }
  }

  // base_interval - computed: false, optional: true, required: false
  private _baseInterval?: string; 
  public get baseInterval() {
    return this.getStringAttribute('base_interval');
  }
  public set baseInterval(value: string) {
    this._baseInterval = value;
  }
  public resetBaseInterval() {
    this._baseInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseIntervalInput() {
    return this._baseInterval;
  }

  // max_interval - computed: false, optional: true, required: false
  private _maxInterval?: string; 
  public get maxInterval() {
    return this.getStringAttribute('max_interval');
  }
  public set maxInterval(value: string) {
    this._maxInterval = value;
  }
  public resetMaxInterval() {
    this._maxInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxIntervalInput() {
    return this._maxInterval;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#num_retries DataK8SGatewaySoloIoRouteOptionV1Manifest#num_retries}
  */
  readonly numRetries?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#retry_back_off DataK8SGatewaySoloIoRouteOptionV1Manifest#retry_back_off}
  */
  readonly retryBackOff?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    num_retries: cdktf.numberToTerraform(struct!.numRetries),
    retry_back_off: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffToTerraform(struct!.retryBackOff),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    num_retries: {
      value: cdktf.numberToHclTerraform(struct!.numRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_back_off: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffToHclTerraform(struct!.retryBackOff),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._numRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.numRetries = this._numRetries;
    }
    if (this._retryBackOff?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryBackOff = this._retryBackOff?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._numRetries = undefined;
      this._retryBackOff.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._numRetries = value.numRetries;
      this._retryBackOff.internalValue = value.retryBackOff;
    }
  }

  // num_retries - computed: false, optional: true, required: false
  private _numRetries?: number; 
  public get numRetries() {
    return this.getNumberAttribute('num_retries');
  }
  public set numRetries(value: number) {
    this._numRetries = value;
  }
  public resetNumRetries() {
    this._numRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numRetriesInput() {
    return this._numRetries;
  }

  // retry_back_off - computed: false, optional: true, required: false
  private _retryBackOff = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffOutputReference(this, "retry_back_off");
  public get retryBackOff() {
    return this._retryBackOff;
  }
  public putRetryBackOff(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff) {
    this._retryBackOff.internalValue = value;
  }
  public resetRetryBackOff() {
    this._retryBackOff.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryBackOffInput() {
    return this._retryBackOff.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#authority DataK8SGatewaySoloIoRouteOptionV1Manifest#authority}
  */
  readonly authority?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#ext_proc_server_ref DataK8SGatewaySoloIoRouteOptionV1Manifest#ext_proc_server_ref}
  */
  readonly extProcServerRef?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#initial_metadata DataK8SGatewaySoloIoRouteOptionV1Manifest#initial_metadata}
  */
  readonly initialMetadata?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#retry_policy DataK8SGatewaySoloIoRouteOptionV1Manifest#retry_policy}
  */
  readonly retryPolicy?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#timeout DataK8SGatewaySoloIoRouteOptionV1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authority: cdktf.stringToTerraform(struct!.authority),
    ext_proc_server_ref: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRefToTerraform(struct!.extProcServerRef),
    initial_metadata: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadataToTerraform, false)(struct!.initialMetadata),
    retry_policy: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyToTerraform(struct!.retryPolicy),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authority: {
      value: cdktf.stringToHclTerraform(struct!.authority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ext_proc_server_ref: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRefToHclTerraform(struct!.extProcServerRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRef",
    },
    initial_metadata: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadataToHclTerraform, false)(struct!.initialMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadataList",
    },
    retry_policy: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyToHclTerraform(struct!.retryPolicy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicy",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authority !== undefined) {
      hasAnyValues = true;
      internalValueResult.authority = this._authority;
    }
    if (this._extProcServerRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extProcServerRef = this._extProcServerRef?.internalValue;
    }
    if (this._initialMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialMetadata = this._initialMetadata?.internalValue;
    }
    if (this._retryPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryPolicy = this._retryPolicy?.internalValue;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authority = undefined;
      this._extProcServerRef.internalValue = undefined;
      this._initialMetadata.internalValue = undefined;
      this._retryPolicy.internalValue = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authority = value.authority;
      this._extProcServerRef.internalValue = value.extProcServerRef;
      this._initialMetadata.internalValue = value.initialMetadata;
      this._retryPolicy.internalValue = value.retryPolicy;
      this._timeout = value.timeout;
    }
  }

  // authority - computed: false, optional: true, required: false
  private _authority?: string; 
  public get authority() {
    return this.getStringAttribute('authority');
  }
  public set authority(value: string) {
    this._authority = value;
  }
  public resetAuthority() {
    this._authority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorityInput() {
    return this._authority;
  }

  // ext_proc_server_ref - computed: false, optional: true, required: false
  private _extProcServerRef = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRefOutputReference(this, "ext_proc_server_ref");
  public get extProcServerRef() {
    return this._extProcServerRef;
  }
  public putExtProcServerRef(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceExtProcServerRef) {
    this._extProcServerRef.internalValue = value;
  }
  public resetExtProcServerRef() {
    this._extProcServerRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extProcServerRefInput() {
    return this._extProcServerRef.internalValue;
  }

  // initial_metadata - computed: false, optional: true, required: false
  private _initialMetadata = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadataList(this, "initial_metadata", false);
  public get initialMetadata() {
    return this._initialMetadata;
  }
  public putInitialMetadata(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceInitialMetadata[] | cdktf.IResolvable) {
    this._initialMetadata.internalValue = value;
  }
  public resetInitialMetadata() {
    this._initialMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialMetadataInput() {
    return this._initialMetadata.internalValue;
  }

  // retry_policy - computed: false, optional: true, required: false
  private _retryPolicy = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicyOutputReference(this, "retry_policy");
  public get retryPolicy() {
    return this._retryPolicy;
  }
  public putRetryPolicy(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceRetryPolicy) {
    this._retryPolicy.internalValue = value;
  }
  public resetRetryPolicy() {
    this._retryPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryPolicyInput() {
    return this._retryPolicy.internalValue;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingMode {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request_body_mode DataK8SGatewaySoloIoRouteOptionV1Manifest#request_body_mode}
  */
  readonly requestBodyMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request_header_mode DataK8SGatewaySoloIoRouteOptionV1Manifest#request_header_mode}
  */
  readonly requestHeaderMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request_trailer_mode DataK8SGatewaySoloIoRouteOptionV1Manifest#request_trailer_mode}
  */
  readonly requestTrailerMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#response_body_mode DataK8SGatewaySoloIoRouteOptionV1Manifest#response_body_mode}
  */
  readonly responseBodyMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#response_header_mode DataK8SGatewaySoloIoRouteOptionV1Manifest#response_header_mode}
  */
  readonly responseHeaderMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#response_trailer_mode DataK8SGatewaySoloIoRouteOptionV1Manifest#response_trailer_mode}
  */
  readonly responseTrailerMode?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingModeToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request_body_mode: cdktf.stringToTerraform(struct!.requestBodyMode),
    request_header_mode: cdktf.stringToTerraform(struct!.requestHeaderMode),
    request_trailer_mode: cdktf.stringToTerraform(struct!.requestTrailerMode),
    response_body_mode: cdktf.stringToTerraform(struct!.responseBodyMode),
    response_header_mode: cdktf.stringToTerraform(struct!.responseHeaderMode),
    response_trailer_mode: cdktf.stringToTerraform(struct!.responseTrailerMode),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingModeToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request_body_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestBodyMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_header_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestHeaderMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_trailer_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestTrailerMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_body_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseBodyMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_header_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseHeaderMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_trailer_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseTrailerMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestBodyMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestBodyMode = this._requestBodyMode;
    }
    if (this._requestHeaderMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaderMode = this._requestHeaderMode;
    }
    if (this._requestTrailerMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTrailerMode = this._requestTrailerMode;
    }
    if (this._responseBodyMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseBodyMode = this._responseBodyMode;
    }
    if (this._responseHeaderMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeaderMode = this._responseHeaderMode;
    }
    if (this._responseTrailerMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTrailerMode = this._responseTrailerMode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestBodyMode = undefined;
      this._requestHeaderMode = undefined;
      this._requestTrailerMode = undefined;
      this._responseBodyMode = undefined;
      this._responseHeaderMode = undefined;
      this._responseTrailerMode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestBodyMode = value.requestBodyMode;
      this._requestHeaderMode = value.requestHeaderMode;
      this._requestTrailerMode = value.requestTrailerMode;
      this._responseBodyMode = value.responseBodyMode;
      this._responseHeaderMode = value.responseHeaderMode;
      this._responseTrailerMode = value.responseTrailerMode;
    }
  }

  // request_body_mode - computed: false, optional: true, required: false
  private _requestBodyMode?: string; 
  public get requestBodyMode() {
    return this.getStringAttribute('request_body_mode');
  }
  public set requestBodyMode(value: string) {
    this._requestBodyMode = value;
  }
  public resetRequestBodyMode() {
    this._requestBodyMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestBodyModeInput() {
    return this._requestBodyMode;
  }

  // request_header_mode - computed: false, optional: true, required: false
  private _requestHeaderMode?: string; 
  public get requestHeaderMode() {
    return this.getStringAttribute('request_header_mode');
  }
  public set requestHeaderMode(value: string) {
    this._requestHeaderMode = value;
  }
  public resetRequestHeaderMode() {
    this._requestHeaderMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeaderModeInput() {
    return this._requestHeaderMode;
  }

  // request_trailer_mode - computed: false, optional: true, required: false
  private _requestTrailerMode?: string; 
  public get requestTrailerMode() {
    return this.getStringAttribute('request_trailer_mode');
  }
  public set requestTrailerMode(value: string) {
    this._requestTrailerMode = value;
  }
  public resetRequestTrailerMode() {
    this._requestTrailerMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTrailerModeInput() {
    return this._requestTrailerMode;
  }

  // response_body_mode - computed: false, optional: true, required: false
  private _responseBodyMode?: string; 
  public get responseBodyMode() {
    return this.getStringAttribute('response_body_mode');
  }
  public set responseBodyMode(value: string) {
    this._responseBodyMode = value;
  }
  public resetResponseBodyMode() {
    this._responseBodyMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseBodyModeInput() {
    return this._responseBodyMode;
  }

  // response_header_mode - computed: false, optional: true, required: false
  private _responseHeaderMode?: string; 
  public get responseHeaderMode() {
    return this.getStringAttribute('response_header_mode');
  }
  public set responseHeaderMode(value: string) {
    this._responseHeaderMode = value;
  }
  public resetResponseHeaderMode() {
    this._responseHeaderMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeaderModeInput() {
    return this._responseHeaderMode;
  }

  // response_trailer_mode - computed: false, optional: true, required: false
  private _responseTrailerMode?: string; 
  public get responseTrailerMode() {
    return this.getStringAttribute('response_trailer_mode');
  }
  public set responseTrailerMode(value: string) {
    this._responseTrailerMode = value;
  }
  public resetResponseTrailerMode() {
    this._responseTrailerMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTrailerModeInput() {
    return this._responseTrailerMode;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverrides {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#async_mode DataK8SGatewaySoloIoRouteOptionV1Manifest#async_mode}
  */
  readonly asyncMode?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#grpc_service DataK8SGatewaySoloIoRouteOptionV1Manifest#grpc_service}
  */
  readonly grpcService?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata_context_namespaces DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata_context_namespaces}
  */
  readonly metadataContextNamespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#processing_mode DataK8SGatewaySoloIoRouteOptionV1Manifest#processing_mode}
  */
  readonly processingMode?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingMode;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request_attributes DataK8SGatewaySoloIoRouteOptionV1Manifest#request_attributes}
  */
  readonly requestAttributes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#response_attributes DataK8SGatewaySoloIoRouteOptionV1Manifest#response_attributes}
  */
  readonly responseAttributes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#typed_metadata_context_namespaces DataK8SGatewaySoloIoRouteOptionV1Manifest#typed_metadata_context_namespaces}
  */
  readonly typedMetadataContextNamespaces?: string[];
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    async_mode: cdktf.booleanToTerraform(struct!.asyncMode),
    grpc_service: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceToTerraform(struct!.grpcService),
    metadata_context_namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.metadataContextNamespaces),
    processing_mode: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingModeToTerraform(struct!.processingMode),
    request_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestAttributes),
    response_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.responseAttributes),
    typed_metadata_context_namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.typedMetadataContextNamespaces),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    async_mode: {
      value: cdktf.booleanToHclTerraform(struct!.asyncMode),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    grpc_service: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceToHclTerraform(struct!.grpcService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcService",
    },
    metadata_context_namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.metadataContextNamespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    processing_mode: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingModeToHclTerraform(struct!.processingMode),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingMode",
    },
    request_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestAttributes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    response_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.responseAttributes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    typed_metadata_context_namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.typedMetadataContextNamespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asyncMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncMode = this._asyncMode;
    }
    if (this._grpcService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcService = this._grpcService?.internalValue;
    }
    if (this._metadataContextNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataContextNamespaces = this._metadataContextNamespaces;
    }
    if (this._processingMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processingMode = this._processingMode?.internalValue;
    }
    if (this._requestAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestAttributes = this._requestAttributes;
    }
    if (this._responseAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseAttributes = this._responseAttributes;
    }
    if (this._typedMetadataContextNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.typedMetadataContextNamespaces = this._typedMetadataContextNamespaces;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asyncMode = undefined;
      this._grpcService.internalValue = undefined;
      this._metadataContextNamespaces = undefined;
      this._processingMode.internalValue = undefined;
      this._requestAttributes = undefined;
      this._responseAttributes = undefined;
      this._typedMetadataContextNamespaces = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asyncMode = value.asyncMode;
      this._grpcService.internalValue = value.grpcService;
      this._metadataContextNamespaces = value.metadataContextNamespaces;
      this._processingMode.internalValue = value.processingMode;
      this._requestAttributes = value.requestAttributes;
      this._responseAttributes = value.responseAttributes;
      this._typedMetadataContextNamespaces = value.typedMetadataContextNamespaces;
    }
  }

  // async_mode - computed: false, optional: true, required: false
  private _asyncMode?: boolean | cdktf.IResolvable; 
  public get asyncMode() {
    return this.getBooleanAttribute('async_mode');
  }
  public set asyncMode(value: boolean | cdktf.IResolvable) {
    this._asyncMode = value;
  }
  public resetAsyncMode() {
    this._asyncMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncModeInput() {
    return this._asyncMode;
  }

  // grpc_service - computed: false, optional: true, required: false
  private _grpcService = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcServiceOutputReference(this, "grpc_service");
  public get grpcService() {
    return this._grpcService;
  }
  public putGrpcService(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesGrpcService) {
    this._grpcService.internalValue = value;
  }
  public resetGrpcService() {
    this._grpcService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServiceInput() {
    return this._grpcService.internalValue;
  }

  // metadata_context_namespaces - computed: false, optional: true, required: false
  private _metadataContextNamespaces?: string[]; 
  public get metadataContextNamespaces() {
    return this.getListAttribute('metadata_context_namespaces');
  }
  public set metadataContextNamespaces(value: string[]) {
    this._metadataContextNamespaces = value;
  }
  public resetMetadataContextNamespaces() {
    this._metadataContextNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataContextNamespacesInput() {
    return this._metadataContextNamespaces;
  }

  // processing_mode - computed: false, optional: true, required: false
  private _processingMode = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingModeOutputReference(this, "processing_mode");
  public get processingMode() {
    return this._processingMode;
  }
  public putProcessingMode(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesProcessingMode) {
    this._processingMode.internalValue = value;
  }
  public resetProcessingMode() {
    this._processingMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processingModeInput() {
    return this._processingMode.internalValue;
  }

  // request_attributes - computed: false, optional: true, required: false
  private _requestAttributes?: string[]; 
  public get requestAttributes() {
    return this.getListAttribute('request_attributes');
  }
  public set requestAttributes(value: string[]) {
    this._requestAttributes = value;
  }
  public resetRequestAttributes() {
    this._requestAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestAttributesInput() {
    return this._requestAttributes;
  }

  // response_attributes - computed: false, optional: true, required: false
  private _responseAttributes?: string[]; 
  public get responseAttributes() {
    return this.getListAttribute('response_attributes');
  }
  public set responseAttributes(value: string[]) {
    this._responseAttributes = value;
  }
  public resetResponseAttributes() {
    this._responseAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseAttributesInput() {
    return this._responseAttributes;
  }

  // typed_metadata_context_namespaces - computed: false, optional: true, required: false
  private _typedMetadataContextNamespaces?: string[]; 
  public get typedMetadataContextNamespaces() {
    return this.getListAttribute('typed_metadata_context_namespaces');
  }
  public set typedMetadataContextNamespaces(value: string[]) {
    this._typedMetadataContextNamespaces = value;
  }
  public resetTypedMetadataContextNamespaces() {
    this._typedMetadataContextNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typedMetadataContextNamespacesInput() {
    return this._typedMetadataContextNamespaces;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#disabled DataK8SGatewaySoloIoRouteOptionV1Manifest#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#overrides DataK8SGatewaySoloIoRouteOptionV1Manifest#overrides}
  */
  readonly overrides?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverrides;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    overrides: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesToTerraform(struct!.overrides),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    overrides: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverrides",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._overrides.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._overrides.internalValue = value.overrides;
    }
  }

  // disabled - computed: false, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtProcOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRefToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#context_extensions DataK8SGatewaySoloIoRouteOptionV1Manifest#context_extensions}
  */
  readonly contextExtensions?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuthToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context_extensions: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.contextExtensions),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context_extensions: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.contextExtensions),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._contextExtensions !== undefined) {
      hasAnyValues = true;
      internalValueResult.contextExtensions = this._contextExtensions;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._contextExtensions = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._contextExtensions = value.contextExtensions;
      this._name = value.name;
    }
  }

  // context_extensions - computed: false, optional: true, required: false
  private _contextExtensions?: { [key: string]: string }; 
  public get contextExtensions() {
    return this.getStringMapAttribute('context_extensions');
  }
  public set contextExtensions(value: { [key: string]: string }) {
    this._contextExtensions = value;
  }
  public resetContextExtensions() {
    this._contextExtensions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextExtensionsInput() {
    return this._contextExtensions;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#config_ref DataK8SGatewaySoloIoRouteOptionV1Manifest#config_ref}
  */
  readonly configRef?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#custom_auth DataK8SGatewaySoloIoRouteOptionV1Manifest#custom_auth}
  */
  readonly customAuth?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#disable DataK8SGatewaySoloIoRouteOptionV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_ref: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRefToTerraform(struct!.configRef),
    custom_auth: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuthToTerraform(struct!.customAuth),
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_ref: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRefToHclTerraform(struct!.configRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRef",
    },
    custom_auth: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuthToHclTerraform(struct!.customAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuth",
    },
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configRef = this._configRef?.internalValue;
    }
    if (this._customAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customAuth = this._customAuth?.internalValue;
    }
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configRef.internalValue = undefined;
      this._customAuth.internalValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configRef.internalValue = value.configRef;
      this._customAuth.internalValue = value.customAuth;
      this._disable = value.disable;
    }
  }

  // config_ref - computed: false, optional: true, required: false
  private _configRef = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRefOutputReference(this, "config_ref");
  public get configRef() {
    return this._configRef;
  }
  public putConfigRef(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthConfigRef) {
    this._configRef.internalValue = value;
  }
  public resetConfigRef() {
    this._configRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configRefInput() {
    return this._configRef.internalValue;
  }

  // custom_auth - computed: false, optional: true, required: false
  private _customAuth = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuthOutputReference(this, "custom_auth");
  public get customAuth() {
    return this._customAuth;
  }
  public putCustomAuth(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtauthCustomAuth) {
    this._customAuth.internalValue = value;
  }
  public resetCustomAuth() {
    this._customAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customAuthInput() {
    return this._customAuth.internalValue;
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtensions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#configs DataK8SGatewaySoloIoRouteOptionV1Manifest#configs}
  */
  readonly configs?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtensionsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtensions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    configs: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.configs),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtensionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtensions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    configs: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.configs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtensionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtensions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configs !== undefined) {
      hasAnyValues = true;
      internalValueResult.configs = this._configs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsExtensions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configs = value.configs;
    }
  }

  // configs - computed: false, optional: true, required: false
  private _configs?: { [key: string]: string }; 
  public get configs() {
    return this.getStringMapAttribute('configs');
  }
  public set configs(value: { [key: string]: string }) {
    this._configs = value;
  }
  public resetConfigs() {
    this._configs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configsInput() {
    return this._configs;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbort {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#http_status DataK8SGatewaySoloIoRouteOptionV1Manifest#http_status}
  */
  readonly httpStatus?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#percentage DataK8SGatewaySoloIoRouteOptionV1Manifest#percentage}
  */
  readonly percentage?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbortToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    percentage: cdktf.numberToTerraform(struct!.percentage),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbortToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    percentage: {
      value: cdktf.numberToHclTerraform(struct!.percentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._percentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.percentage = this._percentage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._httpStatus = undefined;
      this._percentage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._httpStatus = value.httpStatus;
      this._percentage = value.percentage;
    }
  }

  // http_status - computed: false, optional: true, required: false
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  public resetHttpStatus() {
    this._httpStatus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // percentage - computed: false, optional: true, required: false
  private _percentage?: number; 
  public get percentage() {
    return this.getNumberAttribute('percentage');
  }
  public set percentage(value: number) {
    this._percentage = value;
  }
  public resetPercentage() {
    this._percentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentageInput() {
    return this._percentage;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelay {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#fixed_delay DataK8SGatewaySoloIoRouteOptionV1Manifest#fixed_delay}
  */
  readonly fixedDelay?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#percentage DataK8SGatewaySoloIoRouteOptionV1Manifest#percentage}
  */
  readonly percentage?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelayToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelay | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fixed_delay: cdktf.stringToTerraform(struct!.fixedDelay),
    percentage: cdktf.numberToTerraform(struct!.percentage),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelayToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelay | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fixed_delay: {
      value: cdktf.stringToHclTerraform(struct!.fixedDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    percentage: {
      value: cdktf.numberToHclTerraform(struct!.percentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelayOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelay | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fixedDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.fixedDelay = this._fixedDelay;
    }
    if (this._percentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.percentage = this._percentage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelay | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fixedDelay = undefined;
      this._percentage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fixedDelay = value.fixedDelay;
      this._percentage = value.percentage;
    }
  }

  // fixed_delay - computed: false, optional: true, required: false
  private _fixedDelay?: string; 
  public get fixedDelay() {
    return this.getStringAttribute('fixed_delay');
  }
  public set fixedDelay(value: string) {
    this._fixedDelay = value;
  }
  public resetFixedDelay() {
    this._fixedDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fixedDelayInput() {
    return this._fixedDelay;
  }

  // percentage - computed: false, optional: true, required: false
  private _percentage?: number; 
  public get percentage() {
    return this.getNumberAttribute('percentage');
  }
  public set percentage(value: number) {
    this._percentage = value;
  }
  public resetPercentage() {
    this._percentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentageInput() {
    return this._percentage;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaults {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#abort DataK8SGatewaySoloIoRouteOptionV1Manifest#abort}
  */
  readonly abort?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbort;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#delay DataK8SGatewaySoloIoRouteOptionV1Manifest#delay}
  */
  readonly delay?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelay;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    abort: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbortToTerraform(struct!.abort),
    delay: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelayToTerraform(struct!.delay),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    abort: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbortToHclTerraform(struct!.abort),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbort",
    },
    delay: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelayToHclTerraform(struct!.delay),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelay",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaults | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._abort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.abort = this._abort?.internalValue;
    }
    if (this._delay?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.delay = this._delay?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaults | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._abort.internalValue = undefined;
      this._delay.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._abort.internalValue = value.abort;
      this._delay.internalValue = value.delay;
    }
  }

  // abort - computed: false, optional: true, required: false
  private _abort = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbortOutputReference(this, "abort");
  public get abort() {
    return this._abort;
  }
  public putAbort(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsAbort) {
    this._abort.internalValue = value;
  }
  public resetAbort() {
    this._abort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get abortInput() {
    return this._abort.internalValue;
  }

  // delay - computed: false, optional: true, required: false
  private _delay = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelayOutputReference(this, "delay");
  public get delay() {
    return this._delay;
  }
  public putDelay(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsFaultsDelay) {
    this._delay.internalValue = value;
  }
  public resetDelay() {
    this._delay.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delayInput() {
    return this._delay.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#value DataK8SGatewaySoloIoRouteOptionV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAdd {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#append DataK8SGatewaySoloIoRouteOptionV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header DataK8SGatewaySoloIoRouteOptionV1Manifest#header}
  */
  readonly header?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header_secret_ref DataK8SGatewaySoloIoRouteOptionV1Manifest#header_secret_ref}
  */
  readonly headerSecretRef?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    header: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderToTerraform(struct!.header),
    header_secret_ref: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToTerraform(struct!.headerSecretRef),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    header: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderToHclTerraform(struct!.header),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeader",
    },
    header_secret_ref: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToHclTerraform(struct!.headerSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._header?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header?.internalValue;
    }
    if (this._headerSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerSecretRef = this._headerSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._header.internalValue = undefined;
      this._headerSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._header.internalValue = value.header;
      this._headerSecretRef.internalValue = value.headerSecretRef;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // header - computed: false, optional: true, required: false
  private _header = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderOutputReference(this, "header");
  public get header() {
    return this._header;
  }
  public putHeader(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeader) {
    this._header.internalValue = value;
  }
  public resetHeader() {
    this._header.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header.internalValue;
  }

  // header_secret_ref - computed: false, optional: true, required: false
  private _headerSecretRef = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefOutputReference(this, "header_secret_ref");
  public get headerSecretRef() {
    return this._headerSecretRef;
  }
  public putHeaderSecretRef(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef) {
    this._headerSecretRef.internalValue = value;
  }
  public resetHeaderSecretRef() {
    this._headerSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerSecretRefInput() {
    return this._headerSecretRef.internalValue;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAdd[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#value DataK8SGatewaySoloIoRouteOptionV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeaderToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeaderToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAdd {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#append DataK8SGatewaySoloIoRouteOptionV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header DataK8SGatewaySoloIoRouteOptionV1Manifest#header}
  */
  readonly header?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeader;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    header: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeaderToTerraform(struct!.header),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    header: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeaderToHclTerraform(struct!.header),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeader",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._header?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._header.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._header.internalValue = value.header;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // header - computed: false, optional: true, required: false
  private _header = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeaderOutputReference(this, "header");
  public get header() {
    return this._header;
  }
  public putHeader(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddHeader) {
    this._header.internalValue = value;
  }
  public resetHeader() {
    this._header.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header.internalValue;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAdd[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request_headers_to_add DataK8SGatewaySoloIoRouteOptionV1Manifest#request_headers_to_add}
  */
  readonly requestHeadersToAdd?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAdd[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request_headers_to_remove DataK8SGatewaySoloIoRouteOptionV1Manifest#request_headers_to_remove}
  */
  readonly requestHeadersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#response_headers_to_add DataK8SGatewaySoloIoRouteOptionV1Manifest#response_headers_to_add}
  */
  readonly responseHeadersToAdd?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAdd[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#response_headers_to_remove DataK8SGatewaySoloIoRouteOptionV1Manifest#response_headers_to_remove}
  */
  readonly responseHeadersToRemove?: string[];
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request_headers_to_add: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddToTerraform, false)(struct!.requestHeadersToAdd),
    request_headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestHeadersToRemove),
    response_headers_to_add: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddToTerraform, false)(struct!.responseHeadersToAdd),
    response_headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.responseHeadersToRemove),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request_headers_to_add: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddToHclTerraform, false)(struct!.requestHeadersToAdd),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddList",
    },
    request_headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestHeadersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    response_headers_to_add: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddToHclTerraform, false)(struct!.responseHeadersToAdd),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddList",
    },
    response_headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.responseHeadersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestHeadersToAdd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersToAdd = this._requestHeadersToAdd?.internalValue;
    }
    if (this._requestHeadersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersToRemove = this._requestHeadersToRemove;
    }
    if (this._responseHeadersToAdd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeadersToAdd = this._responseHeadersToAdd?.internalValue;
    }
    if (this._responseHeadersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeadersToRemove = this._responseHeadersToRemove;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestHeadersToAdd.internalValue = undefined;
      this._requestHeadersToRemove = undefined;
      this._responseHeadersToAdd.internalValue = undefined;
      this._responseHeadersToRemove = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestHeadersToAdd.internalValue = value.requestHeadersToAdd;
      this._requestHeadersToRemove = value.requestHeadersToRemove;
      this._responseHeadersToAdd.internalValue = value.responseHeadersToAdd;
      this._responseHeadersToRemove = value.responseHeadersToRemove;
    }
  }

  // request_headers_to_add - computed: false, optional: true, required: false
  private _requestHeadersToAdd = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAddList(this, "request_headers_to_add", false);
  public get requestHeadersToAdd() {
    return this._requestHeadersToAdd;
  }
  public putRequestHeadersToAdd(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationRequestHeadersToAdd[] | cdktf.IResolvable) {
    this._requestHeadersToAdd.internalValue = value;
  }
  public resetRequestHeadersToAdd() {
    this._requestHeadersToAdd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersToAddInput() {
    return this._requestHeadersToAdd.internalValue;
  }

  // request_headers_to_remove - computed: false, optional: true, required: false
  private _requestHeadersToRemove?: string[]; 
  public get requestHeadersToRemove() {
    return this.getListAttribute('request_headers_to_remove');
  }
  public set requestHeadersToRemove(value: string[]) {
    this._requestHeadersToRemove = value;
  }
  public resetRequestHeadersToRemove() {
    this._requestHeadersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersToRemoveInput() {
    return this._requestHeadersToRemove;
  }

  // response_headers_to_add - computed: false, optional: true, required: false
  private _responseHeadersToAdd = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAddList(this, "response_headers_to_add", false);
  public get responseHeadersToAdd() {
    return this._responseHeadersToAdd;
  }
  public putResponseHeadersToAdd(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHeaderManipulationResponseHeadersToAdd[] | cdktf.IResolvable) {
    this._responseHeadersToAdd.internalValue = value;
  }
  public resetResponseHeadersToAdd() {
    this._responseHeadersToAdd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeadersToAddInput() {
    return this._responseHeadersToAdd.internalValue;
  }

  // response_headers_to_remove - computed: false, optional: true, required: false
  private _responseHeadersToRemove?: string[]; 
  public get responseHeadersToRemove() {
    return this.getListAttribute('response_headers_to_remove');
  }
  public set responseHeadersToRemove(value: string[]) {
    this._responseHeadersToRemove = value;
  }
  public resetResponseHeadersToRemove() {
    this._responseHeadersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeadersToRemoveInput() {
    return this._responseHeadersToRemove;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#max_program_size DataK8SGatewaySoloIoRouteOptionV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPattern {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#google_re2 DataK8SGatewaySoloIoRouteOptionV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex DataK8SGatewaySoloIoRouteOptionV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPattern | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPattern | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPattern | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPattern | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#pattern DataK8SGatewaySoloIoRouteOptionV1Manifest#pattern}
  */
  readonly pattern?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPattern;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#substitution DataK8SGatewaySoloIoRouteOptionV1Manifest#substitution}
  */
  readonly substitution?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pattern: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternToTerraform(struct!.pattern),
    substitution: cdktf.stringToTerraform(struct!.substitution),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pattern: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternToHclTerraform(struct!.pattern),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPattern",
    },
    substitution: {
      value: cdktf.stringToHclTerraform(struct!.substitution),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pattern?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pattern = this._pattern?.internalValue;
    }
    if (this._substitution !== undefined) {
      hasAnyValues = true;
      internalValueResult.substitution = this._substitution;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pattern.internalValue = undefined;
      this._substitution = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pattern.internalValue = value.pattern;
      this._substitution = value.substitution;
    }
  }

  // pattern - computed: false, optional: true, required: false
  private _pattern = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPatternOutputReference(this, "pattern");
  public get pattern() {
    return this._pattern;
  }
  public putPattern(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsHostRewritePathRegexPattern) {
    this._pattern.internalValue = value;
  }
  public resetPattern() {
    this._pattern.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternInput() {
    return this._pattern.internalValue;
  }

  // substitution - computed: false, optional: true, required: false
  private _substitution?: string; 
  public get substitution() {
    return this.getStringAttribute('substitution');
  }
  public set substitution(value: string) {
    this._substitution = value;
  }
  public resetSubstitution() {
    this._substitution = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get substitutionInput() {
    return this._substitution;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwt {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#disable DataK8SGatewaySoloIoRouteOptionV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disable = value.disable;
    }
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#append DataK8SGatewaySoloIoRouteOptionV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#claim DataK8SGatewaySoloIoRouteOptionV1Manifest#claim}
  */
  readonly claim?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header DataK8SGatewaySoloIoRouteOptionV1Manifest#header}
  */
  readonly header?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    claim: cdktf.stringToTerraform(struct!.claim),
    header: cdktf.stringToTerraform(struct!.header),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    claim: {
      value: cdktf.stringToHclTerraform(struct!.claim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._claim !== undefined) {
      hasAnyValues = true;
      internalValueResult.claim = this._claim;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._claim = undefined;
      this._header = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._claim = value.claim;
      this._header = value.header;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // claim - computed: false, optional: true, required: false
  private _claim?: string; 
  public get claim() {
    return this.getStringAttribute('claim');
  }
  public set claim(value: string) {
    this._claim = value;
  }
  public resetClaim() {
    this._claim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimInput() {
    return this._claim;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#fast_listener DataK8SGatewaySoloIoRouteOptionV1Manifest#fast_listener}
  */
  readonly fastListener?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fast_listener: cdktf.booleanToTerraform(struct!.fastListener),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fast_listener: {
      value: cdktf.booleanToHclTerraform(struct!.fastListener),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fastListener !== undefined) {
      hasAnyValues = true;
      internalValueResult.fastListener = this._fastListener;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fastListener = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fastListener = value.fastListener;
    }
  }

  // fast_listener - computed: false, optional: true, required: false
  private _fastListener?: boolean | cdktf.IResolvable; 
  public get fastListener() {
    return this.getBooleanAttribute('fast_listener');
  }
  public set fastListener(value: boolean | cdktf.IResolvable) {
    this._fastListener = value;
  }
  public resetFastListener() {
    this._fastListener = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fastListenerInput() {
    return this._fastListener;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#async_fetch DataK8SGatewaySoloIoRouteOptionV1Manifest#async_fetch}
  */
  readonly asyncFetch?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#cache_duration DataK8SGatewaySoloIoRouteOptionV1Manifest#cache_duration}
  */
  readonly cacheDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#upstream_ref DataK8SGatewaySoloIoRouteOptionV1Manifest#upstream_ref}
  */
  readonly upstreamRef?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#url DataK8SGatewaySoloIoRouteOptionV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    async_fetch: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchToTerraform(struct!.asyncFetch),
    cache_duration: cdktf.stringToTerraform(struct!.cacheDuration),
    upstream_ref: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefToTerraform(struct!.upstreamRef),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    async_fetch: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchToHclTerraform(struct!.asyncFetch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch",
    },
    cache_duration: {
      value: cdktf.stringToHclTerraform(struct!.cacheDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    upstream_ref: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefToHclTerraform(struct!.upstreamRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asyncFetch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncFetch = this._asyncFetch?.internalValue;
    }
    if (this._cacheDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheDuration = this._cacheDuration;
    }
    if (this._upstreamRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upstreamRef = this._upstreamRef?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asyncFetch.internalValue = undefined;
      this._cacheDuration = undefined;
      this._upstreamRef.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asyncFetch.internalValue = value.asyncFetch;
      this._cacheDuration = value.cacheDuration;
      this._upstreamRef.internalValue = value.upstreamRef;
      this._url = value.url;
    }
  }

  // async_fetch - computed: false, optional: true, required: false
  private _asyncFetch = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchOutputReference(this, "async_fetch");
  public get asyncFetch() {
    return this._asyncFetch;
  }
  public putAsyncFetch(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch) {
    this._asyncFetch.internalValue = value;
  }
  public resetAsyncFetch() {
    this._asyncFetch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncFetchInput() {
    return this._asyncFetch.internalValue;
  }

  // cache_duration - computed: false, optional: true, required: false
  private _cacheDuration?: string; 
  public get cacheDuration() {
    return this.getStringAttribute('cache_duration');
  }
  public set cacheDuration(value: string) {
    this._cacheDuration = value;
  }
  public resetCacheDuration() {
    this._cacheDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheDurationInput() {
    return this._cacheDuration;
  }

  // upstream_ref - computed: false, optional: true, required: false
  private _upstreamRef = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefOutputReference(this, "upstream_ref");
  public get upstreamRef() {
    return this._upstreamRef;
  }
  public putUpstreamRef(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef) {
    this._upstreamRef.internalValue = value;
  }
  public resetUpstreamRef() {
    this._upstreamRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upstreamRefInput() {
    return this._upstreamRef.internalValue;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwks {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#local DataK8SGatewaySoloIoRouteOptionV1Manifest#local}
  */
  readonly local?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#remote DataK8SGatewaySoloIoRouteOptionV1Manifest#remote}
  */
  readonly remote?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    local: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalToTerraform(struct!.local),
    remote: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteToTerraform(struct!.remote),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    local: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalToHclTerraform(struct!.local),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal",
    },
    remote: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteToHclTerraform(struct!.remote),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._local?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.local = this._local?.internalValue;
    }
    if (this._remote?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remote = this._remote?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._local.internalValue = undefined;
      this._remote.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._local.internalValue = value.local;
      this._remote.internalValue = value.remote;
    }
  }

  // local - computed: false, optional: true, required: false
  private _local = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalOutputReference(this, "local");
  public get local() {
    return this._local;
  }
  public putLocal(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal) {
    this._local.internalValue = value;
  }
  public resetLocal() {
    this._local.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localInput() {
    return this._local.internalValue;
  }

  // remote - computed: false, optional: true, required: false
  private _remote = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteOutputReference(this, "remote");
  public get remote() {
    return this._remote;
  }
  public putRemote(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote) {
    this._remote.internalValue = value;
  }
  public resetRemote() {
    this._remote.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteInput() {
    return this._remote.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header DataK8SGatewaySoloIoRouteOptionV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prefix DataK8SGatewaySoloIoRouteOptionV1Manifest#prefix}
  */
  readonly prefix?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header: cdktf.stringToTerraform(struct!.header),
    prefix: cdktf.stringToTerraform(struct!.prefix),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._header = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._header = value.header;
      this._prefix = value.prefix;
    }
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#headers DataK8SGatewaySoloIoRouteOptionV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#query_params DataK8SGatewaySoloIoRouteOptionV1Manifest#query_params}
  */
  readonly queryParams?: string[];
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersToTerraform, false)(struct!.headers),
    query_params: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersList",
    },
    query_params: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.queryParams),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._queryParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._queryParams = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._queryParams = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams?: string[]; 
  public get queryParams() {
    return this.getListAttribute('query_params');
  }
  public set queryParams(value: string[]) {
    this._queryParams = value;
  }
  public resetQueryParams() {
    this._queryParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProviders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#audiences DataK8SGatewaySoloIoRouteOptionV1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#claims_to_headers DataK8SGatewaySoloIoRouteOptionV1Manifest#claims_to_headers}
  */
  readonly claimsToHeaders?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#clock_skew_seconds DataK8SGatewaySoloIoRouteOptionV1Manifest#clock_skew_seconds}
  */
  readonly clockSkewSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#issuer DataK8SGatewaySoloIoRouteOptionV1Manifest#issuer}
  */
  readonly issuer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#jwks DataK8SGatewaySoloIoRouteOptionV1Manifest#jwks}
  */
  readonly jwks?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwks;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#keep_token DataK8SGatewaySoloIoRouteOptionV1Manifest#keep_token}
  */
  readonly keepToken?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#token_source DataK8SGatewaySoloIoRouteOptionV1Manifest#token_source}
  */
  readonly tokenSource?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    claims_to_headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersToTerraform, false)(struct!.claimsToHeaders),
    clock_skew_seconds: cdktf.numberToTerraform(struct!.clockSkewSeconds),
    issuer: cdktf.stringToTerraform(struct!.issuer),
    jwks: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksToTerraform(struct!.jwks),
    keep_token: cdktf.booleanToTerraform(struct!.keepToken),
    token_source: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceToTerraform(struct!.tokenSource),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    claims_to_headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersToHclTerraform, false)(struct!.claimsToHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersList",
    },
    clock_skew_seconds: {
      value: cdktf.numberToHclTerraform(struct!.clockSkewSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    issuer: {
      value: cdktf.stringToHclTerraform(struct!.issuer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jwks: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksToHclTerraform(struct!.jwks),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwks",
    },
    keep_token: {
      value: cdktf.booleanToHclTerraform(struct!.keepToken),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    token_source: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceToHclTerraform(struct!.tokenSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProviders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._claimsToHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claimsToHeaders = this._claimsToHeaders?.internalValue;
    }
    if (this._clockSkewSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.clockSkewSeconds = this._clockSkewSeconds;
    }
    if (this._issuer !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuer = this._issuer;
    }
    if (this._jwks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwks = this._jwks?.internalValue;
    }
    if (this._keepToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepToken = this._keepToken;
    }
    if (this._tokenSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSource = this._tokenSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProviders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._claimsToHeaders.internalValue = undefined;
      this._clockSkewSeconds = undefined;
      this._issuer = undefined;
      this._jwks.internalValue = undefined;
      this._keepToken = undefined;
      this._tokenSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._claimsToHeaders.internalValue = value.claimsToHeaders;
      this._clockSkewSeconds = value.clockSkewSeconds;
      this._issuer = value.issuer;
      this._jwks.internalValue = value.jwks;
      this._keepToken = value.keepToken;
      this._tokenSource.internalValue = value.tokenSource;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // claims_to_headers - computed: false, optional: true, required: false
  private _claimsToHeaders = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersList(this, "claims_to_headers", false);
  public get claimsToHeaders() {
    return this._claimsToHeaders;
  }
  public putClaimsToHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable) {
    this._claimsToHeaders.internalValue = value;
  }
  public resetClaimsToHeaders() {
    this._claimsToHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsToHeadersInput() {
    return this._claimsToHeaders.internalValue;
  }

  // clock_skew_seconds - computed: false, optional: true, required: false
  private _clockSkewSeconds?: number; 
  public get clockSkewSeconds() {
    return this.getNumberAttribute('clock_skew_seconds');
  }
  public set clockSkewSeconds(value: number) {
    this._clockSkewSeconds = value;
  }
  public resetClockSkewSeconds() {
    this._clockSkewSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clockSkewSecondsInput() {
    return this._clockSkewSeconds;
  }

  // issuer - computed: false, optional: true, required: false
  private _issuer?: string; 
  public get issuer() {
    return this.getStringAttribute('issuer');
  }
  public set issuer(value: string) {
    this._issuer = value;
  }
  public resetIssuer() {
    this._issuer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuerInput() {
    return this._issuer;
  }

  // jwks - computed: false, optional: true, required: false
  private _jwks = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwksOutputReference(this, "jwks");
  public get jwks() {
    return this._jwks;
  }
  public putJwks(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersJwks) {
    this._jwks.internalValue = value;
  }
  public resetJwks() {
    this._jwks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwksInput() {
    return this._jwks.internalValue;
  }

  // keep_token - computed: false, optional: true, required: false
  private _keepToken?: boolean | cdktf.IResolvable; 
  public get keepToken() {
    return this.getBooleanAttribute('keep_token');
  }
  public set keepToken(value: boolean | cdktf.IResolvable) {
    this._keepToken = value;
  }
  public resetKeepToken() {
    this._keepToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepTokenInput() {
    return this._keepToken;
  }

  // token_source - computed: false, optional: true, required: false
  private _tokenSource = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceOutputReference(this, "token_source");
  public get tokenSource() {
    return this._tokenSource;
  }
  public putTokenSource(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource) {
    this._tokenSource.internalValue = value;
  }
  public resetTokenSource() {
    this._tokenSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSourceInput() {
    return this._tokenSource.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#allow_missing_or_failed_jwt DataK8SGatewaySoloIoRouteOptionV1Manifest#allow_missing_or_failed_jwt}
  */
  readonly allowMissingOrFailedJwt?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#providers DataK8SGatewaySoloIoRouteOptionV1Manifest#providers}
  */
  readonly providers?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProviders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#validation_policy DataK8SGatewaySoloIoRouteOptionV1Manifest#validation_policy}
  */
  readonly validationPolicy?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_missing_or_failed_jwt: cdktf.booleanToTerraform(struct!.allowMissingOrFailedJwt),
    providers: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersToTerraform(struct!.providers),
    validation_policy: cdktf.stringToTerraform(struct!.validationPolicy),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_missing_or_failed_jwt: {
      value: cdktf.booleanToHclTerraform(struct!.allowMissingOrFailedJwt),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    providers: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersToHclTerraform(struct!.providers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProviders",
    },
    validation_policy: {
      value: cdktf.stringToHclTerraform(struct!.validationPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowMissingOrFailedJwt !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowMissingOrFailedJwt = this._allowMissingOrFailedJwt;
    }
    if (this._providers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.providers = this._providers?.internalValue;
    }
    if (this._validationPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.validationPolicy = this._validationPolicy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowMissingOrFailedJwt = undefined;
      this._providers.internalValue = undefined;
      this._validationPolicy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowMissingOrFailedJwt = value.allowMissingOrFailedJwt;
      this._providers.internalValue = value.providers;
      this._validationPolicy = value.validationPolicy;
    }
  }

  // allow_missing_or_failed_jwt - computed: false, optional: true, required: false
  private _allowMissingOrFailedJwt?: boolean | cdktf.IResolvable; 
  public get allowMissingOrFailedJwt() {
    return this.getBooleanAttribute('allow_missing_or_failed_jwt');
  }
  public set allowMissingOrFailedJwt(value: boolean | cdktf.IResolvable) {
    this._allowMissingOrFailedJwt = value;
  }
  public resetAllowMissingOrFailedJwt() {
    this._allowMissingOrFailedJwt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowMissingOrFailedJwtInput() {
    return this._allowMissingOrFailedJwt;
  }

  // providers - computed: false, optional: true, required: false
  private _providers = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProvidersOutputReference(this, "providers");
  public get providers() {
    return this._providers;
  }
  public putProviders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthProviders) {
    this._providers.internalValue = value;
  }
  public resetProviders() {
    this._providers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providersInput() {
    return this._providers.internalValue;
  }

  // validation_policy - computed: false, optional: true, required: false
  private _validationPolicy?: string; 
  public get validationPolicy() {
    return this.getStringAttribute('validation_policy');
  }
  public set validationPolicy(value: string) {
    this._validationPolicy = value;
  }
  public resetValidationPolicy() {
    this._validationPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validationPolicyInput() {
    return this._validationPolicy;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#append DataK8SGatewaySoloIoRouteOptionV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#claim DataK8SGatewaySoloIoRouteOptionV1Manifest#claim}
  */
  readonly claim?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header DataK8SGatewaySoloIoRouteOptionV1Manifest#header}
  */
  readonly header?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    claim: cdktf.stringToTerraform(struct!.claim),
    header: cdktf.stringToTerraform(struct!.header),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    claim: {
      value: cdktf.stringToHclTerraform(struct!.claim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._claim !== undefined) {
      hasAnyValues = true;
      internalValueResult.claim = this._claim;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._claim = undefined;
      this._header = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._claim = value.claim;
      this._header = value.header;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // claim - computed: false, optional: true, required: false
  private _claim?: string; 
  public get claim() {
    return this.getStringAttribute('claim');
  }
  public set claim(value: string) {
    this._claim = value;
  }
  public resetClaim() {
    this._claim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimInput() {
    return this._claim;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#fast_listener DataK8SGatewaySoloIoRouteOptionV1Manifest#fast_listener}
  */
  readonly fastListener?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fast_listener: cdktf.booleanToTerraform(struct!.fastListener),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fast_listener: {
      value: cdktf.booleanToHclTerraform(struct!.fastListener),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fastListener !== undefined) {
      hasAnyValues = true;
      internalValueResult.fastListener = this._fastListener;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fastListener = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fastListener = value.fastListener;
    }
  }

  // fast_listener - computed: false, optional: true, required: false
  private _fastListener?: boolean | cdktf.IResolvable; 
  public get fastListener() {
    return this.getBooleanAttribute('fast_listener');
  }
  public set fastListener(value: boolean | cdktf.IResolvable) {
    this._fastListener = value;
  }
  public resetFastListener() {
    this._fastListener = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fastListenerInput() {
    return this._fastListener;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#async_fetch DataK8SGatewaySoloIoRouteOptionV1Manifest#async_fetch}
  */
  readonly asyncFetch?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#cache_duration DataK8SGatewaySoloIoRouteOptionV1Manifest#cache_duration}
  */
  readonly cacheDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#upstream_ref DataK8SGatewaySoloIoRouteOptionV1Manifest#upstream_ref}
  */
  readonly upstreamRef?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#url DataK8SGatewaySoloIoRouteOptionV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    async_fetch: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchToTerraform(struct!.asyncFetch),
    cache_duration: cdktf.stringToTerraform(struct!.cacheDuration),
    upstream_ref: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefToTerraform(struct!.upstreamRef),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    async_fetch: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchToHclTerraform(struct!.asyncFetch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch",
    },
    cache_duration: {
      value: cdktf.stringToHclTerraform(struct!.cacheDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    upstream_ref: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefToHclTerraform(struct!.upstreamRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asyncFetch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncFetch = this._asyncFetch?.internalValue;
    }
    if (this._cacheDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheDuration = this._cacheDuration;
    }
    if (this._upstreamRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upstreamRef = this._upstreamRef?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asyncFetch.internalValue = undefined;
      this._cacheDuration = undefined;
      this._upstreamRef.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asyncFetch.internalValue = value.asyncFetch;
      this._cacheDuration = value.cacheDuration;
      this._upstreamRef.internalValue = value.upstreamRef;
      this._url = value.url;
    }
  }

  // async_fetch - computed: false, optional: true, required: false
  private _asyncFetch = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchOutputReference(this, "async_fetch");
  public get asyncFetch() {
    return this._asyncFetch;
  }
  public putAsyncFetch(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch) {
    this._asyncFetch.internalValue = value;
  }
  public resetAsyncFetch() {
    this._asyncFetch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncFetchInput() {
    return this._asyncFetch.internalValue;
  }

  // cache_duration - computed: false, optional: true, required: false
  private _cacheDuration?: string; 
  public get cacheDuration() {
    return this.getStringAttribute('cache_duration');
  }
  public set cacheDuration(value: string) {
    this._cacheDuration = value;
  }
  public resetCacheDuration() {
    this._cacheDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheDurationInput() {
    return this._cacheDuration;
  }

  // upstream_ref - computed: false, optional: true, required: false
  private _upstreamRef = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefOutputReference(this, "upstream_ref");
  public get upstreamRef() {
    return this._upstreamRef;
  }
  public putUpstreamRef(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef) {
    this._upstreamRef.internalValue = value;
  }
  public resetUpstreamRef() {
    this._upstreamRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upstreamRefInput() {
    return this._upstreamRef.internalValue;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#local DataK8SGatewaySoloIoRouteOptionV1Manifest#local}
  */
  readonly local?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#remote DataK8SGatewaySoloIoRouteOptionV1Manifest#remote}
  */
  readonly remote?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    local: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalToTerraform(struct!.local),
    remote: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteToTerraform(struct!.remote),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    local: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalToHclTerraform(struct!.local),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal",
    },
    remote: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteToHclTerraform(struct!.remote),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._local?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.local = this._local?.internalValue;
    }
    if (this._remote?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remote = this._remote?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._local.internalValue = undefined;
      this._remote.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._local.internalValue = value.local;
      this._remote.internalValue = value.remote;
    }
  }

  // local - computed: false, optional: true, required: false
  private _local = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalOutputReference(this, "local");
  public get local() {
    return this._local;
  }
  public putLocal(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal) {
    this._local.internalValue = value;
  }
  public resetLocal() {
    this._local.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localInput() {
    return this._local.internalValue;
  }

  // remote - computed: false, optional: true, required: false
  private _remote = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteOutputReference(this, "remote");
  public get remote() {
    return this._remote;
  }
  public putRemote(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote) {
    this._remote.internalValue = value;
  }
  public resetRemote() {
    this._remote.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteInput() {
    return this._remote.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header DataK8SGatewaySoloIoRouteOptionV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prefix DataK8SGatewaySoloIoRouteOptionV1Manifest#prefix}
  */
  readonly prefix?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header: cdktf.stringToTerraform(struct!.header),
    prefix: cdktf.stringToTerraform(struct!.prefix),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._header = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._header = value.header;
      this._prefix = value.prefix;
    }
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#headers DataK8SGatewaySoloIoRouteOptionV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#query_params DataK8SGatewaySoloIoRouteOptionV1Manifest#query_params}
  */
  readonly queryParams?: string[];
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersToTerraform, false)(struct!.headers),
    query_params: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersList",
    },
    query_params: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.queryParams),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._queryParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._queryParams = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._queryParams = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams?: string[]; 
  public get queryParams() {
    return this.getListAttribute('query_params');
  }
  public set queryParams(value: string[]) {
    this._queryParams = value;
  }
  public resetQueryParams() {
    this._queryParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProviders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#audiences DataK8SGatewaySoloIoRouteOptionV1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#claims_to_headers DataK8SGatewaySoloIoRouteOptionV1Manifest#claims_to_headers}
  */
  readonly claimsToHeaders?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#clock_skew_seconds DataK8SGatewaySoloIoRouteOptionV1Manifest#clock_skew_seconds}
  */
  readonly clockSkewSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#issuer DataK8SGatewaySoloIoRouteOptionV1Manifest#issuer}
  */
  readonly issuer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#jwks DataK8SGatewaySoloIoRouteOptionV1Manifest#jwks}
  */
  readonly jwks?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#keep_token DataK8SGatewaySoloIoRouteOptionV1Manifest#keep_token}
  */
  readonly keepToken?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#token_source DataK8SGatewaySoloIoRouteOptionV1Manifest#token_source}
  */
  readonly tokenSource?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    claims_to_headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersToTerraform, false)(struct!.claimsToHeaders),
    clock_skew_seconds: cdktf.numberToTerraform(struct!.clockSkewSeconds),
    issuer: cdktf.stringToTerraform(struct!.issuer),
    jwks: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksToTerraform(struct!.jwks),
    keep_token: cdktf.booleanToTerraform(struct!.keepToken),
    token_source: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceToTerraform(struct!.tokenSource),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    claims_to_headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersToHclTerraform, false)(struct!.claimsToHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersList",
    },
    clock_skew_seconds: {
      value: cdktf.numberToHclTerraform(struct!.clockSkewSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    issuer: {
      value: cdktf.stringToHclTerraform(struct!.issuer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jwks: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksToHclTerraform(struct!.jwks),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks",
    },
    keep_token: {
      value: cdktf.booleanToHclTerraform(struct!.keepToken),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    token_source: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceToHclTerraform(struct!.tokenSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProviders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._claimsToHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claimsToHeaders = this._claimsToHeaders?.internalValue;
    }
    if (this._clockSkewSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.clockSkewSeconds = this._clockSkewSeconds;
    }
    if (this._issuer !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuer = this._issuer;
    }
    if (this._jwks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwks = this._jwks?.internalValue;
    }
    if (this._keepToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepToken = this._keepToken;
    }
    if (this._tokenSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSource = this._tokenSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProviders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._claimsToHeaders.internalValue = undefined;
      this._clockSkewSeconds = undefined;
      this._issuer = undefined;
      this._jwks.internalValue = undefined;
      this._keepToken = undefined;
      this._tokenSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._claimsToHeaders.internalValue = value.claimsToHeaders;
      this._clockSkewSeconds = value.clockSkewSeconds;
      this._issuer = value.issuer;
      this._jwks.internalValue = value.jwks;
      this._keepToken = value.keepToken;
      this._tokenSource.internalValue = value.tokenSource;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // claims_to_headers - computed: false, optional: true, required: false
  private _claimsToHeaders = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersList(this, "claims_to_headers", false);
  public get claimsToHeaders() {
    return this._claimsToHeaders;
  }
  public putClaimsToHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable) {
    this._claimsToHeaders.internalValue = value;
  }
  public resetClaimsToHeaders() {
    this._claimsToHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsToHeadersInput() {
    return this._claimsToHeaders.internalValue;
  }

  // clock_skew_seconds - computed: false, optional: true, required: false
  private _clockSkewSeconds?: number; 
  public get clockSkewSeconds() {
    return this.getNumberAttribute('clock_skew_seconds');
  }
  public set clockSkewSeconds(value: number) {
    this._clockSkewSeconds = value;
  }
  public resetClockSkewSeconds() {
    this._clockSkewSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clockSkewSecondsInput() {
    return this._clockSkewSeconds;
  }

  // issuer - computed: false, optional: true, required: false
  private _issuer?: string; 
  public get issuer() {
    return this.getStringAttribute('issuer');
  }
  public set issuer(value: string) {
    this._issuer = value;
  }
  public resetIssuer() {
    this._issuer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuerInput() {
    return this._issuer;
  }

  // jwks - computed: false, optional: true, required: false
  private _jwks = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksOutputReference(this, "jwks");
  public get jwks() {
    return this._jwks;
  }
  public putJwks(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks) {
    this._jwks.internalValue = value;
  }
  public resetJwks() {
    this._jwks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwksInput() {
    return this._jwks.internalValue;
  }

  // keep_token - computed: false, optional: true, required: false
  private _keepToken?: boolean | cdktf.IResolvable; 
  public get keepToken() {
    return this.getBooleanAttribute('keep_token');
  }
  public set keepToken(value: boolean | cdktf.IResolvable) {
    this._keepToken = value;
  }
  public resetKeepToken() {
    this._keepToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepTokenInput() {
    return this._keepToken;
  }

  // token_source - computed: false, optional: true, required: false
  private _tokenSource = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceOutputReference(this, "token_source");
  public get tokenSource() {
    return this._tokenSource;
  }
  public putTokenSource(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource) {
    this._tokenSource.internalValue = value;
  }
  public resetTokenSource() {
    this._tokenSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSourceInput() {
    return this._tokenSource.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#allow_missing_or_failed_jwt DataK8SGatewaySoloIoRouteOptionV1Manifest#allow_missing_or_failed_jwt}
  */
  readonly allowMissingOrFailedJwt?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#providers DataK8SGatewaySoloIoRouteOptionV1Manifest#providers}
  */
  readonly providers?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProviders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#validation_policy DataK8SGatewaySoloIoRouteOptionV1Manifest#validation_policy}
  */
  readonly validationPolicy?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_missing_or_failed_jwt: cdktf.booleanToTerraform(struct!.allowMissingOrFailedJwt),
    providers: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersToTerraform(struct!.providers),
    validation_policy: cdktf.stringToTerraform(struct!.validationPolicy),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_missing_or_failed_jwt: {
      value: cdktf.booleanToHclTerraform(struct!.allowMissingOrFailedJwt),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    providers: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersToHclTerraform(struct!.providers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProviders",
    },
    validation_policy: {
      value: cdktf.stringToHclTerraform(struct!.validationPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowMissingOrFailedJwt !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowMissingOrFailedJwt = this._allowMissingOrFailedJwt;
    }
    if (this._providers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.providers = this._providers?.internalValue;
    }
    if (this._validationPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.validationPolicy = this._validationPolicy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowMissingOrFailedJwt = undefined;
      this._providers.internalValue = undefined;
      this._validationPolicy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowMissingOrFailedJwt = value.allowMissingOrFailedJwt;
      this._providers.internalValue = value.providers;
      this._validationPolicy = value.validationPolicy;
    }
  }

  // allow_missing_or_failed_jwt - computed: false, optional: true, required: false
  private _allowMissingOrFailedJwt?: boolean | cdktf.IResolvable; 
  public get allowMissingOrFailedJwt() {
    return this.getBooleanAttribute('allow_missing_or_failed_jwt');
  }
  public set allowMissingOrFailedJwt(value: boolean | cdktf.IResolvable) {
    this._allowMissingOrFailedJwt = value;
  }
  public resetAllowMissingOrFailedJwt() {
    this._allowMissingOrFailedJwt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowMissingOrFailedJwtInput() {
    return this._allowMissingOrFailedJwt;
  }

  // providers - computed: false, optional: true, required: false
  private _providers = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProvidersOutputReference(this, "providers");
  public get providers() {
    return this._providers;
  }
  public putProviders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthProviders) {
    this._providers.internalValue = value;
  }
  public resetProviders() {
    this._providers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providersInput() {
    return this._providers.internalValue;
  }

  // validation_policy - computed: false, optional: true, required: false
  private _validationPolicy?: string; 
  public get validationPolicy() {
    return this.getStringAttribute('validation_policy');
  }
  public set validationPolicy(value: string) {
    this._validationPolicy = value;
  }
  public resetValidationPolicy() {
    this._validationPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validationPolicyInput() {
    return this._validationPolicy;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStaged {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#after_ext_auth DataK8SGatewaySoloIoRouteOptionV1Manifest#after_ext_auth}
  */
  readonly afterExtAuth?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#before_ext_auth DataK8SGatewaySoloIoRouteOptionV1Manifest#before_ext_auth}
  */
  readonly beforeExtAuth?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuth;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStaged | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    after_ext_auth: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthToTerraform(struct!.afterExtAuth),
    before_ext_auth: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthToTerraform(struct!.beforeExtAuth),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStaged | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    after_ext_auth: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthToHclTerraform(struct!.afterExtAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuth",
    },
    before_ext_auth: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthToHclTerraform(struct!.beforeExtAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuth",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStaged | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._afterExtAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.afterExtAuth = this._afterExtAuth?.internalValue;
    }
    if (this._beforeExtAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.beforeExtAuth = this._beforeExtAuth?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStaged | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._afterExtAuth.internalValue = undefined;
      this._beforeExtAuth.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._afterExtAuth.internalValue = value.afterExtAuth;
      this._beforeExtAuth.internalValue = value.beforeExtAuth;
    }
  }

  // after_ext_auth - computed: false, optional: true, required: false
  private _afterExtAuth = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuthOutputReference(this, "after_ext_auth");
  public get afterExtAuth() {
    return this._afterExtAuth;
  }
  public putAfterExtAuth(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedAfterExtAuth) {
    this._afterExtAuth.internalValue = value;
  }
  public resetAfterExtAuth() {
    this._afterExtAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get afterExtAuthInput() {
    return this._afterExtAuth.internalValue;
  }

  // before_ext_auth - computed: false, optional: true, required: false
  private _beforeExtAuth = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuthOutputReference(this, "before_ext_auth");
  public get beforeExtAuth() {
    return this._beforeExtAuth;
  }
  public putBeforeExtAuth(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtProvidersStagedBeforeExtAuth) {
    this._beforeExtAuth.internalValue = value;
  }
  public resetBeforeExtAuth() {
    this._beforeExtAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get beforeExtAuthInput() {
    return this._beforeExtAuth.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#disable DataK8SGatewaySoloIoRouteOptionV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuthToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disable = value.disable;
    }
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#disable DataK8SGatewaySoloIoRouteOptionV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuthToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disable = value.disable;
    }
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStaged {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#after_ext_auth DataK8SGatewaySoloIoRouteOptionV1Manifest#after_ext_auth}
  */
  readonly afterExtAuth?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#before_ext_auth DataK8SGatewaySoloIoRouteOptionV1Manifest#before_ext_auth}
  */
  readonly beforeExtAuth?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuth;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStaged | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    after_ext_auth: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuthToTerraform(struct!.afterExtAuth),
    before_ext_auth: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuthToTerraform(struct!.beforeExtAuth),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStaged | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    after_ext_auth: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuthToHclTerraform(struct!.afterExtAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuth",
    },
    before_ext_auth: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuthToHclTerraform(struct!.beforeExtAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuth",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStaged | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._afterExtAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.afterExtAuth = this._afterExtAuth?.internalValue;
    }
    if (this._beforeExtAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.beforeExtAuth = this._beforeExtAuth?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStaged | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._afterExtAuth.internalValue = undefined;
      this._beforeExtAuth.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._afterExtAuth.internalValue = value.afterExtAuth;
      this._beforeExtAuth.internalValue = value.beforeExtAuth;
    }
  }

  // after_ext_auth - computed: false, optional: true, required: false
  private _afterExtAuth = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuthOutputReference(this, "after_ext_auth");
  public get afterExtAuth() {
    return this._afterExtAuth;
  }
  public putAfterExtAuth(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedAfterExtAuth) {
    this._afterExtAuth.internalValue = value;
  }
  public resetAfterExtAuth() {
    this._afterExtAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get afterExtAuthInput() {
    return this._afterExtAuth.internalValue;
  }

  // before_ext_auth - computed: false, optional: true, required: false
  private _beforeExtAuth = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuthOutputReference(this, "before_ext_auth");
  public get beforeExtAuth() {
    return this._beforeExtAuth;
  }
  public putBeforeExtAuth(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsJwtStagedBeforeExtAuth) {
    this._beforeExtAuth.internalValue = value;
  }
  public resetBeforeExtAuth() {
    this._beforeExtAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get beforeExtAuthInput() {
    return this._beforeExtAuth.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookie {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#path DataK8SGatewaySoloIoRouteOptionV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#ttl DataK8SGatewaySoloIoRouteOptionV1Manifest#ttl}
  */
  readonly ttl?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookieToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    ttl: cdktf.stringToTerraform(struct!.ttl),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookieToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookieOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookie | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookie | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
      this._ttl = value.ttl;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPolicies {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#cookie DataK8SGatewaySoloIoRouteOptionV1Manifest#cookie}
  */
  readonly cookie?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookie;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header DataK8SGatewaySoloIoRouteOptionV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#source_ip DataK8SGatewaySoloIoRouteOptionV1Manifest#source_ip}
  */
  readonly sourceIp?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#terminal DataK8SGatewaySoloIoRouteOptionV1Manifest#terminal}
  */
  readonly terminal?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPolicies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookie: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookieToTerraform(struct!.cookie),
    header: cdktf.stringToTerraform(struct!.header),
    source_ip: cdktf.booleanToTerraform(struct!.sourceIp),
    terminal: cdktf.booleanToTerraform(struct!.terminal),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPolicies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookie: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookieToHclTerraform(struct!.cookie),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookie",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_ip: {
      value: cdktf.booleanToHclTerraform(struct!.sourceIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    terminal: {
      value: cdktf.booleanToHclTerraform(struct!.terminal),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPolicies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookie?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookie = this._cookie?.internalValue;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._sourceIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceIp = this._sourceIp;
    }
    if (this._terminal !== undefined) {
      hasAnyValues = true;
      internalValueResult.terminal = this._terminal;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPolicies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookie.internalValue = undefined;
      this._header = undefined;
      this._sourceIp = undefined;
      this._terminal = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookie.internalValue = value.cookie;
      this._header = value.header;
      this._sourceIp = value.sourceIp;
      this._terminal = value.terminal;
    }
  }

  // cookie - computed: false, optional: true, required: false
  private _cookie = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookieOutputReference(this, "cookie");
  public get cookie() {
    return this._cookie;
  }
  public putCookie(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesCookie) {
    this._cookie.internalValue = value;
  }
  public resetCookie() {
    this._cookie.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookieInput() {
    return this._cookie.internalValue;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // source_ip - computed: false, optional: true, required: false
  private _sourceIp?: boolean | cdktf.IResolvable; 
  public get sourceIp() {
    return this.getBooleanAttribute('source_ip');
  }
  public set sourceIp(value: boolean | cdktf.IResolvable) {
    this._sourceIp = value;
  }
  public resetSourceIp() {
    this._sourceIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceIpInput() {
    return this._sourceIp;
  }

  // terminal - computed: false, optional: true, required: false
  private _terminal?: boolean | cdktf.IResolvable; 
  public get terminal() {
    return this.getBooleanAttribute('terminal');
  }
  public set terminal(value: boolean | cdktf.IResolvable) {
    this._terminal = value;
  }
  public resetTerminal() {
    this._terminal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get terminalInput() {
    return this._terminal;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPolicies[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHash {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#hash_policies DataK8SGatewaySoloIoRouteOptionV1Manifest#hash_policies}
  */
  readonly hashPolicies?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPolicies[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHash | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hash_policies: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesToTerraform, false)(struct!.hashPolicies),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHash | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hash_policies: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesToHclTerraform, false)(struct!.hashPolicies),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHash | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hashPolicies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashPolicies = this._hashPolicies?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHash | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hashPolicies.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hashPolicies.internalValue = value.hashPolicies;
    }
  }

  // hash_policies - computed: false, optional: true, required: false
  private _hashPolicies = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPoliciesList(this, "hash_policies", false);
  public get hashPolicies() {
    return this._hashPolicies;
  }
  public putHashPolicies(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsLbHashHashPolicies[] | cdktf.IResolvable) {
    this._hashPolicies.internalValue = value;
  }
  public resetHashPolicies() {
    this._hashPolicies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashPoliciesInput() {
    return this._hashPolicies.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsMaxStreamDuration {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#grpc_timeout_header_max DataK8SGatewaySoloIoRouteOptionV1Manifest#grpc_timeout_header_max}
  */
  readonly grpcTimeoutHeaderMax?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#grpc_timeout_header_offset DataK8SGatewaySoloIoRouteOptionV1Manifest#grpc_timeout_header_offset}
  */
  readonly grpcTimeoutHeaderOffset?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#max_stream_duration DataK8SGatewaySoloIoRouteOptionV1Manifest#max_stream_duration}
  */
  readonly maxStreamDuration?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsMaxStreamDurationToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsMaxStreamDuration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    grpc_timeout_header_max: cdktf.stringToTerraform(struct!.grpcTimeoutHeaderMax),
    grpc_timeout_header_offset: cdktf.stringToTerraform(struct!.grpcTimeoutHeaderOffset),
    max_stream_duration: cdktf.stringToTerraform(struct!.maxStreamDuration),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsMaxStreamDurationToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsMaxStreamDuration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    grpc_timeout_header_max: {
      value: cdktf.stringToHclTerraform(struct!.grpcTimeoutHeaderMax),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    grpc_timeout_header_offset: {
      value: cdktf.stringToHclTerraform(struct!.grpcTimeoutHeaderOffset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_stream_duration: {
      value: cdktf.stringToHclTerraform(struct!.maxStreamDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsMaxStreamDurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsMaxStreamDuration | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._grpcTimeoutHeaderMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcTimeoutHeaderMax = this._grpcTimeoutHeaderMax;
    }
    if (this._grpcTimeoutHeaderOffset !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcTimeoutHeaderOffset = this._grpcTimeoutHeaderOffset;
    }
    if (this._maxStreamDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxStreamDuration = this._maxStreamDuration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsMaxStreamDuration | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._grpcTimeoutHeaderMax = undefined;
      this._grpcTimeoutHeaderOffset = undefined;
      this._maxStreamDuration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._grpcTimeoutHeaderMax = value.grpcTimeoutHeaderMax;
      this._grpcTimeoutHeaderOffset = value.grpcTimeoutHeaderOffset;
      this._maxStreamDuration = value.maxStreamDuration;
    }
  }

  // grpc_timeout_header_max - computed: false, optional: true, required: false
  private _grpcTimeoutHeaderMax?: string; 
  public get grpcTimeoutHeaderMax() {
    return this.getStringAttribute('grpc_timeout_header_max');
  }
  public set grpcTimeoutHeaderMax(value: string) {
    this._grpcTimeoutHeaderMax = value;
  }
  public resetGrpcTimeoutHeaderMax() {
    this._grpcTimeoutHeaderMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcTimeoutHeaderMaxInput() {
    return this._grpcTimeoutHeaderMax;
  }

  // grpc_timeout_header_offset - computed: false, optional: true, required: false
  private _grpcTimeoutHeaderOffset?: string; 
  public get grpcTimeoutHeaderOffset() {
    return this.getStringAttribute('grpc_timeout_header_offset');
  }
  public set grpcTimeoutHeaderOffset(value: string) {
    this._grpcTimeoutHeaderOffset = value;
  }
  public resetGrpcTimeoutHeaderOffset() {
    this._grpcTimeoutHeaderOffset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcTimeoutHeaderOffsetInput() {
    return this._grpcTimeoutHeaderOffset;
  }

  // max_stream_duration - computed: false, optional: true, required: false
  private _maxStreamDuration?: string; 
  public get maxStreamDuration() {
    return this.getStringAttribute('max_stream_duration');
  }
  public set maxStreamDuration(value: string) {
    this._maxStreamDuration = value;
  }
  public resetMaxStreamDuration() {
    this._maxStreamDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxStreamDurationInput() {
    return this._maxStreamDuration;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#refs DataK8SGatewaySoloIoRouteOptionV1Manifest#refs}
  */
  readonly refs?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefs[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    refs: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefsToTerraform, false)(struct!.refs),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    refs: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefsToHclTerraform, false)(struct!.refs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._refs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.refs = this._refs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._refs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._refs.internalValue = value.refs;
    }
  }

  // refs - computed: false, optional: true, required: false
  private _refs = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefsList(this, "refs", false);
  public get refs() {
    return this._refs;
  }
  public putRefs(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitConfigsRefs[] | cdktf.IResolvable) {
    this._refs.internalValue = value;
  }
  public resetRefs() {
    this._refs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refsInput() {
    return this._refs.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#refs DataK8SGatewaySoloIoRouteOptionV1Manifest#refs}
  */
  readonly refs?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefs[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    refs: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefsToTerraform, false)(struct!.refs),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    refs: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefsToHclTerraform, false)(struct!.refs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._refs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.refs = this._refs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._refs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._refs.internalValue = value.refs;
    }
  }

  // refs - computed: false, optional: true, required: false
  private _refs = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefsList(this, "refs", false);
  public get refs() {
    return this._refs;
  }
  public putRefs(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitEarlyConfigsRefs[] | cdktf.IResolvable) {
    this._refs.internalValue = value;
  }
  public resetRefs() {
    this._refs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refsInput() {
    return this._refs.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#namespace DataK8SGatewaySoloIoRouteOptionV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#refs DataK8SGatewaySoloIoRouteOptionV1Manifest#refs}
  */
  readonly refs?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefs[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    refs: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefsToTerraform, false)(struct!.refs),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    refs: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefsToHclTerraform, false)(struct!.refs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._refs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.refs = this._refs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._refs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._refs.internalValue = value.refs;
    }
  }

  // refs - computed: false, optional: true, required: false
  private _refs = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefsList(this, "refs", false);
  public get refs() {
    return this._refs;
  }
  public putRefs(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRateLimitRegularConfigsRefs[] | cdktf.IResolvable) {
    this._refs.internalValue = value;
  }
  public resetRefs() {
    this._refs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refsInput() {
    return this._refs.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#fill_interval DataK8SGatewaySoloIoRouteOptionV1Manifest#fill_interval}
  */
  readonly fillInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#max_tokens DataK8SGatewaySoloIoRouteOptionV1Manifest#max_tokens}
  */
  readonly maxTokens?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#tokens_per_fill DataK8SGatewaySoloIoRouteOptionV1Manifest#tokens_per_fill}
  */
  readonly tokensPerFill?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimitToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fill_interval: cdktf.stringToTerraform(struct!.fillInterval),
    max_tokens: cdktf.numberToTerraform(struct!.maxTokens),
    tokens_per_fill: cdktf.numberToTerraform(struct!.tokensPerFill),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fill_interval: {
      value: cdktf.stringToHclTerraform(struct!.fillInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_tokens: {
      value: cdktf.numberToHclTerraform(struct!.maxTokens),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tokens_per_fill: {
      value: cdktf.numberToHclTerraform(struct!.tokensPerFill),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fillInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.fillInterval = this._fillInterval;
    }
    if (this._maxTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTokens = this._maxTokens;
    }
    if (this._tokensPerFill !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokensPerFill = this._tokensPerFill;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fillInterval = undefined;
      this._maxTokens = undefined;
      this._tokensPerFill = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fillInterval = value.fillInterval;
      this._maxTokens = value.maxTokens;
      this._tokensPerFill = value.tokensPerFill;
    }
  }

  // fill_interval - computed: false, optional: true, required: false
  private _fillInterval?: string; 
  public get fillInterval() {
    return this.getStringAttribute('fill_interval');
  }
  public set fillInterval(value: string) {
    this._fillInterval = value;
  }
  public resetFillInterval() {
    this._fillInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fillIntervalInput() {
    return this._fillInterval;
  }

  // max_tokens - computed: false, optional: true, required: false
  private _maxTokens?: number; 
  public get maxTokens() {
    return this.getNumberAttribute('max_tokens');
  }
  public set maxTokens(value: number) {
    this._maxTokens = value;
  }
  public resetMaxTokens() {
    this._maxTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTokensInput() {
    return this._maxTokens;
  }

  // tokens_per_fill - computed: false, optional: true, required: false
  private _tokensPerFill?: number; 
  public get tokensPerFill() {
    return this.getNumberAttribute('tokens_per_fill');
  }
  public set tokensPerFill(value: number) {
    this._tokensPerFill = value;
  }
  public resetTokensPerFill() {
    this._tokensPerFill = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokensPerFillInput() {
    return this._tokensPerFill;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#end DataK8SGatewaySoloIoRouteOptionV1Manifest#end}
  */
  readonly end?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#start DataK8SGatewaySoloIoRouteOptionV1Manifest#start}
  */
  readonly start?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.numberToTerraform(struct!.end),
    start: cdktf.numberToTerraform(struct!.start),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: true, required: false
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  public resetStart() {
    this._start = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#exact_match DataK8SGatewaySoloIoRouteOptionV1Manifest#exact_match}
  */
  readonly exactMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#invert_match DataK8SGatewaySoloIoRouteOptionV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prefix_match DataK8SGatewaySoloIoRouteOptionV1Manifest#prefix_match}
  */
  readonly prefixMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#present_match DataK8SGatewaySoloIoRouteOptionV1Manifest#present_match}
  */
  readonly presentMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#range_match DataK8SGatewaySoloIoRouteOptionV1Manifest#range_match}
  */
  readonly rangeMatch?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex_match DataK8SGatewaySoloIoRouteOptionV1Manifest#regex_match}
  */
  readonly regexMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#suffix_match DataK8SGatewaySoloIoRouteOptionV1Manifest#suffix_match}
  */
  readonly suffixMatch?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact_match: cdktf.stringToTerraform(struct!.exactMatch),
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    prefix_match: cdktf.stringToTerraform(struct!.prefixMatch),
    present_match: cdktf.booleanToTerraform(struct!.presentMatch),
    range_match: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct!.rangeMatch),
    regex_match: cdktf.stringToTerraform(struct!.regexMatch),
    suffix_match: cdktf.stringToTerraform(struct!.suffixMatch),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact_match: {
      value: cdktf.stringToHclTerraform(struct!.exactMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_match: {
      value: cdktf.stringToHclTerraform(struct!.prefixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    present_match: {
      value: cdktf.booleanToHclTerraform(struct!.presentMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    range_match: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct!.rangeMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch",
    },
    regex_match: {
      value: cdktf.stringToHclTerraform(struct!.regexMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suffix_match: {
      value: cdktf.stringToHclTerraform(struct!.suffixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exactMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.exactMatch = this._exactMatch;
    }
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._prefixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixMatch = this._prefixMatch;
    }
    if (this._presentMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.presentMatch = this._presentMatch;
    }
    if (this._rangeMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rangeMatch = this._rangeMatch?.internalValue;
    }
    if (this._regexMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexMatch = this._regexMatch;
    }
    if (this._suffixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffixMatch = this._suffixMatch;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exactMatch = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._prefixMatch = undefined;
      this._presentMatch = undefined;
      this._rangeMatch.internalValue = undefined;
      this._regexMatch = undefined;
      this._suffixMatch = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exactMatch = value.exactMatch;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._prefixMatch = value.prefixMatch;
      this._presentMatch = value.presentMatch;
      this._rangeMatch.internalValue = value.rangeMatch;
      this._regexMatch = value.regexMatch;
      this._suffixMatch = value.suffixMatch;
    }
  }

  // exact_match - computed: false, optional: true, required: false
  private _exactMatch?: string; 
  public get exactMatch() {
    return this.getStringAttribute('exact_match');
  }
  public set exactMatch(value: string) {
    this._exactMatch = value;
  }
  public resetExactMatch() {
    this._exactMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactMatchInput() {
    return this._exactMatch;
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // prefix_match - computed: false, optional: true, required: false
  private _prefixMatch?: string; 
  public get prefixMatch() {
    return this.getStringAttribute('prefix_match');
  }
  public set prefixMatch(value: string) {
    this._prefixMatch = value;
  }
  public resetPrefixMatch() {
    this._prefixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixMatchInput() {
    return this._prefixMatch;
  }

  // present_match - computed: false, optional: true, required: false
  private _presentMatch?: boolean | cdktf.IResolvable; 
  public get presentMatch() {
    return this.getBooleanAttribute('present_match');
  }
  public set presentMatch(value: boolean | cdktf.IResolvable) {
    this._presentMatch = value;
  }
  public resetPresentMatch() {
    this._presentMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get presentMatchInput() {
    return this._presentMatch;
  }

  // range_match - computed: false, optional: true, required: false
  private _rangeMatch = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchOutputReference(this, "range_match");
  public get rangeMatch() {
    return this._rangeMatch;
  }
  public putRangeMatch(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch) {
    this._rangeMatch.internalValue = value;
  }
  public resetRangeMatch() {
    this._rangeMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangeMatchInput() {
    return this._rangeMatch.internalValue;
  }

  // regex_match - computed: false, optional: true, required: false
  private _regexMatch?: string; 
  public get regexMatch() {
    return this.getStringAttribute('regex_match');
  }
  public set regexMatch(value: string) {
    this._regexMatch = value;
  }
  public resetRegexMatch() {
    this._regexMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexMatchInput() {
    return this._regexMatch;
  }

  // suffix_match - computed: false, optional: true, required: false
  private _suffixMatch?: string; 
  public get suffixMatch() {
    return this.getStringAttribute('suffix_match');
  }
  public set suffixMatch(value: string) {
    this._suffixMatch = value;
  }
  public resetSuffixMatch() {
    this._suffixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixMatchInput() {
    return this._suffixMatch;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#expect_match DataK8SGatewaySoloIoRouteOptionV1Manifest#expect_match}
  */
  readonly expectMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#headers DataK8SGatewaySoloIoRouteOptionV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
    expect_match: cdktf.booleanToTerraform(struct!.expectMatch),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersToTerraform, false)(struct!.headers),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect_match: {
      value: cdktf.booleanToHclTerraform(struct!.expectMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    if (this._expectMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.expectMatch = this._expectMatch;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
      this._expectMatch = undefined;
      this._headers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
      this._expectMatch = value.expectMatch;
      this._headers.internalValue = value.headers;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }

  // expect_match - computed: false, optional: true, required: false
  private _expectMatch?: boolean | cdktf.IResolvable; 
  public get expectMatch() {
    return this.getBooleanAttribute('expect_match');
  }
  public set expectMatch(value: boolean | cdktf.IResolvable) {
    this._expectMatch = value;
  }
  public resetExpectMatch() {
    this._expectMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectMatchInput() {
    return this._expectMatch;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#path DataK8SGatewaySoloIoRouteOptionV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#default_value DataK8SGatewaySoloIoRouteOptionV1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#source DataK8SGatewaySoloIoRouteOptionV1Manifest#source}
  */
  readonly source?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    metadata_key: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyToTerraform(struct!.metadataKey),
    source: cdktf.stringToTerraform(struct!.source),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKey",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._descriptorKey = undefined;
      this._metadataKey.internalValue = undefined;
      this._source = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._descriptorKey = value.descriptorKey;
      this._metadataKey.internalValue = value.metadataKey;
      this._source = value.source;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header_name DataK8SGatewaySoloIoRouteOptionV1Manifest#header_name}
  */
  readonly headerName?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    header_name: cdktf.stringToTerraform(struct!.headerName),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_name: {
      value: cdktf.stringToHclTerraform(struct!.headerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._headerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerName = this._headerName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorKey = undefined;
      this._headerName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorKey = value.descriptorKey;
      this._headerName = value.headerName;
    }
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // header_name - computed: false, optional: true, required: false
  private _headerName?: string; 
  public get headerName() {
    return this.getStringAttribute('header_name');
  }
  public set headerName(value: string) {
    this._headerName = value;
  }
  public resetHeaderName() {
    this._headerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerNameInput() {
    return this._headerName;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#destination_cluster DataK8SGatewaySoloIoRouteOptionV1Manifest#destination_cluster}
  */
  readonly destinationCluster?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#generic_key DataK8SGatewaySoloIoRouteOptionV1Manifest#generic_key}
  */
  readonly genericKey?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header_value_match DataK8SGatewaySoloIoRouteOptionV1Manifest#header_value_match}
  */
  readonly headerValueMatch?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata}
  */
  readonly metadata?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadata;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#remote_address DataK8SGatewaySoloIoRouteOptionV1Manifest#remote_address}
  */
  readonly remoteAddress?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request_headers DataK8SGatewaySoloIoRouteOptionV1Manifest#request_headers}
  */
  readonly requestHeaders?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#source_cluster DataK8SGatewaySoloIoRouteOptionV1Manifest#source_cluster}
  */
  readonly sourceCluster?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    destination_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.destinationCluster),
    generic_key: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKeyToTerraform(struct!.genericKey),
    header_value_match: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchToTerraform(struct!.headerValueMatch),
    metadata: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataToTerraform(struct!.metadata),
    remote_address: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remoteAddress),
    request_headers: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeadersToTerraform(struct!.requestHeaders),
    source_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.sourceCluster),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    destination_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.destinationCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    generic_key: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKeyToHclTerraform(struct!.genericKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKey",
    },
    header_value_match: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchToHclTerraform(struct!.headerValueMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatch",
    },
    metadata: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadata",
    },
    remote_address: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remoteAddress),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    request_headers: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeadersToHclTerraform(struct!.requestHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeaders",
    },
    source_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.sourceCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._destinationCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationCluster = this._destinationCluster;
    }
    if (this._genericKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.genericKey = this._genericKey?.internalValue;
    }
    if (this._headerValueMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerValueMatch = this._headerValueMatch?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._remoteAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteAddress = this._remoteAddress;
    }
    if (this._requestHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaders = this._requestHeaders?.internalValue;
    }
    if (this._sourceCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceCluster = this._sourceCluster;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._destinationCluster = undefined;
      this._genericKey.internalValue = undefined;
      this._headerValueMatch.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._remoteAddress = undefined;
      this._requestHeaders.internalValue = undefined;
      this._sourceCluster = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._destinationCluster = value.destinationCluster;
      this._genericKey.internalValue = value.genericKey;
      this._headerValueMatch.internalValue = value.headerValueMatch;
      this._metadata.internalValue = value.metadata;
      this._remoteAddress = value.remoteAddress;
      this._requestHeaders.internalValue = value.requestHeaders;
      this._sourceCluster = value.sourceCluster;
    }
  }

  // destination_cluster - computed: false, optional: true, required: false
  private _destinationCluster?: { [key: string]: string }; 
  public get destinationCluster() {
    return this.getStringMapAttribute('destination_cluster');
  }
  public set destinationCluster(value: { [key: string]: string }) {
    this._destinationCluster = value;
  }
  public resetDestinationCluster() {
    this._destinationCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationClusterInput() {
    return this._destinationCluster;
  }

  // generic_key - computed: false, optional: true, required: false
  private _genericKey = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKeyOutputReference(this, "generic_key");
  public get genericKey() {
    return this._genericKey;
  }
  public putGenericKey(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsGenericKey) {
    this._genericKey.internalValue = value;
  }
  public resetGenericKey() {
    this._genericKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get genericKeyInput() {
    return this._genericKey.internalValue;
  }

  // header_value_match - computed: false, optional: true, required: false
  private _headerValueMatch = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatchOutputReference(this, "header_value_match");
  public get headerValueMatch() {
    return this._headerValueMatch;
  }
  public putHeaderValueMatch(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsHeaderValueMatch) {
    this._headerValueMatch.internalValue = value;
  }
  public resetHeaderValueMatch() {
    this._headerValueMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerValueMatchInput() {
    return this._headerValueMatch.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // remote_address - computed: false, optional: true, required: false
  private _remoteAddress?: { [key: string]: string }; 
  public get remoteAddress() {
    return this.getStringMapAttribute('remote_address');
  }
  public set remoteAddress(value: { [key: string]: string }) {
    this._remoteAddress = value;
  }
  public resetRemoteAddress() {
    this._remoteAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteAddressInput() {
    return this._remoteAddress;
  }

  // request_headers - computed: false, optional: true, required: false
  private _requestHeaders = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeadersOutputReference(this, "request_headers");
  public get requestHeaders() {
    return this._requestHeaders;
  }
  public putRequestHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsRequestHeaders) {
    this._requestHeaders.internalValue = value;
  }
  public resetRequestHeaders() {
    this._requestHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersInput() {
    return this._requestHeaders.internalValue;
  }

  // source_cluster - computed: false, optional: true, required: false
  private _sourceCluster?: { [key: string]: string }; 
  public get sourceCluster() {
    return this.getStringMapAttribute('source_cluster');
  }
  public set sourceCluster(value: { [key: string]: string }) {
    this._sourceCluster = value;
  }
  public resetSourceCluster() {
    this._sourceCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceClusterInput() {
    return this._sourceCluster;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#path DataK8SGatewaySoloIoRouteOptionV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_key: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyToTerraform(struct!.metadataKey),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataKey.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataKey.internalValue = value.metadataKey;
    }
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#dynamic_metadata DataK8SGatewaySoloIoRouteOptionV1Manifest#dynamic_metadata}
  */
  readonly dynamicMetadata?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadata;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dynamic_metadata: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataToTerraform(struct!.dynamicMetadata),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dynamic_metadata: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataToHclTerraform(struct!.dynamicMetadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadata",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dynamicMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadata = this._dynamicMetadata?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dynamicMetadata.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dynamicMetadata.internalValue = value.dynamicMetadata;
    }
  }

  // dynamic_metadata - computed: false, optional: true, required: false
  private _dynamicMetadata = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadataOutputReference(this, "dynamic_metadata");
  public get dynamicMetadata() {
    return this._dynamicMetadata;
  }
  public putDynamicMetadata(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitDynamicMetadata) {
    this._dynamicMetadata.internalValue = value;
  }
  public resetDynamicMetadata() {
    this._dynamicMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataInput() {
    return this._dynamicMetadata.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#end DataK8SGatewaySoloIoRouteOptionV1Manifest#end}
  */
  readonly end?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#start DataK8SGatewaySoloIoRouteOptionV1Manifest#start}
  */
  readonly start?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.numberToTerraform(struct!.end),
    start: cdktf.numberToTerraform(struct!.start),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: true, required: false
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  public resetStart() {
    this._start = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#exact_match DataK8SGatewaySoloIoRouteOptionV1Manifest#exact_match}
  */
  readonly exactMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#invert_match DataK8SGatewaySoloIoRouteOptionV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prefix_match DataK8SGatewaySoloIoRouteOptionV1Manifest#prefix_match}
  */
  readonly prefixMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#present_match DataK8SGatewaySoloIoRouteOptionV1Manifest#present_match}
  */
  readonly presentMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#range_match DataK8SGatewaySoloIoRouteOptionV1Manifest#range_match}
  */
  readonly rangeMatch?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex_match DataK8SGatewaySoloIoRouteOptionV1Manifest#regex_match}
  */
  readonly regexMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#suffix_match DataK8SGatewaySoloIoRouteOptionV1Manifest#suffix_match}
  */
  readonly suffixMatch?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact_match: cdktf.stringToTerraform(struct!.exactMatch),
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    prefix_match: cdktf.stringToTerraform(struct!.prefixMatch),
    present_match: cdktf.booleanToTerraform(struct!.presentMatch),
    range_match: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct!.rangeMatch),
    regex_match: cdktf.stringToTerraform(struct!.regexMatch),
    suffix_match: cdktf.stringToTerraform(struct!.suffixMatch),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact_match: {
      value: cdktf.stringToHclTerraform(struct!.exactMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_match: {
      value: cdktf.stringToHclTerraform(struct!.prefixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    present_match: {
      value: cdktf.booleanToHclTerraform(struct!.presentMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    range_match: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct!.rangeMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch",
    },
    regex_match: {
      value: cdktf.stringToHclTerraform(struct!.regexMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suffix_match: {
      value: cdktf.stringToHclTerraform(struct!.suffixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exactMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.exactMatch = this._exactMatch;
    }
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._prefixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixMatch = this._prefixMatch;
    }
    if (this._presentMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.presentMatch = this._presentMatch;
    }
    if (this._rangeMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rangeMatch = this._rangeMatch?.internalValue;
    }
    if (this._regexMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexMatch = this._regexMatch;
    }
    if (this._suffixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffixMatch = this._suffixMatch;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exactMatch = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._prefixMatch = undefined;
      this._presentMatch = undefined;
      this._rangeMatch.internalValue = undefined;
      this._regexMatch = undefined;
      this._suffixMatch = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exactMatch = value.exactMatch;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._prefixMatch = value.prefixMatch;
      this._presentMatch = value.presentMatch;
      this._rangeMatch.internalValue = value.rangeMatch;
      this._regexMatch = value.regexMatch;
      this._suffixMatch = value.suffixMatch;
    }
  }

  // exact_match - computed: false, optional: true, required: false
  private _exactMatch?: string; 
  public get exactMatch() {
    return this.getStringAttribute('exact_match');
  }
  public set exactMatch(value: string) {
    this._exactMatch = value;
  }
  public resetExactMatch() {
    this._exactMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactMatchInput() {
    return this._exactMatch;
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // prefix_match - computed: false, optional: true, required: false
  private _prefixMatch?: string; 
  public get prefixMatch() {
    return this.getStringAttribute('prefix_match');
  }
  public set prefixMatch(value: string) {
    this._prefixMatch = value;
  }
  public resetPrefixMatch() {
    this._prefixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixMatchInput() {
    return this._prefixMatch;
  }

  // present_match - computed: false, optional: true, required: false
  private _presentMatch?: boolean | cdktf.IResolvable; 
  public get presentMatch() {
    return this.getBooleanAttribute('present_match');
  }
  public set presentMatch(value: boolean | cdktf.IResolvable) {
    this._presentMatch = value;
  }
  public resetPresentMatch() {
    this._presentMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get presentMatchInput() {
    return this._presentMatch;
  }

  // range_match - computed: false, optional: true, required: false
  private _rangeMatch = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchOutputReference(this, "range_match");
  public get rangeMatch() {
    return this._rangeMatch;
  }
  public putRangeMatch(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch) {
    this._rangeMatch.internalValue = value;
  }
  public resetRangeMatch() {
    this._rangeMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangeMatchInput() {
    return this._rangeMatch.internalValue;
  }

  // regex_match - computed: false, optional: true, required: false
  private _regexMatch?: string; 
  public get regexMatch() {
    return this.getStringAttribute('regex_match');
  }
  public set regexMatch(value: string) {
    this._regexMatch = value;
  }
  public resetRegexMatch() {
    this._regexMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexMatchInput() {
    return this._regexMatch;
  }

  // suffix_match - computed: false, optional: true, required: false
  private _suffixMatch?: string; 
  public get suffixMatch() {
    return this.getStringAttribute('suffix_match');
  }
  public set suffixMatch(value: string) {
    this._suffixMatch = value;
  }
  public resetSuffixMatch() {
    this._suffixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixMatchInput() {
    return this._suffixMatch;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#expect_match DataK8SGatewaySoloIoRouteOptionV1Manifest#expect_match}
  */
  readonly expectMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#headers DataK8SGatewaySoloIoRouteOptionV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
    expect_match: cdktf.booleanToTerraform(struct!.expectMatch),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersToTerraform, false)(struct!.headers),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect_match: {
      value: cdktf.booleanToHclTerraform(struct!.expectMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    if (this._expectMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.expectMatch = this._expectMatch;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
      this._expectMatch = undefined;
      this._headers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
      this._expectMatch = value.expectMatch;
      this._headers.internalValue = value.headers;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }

  // expect_match - computed: false, optional: true, required: false
  private _expectMatch?: boolean | cdktf.IResolvable; 
  public get expectMatch() {
    return this.getBooleanAttribute('expect_match');
  }
  public set expectMatch(value: boolean | cdktf.IResolvable) {
    this._expectMatch = value;
  }
  public resetExpectMatch() {
    this._expectMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectMatchInput() {
    return this._expectMatch;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#path DataK8SGatewaySoloIoRouteOptionV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#default_value DataK8SGatewaySoloIoRouteOptionV1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#source DataK8SGatewaySoloIoRouteOptionV1Manifest#source}
  */
  readonly source?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    metadata_key: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyToTerraform(struct!.metadataKey),
    source: cdktf.stringToTerraform(struct!.source),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._descriptorKey = undefined;
      this._metadataKey.internalValue = undefined;
      this._source = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._descriptorKey = value.descriptorKey;
      this._metadataKey.internalValue = value.metadataKey;
      this._source = value.source;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header_name DataK8SGatewaySoloIoRouteOptionV1Manifest#header_name}
  */
  readonly headerName?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    header_name: cdktf.stringToTerraform(struct!.headerName),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_name: {
      value: cdktf.stringToHclTerraform(struct!.headerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._headerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerName = this._headerName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorKey = undefined;
      this._headerName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorKey = value.descriptorKey;
      this._headerName = value.headerName;
    }
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // header_name - computed: false, optional: true, required: false
  private _headerName?: string; 
  public get headerName() {
    return this.getStringAttribute('header_name');
  }
  public set headerName(value: string) {
    this._headerName = value;
  }
  public resetHeaderName() {
    this._headerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerNameInput() {
    return this._headerName;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#destination_cluster DataK8SGatewaySoloIoRouteOptionV1Manifest#destination_cluster}
  */
  readonly destinationCluster?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#generic_key DataK8SGatewaySoloIoRouteOptionV1Manifest#generic_key}
  */
  readonly genericKey?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header_value_match DataK8SGatewaySoloIoRouteOptionV1Manifest#header_value_match}
  */
  readonly headerValueMatch?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata}
  */
  readonly metadata?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadata;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#remote_address DataK8SGatewaySoloIoRouteOptionV1Manifest#remote_address}
  */
  readonly remoteAddress?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request_headers DataK8SGatewaySoloIoRouteOptionV1Manifest#request_headers}
  */
  readonly requestHeaders?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#source_cluster DataK8SGatewaySoloIoRouteOptionV1Manifest#source_cluster}
  */
  readonly sourceCluster?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    destination_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.destinationCluster),
    generic_key: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKeyToTerraform(struct!.genericKey),
    header_value_match: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchToTerraform(struct!.headerValueMatch),
    metadata: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataToTerraform(struct!.metadata),
    remote_address: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remoteAddress),
    request_headers: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeadersToTerraform(struct!.requestHeaders),
    source_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.sourceCluster),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    destination_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.destinationCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    generic_key: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKeyToHclTerraform(struct!.genericKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKey",
    },
    header_value_match: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchToHclTerraform(struct!.headerValueMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatch",
    },
    metadata: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadata",
    },
    remote_address: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remoteAddress),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    request_headers: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeadersToHclTerraform(struct!.requestHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeaders",
    },
    source_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.sourceCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._destinationCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationCluster = this._destinationCluster;
    }
    if (this._genericKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.genericKey = this._genericKey?.internalValue;
    }
    if (this._headerValueMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerValueMatch = this._headerValueMatch?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._remoteAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteAddress = this._remoteAddress;
    }
    if (this._requestHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaders = this._requestHeaders?.internalValue;
    }
    if (this._sourceCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceCluster = this._sourceCluster;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._destinationCluster = undefined;
      this._genericKey.internalValue = undefined;
      this._headerValueMatch.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._remoteAddress = undefined;
      this._requestHeaders.internalValue = undefined;
      this._sourceCluster = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._destinationCluster = value.destinationCluster;
      this._genericKey.internalValue = value.genericKey;
      this._headerValueMatch.internalValue = value.headerValueMatch;
      this._metadata.internalValue = value.metadata;
      this._remoteAddress = value.remoteAddress;
      this._requestHeaders.internalValue = value.requestHeaders;
      this._sourceCluster = value.sourceCluster;
    }
  }

  // destination_cluster - computed: false, optional: true, required: false
  private _destinationCluster?: { [key: string]: string }; 
  public get destinationCluster() {
    return this.getStringMapAttribute('destination_cluster');
  }
  public set destinationCluster(value: { [key: string]: string }) {
    this._destinationCluster = value;
  }
  public resetDestinationCluster() {
    this._destinationCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationClusterInput() {
    return this._destinationCluster;
  }

  // generic_key - computed: false, optional: true, required: false
  private _genericKey = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKeyOutputReference(this, "generic_key");
  public get genericKey() {
    return this._genericKey;
  }
  public putGenericKey(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsGenericKey) {
    this._genericKey.internalValue = value;
  }
  public resetGenericKey() {
    this._genericKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get genericKeyInput() {
    return this._genericKey.internalValue;
  }

  // header_value_match - computed: false, optional: true, required: false
  private _headerValueMatch = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatchOutputReference(this, "header_value_match");
  public get headerValueMatch() {
    return this._headerValueMatch;
  }
  public putHeaderValueMatch(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsHeaderValueMatch) {
    this._headerValueMatch.internalValue = value;
  }
  public resetHeaderValueMatch() {
    this._headerValueMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerValueMatchInput() {
    return this._headerValueMatch.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // remote_address - computed: false, optional: true, required: false
  private _remoteAddress?: { [key: string]: string }; 
  public get remoteAddress() {
    return this.getStringMapAttribute('remote_address');
  }
  public set remoteAddress(value: { [key: string]: string }) {
    this._remoteAddress = value;
  }
  public resetRemoteAddress() {
    this._remoteAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteAddressInput() {
    return this._remoteAddress;
  }

  // request_headers - computed: false, optional: true, required: false
  private _requestHeaders = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeadersOutputReference(this, "request_headers");
  public get requestHeaders() {
    return this._requestHeaders;
  }
  public putRequestHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsRequestHeaders) {
    this._requestHeaders.internalValue = value;
  }
  public resetRequestHeaders() {
    this._requestHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersInput() {
    return this._requestHeaders.internalValue;
  }

  // source_cluster - computed: false, optional: true, required: false
  private _sourceCluster?: { [key: string]: string }; 
  public get sourceCluster() {
    return this.getStringMapAttribute('source_cluster');
  }
  public set sourceCluster(value: { [key: string]: string }) {
    this._sourceCluster = value;
  }
  public resetSourceCluster() {
    this._sourceCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceClusterInput() {
    return this._sourceCluster;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#actions DataK8SGatewaySoloIoRouteOptionV1Manifest#actions}
  */
  readonly actions?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#limit DataK8SGatewaySoloIoRouteOptionV1Manifest#limit}
  */
  readonly limit?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#set_actions DataK8SGatewaySoloIoRouteOptionV1Manifest#set_actions}
  */
  readonly setActions?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActions[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    actions: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsToTerraform, false)(struct!.actions),
    limit: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitToTerraform(struct!.limit),
    set_actions: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsToTerraform, false)(struct!.setActions),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsToHclTerraform, false)(struct!.actions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsList",
    },
    limit: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitToHclTerraform(struct!.limit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimit",
    },
    set_actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsToHclTerraform, false)(struct!.setActions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.actions = this._actions?.internalValue;
    }
    if (this._limit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit?.internalValue;
    }
    if (this._setActions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.setActions = this._setActions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actions.internalValue = undefined;
      this._limit.internalValue = undefined;
      this._setActions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actions.internalValue = value.actions;
      this._limit.internalValue = value.limit;
      this._setActions.internalValue = value.setActions;
    }
  }

  // actions - computed: false, optional: true, required: false
  private _actions = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActionsList(this, "actions", false);
  public get actions() {
    return this._actions;
  }
  public putActions(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsActions[] | cdktf.IResolvable) {
    this._actions.internalValue = value;
  }
  public resetActions() {
    this._actions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionsInput() {
    return this._actions.internalValue;
  }

  // limit - computed: false, optional: true, required: false
  private _limit = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimitOutputReference(this, "limit");
  public get limit() {
    return this._limit;
  }
  public putLimit(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsLimit) {
    this._limit.internalValue = value;
  }
  public resetLimit() {
    this._limit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit.internalValue;
  }

  // set_actions - computed: false, optional: true, required: false
  private _setActions = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActionsList(this, "set_actions", false);
  public get setActions() {
    return this._setActions;
  }
  public putSetActions(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsSetActions[] | cdktf.IResolvable) {
    this._setActions.internalValue = value;
  }
  public resetSetActions() {
    this._setActions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setActionsInput() {
    return this._setActions.internalValue;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimits[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#include_vh_rate_limits DataK8SGatewaySoloIoRouteOptionV1Manifest#include_vh_rate_limits}
  */
  readonly includeVhRateLimits?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#local_ratelimit DataK8SGatewaySoloIoRouteOptionV1Manifest#local_ratelimit}
  */
  readonly localRatelimit?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#rate_limits DataK8SGatewaySoloIoRouteOptionV1Manifest#rate_limits}
  */
  readonly rateLimits?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimits[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    include_vh_rate_limits: cdktf.booleanToTerraform(struct!.includeVhRateLimits),
    local_ratelimit: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimitToTerraform(struct!.localRatelimit),
    rate_limits: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsToTerraform, false)(struct!.rateLimits),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    include_vh_rate_limits: {
      value: cdktf.booleanToHclTerraform(struct!.includeVhRateLimits),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_ratelimit: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimitToHclTerraform(struct!.localRatelimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimit",
    },
    rate_limits: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsToHclTerraform, false)(struct!.rateLimits),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._includeVhRateLimits !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeVhRateLimits = this._includeVhRateLimits;
    }
    if (this._localRatelimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localRatelimit = this._localRatelimit?.internalValue;
    }
    if (this._rateLimits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rateLimits = this._rateLimits?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._includeVhRateLimits = undefined;
      this._localRatelimit.internalValue = undefined;
      this._rateLimits.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._includeVhRateLimits = value.includeVhRateLimits;
      this._localRatelimit.internalValue = value.localRatelimit;
      this._rateLimits.internalValue = value.rateLimits;
    }
  }

  // include_vh_rate_limits - computed: false, optional: true, required: false
  private _includeVhRateLimits?: boolean | cdktf.IResolvable; 
  public get includeVhRateLimits() {
    return this.getBooleanAttribute('include_vh_rate_limits');
  }
  public set includeVhRateLimits(value: boolean | cdktf.IResolvable) {
    this._includeVhRateLimits = value;
  }
  public resetIncludeVhRateLimits() {
    this._includeVhRateLimits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeVhRateLimitsInput() {
    return this._includeVhRateLimits;
  }

  // local_ratelimit - computed: false, optional: true, required: false
  private _localRatelimit = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimitOutputReference(this, "local_ratelimit");
  public get localRatelimit() {
    return this._localRatelimit;
  }
  public putLocalRatelimit(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitLocalRatelimit) {
    this._localRatelimit.internalValue = value;
  }
  public resetLocalRatelimit() {
    this._localRatelimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localRatelimitInput() {
    return this._localRatelimit.internalValue;
  }

  // rate_limits - computed: false, optional: true, required: false
  private _rateLimits = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimitsList(this, "rate_limits", false);
  public get rateLimits() {
    return this._rateLimits;
  }
  public putRateLimits(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitRateLimits[] | cdktf.IResolvable) {
    this._rateLimits.internalValue = value;
  }
  public resetRateLimits() {
    this._rateLimits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rateLimitsInput() {
    return this._rateLimits.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#requests_per_unit DataK8SGatewaySoloIoRouteOptionV1Manifest#requests_per_unit}
  */
  readonly requestsPerUnit?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#unit DataK8SGatewaySoloIoRouteOptionV1Manifest#unit}
  */
  readonly unit?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimitsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    requests_per_unit: cdktf.numberToTerraform(struct!.requestsPerUnit),
    unit: cdktf.stringToTerraform(struct!.unit),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimitsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    requests_per_unit: {
      value: cdktf.numberToHclTerraform(struct!.requestsPerUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestsPerUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestsPerUnit = this._requestsPerUnit;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestsPerUnit = undefined;
      this._unit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestsPerUnit = value.requestsPerUnit;
      this._unit = value.unit;
    }
  }

  // requests_per_unit - computed: false, optional: true, required: false
  private _requestsPerUnit?: number; 
  public get requestsPerUnit() {
    return this.getNumberAttribute('requests_per_unit');
  }
  public set requestsPerUnit(value: number) {
    this._requestsPerUnit = value;
  }
  public resetRequestsPerUnit() {
    this._requestsPerUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsPerUnitInput() {
    return this._requestsPerUnit;
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#requests_per_unit DataK8SGatewaySoloIoRouteOptionV1Manifest#requests_per_unit}
  */
  readonly requestsPerUnit?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#unit DataK8SGatewaySoloIoRouteOptionV1Manifest#unit}
  */
  readonly unit?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimitsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    requests_per_unit: cdktf.numberToTerraform(struct!.requestsPerUnit),
    unit: cdktf.stringToTerraform(struct!.unit),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimitsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    requests_per_unit: {
      value: cdktf.numberToHclTerraform(struct!.requestsPerUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestsPerUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestsPerUnit = this._requestsPerUnit;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestsPerUnit = undefined;
      this._unit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestsPerUnit = value.requestsPerUnit;
      this._unit = value.unit;
    }
  }

  // requests_per_unit - computed: false, optional: true, required: false
  private _requestsPerUnit?: number; 
  public get requestsPerUnit() {
    return this.getNumberAttribute('requests_per_unit');
  }
  public set requestsPerUnit(value: number) {
    this._requestsPerUnit = value;
  }
  public resetRequestsPerUnit() {
    this._requestsPerUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsPerUnitInput() {
    return this._requestsPerUnit;
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasic {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#anonymous_limits DataK8SGatewaySoloIoRouteOptionV1Manifest#anonymous_limits}
  */
  readonly anonymousLimits?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#authorized_limits DataK8SGatewaySoloIoRouteOptionV1Manifest#authorized_limits}
  */
  readonly authorizedLimits?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimits;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    anonymous_limits: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimitsToTerraform(struct!.anonymousLimits),
    authorized_limits: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimitsToTerraform(struct!.authorizedLimits),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    anonymous_limits: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimitsToHclTerraform(struct!.anonymousLimits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimits",
    },
    authorized_limits: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimitsToHclTerraform(struct!.authorizedLimits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimits",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._anonymousLimits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.anonymousLimits = this._anonymousLimits?.internalValue;
    }
    if (this._authorizedLimits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizedLimits = this._authorizedLimits?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._anonymousLimits.internalValue = undefined;
      this._authorizedLimits.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._anonymousLimits.internalValue = value.anonymousLimits;
      this._authorizedLimits.internalValue = value.authorizedLimits;
    }
  }

  // anonymous_limits - computed: false, optional: true, required: false
  private _anonymousLimits = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimitsOutputReference(this, "anonymous_limits");
  public get anonymousLimits() {
    return this._anonymousLimits;
  }
  public putAnonymousLimits(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAnonymousLimits) {
    this._anonymousLimits.internalValue = value;
  }
  public resetAnonymousLimits() {
    this._anonymousLimits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anonymousLimitsInput() {
    return this._anonymousLimits.internalValue;
  }

  // authorized_limits - computed: false, optional: true, required: false
  private _authorizedLimits = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimitsOutputReference(this, "authorized_limits");
  public get authorizedLimits() {
    return this._authorizedLimits;
  }
  public putAuthorizedLimits(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitBasicAuthorizedLimits) {
    this._authorizedLimits.internalValue = value;
  }
  public resetAuthorizedLimits() {
    this._authorizedLimits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizedLimitsInput() {
    return this._authorizedLimits.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyLocalRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#fill_interval DataK8SGatewaySoloIoRouteOptionV1Manifest#fill_interval}
  */
  readonly fillInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#max_tokens DataK8SGatewaySoloIoRouteOptionV1Manifest#max_tokens}
  */
  readonly maxTokens?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#tokens_per_fill DataK8SGatewaySoloIoRouteOptionV1Manifest#tokens_per_fill}
  */
  readonly tokensPerFill?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyLocalRatelimitToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fill_interval: cdktf.stringToTerraform(struct!.fillInterval),
    max_tokens: cdktf.numberToTerraform(struct!.maxTokens),
    tokens_per_fill: cdktf.numberToTerraform(struct!.tokensPerFill),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyLocalRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fill_interval: {
      value: cdktf.stringToHclTerraform(struct!.fillInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_tokens: {
      value: cdktf.numberToHclTerraform(struct!.maxTokens),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tokens_per_fill: {
      value: cdktf.numberToHclTerraform(struct!.tokensPerFill),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyLocalRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyLocalRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fillInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.fillInterval = this._fillInterval;
    }
    if (this._maxTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTokens = this._maxTokens;
    }
    if (this._tokensPerFill !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokensPerFill = this._tokensPerFill;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyLocalRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fillInterval = undefined;
      this._maxTokens = undefined;
      this._tokensPerFill = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fillInterval = value.fillInterval;
      this._maxTokens = value.maxTokens;
      this._tokensPerFill = value.tokensPerFill;
    }
  }

  // fill_interval - computed: false, optional: true, required: false
  private _fillInterval?: string; 
  public get fillInterval() {
    return this.getStringAttribute('fill_interval');
  }
  public set fillInterval(value: string) {
    this._fillInterval = value;
  }
  public resetFillInterval() {
    this._fillInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fillIntervalInput() {
    return this._fillInterval;
  }

  // max_tokens - computed: false, optional: true, required: false
  private _maxTokens?: number; 
  public get maxTokens() {
    return this.getNumberAttribute('max_tokens');
  }
  public set maxTokens(value: number) {
    this._maxTokens = value;
  }
  public resetMaxTokens() {
    this._maxTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTokensInput() {
    return this._maxTokens;
  }

  // tokens_per_fill - computed: false, optional: true, required: false
  private _tokensPerFill?: number; 
  public get tokensPerFill() {
    return this.getNumberAttribute('tokens_per_fill');
  }
  public set tokensPerFill(value: number) {
    this._tokensPerFill = value;
  }
  public resetTokensPerFill() {
    this._tokensPerFill = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokensPerFillInput() {
    return this._tokensPerFill;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#end DataK8SGatewaySoloIoRouteOptionV1Manifest#end}
  */
  readonly end?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#start DataK8SGatewaySoloIoRouteOptionV1Manifest#start}
  */
  readonly start?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.numberToTerraform(struct!.end),
    start: cdktf.numberToTerraform(struct!.start),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: true, required: false
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  public resetStart() {
    this._start = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#exact_match DataK8SGatewaySoloIoRouteOptionV1Manifest#exact_match}
  */
  readonly exactMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#invert_match DataK8SGatewaySoloIoRouteOptionV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prefix_match DataK8SGatewaySoloIoRouteOptionV1Manifest#prefix_match}
  */
  readonly prefixMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#present_match DataK8SGatewaySoloIoRouteOptionV1Manifest#present_match}
  */
  readonly presentMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#range_match DataK8SGatewaySoloIoRouteOptionV1Manifest#range_match}
  */
  readonly rangeMatch?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex_match DataK8SGatewaySoloIoRouteOptionV1Manifest#regex_match}
  */
  readonly regexMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#suffix_match DataK8SGatewaySoloIoRouteOptionV1Manifest#suffix_match}
  */
  readonly suffixMatch?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact_match: cdktf.stringToTerraform(struct!.exactMatch),
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    prefix_match: cdktf.stringToTerraform(struct!.prefixMatch),
    present_match: cdktf.booleanToTerraform(struct!.presentMatch),
    range_match: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct!.rangeMatch),
    regex_match: cdktf.stringToTerraform(struct!.regexMatch),
    suffix_match: cdktf.stringToTerraform(struct!.suffixMatch),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact_match: {
      value: cdktf.stringToHclTerraform(struct!.exactMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_match: {
      value: cdktf.stringToHclTerraform(struct!.prefixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    present_match: {
      value: cdktf.booleanToHclTerraform(struct!.presentMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    range_match: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct!.rangeMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch",
    },
    regex_match: {
      value: cdktf.stringToHclTerraform(struct!.regexMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suffix_match: {
      value: cdktf.stringToHclTerraform(struct!.suffixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exactMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.exactMatch = this._exactMatch;
    }
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._prefixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixMatch = this._prefixMatch;
    }
    if (this._presentMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.presentMatch = this._presentMatch;
    }
    if (this._rangeMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rangeMatch = this._rangeMatch?.internalValue;
    }
    if (this._regexMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexMatch = this._regexMatch;
    }
    if (this._suffixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffixMatch = this._suffixMatch;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exactMatch = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._prefixMatch = undefined;
      this._presentMatch = undefined;
      this._rangeMatch.internalValue = undefined;
      this._regexMatch = undefined;
      this._suffixMatch = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exactMatch = value.exactMatch;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._prefixMatch = value.prefixMatch;
      this._presentMatch = value.presentMatch;
      this._rangeMatch.internalValue = value.rangeMatch;
      this._regexMatch = value.regexMatch;
      this._suffixMatch = value.suffixMatch;
    }
  }

  // exact_match - computed: false, optional: true, required: false
  private _exactMatch?: string; 
  public get exactMatch() {
    return this.getStringAttribute('exact_match');
  }
  public set exactMatch(value: string) {
    this._exactMatch = value;
  }
  public resetExactMatch() {
    this._exactMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactMatchInput() {
    return this._exactMatch;
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // prefix_match - computed: false, optional: true, required: false
  private _prefixMatch?: string; 
  public get prefixMatch() {
    return this.getStringAttribute('prefix_match');
  }
  public set prefixMatch(value: string) {
    this._prefixMatch = value;
  }
  public resetPrefixMatch() {
    this._prefixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixMatchInput() {
    return this._prefixMatch;
  }

  // present_match - computed: false, optional: true, required: false
  private _presentMatch?: boolean | cdktf.IResolvable; 
  public get presentMatch() {
    return this.getBooleanAttribute('present_match');
  }
  public set presentMatch(value: boolean | cdktf.IResolvable) {
    this._presentMatch = value;
  }
  public resetPresentMatch() {
    this._presentMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get presentMatchInput() {
    return this._presentMatch;
  }

  // range_match - computed: false, optional: true, required: false
  private _rangeMatch = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchOutputReference(this, "range_match");
  public get rangeMatch() {
    return this._rangeMatch;
  }
  public putRangeMatch(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch) {
    this._rangeMatch.internalValue = value;
  }
  public resetRangeMatch() {
    this._rangeMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangeMatchInput() {
    return this._rangeMatch.internalValue;
  }

  // regex_match - computed: false, optional: true, required: false
  private _regexMatch?: string; 
  public get regexMatch() {
    return this.getStringAttribute('regex_match');
  }
  public set regexMatch(value: string) {
    this._regexMatch = value;
  }
  public resetRegexMatch() {
    this._regexMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexMatchInput() {
    return this._regexMatch;
  }

  // suffix_match - computed: false, optional: true, required: false
  private _suffixMatch?: string; 
  public get suffixMatch() {
    return this.getStringAttribute('suffix_match');
  }
  public set suffixMatch(value: string) {
    this._suffixMatch = value;
  }
  public resetSuffixMatch() {
    this._suffixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixMatchInput() {
    return this._suffixMatch;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#expect_match DataK8SGatewaySoloIoRouteOptionV1Manifest#expect_match}
  */
  readonly expectMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#headers DataK8SGatewaySoloIoRouteOptionV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
    expect_match: cdktf.booleanToTerraform(struct!.expectMatch),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersToTerraform, false)(struct!.headers),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect_match: {
      value: cdktf.booleanToHclTerraform(struct!.expectMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    if (this._expectMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.expectMatch = this._expectMatch;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
      this._expectMatch = undefined;
      this._headers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
      this._expectMatch = value.expectMatch;
      this._headers.internalValue = value.headers;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }

  // expect_match - computed: false, optional: true, required: false
  private _expectMatch?: boolean | cdktf.IResolvable; 
  public get expectMatch() {
    return this.getBooleanAttribute('expect_match');
  }
  public set expectMatch(value: boolean | cdktf.IResolvable) {
    this._expectMatch = value;
  }
  public resetExpectMatch() {
    this._expectMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectMatchInput() {
    return this._expectMatch;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#path DataK8SGatewaySoloIoRouteOptionV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#default_value DataK8SGatewaySoloIoRouteOptionV1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#source DataK8SGatewaySoloIoRouteOptionV1Manifest#source}
  */
  readonly source?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    metadata_key: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyToTerraform(struct!.metadataKey),
    source: cdktf.stringToTerraform(struct!.source),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._descriptorKey = undefined;
      this._metadataKey.internalValue = undefined;
      this._source = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._descriptorKey = value.descriptorKey;
      this._metadataKey.internalValue = value.metadataKey;
      this._source = value.source;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header_name DataK8SGatewaySoloIoRouteOptionV1Manifest#header_name}
  */
  readonly headerName?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    header_name: cdktf.stringToTerraform(struct!.headerName),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_name: {
      value: cdktf.stringToHclTerraform(struct!.headerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._headerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerName = this._headerName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorKey = undefined;
      this._headerName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorKey = value.descriptorKey;
      this._headerName = value.headerName;
    }
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // header_name - computed: false, optional: true, required: false
  private _headerName?: string; 
  public get headerName() {
    return this.getStringAttribute('header_name');
  }
  public set headerName(value: string) {
    this._headerName = value;
  }
  public resetHeaderName() {
    this._headerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerNameInput() {
    return this._headerName;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#destination_cluster DataK8SGatewaySoloIoRouteOptionV1Manifest#destination_cluster}
  */
  readonly destinationCluster?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#generic_key DataK8SGatewaySoloIoRouteOptionV1Manifest#generic_key}
  */
  readonly genericKey?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header_value_match DataK8SGatewaySoloIoRouteOptionV1Manifest#header_value_match}
  */
  readonly headerValueMatch?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata}
  */
  readonly metadata?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadata;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#remote_address DataK8SGatewaySoloIoRouteOptionV1Manifest#remote_address}
  */
  readonly remoteAddress?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request_headers DataK8SGatewaySoloIoRouteOptionV1Manifest#request_headers}
  */
  readonly requestHeaders?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#source_cluster DataK8SGatewaySoloIoRouteOptionV1Manifest#source_cluster}
  */
  readonly sourceCluster?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    destination_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.destinationCluster),
    generic_key: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKeyToTerraform(struct!.genericKey),
    header_value_match: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchToTerraform(struct!.headerValueMatch),
    metadata: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataToTerraform(struct!.metadata),
    remote_address: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remoteAddress),
    request_headers: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeadersToTerraform(struct!.requestHeaders),
    source_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.sourceCluster),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    destination_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.destinationCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    generic_key: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKeyToHclTerraform(struct!.genericKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKey",
    },
    header_value_match: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchToHclTerraform(struct!.headerValueMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch",
    },
    metadata: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadata",
    },
    remote_address: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remoteAddress),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    request_headers: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeadersToHclTerraform(struct!.requestHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeaders",
    },
    source_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.sourceCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._destinationCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationCluster = this._destinationCluster;
    }
    if (this._genericKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.genericKey = this._genericKey?.internalValue;
    }
    if (this._headerValueMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerValueMatch = this._headerValueMatch?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._remoteAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteAddress = this._remoteAddress;
    }
    if (this._requestHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaders = this._requestHeaders?.internalValue;
    }
    if (this._sourceCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceCluster = this._sourceCluster;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._destinationCluster = undefined;
      this._genericKey.internalValue = undefined;
      this._headerValueMatch.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._remoteAddress = undefined;
      this._requestHeaders.internalValue = undefined;
      this._sourceCluster = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._destinationCluster = value.destinationCluster;
      this._genericKey.internalValue = value.genericKey;
      this._headerValueMatch.internalValue = value.headerValueMatch;
      this._metadata.internalValue = value.metadata;
      this._remoteAddress = value.remoteAddress;
      this._requestHeaders.internalValue = value.requestHeaders;
      this._sourceCluster = value.sourceCluster;
    }
  }

  // destination_cluster - computed: false, optional: true, required: false
  private _destinationCluster?: { [key: string]: string }; 
  public get destinationCluster() {
    return this.getStringMapAttribute('destination_cluster');
  }
  public set destinationCluster(value: { [key: string]: string }) {
    this._destinationCluster = value;
  }
  public resetDestinationCluster() {
    this._destinationCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationClusterInput() {
    return this._destinationCluster;
  }

  // generic_key - computed: false, optional: true, required: false
  private _genericKey = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKeyOutputReference(this, "generic_key");
  public get genericKey() {
    return this._genericKey;
  }
  public putGenericKey(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsGenericKey) {
    this._genericKey.internalValue = value;
  }
  public resetGenericKey() {
    this._genericKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get genericKeyInput() {
    return this._genericKey.internalValue;
  }

  // header_value_match - computed: false, optional: true, required: false
  private _headerValueMatch = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchOutputReference(this, "header_value_match");
  public get headerValueMatch() {
    return this._headerValueMatch;
  }
  public putHeaderValueMatch(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch) {
    this._headerValueMatch.internalValue = value;
  }
  public resetHeaderValueMatch() {
    this._headerValueMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerValueMatchInput() {
    return this._headerValueMatch.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // remote_address - computed: false, optional: true, required: false
  private _remoteAddress?: { [key: string]: string }; 
  public get remoteAddress() {
    return this.getStringMapAttribute('remote_address');
  }
  public set remoteAddress(value: { [key: string]: string }) {
    this._remoteAddress = value;
  }
  public resetRemoteAddress() {
    this._remoteAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteAddressInput() {
    return this._remoteAddress;
  }

  // request_headers - computed: false, optional: true, required: false
  private _requestHeaders = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeadersOutputReference(this, "request_headers");
  public get requestHeaders() {
    return this._requestHeaders;
  }
  public putRequestHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsRequestHeaders) {
    this._requestHeaders.internalValue = value;
  }
  public resetRequestHeaders() {
    this._requestHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersInput() {
    return this._requestHeaders.internalValue;
  }

  // source_cluster - computed: false, optional: true, required: false
  private _sourceCluster?: { [key: string]: string }; 
  public get sourceCluster() {
    return this.getStringMapAttribute('source_cluster');
  }
  public set sourceCluster(value: { [key: string]: string }) {
    this._sourceCluster = value;
  }
  public resetSourceCluster() {
    this._sourceCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceClusterInput() {
    return this._sourceCluster;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#path DataK8SGatewaySoloIoRouteOptionV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_key: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyToTerraform(struct!.metadataKey),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataKey.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataKey.internalValue = value.metadataKey;
    }
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#dynamic_metadata DataK8SGatewaySoloIoRouteOptionV1Manifest#dynamic_metadata}
  */
  readonly dynamicMetadata?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dynamic_metadata: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataToTerraform(struct!.dynamicMetadata),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dynamic_metadata: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataToHclTerraform(struct!.dynamicMetadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dynamicMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadata = this._dynamicMetadata?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dynamicMetadata.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dynamicMetadata.internalValue = value.dynamicMetadata;
    }
  }

  // dynamic_metadata - computed: false, optional: true, required: false
  private _dynamicMetadata = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataOutputReference(this, "dynamic_metadata");
  public get dynamicMetadata() {
    return this._dynamicMetadata;
  }
  public putDynamicMetadata(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata) {
    this._dynamicMetadata.internalValue = value;
  }
  public resetDynamicMetadata() {
    this._dynamicMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataInput() {
    return this._dynamicMetadata.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#end DataK8SGatewaySoloIoRouteOptionV1Manifest#end}
  */
  readonly end?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#start DataK8SGatewaySoloIoRouteOptionV1Manifest#start}
  */
  readonly start?: number;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.numberToTerraform(struct!.end),
    start: cdktf.numberToTerraform(struct!.start),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: true, required: false
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  public resetStart() {
    this._start = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#exact_match DataK8SGatewaySoloIoRouteOptionV1Manifest#exact_match}
  */
  readonly exactMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#invert_match DataK8SGatewaySoloIoRouteOptionV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#name DataK8SGatewaySoloIoRouteOptionV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#prefix_match DataK8SGatewaySoloIoRouteOptionV1Manifest#prefix_match}
  */
  readonly prefixMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#present_match DataK8SGatewaySoloIoRouteOptionV1Manifest#present_match}
  */
  readonly presentMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#range_match DataK8SGatewaySoloIoRouteOptionV1Manifest#range_match}
  */
  readonly rangeMatch?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#regex_match DataK8SGatewaySoloIoRouteOptionV1Manifest#regex_match}
  */
  readonly regexMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#suffix_match DataK8SGatewaySoloIoRouteOptionV1Manifest#suffix_match}
  */
  readonly suffixMatch?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact_match: cdktf.stringToTerraform(struct!.exactMatch),
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    prefix_match: cdktf.stringToTerraform(struct!.prefixMatch),
    present_match: cdktf.booleanToTerraform(struct!.presentMatch),
    range_match: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct!.rangeMatch),
    regex_match: cdktf.stringToTerraform(struct!.regexMatch),
    suffix_match: cdktf.stringToTerraform(struct!.suffixMatch),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact_match: {
      value: cdktf.stringToHclTerraform(struct!.exactMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_match: {
      value: cdktf.stringToHclTerraform(struct!.prefixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    present_match: {
      value: cdktf.booleanToHclTerraform(struct!.presentMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    range_match: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct!.rangeMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch",
    },
    regex_match: {
      value: cdktf.stringToHclTerraform(struct!.regexMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suffix_match: {
      value: cdktf.stringToHclTerraform(struct!.suffixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exactMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.exactMatch = this._exactMatch;
    }
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._prefixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixMatch = this._prefixMatch;
    }
    if (this._presentMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.presentMatch = this._presentMatch;
    }
    if (this._rangeMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rangeMatch = this._rangeMatch?.internalValue;
    }
    if (this._regexMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexMatch = this._regexMatch;
    }
    if (this._suffixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffixMatch = this._suffixMatch;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exactMatch = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._prefixMatch = undefined;
      this._presentMatch = undefined;
      this._rangeMatch.internalValue = undefined;
      this._regexMatch = undefined;
      this._suffixMatch = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exactMatch = value.exactMatch;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._prefixMatch = value.prefixMatch;
      this._presentMatch = value.presentMatch;
      this._rangeMatch.internalValue = value.rangeMatch;
      this._regexMatch = value.regexMatch;
      this._suffixMatch = value.suffixMatch;
    }
  }

  // exact_match - computed: false, optional: true, required: false
  private _exactMatch?: string; 
  public get exactMatch() {
    return this.getStringAttribute('exact_match');
  }
  public set exactMatch(value: string) {
    this._exactMatch = value;
  }
  public resetExactMatch() {
    this._exactMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactMatchInput() {
    return this._exactMatch;
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // prefix_match - computed: false, optional: true, required: false
  private _prefixMatch?: string; 
  public get prefixMatch() {
    return this.getStringAttribute('prefix_match');
  }
  public set prefixMatch(value: string) {
    this._prefixMatch = value;
  }
  public resetPrefixMatch() {
    this._prefixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixMatchInput() {
    return this._prefixMatch;
  }

  // present_match - computed: false, optional: true, required: false
  private _presentMatch?: boolean | cdktf.IResolvable; 
  public get presentMatch() {
    return this.getBooleanAttribute('present_match');
  }
  public set presentMatch(value: boolean | cdktf.IResolvable) {
    this._presentMatch = value;
  }
  public resetPresentMatch() {
    this._presentMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get presentMatchInput() {
    return this._presentMatch;
  }

  // range_match - computed: false, optional: true, required: false
  private _rangeMatch = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchOutputReference(this, "range_match");
  public get rangeMatch() {
    return this._rangeMatch;
  }
  public putRangeMatch(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch) {
    this._rangeMatch.internalValue = value;
  }
  public resetRangeMatch() {
    this._rangeMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangeMatchInput() {
    return this._rangeMatch.internalValue;
  }

  // regex_match - computed: false, optional: true, required: false
  private _regexMatch?: string; 
  public get regexMatch() {
    return this.getStringAttribute('regex_match');
  }
  public set regexMatch(value: string) {
    this._regexMatch = value;
  }
  public resetRegexMatch() {
    this._regexMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexMatchInput() {
    return this._regexMatch;
  }

  // suffix_match - computed: false, optional: true, required: false
  private _suffixMatch?: string; 
  public get suffixMatch() {
    return this.getStringAttribute('suffix_match');
  }
  public set suffixMatch(value: string) {
    this._suffixMatch = value;
  }
  public resetSuffixMatch() {
    this._suffixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixMatchInput() {
    return this._suffixMatch;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#expect_match DataK8SGatewaySoloIoRouteOptionV1Manifest#expect_match}
  */
  readonly expectMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#headers DataK8SGatewaySoloIoRouteOptionV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeaders[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
    expect_match: cdktf.booleanToTerraform(struct!.expectMatch),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersToTerraform, false)(struct!.headers),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect_match: {
      value: cdktf.booleanToHclTerraform(struct!.expectMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    if (this._expectMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.expectMatch = this._expectMatch;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
      this._expectMatch = undefined;
      this._headers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
      this._expectMatch = value.expectMatch;
      this._headers.internalValue = value.headers;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }

  // expect_match - computed: false, optional: true, required: false
  private _expectMatch?: boolean | cdktf.IResolvable; 
  public get expectMatch() {
    return this.getBooleanAttribute('expect_match');
  }
  public set expectMatch(value: boolean | cdktf.IResolvable) {
    this._expectMatch = value;
  }
  public resetExpectMatch() {
    this._expectMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectMatchInput() {
    return this._expectMatch;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#key DataK8SGatewaySoloIoRouteOptionV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#path DataK8SGatewaySoloIoRouteOptionV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#default_value DataK8SGatewaySoloIoRouteOptionV1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#source DataK8SGatewaySoloIoRouteOptionV1Manifest#source}
  */
  readonly source?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    metadata_key: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyToTerraform(struct!.metadataKey),
    source: cdktf.stringToTerraform(struct!.source),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKey",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._descriptorKey = undefined;
      this._metadataKey.internalValue = undefined;
      this._source = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._descriptorKey = value.descriptorKey;
      this._metadataKey.internalValue = value.metadataKey;
      this._source = value.source;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteOptionV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header_name DataK8SGatewaySoloIoRouteOptionV1Manifest#header_name}
  */
  readonly headerName?: string;
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    header_name: cdktf.stringToTerraform(struct!.headerName),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_name: {
      value: cdktf.stringToHclTerraform(struct!.headerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._headerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerName = this._headerName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorKey = undefined;
      this._headerName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorKey = value.descriptorKey;
      this._headerName = value.headerName;
    }
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // header_name - computed: false, optional: true, required: false
  private _headerName?: string; 
  public get headerName() {
    return this.getStringAttribute('header_name');
  }
  public set headerName(value: string) {
    this._headerName = value;
  }
  public resetHeaderName() {
    this._headerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerNameInput() {
    return this._headerName;
  }
}
export interface DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#destination_cluster DataK8SGatewaySoloIoRouteOptionV1Manifest#destination_cluster}
  */
  readonly destinationCluster?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#generic_key DataK8SGatewaySoloIoRouteOptionV1Manifest#generic_key}
  */
  readonly genericKey?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#header_value_match DataK8SGatewaySoloIoRouteOptionV1Manifest#header_value_match}
  */
  readonly headerValueMatch?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#metadata DataK8SGatewaySoloIoRouteOptionV1Manifest#metadata}
  */
  readonly metadata?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadata;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#remote_address DataK8SGatewaySoloIoRouteOptionV1Manifest#remote_address}
  */
  readonly remoteAddress?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#request_headers DataK8SGatewaySoloIoRouteOptionV1Manifest#request_headers}
  */
  readonly requestHeaders?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_option_v1_manifest#source_cluster DataK8SGatewaySoloIoRouteOptionV1Manifest#source_cluster}
  */
  readonly sourceCluster?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    destination_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.destinationCluster),
    generic_key: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKeyToTerraform(struct!.genericKey),
    header_value_match: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchToTerraform(struct!.headerValueMatch),
    metadata: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataToTerraform(struct!.metadata),
    remote_address: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remoteAddress),
    request_headers: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeadersToTerraform(struct!.requestHeaders),
    source_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.sourceCluster),
  }
}


export function dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    destination_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.destinationCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    generic_key: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKeyToHclTerraform(struct!.genericKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKey",
    },
    header_value_match: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchToHclTerraform(struct!.headerValueMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatch",
    },
    metadata: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadata",
    },
    remote_address: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remoteAddress),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    request_headers: {
      value: dataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeadersToHclTerraform(struct!.requestHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeaders",
    },
    source_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.sourceCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._destinationCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationCluster = this._destinationCluster;
    }
    if (this._genericKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.genericKey = this._genericKey?.internalValue;
    }
    if (this._headerValueMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerValueMatch = this._headerValueMatch?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._remoteAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteAddress = this._remoteAddress;
    }
    if (this._requestHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaders = this._requestHeaders?.internalValue;
    }
    if (this._sourceCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceCluster = this._sourceCluster;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._destinationCluster = undefined;
      this._genericKey.internalValue = undefined;
      this._headerValueMatch.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._remoteAddress = undefined;
      this._requestHeaders.internalValue = undefined;
      this._sourceCluster = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._destinationCluster = value.destinationCluster;
      this._genericKey.internalValue = value.genericKey;
      this._headerValueMatch.internalValue = value.headerValueMatch;
      this._metadata.internalValue = value.metadata;
      this._remoteAddress = value.remoteAddress;
      this._requestHeaders.internalValue = value.requestHeaders;
      this._sourceCluster = value.sourceCluster;
    }
  }

  // destination_cluster - computed: false, optional: true, required: false
  private _destinationCluster?: { [key: string]: string }; 
  public get destinationCluster() {
    return this.getStringMapAttribute('destination_cluster');
  }
  public set destinationCluster(value: { [key: string]: string }) {
    this._destinationCluster = value;
  }
  public resetDestinationCluster() {
    this._destinationCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationClusterInput() {
    return this._destinationCluster;
  }

  // generic_key - computed: false, optional: true, required: false
  private _genericKey = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKeyOutputReference(this, "generic_key");
  public get genericKey() {
    return this._genericKey;
  }
  public putGenericKey(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsGenericKey) {
    this._genericKey.internalValue = value;
  }
  public resetGenericKey() {
    this._genericKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get genericKeyInput() {
    return this._genericKey.internalValue;
  }

  // header_value_match - computed: false, optional: true, required: false
  private _headerValueMatch = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatchOutputReference(this, "header_value_match");
  public get headerValueMatch() {
    return this._headerValueMatch;
  }
  public putHeaderValueMatch(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsHeaderValueMatch) {
    this._headerValueMatch.internalValue = value;
  }
  public resetHeaderValueMatch() {
    this._headerValueMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerValueMatchInput() {
    return this._headerValueMatch.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // remote_address - computed: false, optional: true, required: false
  private _remoteAddress?: { [key: string]: string }; 
  public get remoteAddress() {
    return this.getStringMapAttribute('remote_address');
  }
  public set remoteAddress(value: { [key: string]: string }) {
    this._remoteAddress = value;
  }
  public resetRemoteAddress() {
    this._remoteAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteAddressInput() {
    return this._remoteAddress;
  }

  // request_headers - computed: false, optional: true, required: false
  private _requestHeaders = new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeadersOutputReference(this, "request_headers");
  public get requestHeaders() {
    return this._requestHeaders;
  }
  public putRequestHeaders(value: DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsRequestHeaders) {
    this._requestHeaders.internalValue = value;
  }
  public resetRequestHeaders() {
    this._requestHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersInput() {
    return this._requestHeaders.internalValue;
  }

  // source_cluster - computed: false, optional: true, required: false
  private _sourceCluster?: { [key: string]: string }; 
  public get sourceCluster() {
    return this.getStringMapAttribute('source_cluster');
  }
  public set sourceCluster(value: { [key: string]: string }) {
    this._sourceCluster = value;
  }
  public resetSourceCluster() {
    this._sourceCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceClusterInput() {
    return this._sourceCluster;
  }
}

export class DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteOptionV1ManifestSpecOptionsRatelimitEarlyRateLimitsSetActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
