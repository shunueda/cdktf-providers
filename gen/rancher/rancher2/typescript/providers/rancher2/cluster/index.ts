// https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ClusterConfig extends cdktf.TerraformMetaArguments {
  /**
  * Annotations of the resource
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#annotations Cluster#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Cluster template ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_template_id Cluster#cluster_template_id}
  */
  readonly clusterTemplateId?: string;
  /**
  * Cluster template revision ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_template_revision_id Cluster#cluster_template_revision_id}
  */
  readonly clusterTemplateRevisionId?: string;
  /**
  * Default pod security admission configuration template name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#default_pod_security_admission_configuration_template_name Cluster#default_pod_security_admission_configuration_template_name}
  */
  readonly defaultPodSecurityAdmissionConfigurationTemplateName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#description Cluster#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#desired_agent_image Cluster#desired_agent_image}
  */
  readonly desiredAgentImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#desired_auth_image Cluster#desired_auth_image}
  */
  readonly desiredAuthImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#docker_root_dir Cluster#docker_root_dir}
  */
  readonly dockerRootDir?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#driver Cluster#driver}
  */
  readonly driver?: string;
  /**
  * Enable project network isolation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enable_network_policy Cluster#enable_network_policy}
  */
  readonly enableNetworkPolicy?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#fleet_workspace_name Cluster#fleet_workspace_name}
  */
  readonly fleetWorkspaceName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#id Cluster#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Labels of the resource
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#labels Cluster#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * Windows preferred cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#windows_prefered_cluster Cluster#windows_prefered_cluster}
  */
  readonly windowsPreferedCluster?: boolean | cdktf.IResolvable;
  /**
  * agent_env_vars block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#agent_env_vars Cluster#agent_env_vars}
  */
  readonly agentEnvVars?: ClusterAgentEnvVars[] | cdktf.IResolvable;
  /**
  * aks_config_v2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aks_config_v2 Cluster#aks_config_v2}
  */
  readonly aksConfigV2?: ClusterAksConfigV2;
  /**
  * cluster_agent_deployment_customization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_agent_deployment_customization Cluster#cluster_agent_deployment_customization}
  */
  readonly clusterAgentDeploymentCustomization?: ClusterClusterAgentDeploymentCustomization[] | cdktf.IResolvable;
  /**
  * cluster_auth_endpoint block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_auth_endpoint Cluster#cluster_auth_endpoint}
  */
  readonly clusterAuthEndpoint?: ClusterClusterAuthEndpoint;
  /**
  * cluster_template_answers block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_template_answers Cluster#cluster_template_answers}
  */
  readonly clusterTemplateAnswers?: ClusterClusterTemplateAnswers;
  /**
  * cluster_template_questions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_template_questions Cluster#cluster_template_questions}
  */
  readonly clusterTemplateQuestions?: ClusterClusterTemplateQuestions[] | cdktf.IResolvable;
  /**
  * eks_config_v2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#eks_config_v2 Cluster#eks_config_v2}
  */
  readonly eksConfigV2?: ClusterEksConfigV2;
  /**
  * fleet_agent_deployment_customization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#fleet_agent_deployment_customization Cluster#fleet_agent_deployment_customization}
  */
  readonly fleetAgentDeploymentCustomization?: ClusterFleetAgentDeploymentCustomization[] | cdktf.IResolvable;
  /**
  * gke_config_v2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#gke_config_v2 Cluster#gke_config_v2}
  */
  readonly gkeConfigV2?: ClusterGkeConfigV2;
  /**
  * imported_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#imported_config Cluster#imported_config}
  */
  readonly importedConfig?: ClusterImportedConfig;
  /**
  * k3s_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#k3s_config Cluster#k3s_config}
  */
  readonly k3SConfig?: ClusterK3SConfig;
  /**
  * oke_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#oke_config Cluster#oke_config}
  */
  readonly okeConfig?: ClusterOkeConfig;
  /**
  * rke2_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#rke2_config Cluster#rke2_config}
  */
  readonly rke2Config?: ClusterRke2Config;
  /**
  * rke_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#rke_config Cluster#rke_config}
  */
  readonly rkeConfig?: ClusterRkeConfig;
  /**
  * timeouts block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#timeouts Cluster#timeouts}
  */
  readonly timeouts?: ClusterTimeouts;
}
export interface ClusterClusterRegistrationToken {
}

export function clusterClusterRegistrationTokenToTerraform(struct?: ClusterClusterRegistrationToken): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterClusterRegistrationTokenToHclTerraform(struct?: ClusterClusterRegistrationToken): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterClusterRegistrationTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterClusterRegistrationToken | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterRegistrationToken | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // annotations - computed: true, optional: false, required: false
  private _annotations = new cdktf.StringMap(this, "annotations");
  public get annotations() {
    return this._annotations;
  }

  // cluster_id - computed: true, optional: false, required: false
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }

  // command - computed: true, optional: false, required: false
  public get command() {
    return this.getStringAttribute('command');
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // insecure_command - computed: true, optional: false, required: false
  public get insecureCommand() {
    return this.getStringAttribute('insecure_command');
  }

  // insecure_node_command - computed: true, optional: false, required: false
  public get insecureNodeCommand() {
    return this.getStringAttribute('insecure_node_command');
  }

  // insecure_windows_node_command - computed: true, optional: false, required: false
  public get insecureWindowsNodeCommand() {
    return this.getStringAttribute('insecure_windows_node_command');
  }

  // labels - computed: true, optional: false, required: false
  private _labels = new cdktf.StringMap(this, "labels");
  public get labels() {
    return this._labels;
  }

  // manifest_url - computed: true, optional: false, required: false
  public get manifestUrl() {
    return this.getStringAttribute('manifest_url');
  }

  // name - computed: true, optional: false, required: false
  public get name() {
    return this.getStringAttribute('name');
  }

  // node_command - computed: true, optional: false, required: false
  public get nodeCommand() {
    return this.getStringAttribute('node_command');
  }

  // token - computed: true, optional: false, required: false
  public get token() {
    return this.getStringAttribute('token');
  }

  // windows_node_command - computed: true, optional: false, required: false
  public get windowsNodeCommand() {
    return this.getStringAttribute('windows_node_command');
  }
}

export class ClusterClusterRegistrationTokenList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterClusterRegistrationTokenOutputReference {
    return new ClusterClusterRegistrationTokenOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterAgentEnvVars {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#value Cluster#value}
  */
  readonly value: string;
}

export function clusterAgentEnvVarsToTerraform(struct?: ClusterAgentEnvVars | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterAgentEnvVarsToHclTerraform(struct?: ClusterAgentEnvVars | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterAgentEnvVarsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterAgentEnvVars | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAgentEnvVars | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterAgentEnvVarsList extends cdktf.ComplexList {
  public internalValue? : ClusterAgentEnvVars[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterAgentEnvVarsOutputReference {
    return new ClusterAgentEnvVarsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterAksConfigV2NodePools {
  /**
  * The AKS node pool availability zones
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#availability_zones Cluster#availability_zones}
  */
  readonly availabilityZones?: string[];
  /**
  * The AKS node pool count
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#count Cluster#count}
  */
  readonly count?: number;
  /**
  * Is AKS node pool auto scaling enabled?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enable_auto_scaling Cluster#enable_auto_scaling}
  */
  readonly enableAutoScaling?: boolean | cdktf.IResolvable;
  /**
  * The AKS node pool labels
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#labels Cluster#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * The AKS node pool max count
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_count Cluster#max_count}
  */
  readonly maxCount?: number;
  /**
  * The AKS node pool max pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_pods Cluster#max_pods}
  */
  readonly maxPods?: number;
  /**
  * The AKS node pool max surge
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_surge Cluster#max_surge}
  */
  readonly maxSurge?: string;
  /**
  * The AKS node pool min count
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#min_count Cluster#min_count}
  */
  readonly minCount?: number;
  /**
  * The AKS node pool mode
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#mode Cluster#mode}
  */
  readonly mode?: string;
  /**
  * The AKS node group name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * The AKS node pool orchestrator version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#orchestrator_version Cluster#orchestrator_version}
  */
  readonly orchestratorVersion?: string;
  /**
  * The AKS node pool os disk size gb
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#os_disk_size_gb Cluster#os_disk_size_gb}
  */
  readonly osDiskSizeGb?: number;
  /**
  * The AKS node pool os disk type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#os_disk_type Cluster#os_disk_type}
  */
  readonly osDiskType?: string;
  /**
  * Enable AKS node pool os type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#os_type Cluster#os_type}
  */
  readonly osType?: string;
  /**
  * The AKS node pool taints
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#taints Cluster#taints}
  */
  readonly taints?: string[];
  /**
  * The AKS node pool vm size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vm_size Cluster#vm_size}
  */
  readonly vmSize?: string;
}

export function clusterAksConfigV2NodePoolsToTerraform(struct?: ClusterAksConfigV2NodePools | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    availability_zones: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.availabilityZones),
    count: cdktf.numberToTerraform(struct!.count),
    enable_auto_scaling: cdktf.booleanToTerraform(struct!.enableAutoScaling),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    max_count: cdktf.numberToTerraform(struct!.maxCount),
    max_pods: cdktf.numberToTerraform(struct!.maxPods),
    max_surge: cdktf.stringToTerraform(struct!.maxSurge),
    min_count: cdktf.numberToTerraform(struct!.minCount),
    mode: cdktf.stringToTerraform(struct!.mode),
    name: cdktf.stringToTerraform(struct!.name),
    orchestrator_version: cdktf.stringToTerraform(struct!.orchestratorVersion),
    os_disk_size_gb: cdktf.numberToTerraform(struct!.osDiskSizeGb),
    os_disk_type: cdktf.stringToTerraform(struct!.osDiskType),
    os_type: cdktf.stringToTerraform(struct!.osType),
    taints: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.taints),
    vm_size: cdktf.stringToTerraform(struct!.vmSize),
  }
}


export function clusterAksConfigV2NodePoolsToHclTerraform(struct?: ClusterAksConfigV2NodePools | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    availability_zones: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.availabilityZones),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    count: {
      value: cdktf.numberToHclTerraform(struct!.count),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_auto_scaling: {
      value: cdktf.booleanToHclTerraform(struct!.enableAutoScaling),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    max_count: {
      value: cdktf.numberToHclTerraform(struct!.maxCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_pods: {
      value: cdktf.numberToHclTerraform(struct!.maxPods),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_surge: {
      value: cdktf.stringToHclTerraform(struct!.maxSurge),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_count: {
      value: cdktf.numberToHclTerraform(struct!.minCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    orchestrator_version: {
      value: cdktf.stringToHclTerraform(struct!.orchestratorVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    os_disk_size_gb: {
      value: cdktf.numberToHclTerraform(struct!.osDiskSizeGb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    os_disk_type: {
      value: cdktf.stringToHclTerraform(struct!.osDiskType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    os_type: {
      value: cdktf.stringToHclTerraform(struct!.osType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    taints: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.taints),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    vm_size: {
      value: cdktf.stringToHclTerraform(struct!.vmSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterAksConfigV2NodePoolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterAksConfigV2NodePools | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._availabilityZones !== undefined) {
      hasAnyValues = true;
      internalValueResult.availabilityZones = this._availabilityZones;
    }
    if (this._count !== undefined) {
      hasAnyValues = true;
      internalValueResult.count = this._count;
    }
    if (this._enableAutoScaling !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAutoScaling = this._enableAutoScaling;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._maxCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxCount = this._maxCount;
    }
    if (this._maxPods !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPods = this._maxPods;
    }
    if (this._maxSurge !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSurge = this._maxSurge;
    }
    if (this._minCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.minCount = this._minCount;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._orchestratorVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.orchestratorVersion = this._orchestratorVersion;
    }
    if (this._osDiskSizeGb !== undefined) {
      hasAnyValues = true;
      internalValueResult.osDiskSizeGb = this._osDiskSizeGb;
    }
    if (this._osDiskType !== undefined) {
      hasAnyValues = true;
      internalValueResult.osDiskType = this._osDiskType;
    }
    if (this._osType !== undefined) {
      hasAnyValues = true;
      internalValueResult.osType = this._osType;
    }
    if (this._taints !== undefined) {
      hasAnyValues = true;
      internalValueResult.taints = this._taints;
    }
    if (this._vmSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.vmSize = this._vmSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAksConfigV2NodePools | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._availabilityZones = undefined;
      this._count = undefined;
      this._enableAutoScaling = undefined;
      this._labels = undefined;
      this._maxCount = undefined;
      this._maxPods = undefined;
      this._maxSurge = undefined;
      this._minCount = undefined;
      this._mode = undefined;
      this._name = undefined;
      this._orchestratorVersion = undefined;
      this._osDiskSizeGb = undefined;
      this._osDiskType = undefined;
      this._osType = undefined;
      this._taints = undefined;
      this._vmSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._availabilityZones = value.availabilityZones;
      this._count = value.count;
      this._enableAutoScaling = value.enableAutoScaling;
      this._labels = value.labels;
      this._maxCount = value.maxCount;
      this._maxPods = value.maxPods;
      this._maxSurge = value.maxSurge;
      this._minCount = value.minCount;
      this._mode = value.mode;
      this._name = value.name;
      this._orchestratorVersion = value.orchestratorVersion;
      this._osDiskSizeGb = value.osDiskSizeGb;
      this._osDiskType = value.osDiskType;
      this._osType = value.osType;
      this._taints = value.taints;
      this._vmSize = value.vmSize;
    }
  }

  // availability_zones - computed: false, optional: true, required: false
  private _availabilityZones?: string[]; 
  public get availabilityZones() {
    return this.getListAttribute('availability_zones');
  }
  public set availabilityZones(value: string[]) {
    this._availabilityZones = value;
  }
  public resetAvailabilityZones() {
    this._availabilityZones = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get availabilityZonesInput() {
    return this._availabilityZones;
  }

  // count - computed: false, optional: true, required: false
  private _count?: number; 
  public get count() {
    return this.getNumberAttribute('count');
  }
  public set count(value: number) {
    this._count = value;
  }
  public resetCount() {
    this._count = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get countInput() {
    return this._count;
  }

  // enable_auto_scaling - computed: false, optional: true, required: false
  private _enableAutoScaling?: boolean | cdktf.IResolvable; 
  public get enableAutoScaling() {
    return this.getBooleanAttribute('enable_auto_scaling');
  }
  public set enableAutoScaling(value: boolean | cdktf.IResolvable) {
    this._enableAutoScaling = value;
  }
  public resetEnableAutoScaling() {
    this._enableAutoScaling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAutoScalingInput() {
    return this._enableAutoScaling;
  }

  // labels - computed: true, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // max_count - computed: false, optional: true, required: false
  private _maxCount?: number; 
  public get maxCount() {
    return this.getNumberAttribute('max_count');
  }
  public set maxCount(value: number) {
    this._maxCount = value;
  }
  public resetMaxCount() {
    this._maxCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxCountInput() {
    return this._maxCount;
  }

  // max_pods - computed: false, optional: true, required: false
  private _maxPods?: number; 
  public get maxPods() {
    return this.getNumberAttribute('max_pods');
  }
  public set maxPods(value: number) {
    this._maxPods = value;
  }
  public resetMaxPods() {
    this._maxPods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPodsInput() {
    return this._maxPods;
  }

  // max_surge - computed: false, optional: true, required: false
  private _maxSurge?: string; 
  public get maxSurge() {
    return this.getStringAttribute('max_surge');
  }
  public set maxSurge(value: string) {
    this._maxSurge = value;
  }
  public resetMaxSurge() {
    this._maxSurge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSurgeInput() {
    return this._maxSurge;
  }

  // min_count - computed: false, optional: true, required: false
  private _minCount?: number; 
  public get minCount() {
    return this.getNumberAttribute('min_count');
  }
  public set minCount(value: number) {
    this._minCount = value;
  }
  public resetMinCount() {
    this._minCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minCountInput() {
    return this._minCount;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // orchestrator_version - computed: false, optional: true, required: false
  private _orchestratorVersion?: string; 
  public get orchestratorVersion() {
    return this.getStringAttribute('orchestrator_version');
  }
  public set orchestratorVersion(value: string) {
    this._orchestratorVersion = value;
  }
  public resetOrchestratorVersion() {
    this._orchestratorVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orchestratorVersionInput() {
    return this._orchestratorVersion;
  }

  // os_disk_size_gb - computed: false, optional: true, required: false
  private _osDiskSizeGb?: number; 
  public get osDiskSizeGb() {
    return this.getNumberAttribute('os_disk_size_gb');
  }
  public set osDiskSizeGb(value: number) {
    this._osDiskSizeGb = value;
  }
  public resetOsDiskSizeGb() {
    this._osDiskSizeGb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get osDiskSizeGbInput() {
    return this._osDiskSizeGb;
  }

  // os_disk_type - computed: false, optional: true, required: false
  private _osDiskType?: string; 
  public get osDiskType() {
    return this.getStringAttribute('os_disk_type');
  }
  public set osDiskType(value: string) {
    this._osDiskType = value;
  }
  public resetOsDiskType() {
    this._osDiskType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get osDiskTypeInput() {
    return this._osDiskType;
  }

  // os_type - computed: false, optional: true, required: false
  private _osType?: string; 
  public get osType() {
    return this.getStringAttribute('os_type');
  }
  public set osType(value: string) {
    this._osType = value;
  }
  public resetOsType() {
    this._osType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get osTypeInput() {
    return this._osType;
  }

  // taints - computed: true, optional: true, required: false
  private _taints?: string[]; 
  public get taints() {
    return this.getListAttribute('taints');
  }
  public set taints(value: string[]) {
    this._taints = value;
  }
  public resetTaints() {
    this._taints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taintsInput() {
    return this._taints;
  }

  // vm_size - computed: true, optional: true, required: false
  private _vmSize?: string; 
  public get vmSize() {
    return this.getStringAttribute('vm_size');
  }
  public set vmSize(value: string) {
    this._vmSize = value;
  }
  public resetVmSize() {
    this._vmSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vmSizeInput() {
    return this._vmSize;
  }
}

export class ClusterAksConfigV2NodePoolsList extends cdktf.ComplexList {
  public internalValue? : ClusterAksConfigV2NodePools[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterAksConfigV2NodePoolsOutputReference {
    return new ClusterAksConfigV2NodePoolsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterAksConfigV2 {
  /**
  * The AKS auth base url
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#auth_base_url Cluster#auth_base_url}
  */
  readonly authBaseUrl?: string;
  /**
  * The AKS authorized ip ranges
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#authorized_ip_ranges Cluster#authorized_ip_ranges}
  */
  readonly authorizedIpRanges?: string[];
  /**
  * The AKS base url
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#base_url Cluster#base_url}
  */
  readonly baseUrl?: string;
  /**
  * The AKS Cloud Credential ID to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_credential_id Cluster#cloud_credential_id}
  */
  readonly cloudCredentialId: string;
  /**
  * The AKS dns prefix. Required if `import=false`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#dns_prefix Cluster#dns_prefix}
  */
  readonly dnsPrefix?: string;
  /**
  * Enable AKS http application routing?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#http_application_routing Cluster#http_application_routing}
  */
  readonly httpApplicationRouting?: boolean | cdktf.IResolvable;
  /**
  * Is AKS cluster imported?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#imported Cluster#imported}
  */
  readonly imported?: boolean | cdktf.IResolvable;
  /**
  * The kubernetes master version. Required if `import=false`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kubernetes_version Cluster#kubernetes_version}
  */
  readonly kubernetesVersion?: string;
  /**
  * The AKS linux admin username
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#linux_admin_username Cluster#linux_admin_username}
  */
  readonly linuxAdminUsername?: string;
  /**
  * The AKS linux ssh public key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#linux_ssh_public_key Cluster#linux_ssh_public_key}
  */
  readonly linuxSshPublicKey?: string;
  /**
  * The AKS load balancer sku
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#load_balancer_sku Cluster#load_balancer_sku}
  */
  readonly loadBalancerSku?: string;
  /**
  * The AKS log analytics workspace group
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#log_analytics_workspace_group Cluster#log_analytics_workspace_group}
  */
  readonly logAnalyticsWorkspaceGroup?: string;
  /**
  * The AKS log analytics workspace name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#log_analytics_workspace_name Cluster#log_analytics_workspace_name}
  */
  readonly logAnalyticsWorkspaceName?: string;
  /**
  * Is AKS cluster monitoring enabled?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#monitoring Cluster#monitoring}
  */
  readonly monitoring?: boolean | cdktf.IResolvable;
  /**
  * The AKS cluster name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name?: string;
  /**
  * The AKS network dns service ip
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network_dns_service_ip Cluster#network_dns_service_ip}
  */
  readonly networkDnsServiceIp?: string;
  /**
  * The AKS network docker bridge cidr
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network_docker_bridge_cidr Cluster#network_docker_bridge_cidr}
  */
  readonly networkDockerBridgeCidr?: string;
  /**
  * The AKS network plugin. Required if `import=false`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network_plugin Cluster#network_plugin}
  */
  readonly networkPlugin?: string;
  /**
  * The AKS network pod cidr
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network_pod_cidr Cluster#network_pod_cidr}
  */
  readonly networkPodCidr?: string;
  /**
  * The AKS network policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network_policy Cluster#network_policy}
  */
  readonly networkPolicy?: string;
  /**
  * The AKS network service cidr
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network_service_cidr Cluster#network_service_cidr}
  */
  readonly networkServiceCidr?: string;
  /**
  * The AKS node resource group name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_resource_group Cluster#node_resource_group}
  */
  readonly nodeResourceGroup?: string;
  /**
  * The AKS outbound type for the egress traffic
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#outbound_type Cluster#outbound_type}
  */
  readonly outboundType?: string;
  /**
  * Is AKS cluster private?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#private_cluster Cluster#private_cluster}
  */
  readonly privateCluster?: boolean | cdktf.IResolvable;
  /**
  * The AKS resource group
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#resource_group Cluster#resource_group}
  */
  readonly resourceGroup: string;
  /**
  * The AKS resource location
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#resource_location Cluster#resource_location}
  */
  readonly resourceLocation: string;
  /**
  * The AKS subnet
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#subnet Cluster#subnet}
  */
  readonly subnet?: string;
  /**
  * The AKS cluster tags
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tags Cluster#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The AKS virtual network
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#virtual_network Cluster#virtual_network}
  */
  readonly virtualNetwork?: string;
  /**
  * The AKS virtual network resource group
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#virtual_network_resource_group Cluster#virtual_network_resource_group}
  */
  readonly virtualNetworkResourceGroup?: string;
  /**
  * node_pools block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_pools Cluster#node_pools}
  */
  readonly nodePools?: ClusterAksConfigV2NodePools[] | cdktf.IResolvable;
}

export function clusterAksConfigV2ToTerraform(struct?: ClusterAksConfigV2OutputReference | ClusterAksConfigV2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_base_url: cdktf.stringToTerraform(struct!.authBaseUrl),
    authorized_ip_ranges: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authorizedIpRanges),
    base_url: cdktf.stringToTerraform(struct!.baseUrl),
    cloud_credential_id: cdktf.stringToTerraform(struct!.cloudCredentialId),
    dns_prefix: cdktf.stringToTerraform(struct!.dnsPrefix),
    http_application_routing: cdktf.booleanToTerraform(struct!.httpApplicationRouting),
    imported: cdktf.booleanToTerraform(struct!.imported),
    kubernetes_version: cdktf.stringToTerraform(struct!.kubernetesVersion),
    linux_admin_username: cdktf.stringToTerraform(struct!.linuxAdminUsername),
    linux_ssh_public_key: cdktf.stringToTerraform(struct!.linuxSshPublicKey),
    load_balancer_sku: cdktf.stringToTerraform(struct!.loadBalancerSku),
    log_analytics_workspace_group: cdktf.stringToTerraform(struct!.logAnalyticsWorkspaceGroup),
    log_analytics_workspace_name: cdktf.stringToTerraform(struct!.logAnalyticsWorkspaceName),
    monitoring: cdktf.booleanToTerraform(struct!.monitoring),
    name: cdktf.stringToTerraform(struct!.name),
    network_dns_service_ip: cdktf.stringToTerraform(struct!.networkDnsServiceIp),
    network_docker_bridge_cidr: cdktf.stringToTerraform(struct!.networkDockerBridgeCidr),
    network_plugin: cdktf.stringToTerraform(struct!.networkPlugin),
    network_pod_cidr: cdktf.stringToTerraform(struct!.networkPodCidr),
    network_policy: cdktf.stringToTerraform(struct!.networkPolicy),
    network_service_cidr: cdktf.stringToTerraform(struct!.networkServiceCidr),
    node_resource_group: cdktf.stringToTerraform(struct!.nodeResourceGroup),
    outbound_type: cdktf.stringToTerraform(struct!.outboundType),
    private_cluster: cdktf.booleanToTerraform(struct!.privateCluster),
    resource_group: cdktf.stringToTerraform(struct!.resourceGroup),
    resource_location: cdktf.stringToTerraform(struct!.resourceLocation),
    subnet: cdktf.stringToTerraform(struct!.subnet),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    virtual_network: cdktf.stringToTerraform(struct!.virtualNetwork),
    virtual_network_resource_group: cdktf.stringToTerraform(struct!.virtualNetworkResourceGroup),
    node_pools: cdktf.listMapper(clusterAksConfigV2NodePoolsToTerraform, true)(struct!.nodePools),
  }
}


export function clusterAksConfigV2ToHclTerraform(struct?: ClusterAksConfigV2OutputReference | ClusterAksConfigV2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_base_url: {
      value: cdktf.stringToHclTerraform(struct!.authBaseUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorized_ip_ranges: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authorizedIpRanges),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    base_url: {
      value: cdktf.stringToHclTerraform(struct!.baseUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cloud_credential_id: {
      value: cdktf.stringToHclTerraform(struct!.cloudCredentialId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefix: {
      value: cdktf.stringToHclTerraform(struct!.dnsPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_application_routing: {
      value: cdktf.booleanToHclTerraform(struct!.httpApplicationRouting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    imported: {
      value: cdktf.booleanToHclTerraform(struct!.imported),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kubernetes_version: {
      value: cdktf.stringToHclTerraform(struct!.kubernetesVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    linux_admin_username: {
      value: cdktf.stringToHclTerraform(struct!.linuxAdminUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    linux_ssh_public_key: {
      value: cdktf.stringToHclTerraform(struct!.linuxSshPublicKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancer_sku: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancerSku),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_analytics_workspace_group: {
      value: cdktf.stringToHclTerraform(struct!.logAnalyticsWorkspaceGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_analytics_workspace_name: {
      value: cdktf.stringToHclTerraform(struct!.logAnalyticsWorkspaceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    monitoring: {
      value: cdktf.booleanToHclTerraform(struct!.monitoring),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_dns_service_ip: {
      value: cdktf.stringToHclTerraform(struct!.networkDnsServiceIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_docker_bridge_cidr: {
      value: cdktf.stringToHclTerraform(struct!.networkDockerBridgeCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_plugin: {
      value: cdktf.stringToHclTerraform(struct!.networkPlugin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_pod_cidr: {
      value: cdktf.stringToHclTerraform(struct!.networkPodCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_policy: {
      value: cdktf.stringToHclTerraform(struct!.networkPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_service_cidr: {
      value: cdktf.stringToHclTerraform(struct!.networkServiceCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_resource_group: {
      value: cdktf.stringToHclTerraform(struct!.nodeResourceGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    outbound_type: {
      value: cdktf.stringToHclTerraform(struct!.outboundType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_cluster: {
      value: cdktf.booleanToHclTerraform(struct!.privateCluster),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    resource_group: {
      value: cdktf.stringToHclTerraform(struct!.resourceGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_location: {
      value: cdktf.stringToHclTerraform(struct!.resourceLocation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subnet: {
      value: cdktf.stringToHclTerraform(struct!.subnet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    virtual_network: {
      value: cdktf.stringToHclTerraform(struct!.virtualNetwork),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    virtual_network_resource_group: {
      value: cdktf.stringToHclTerraform(struct!.virtualNetworkResourceGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_pools: {
      value: cdktf.listMapperHcl(clusterAksConfigV2NodePoolsToHclTerraform, true)(struct!.nodePools),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterAksConfigV2NodePoolsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterAksConfigV2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterAksConfigV2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authBaseUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.authBaseUrl = this._authBaseUrl;
    }
    if (this._authorizedIpRanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizedIpRanges = this._authorizedIpRanges;
    }
    if (this._baseUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseUrl = this._baseUrl;
    }
    if (this._cloudCredentialId !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudCredentialId = this._cloudCredentialId;
    }
    if (this._dnsPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPrefix = this._dnsPrefix;
    }
    if (this._httpApplicationRouting !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpApplicationRouting = this._httpApplicationRouting;
    }
    if (this._imported !== undefined) {
      hasAnyValues = true;
      internalValueResult.imported = this._imported;
    }
    if (this._kubernetesVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesVersion = this._kubernetesVersion;
    }
    if (this._linuxAdminUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.linuxAdminUsername = this._linuxAdminUsername;
    }
    if (this._linuxSshPublicKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.linuxSshPublicKey = this._linuxSshPublicKey;
    }
    if (this._loadBalancerSku !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerSku = this._loadBalancerSku;
    }
    if (this._logAnalyticsWorkspaceGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.logAnalyticsWorkspaceGroup = this._logAnalyticsWorkspaceGroup;
    }
    if (this._logAnalyticsWorkspaceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logAnalyticsWorkspaceName = this._logAnalyticsWorkspaceName;
    }
    if (this._monitoring !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoring = this._monitoring;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._networkDnsServiceIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkDnsServiceIp = this._networkDnsServiceIp;
    }
    if (this._networkDockerBridgeCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkDockerBridgeCidr = this._networkDockerBridgeCidr;
    }
    if (this._networkPlugin !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkPlugin = this._networkPlugin;
    }
    if (this._networkPodCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkPodCidr = this._networkPodCidr;
    }
    if (this._networkPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkPolicy = this._networkPolicy;
    }
    if (this._networkServiceCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkServiceCidr = this._networkServiceCidr;
    }
    if (this._nodeResourceGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeResourceGroup = this._nodeResourceGroup;
    }
    if (this._outboundType !== undefined) {
      hasAnyValues = true;
      internalValueResult.outboundType = this._outboundType;
    }
    if (this._privateCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateCluster = this._privateCluster;
    }
    if (this._resourceGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceGroup = this._resourceGroup;
    }
    if (this._resourceLocation !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceLocation = this._resourceLocation;
    }
    if (this._subnet !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnet = this._subnet;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._virtualNetwork !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualNetwork = this._virtualNetwork;
    }
    if (this._virtualNetworkResourceGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualNetworkResourceGroup = this._virtualNetworkResourceGroup;
    }
    if (this._nodePools?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodePools = this._nodePools?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAksConfigV2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authBaseUrl = undefined;
      this._authorizedIpRanges = undefined;
      this._baseUrl = undefined;
      this._cloudCredentialId = undefined;
      this._dnsPrefix = undefined;
      this._httpApplicationRouting = undefined;
      this._imported = undefined;
      this._kubernetesVersion = undefined;
      this._linuxAdminUsername = undefined;
      this._linuxSshPublicKey = undefined;
      this._loadBalancerSku = undefined;
      this._logAnalyticsWorkspaceGroup = undefined;
      this._logAnalyticsWorkspaceName = undefined;
      this._monitoring = undefined;
      this._name = undefined;
      this._networkDnsServiceIp = undefined;
      this._networkDockerBridgeCidr = undefined;
      this._networkPlugin = undefined;
      this._networkPodCidr = undefined;
      this._networkPolicy = undefined;
      this._networkServiceCidr = undefined;
      this._nodeResourceGroup = undefined;
      this._outboundType = undefined;
      this._privateCluster = undefined;
      this._resourceGroup = undefined;
      this._resourceLocation = undefined;
      this._subnet = undefined;
      this._tags = undefined;
      this._virtualNetwork = undefined;
      this._virtualNetworkResourceGroup = undefined;
      this._nodePools.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authBaseUrl = value.authBaseUrl;
      this._authorizedIpRanges = value.authorizedIpRanges;
      this._baseUrl = value.baseUrl;
      this._cloudCredentialId = value.cloudCredentialId;
      this._dnsPrefix = value.dnsPrefix;
      this._httpApplicationRouting = value.httpApplicationRouting;
      this._imported = value.imported;
      this._kubernetesVersion = value.kubernetesVersion;
      this._linuxAdminUsername = value.linuxAdminUsername;
      this._linuxSshPublicKey = value.linuxSshPublicKey;
      this._loadBalancerSku = value.loadBalancerSku;
      this._logAnalyticsWorkspaceGroup = value.logAnalyticsWorkspaceGroup;
      this._logAnalyticsWorkspaceName = value.logAnalyticsWorkspaceName;
      this._monitoring = value.monitoring;
      this._name = value.name;
      this._networkDnsServiceIp = value.networkDnsServiceIp;
      this._networkDockerBridgeCidr = value.networkDockerBridgeCidr;
      this._networkPlugin = value.networkPlugin;
      this._networkPodCidr = value.networkPodCidr;
      this._networkPolicy = value.networkPolicy;
      this._networkServiceCidr = value.networkServiceCidr;
      this._nodeResourceGroup = value.nodeResourceGroup;
      this._outboundType = value.outboundType;
      this._privateCluster = value.privateCluster;
      this._resourceGroup = value.resourceGroup;
      this._resourceLocation = value.resourceLocation;
      this._subnet = value.subnet;
      this._tags = value.tags;
      this._virtualNetwork = value.virtualNetwork;
      this._virtualNetworkResourceGroup = value.virtualNetworkResourceGroup;
      this._nodePools.internalValue = value.nodePools;
    }
  }

  // auth_base_url - computed: false, optional: true, required: false
  private _authBaseUrl?: string; 
  public get authBaseUrl() {
    return this.getStringAttribute('auth_base_url');
  }
  public set authBaseUrl(value: string) {
    this._authBaseUrl = value;
  }
  public resetAuthBaseUrl() {
    this._authBaseUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authBaseUrlInput() {
    return this._authBaseUrl;
  }

  // authorized_ip_ranges - computed: false, optional: true, required: false
  private _authorizedIpRanges?: string[]; 
  public get authorizedIpRanges() {
    return this.getListAttribute('authorized_ip_ranges');
  }
  public set authorizedIpRanges(value: string[]) {
    this._authorizedIpRanges = value;
  }
  public resetAuthorizedIpRanges() {
    this._authorizedIpRanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizedIpRangesInput() {
    return this._authorizedIpRanges;
  }

  // base_url - computed: false, optional: true, required: false
  private _baseUrl?: string; 
  public get baseUrl() {
    return this.getStringAttribute('base_url');
  }
  public set baseUrl(value: string) {
    this._baseUrl = value;
  }
  public resetBaseUrl() {
    this._baseUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseUrlInput() {
    return this._baseUrl;
  }

  // cloud_credential_id - computed: false, optional: false, required: true
  private _cloudCredentialId?: string; 
  public get cloudCredentialId() {
    return this.getStringAttribute('cloud_credential_id');
  }
  public set cloudCredentialId(value: string) {
    this._cloudCredentialId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudCredentialIdInput() {
    return this._cloudCredentialId;
  }

  // dns_prefix - computed: false, optional: true, required: false
  private _dnsPrefix?: string; 
  public get dnsPrefix() {
    return this.getStringAttribute('dns_prefix');
  }
  public set dnsPrefix(value: string) {
    this._dnsPrefix = value;
  }
  public resetDnsPrefix() {
    this._dnsPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPrefixInput() {
    return this._dnsPrefix;
  }

  // http_application_routing - computed: true, optional: true, required: false
  private _httpApplicationRouting?: boolean | cdktf.IResolvable; 
  public get httpApplicationRouting() {
    return this.getBooleanAttribute('http_application_routing');
  }
  public set httpApplicationRouting(value: boolean | cdktf.IResolvable) {
    this._httpApplicationRouting = value;
  }
  public resetHttpApplicationRouting() {
    this._httpApplicationRouting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpApplicationRoutingInput() {
    return this._httpApplicationRouting;
  }

  // imported - computed: false, optional: true, required: false
  private _imported?: boolean | cdktf.IResolvable; 
  public get imported() {
    return this.getBooleanAttribute('imported');
  }
  public set imported(value: boolean | cdktf.IResolvable) {
    this._imported = value;
  }
  public resetImported() {
    this._imported = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importedInput() {
    return this._imported;
  }

  // kubernetes_version - computed: false, optional: true, required: false
  private _kubernetesVersion?: string; 
  public get kubernetesVersion() {
    return this.getStringAttribute('kubernetes_version');
  }
  public set kubernetesVersion(value: string) {
    this._kubernetesVersion = value;
  }
  public resetKubernetesVersion() {
    this._kubernetesVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesVersionInput() {
    return this._kubernetesVersion;
  }

  // linux_admin_username - computed: true, optional: true, required: false
  private _linuxAdminUsername?: string; 
  public get linuxAdminUsername() {
    return this.getStringAttribute('linux_admin_username');
  }
  public set linuxAdminUsername(value: string) {
    this._linuxAdminUsername = value;
  }
  public resetLinuxAdminUsername() {
    this._linuxAdminUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get linuxAdminUsernameInput() {
    return this._linuxAdminUsername;
  }

  // linux_ssh_public_key - computed: true, optional: true, required: false
  private _linuxSshPublicKey?: string; 
  public get linuxSshPublicKey() {
    return this.getStringAttribute('linux_ssh_public_key');
  }
  public set linuxSshPublicKey(value: string) {
    this._linuxSshPublicKey = value;
  }
  public resetLinuxSshPublicKey() {
    this._linuxSshPublicKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get linuxSshPublicKeyInput() {
    return this._linuxSshPublicKey;
  }

  // load_balancer_sku - computed: true, optional: true, required: false
  private _loadBalancerSku?: string; 
  public get loadBalancerSku() {
    return this.getStringAttribute('load_balancer_sku');
  }
  public set loadBalancerSku(value: string) {
    this._loadBalancerSku = value;
  }
  public resetLoadBalancerSku() {
    this._loadBalancerSku = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerSkuInput() {
    return this._loadBalancerSku;
  }

  // log_analytics_workspace_group - computed: true, optional: true, required: false
  private _logAnalyticsWorkspaceGroup?: string; 
  public get logAnalyticsWorkspaceGroup() {
    return this.getStringAttribute('log_analytics_workspace_group');
  }
  public set logAnalyticsWorkspaceGroup(value: string) {
    this._logAnalyticsWorkspaceGroup = value;
  }
  public resetLogAnalyticsWorkspaceGroup() {
    this._logAnalyticsWorkspaceGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logAnalyticsWorkspaceGroupInput() {
    return this._logAnalyticsWorkspaceGroup;
  }

  // log_analytics_workspace_name - computed: true, optional: true, required: false
  private _logAnalyticsWorkspaceName?: string; 
  public get logAnalyticsWorkspaceName() {
    return this.getStringAttribute('log_analytics_workspace_name');
  }
  public set logAnalyticsWorkspaceName(value: string) {
    this._logAnalyticsWorkspaceName = value;
  }
  public resetLogAnalyticsWorkspaceName() {
    this._logAnalyticsWorkspaceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logAnalyticsWorkspaceNameInput() {
    return this._logAnalyticsWorkspaceName;
  }

  // monitoring - computed: true, optional: true, required: false
  private _monitoring?: boolean | cdktf.IResolvable; 
  public get monitoring() {
    return this.getBooleanAttribute('monitoring');
  }
  public set monitoring(value: boolean | cdktf.IResolvable) {
    this._monitoring = value;
  }
  public resetMonitoring() {
    this._monitoring = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringInput() {
    return this._monitoring;
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // network_dns_service_ip - computed: true, optional: true, required: false
  private _networkDnsServiceIp?: string; 
  public get networkDnsServiceIp() {
    return this.getStringAttribute('network_dns_service_ip');
  }
  public set networkDnsServiceIp(value: string) {
    this._networkDnsServiceIp = value;
  }
  public resetNetworkDnsServiceIp() {
    this._networkDnsServiceIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkDnsServiceIpInput() {
    return this._networkDnsServiceIp;
  }

  // network_docker_bridge_cidr - computed: true, optional: true, required: false
  private _networkDockerBridgeCidr?: string; 
  public get networkDockerBridgeCidr() {
    return this.getStringAttribute('network_docker_bridge_cidr');
  }
  public set networkDockerBridgeCidr(value: string) {
    this._networkDockerBridgeCidr = value;
  }
  public resetNetworkDockerBridgeCidr() {
    this._networkDockerBridgeCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkDockerBridgeCidrInput() {
    return this._networkDockerBridgeCidr;
  }

  // network_plugin - computed: false, optional: true, required: false
  private _networkPlugin?: string; 
  public get networkPlugin() {
    return this.getStringAttribute('network_plugin');
  }
  public set networkPlugin(value: string) {
    this._networkPlugin = value;
  }
  public resetNetworkPlugin() {
    this._networkPlugin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkPluginInput() {
    return this._networkPlugin;
  }

  // network_pod_cidr - computed: true, optional: true, required: false
  private _networkPodCidr?: string; 
  public get networkPodCidr() {
    return this.getStringAttribute('network_pod_cidr');
  }
  public set networkPodCidr(value: string) {
    this._networkPodCidr = value;
  }
  public resetNetworkPodCidr() {
    this._networkPodCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkPodCidrInput() {
    return this._networkPodCidr;
  }

  // network_policy - computed: true, optional: true, required: false
  private _networkPolicy?: string; 
  public get networkPolicy() {
    return this.getStringAttribute('network_policy');
  }
  public set networkPolicy(value: string) {
    this._networkPolicy = value;
  }
  public resetNetworkPolicy() {
    this._networkPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkPolicyInput() {
    return this._networkPolicy;
  }

  // network_service_cidr - computed: true, optional: true, required: false
  private _networkServiceCidr?: string; 
  public get networkServiceCidr() {
    return this.getStringAttribute('network_service_cidr');
  }
  public set networkServiceCidr(value: string) {
    this._networkServiceCidr = value;
  }
  public resetNetworkServiceCidr() {
    this._networkServiceCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkServiceCidrInput() {
    return this._networkServiceCidr;
  }

  // node_resource_group - computed: true, optional: true, required: false
  private _nodeResourceGroup?: string; 
  public get nodeResourceGroup() {
    return this.getStringAttribute('node_resource_group');
  }
  public set nodeResourceGroup(value: string) {
    this._nodeResourceGroup = value;
  }
  public resetNodeResourceGroup() {
    this._nodeResourceGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeResourceGroupInput() {
    return this._nodeResourceGroup;
  }

  // outbound_type - computed: false, optional: true, required: false
  private _outboundType?: string; 
  public get outboundType() {
    return this.getStringAttribute('outbound_type');
  }
  public set outboundType(value: string) {
    this._outboundType = value;
  }
  public resetOutboundType() {
    this._outboundType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outboundTypeInput() {
    return this._outboundType;
  }

  // private_cluster - computed: true, optional: true, required: false
  private _privateCluster?: boolean | cdktf.IResolvable; 
  public get privateCluster() {
    return this.getBooleanAttribute('private_cluster');
  }
  public set privateCluster(value: boolean | cdktf.IResolvable) {
    this._privateCluster = value;
  }
  public resetPrivateCluster() {
    this._privateCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateClusterInput() {
    return this._privateCluster;
  }

  // resource_group - computed: false, optional: false, required: true
  private _resourceGroup?: string; 
  public get resourceGroup() {
    return this.getStringAttribute('resource_group');
  }
  public set resourceGroup(value: string) {
    this._resourceGroup = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceGroupInput() {
    return this._resourceGroup;
  }

  // resource_location - computed: false, optional: false, required: true
  private _resourceLocation?: string; 
  public get resourceLocation() {
    return this.getStringAttribute('resource_location');
  }
  public set resourceLocation(value: string) {
    this._resourceLocation = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceLocationInput() {
    return this._resourceLocation;
  }

  // subnet - computed: true, optional: true, required: false
  private _subnet?: string; 
  public get subnet() {
    return this.getStringAttribute('subnet');
  }
  public set subnet(value: string) {
    this._subnet = value;
  }
  public resetSubnet() {
    this._subnet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetInput() {
    return this._subnet;
  }

  // tags - computed: true, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // virtual_network - computed: true, optional: true, required: false
  private _virtualNetwork?: string; 
  public get virtualNetwork() {
    return this.getStringAttribute('virtual_network');
  }
  public set virtualNetwork(value: string) {
    this._virtualNetwork = value;
  }
  public resetVirtualNetwork() {
    this._virtualNetwork = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualNetworkInput() {
    return this._virtualNetwork;
  }

  // virtual_network_resource_group - computed: true, optional: true, required: false
  private _virtualNetworkResourceGroup?: string; 
  public get virtualNetworkResourceGroup() {
    return this.getStringAttribute('virtual_network_resource_group');
  }
  public set virtualNetworkResourceGroup(value: string) {
    this._virtualNetworkResourceGroup = value;
  }
  public resetVirtualNetworkResourceGroup() {
    this._virtualNetworkResourceGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualNetworkResourceGroupInput() {
    return this._virtualNetworkResourceGroup;
  }

  // node_pools - computed: false, optional: true, required: false
  private _nodePools = new ClusterAksConfigV2NodePoolsList(this, "node_pools", false);
  public get nodePools() {
    return this._nodePools;
  }
  public putNodePools(value: ClusterAksConfigV2NodePools[] | cdktf.IResolvable) {
    this._nodePools.internalValue = value;
  }
  public resetNodePools() {
    this._nodePools.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodePoolsInput() {
    return this._nodePools.internalValue;
  }
}
export interface ClusterClusterAgentDeploymentCustomizationAppendTolerations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#effect Cluster#effect}
  */
  readonly effect?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#key Cluster#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#seconds Cluster#seconds}
  */
  readonly seconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: string;
}

export function clusterClusterAgentDeploymentCustomizationAppendTolerationsToTerraform(struct?: ClusterClusterAgentDeploymentCustomizationAppendTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    seconds: cdktf.numberToTerraform(struct!.seconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterClusterAgentDeploymentCustomizationAppendTolerationsToHclTerraform(struct?: ClusterClusterAgentDeploymentCustomizationAppendTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seconds: {
      value: cdktf.numberToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterClusterAgentDeploymentCustomizationAppendTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterClusterAgentDeploymentCustomizationAppendTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterAgentDeploymentCustomizationAppendTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._seconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._seconds = value.seconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // seconds - computed: true, optional: true, required: false
  private _seconds?: number; 
  public get seconds() {
    return this.getNumberAttribute('seconds');
  }
  public set seconds(value: number) {
    this._seconds = value;
  }
  public resetSeconds() {
    this._seconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterClusterAgentDeploymentCustomizationAppendTolerationsList extends cdktf.ComplexList {
  public internalValue? : ClusterClusterAgentDeploymentCustomizationAppendTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterClusterAgentDeploymentCustomizationAppendTolerationsOutputReference {
    return new ClusterClusterAgentDeploymentCustomizationAppendTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirements {
  /**
  * The maximum CPU limit for agent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cpu_limit Cluster#cpu_limit}
  */
  readonly cpuLimit?: string;
  /**
  * The minimum CPU required for agent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * The maximum memory limit for agent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#memory_limit Cluster#memory_limit}
  */
  readonly memoryLimit?: string;
  /**
  * The minimum memory required for agent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#memory_request Cluster#memory_request}
  */
  readonly memoryRequest?: string;
}

export function clusterClusterAgentDeploymentCustomizationOverrideResourceRequirementsToTerraform(struct?: ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu_limit: cdktf.stringToTerraform(struct!.cpuLimit),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    memory_limit: cdktf.stringToTerraform(struct!.memoryLimit),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
  }
}


export function clusterClusterAgentDeploymentCustomizationOverrideResourceRequirementsToHclTerraform(struct?: ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.memoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuLimit = this._cpuLimit;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._memoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLimit = this._memoryLimit;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpuLimit = undefined;
      this._cpuRequest = undefined;
      this._memoryLimit = undefined;
      this._memoryRequest = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpuLimit = value.cpuLimit;
      this._cpuRequest = value.cpuRequest;
      this._memoryLimit = value.memoryLimit;
      this._memoryRequest = value.memoryRequest;
    }
  }

  // cpu_limit - computed: false, optional: true, required: false
  private _cpuLimit?: string; 
  public get cpuLimit() {
    return this.getStringAttribute('cpu_limit');
  }
  public set cpuLimit(value: string) {
    this._cpuLimit = value;
  }
  public resetCpuLimit() {
    this._cpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuLimitInput() {
    return this._cpuLimit;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // memory_limit - computed: false, optional: true, required: false
  private _memoryLimit?: string; 
  public get memoryLimit() {
    return this.getStringAttribute('memory_limit');
  }
  public set memoryLimit(value: string) {
    this._memoryLimit = value;
  }
  public resetMemoryLimit() {
    this._memoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLimitInput() {
    return this._memoryLimit;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }
}

export class ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementsList extends cdktf.ComplexList {
  public internalValue? : ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirements[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementsOutputReference {
    return new ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget {
  /**
  * The maximum number of cattle cluster agent replicas that can be down at a given time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_unavailable Cluster#max_unavailable}
  */
  readonly maxUnavailable?: string;
  /**
  * The minimum number of cattle cluster agent replicas that must be running at a given time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#min_available Cluster#min_available}
  */
  readonly minAvailable?: string;
}

export function clusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetToTerraform(struct?: ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_unavailable: cdktf.stringToTerraform(struct!.maxUnavailable),
    min_available: cdktf.stringToTerraform(struct!.minAvailable),
  }
}


export function clusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetToHclTerraform(struct?: ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_unavailable: {
      value: cdktf.stringToHclTerraform(struct!.maxUnavailable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_available: {
      value: cdktf.stringToHclTerraform(struct!.minAvailable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxUnavailable !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxUnavailable = this._maxUnavailable;
    }
    if (this._minAvailable !== undefined) {
      hasAnyValues = true;
      internalValueResult.minAvailable = this._minAvailable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxUnavailable = undefined;
      this._minAvailable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxUnavailable = value.maxUnavailable;
      this._minAvailable = value.minAvailable;
    }
  }

  // max_unavailable - computed: false, optional: true, required: false
  private _maxUnavailable?: string; 
  public get maxUnavailable() {
    return this.getStringAttribute('max_unavailable');
  }
  public set maxUnavailable(value: string) {
    this._maxUnavailable = value;
  }
  public resetMaxUnavailable() {
    this._maxUnavailable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxUnavailableInput() {
    return this._maxUnavailable;
  }

  // min_available - computed: false, optional: true, required: false
  private _minAvailable?: string; 
  public get minAvailable() {
    return this.getStringAttribute('min_available');
  }
  public set minAvailable(value: string) {
    this._minAvailable = value;
  }
  public resetMinAvailable() {
    this._minAvailable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minAvailableInput() {
    return this._minAvailable;
  }
}

export class ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetList extends cdktf.ComplexList {
  public internalValue? : ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetOutputReference {
    return new ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass {
  /**
  * The preemption behavior for the cattle cluster agent. Must be either 'PreemptLowerPriority' or 'Never'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#preemption_policy Cluster#preemption_policy}
  */
  readonly preemptionPolicy?: string;
  /**
  * The priority value for the cattle cluster agent. Must be between negative 1 billion and 1 billion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#value Cluster#value}
  */
  readonly value: number;
}

export function clusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassToTerraform(struct?: ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preemption_policy: cdktf.stringToTerraform(struct!.preemptionPolicy),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function clusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassToHclTerraform(struct?: ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preemption_policy: {
      value: cdktf.stringToHclTerraform(struct!.preemptionPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preemptionPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.preemptionPolicy = this._preemptionPolicy;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preemptionPolicy = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preemptionPolicy = value.preemptionPolicy;
      this._value = value.value;
    }
  }

  // preemption_policy - computed: false, optional: true, required: false
  private _preemptionPolicy?: string; 
  public get preemptionPolicy() {
    return this.getStringAttribute('preemption_policy');
  }
  public set preemptionPolicy(value: string) {
    this._preemptionPolicy = value;
  }
  public resetPreemptionPolicy() {
    this._preemptionPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preemptionPolicyInput() {
    return this._preemptionPolicy;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassList extends cdktf.ComplexList {
  public internalValue? : ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassOutputReference {
    return new ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterClusterAgentDeploymentCustomizationSchedulingCustomization {
  /**
  * pod_disruption_budget block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#pod_disruption_budget Cluster#pod_disruption_budget}
  */
  readonly podDisruptionBudget?: ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget[] | cdktf.IResolvable;
  /**
  * priority_class block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#priority_class Cluster#priority_class}
  */
  readonly priorityClass?: ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass[] | cdktf.IResolvable;
}

export function clusterClusterAgentDeploymentCustomizationSchedulingCustomizationToTerraform(struct?: ClusterClusterAgentDeploymentCustomizationSchedulingCustomization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_disruption_budget: cdktf.listMapper(clusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetToTerraform, true)(struct!.podDisruptionBudget),
    priority_class: cdktf.listMapper(clusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassToTerraform, true)(struct!.priorityClass),
  }
}


export function clusterClusterAgentDeploymentCustomizationSchedulingCustomizationToHclTerraform(struct?: ClusterClusterAgentDeploymentCustomizationSchedulingCustomization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_disruption_budget: {
      value: cdktf.listMapperHcl(clusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetToHclTerraform, true)(struct!.podDisruptionBudget),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetList",
    },
    priority_class: {
      value: cdktf.listMapperHcl(clusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassToHclTerraform, true)(struct!.priorityClass),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterClusterAgentDeploymentCustomizationSchedulingCustomization | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podDisruptionBudget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podDisruptionBudget = this._podDisruptionBudget?.internalValue;
    }
    if (this._priorityClass?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.priorityClass = this._priorityClass?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterAgentDeploymentCustomizationSchedulingCustomization | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podDisruptionBudget.internalValue = undefined;
      this._priorityClass.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podDisruptionBudget.internalValue = value.podDisruptionBudget;
      this._priorityClass.internalValue = value.priorityClass;
    }
  }

  // pod_disruption_budget - computed: false, optional: true, required: false
  private _podDisruptionBudget = new ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetList(this, "pod_disruption_budget", false);
  public get podDisruptionBudget() {
    return this._podDisruptionBudget;
  }
  public putPodDisruptionBudget(value: ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget[] | cdktf.IResolvable) {
    this._podDisruptionBudget.internalValue = value;
  }
  public resetPodDisruptionBudget() {
    this._podDisruptionBudget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podDisruptionBudgetInput() {
    return this._podDisruptionBudget.internalValue;
  }

  // priority_class - computed: false, optional: true, required: false
  private _priorityClass = new ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassList(this, "priority_class", false);
  public get priorityClass() {
    return this._priorityClass;
  }
  public putPriorityClass(value: ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass[] | cdktf.IResolvable) {
    this._priorityClass.internalValue = value;
  }
  public resetPriorityClass() {
    this._priorityClass.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityClassInput() {
    return this._priorityClass.internalValue;
  }
}

export class ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationList extends cdktf.ComplexList {
  public internalValue? : ClusterClusterAgentDeploymentCustomizationSchedulingCustomization[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationOutputReference {
    return new ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterClusterAgentDeploymentCustomization {
  /**
  * User defined affinity to override default agent affinity
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#override_affinity Cluster#override_affinity}
  */
  readonly overrideAffinity?: string;
  /**
  * append_tolerations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#append_tolerations Cluster#append_tolerations}
  */
  readonly appendTolerations?: ClusterClusterAgentDeploymentCustomizationAppendTolerations[] | cdktf.IResolvable;
  /**
  * override_resource_requirements block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#override_resource_requirements Cluster#override_resource_requirements}
  */
  readonly overrideResourceRequirements?: ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirements[] | cdktf.IResolvable;
  /**
  * scheduling_customization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#scheduling_customization Cluster#scheduling_customization}
  */
  readonly schedulingCustomization?: ClusterClusterAgentDeploymentCustomizationSchedulingCustomization[] | cdktf.IResolvable;
}

export function clusterClusterAgentDeploymentCustomizationToTerraform(struct?: ClusterClusterAgentDeploymentCustomization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_affinity: cdktf.stringToTerraform(struct!.overrideAffinity),
    append_tolerations: cdktf.listMapper(clusterClusterAgentDeploymentCustomizationAppendTolerationsToTerraform, true)(struct!.appendTolerations),
    override_resource_requirements: cdktf.listMapper(clusterClusterAgentDeploymentCustomizationOverrideResourceRequirementsToTerraform, true)(struct!.overrideResourceRequirements),
    scheduling_customization: cdktf.listMapper(clusterClusterAgentDeploymentCustomizationSchedulingCustomizationToTerraform, true)(struct!.schedulingCustomization),
  }
}


export function clusterClusterAgentDeploymentCustomizationToHclTerraform(struct?: ClusterClusterAgentDeploymentCustomization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_affinity: {
      value: cdktf.stringToHclTerraform(struct!.overrideAffinity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    append_tolerations: {
      value: cdktf.listMapperHcl(clusterClusterAgentDeploymentCustomizationAppendTolerationsToHclTerraform, true)(struct!.appendTolerations),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterClusterAgentDeploymentCustomizationAppendTolerationsList",
    },
    override_resource_requirements: {
      value: cdktf.listMapperHcl(clusterClusterAgentDeploymentCustomizationOverrideResourceRequirementsToHclTerraform, true)(struct!.overrideResourceRequirements),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementsList",
    },
    scheduling_customization: {
      value: cdktf.listMapperHcl(clusterClusterAgentDeploymentCustomizationSchedulingCustomizationToHclTerraform, true)(struct!.schedulingCustomization),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterClusterAgentDeploymentCustomizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterClusterAgentDeploymentCustomization | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideAffinity !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideAffinity = this._overrideAffinity;
    }
    if (this._appendTolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appendTolerations = this._appendTolerations?.internalValue;
    }
    if (this._overrideResourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideResourceRequirements = this._overrideResourceRequirements?.internalValue;
    }
    if (this._schedulingCustomization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.schedulingCustomization = this._schedulingCustomization?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterAgentDeploymentCustomization | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideAffinity = undefined;
      this._appendTolerations.internalValue = undefined;
      this._overrideResourceRequirements.internalValue = undefined;
      this._schedulingCustomization.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideAffinity = value.overrideAffinity;
      this._appendTolerations.internalValue = value.appendTolerations;
      this._overrideResourceRequirements.internalValue = value.overrideResourceRequirements;
      this._schedulingCustomization.internalValue = value.schedulingCustomization;
    }
  }

  // override_affinity - computed: false, optional: true, required: false
  private _overrideAffinity?: string; 
  public get overrideAffinity() {
    return this.getStringAttribute('override_affinity');
  }
  public set overrideAffinity(value: string) {
    this._overrideAffinity = value;
  }
  public resetOverrideAffinity() {
    this._overrideAffinity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideAffinityInput() {
    return this._overrideAffinity;
  }

  // append_tolerations - computed: false, optional: true, required: false
  private _appendTolerations = new ClusterClusterAgentDeploymentCustomizationAppendTolerationsList(this, "append_tolerations", false);
  public get appendTolerations() {
    return this._appendTolerations;
  }
  public putAppendTolerations(value: ClusterClusterAgentDeploymentCustomizationAppendTolerations[] | cdktf.IResolvable) {
    this._appendTolerations.internalValue = value;
  }
  public resetAppendTolerations() {
    this._appendTolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendTolerationsInput() {
    return this._appendTolerations.internalValue;
  }

  // override_resource_requirements - computed: false, optional: true, required: false
  private _overrideResourceRequirements = new ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementsList(this, "override_resource_requirements", false);
  public get overrideResourceRequirements() {
    return this._overrideResourceRequirements;
  }
  public putOverrideResourceRequirements(value: ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirements[] | cdktf.IResolvable) {
    this._overrideResourceRequirements.internalValue = value;
  }
  public resetOverrideResourceRequirements() {
    this._overrideResourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideResourceRequirementsInput() {
    return this._overrideResourceRequirements.internalValue;
  }

  // scheduling_customization - computed: false, optional: true, required: false
  private _schedulingCustomization = new ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationList(this, "scheduling_customization", false);
  public get schedulingCustomization() {
    return this._schedulingCustomization;
  }
  public putSchedulingCustomization(value: ClusterClusterAgentDeploymentCustomizationSchedulingCustomization[] | cdktf.IResolvable) {
    this._schedulingCustomization.internalValue = value;
  }
  public resetSchedulingCustomization() {
    this._schedulingCustomization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schedulingCustomizationInput() {
    return this._schedulingCustomization.internalValue;
  }
}

export class ClusterClusterAgentDeploymentCustomizationList extends cdktf.ComplexList {
  public internalValue? : ClusterClusterAgentDeploymentCustomization[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterClusterAgentDeploymentCustomizationOutputReference {
    return new ClusterClusterAgentDeploymentCustomizationOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterClusterAuthEndpoint {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ca_certs Cluster#ca_certs}
  */
  readonly caCerts?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#fqdn Cluster#fqdn}
  */
  readonly fqdn?: string;
}

export function clusterClusterAuthEndpointToTerraform(struct?: ClusterClusterAuthEndpointOutputReference | ClusterClusterAuthEndpoint): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certs: cdktf.stringToTerraform(struct!.caCerts),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
  }
}


export function clusterClusterAuthEndpointToHclTerraform(struct?: ClusterClusterAuthEndpointOutputReference | ClusterClusterAuthEndpoint): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certs: {
      value: cdktf.stringToHclTerraform(struct!.caCerts),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterClusterAuthEndpointOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterClusterAuthEndpoint | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCerts !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCerts = this._caCerts;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterAuthEndpoint | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._caCerts = undefined;
      this._enabled = undefined;
      this._fqdn = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._caCerts = value.caCerts;
      this._enabled = value.enabled;
      this._fqdn = value.fqdn;
    }
  }

  // ca_certs - computed: false, optional: true, required: false
  private _caCerts?: string; 
  public get caCerts() {
    return this.getStringAttribute('ca_certs');
  }
  public set caCerts(value: string) {
    this._caCerts = value;
  }
  public resetCaCerts() {
    this._caCerts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertsInput() {
    return this._caCerts;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }
}
export interface ClusterClusterTemplateAnswers {
  /**
  * Cluster ID for answer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_id Cluster#cluster_id}
  */
  readonly clusterId?: string;
  /**
  * Project ID for answer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#project_id Cluster#project_id}
  */
  readonly projectId?: string;
  /**
  * Key/values for answer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: { [key: string]: string };
}

export function clusterClusterTemplateAnswersToTerraform(struct?: ClusterClusterTemplateAnswersOutputReference | ClusterClusterTemplateAnswers): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_id: cdktf.stringToTerraform(struct!.clusterId),
    project_id: cdktf.stringToTerraform(struct!.projectId),
    values: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.values),
  }
}


export function clusterClusterTemplateAnswersToHclTerraform(struct?: ClusterClusterTemplateAnswersOutputReference | ClusterClusterTemplateAnswers): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.values),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterClusterTemplateAnswersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterClusterTemplateAnswers | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterTemplateAnswers | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clusterId = undefined;
      this._projectId = undefined;
      this._values = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clusterId = value.clusterId;
      this._projectId = value.projectId;
      this._values = value.values;
    }
  }

  // cluster_id - computed: true, optional: true, required: false
  private _clusterId?: string; 
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }
  public set clusterId(value: string) {
    this._clusterId = value;
  }
  public resetClusterId() {
    this._clusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // project_id - computed: true, optional: true, required: false
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  public resetProjectId() {
    this._projectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }

  // values - computed: true, optional: true, required: false
  private _values?: { [key: string]: string }; 
  public get values() {
    return this.getStringMapAttribute('values');
  }
  public set values(value: { [key: string]: string }) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}
export interface ClusterClusterTemplateQuestions {
  /**
  * Default variable value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#default Cluster#default}
  */
  readonly default: string;
  /**
  * Required variable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#required Cluster#required}
  */
  readonly required?: boolean | cdktf.IResolvable;
  /**
  * Variable type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#type Cluster#type}
  */
  readonly type?: string;
  /**
  * Variable name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#variable Cluster#variable}
  */
  readonly variable: string;
}

export function clusterClusterTemplateQuestionsToTerraform(struct?: ClusterClusterTemplateQuestions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default: cdktf.stringToTerraform(struct!.default),
    required: cdktf.booleanToTerraform(struct!.required),
    type: cdktf.stringToTerraform(struct!.type),
    variable: cdktf.stringToTerraform(struct!.variable),
  }
}


export function clusterClusterTemplateQuestionsToHclTerraform(struct?: ClusterClusterTemplateQuestions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default: {
      value: cdktf.stringToHclTerraform(struct!.default),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    required: {
      value: cdktf.booleanToHclTerraform(struct!.required),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    variable: {
      value: cdktf.stringToHclTerraform(struct!.variable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterClusterTemplateQuestionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterClusterTemplateQuestions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._required !== undefined) {
      hasAnyValues = true;
      internalValueResult.required = this._required;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._variable !== undefined) {
      hasAnyValues = true;
      internalValueResult.variable = this._variable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterTemplateQuestions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._default = undefined;
      this._required = undefined;
      this._type = undefined;
      this._variable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._default = value.default;
      this._required = value.required;
      this._type = value.type;
      this._variable = value.variable;
    }
  }

  // default - computed: false, optional: false, required: true
  private _default?: string; 
  public get default() {
    return this.getStringAttribute('default');
  }
  public set default(value: string) {
    this._default = value;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // required - computed: false, optional: true, required: false
  private _required?: boolean | cdktf.IResolvable; 
  public get required() {
    return this.getBooleanAttribute('required');
  }
  public set required(value: boolean | cdktf.IResolvable) {
    this._required = value;
  }
  public resetRequired() {
    this._required = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredInput() {
    return this._required;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // variable - computed: false, optional: false, required: true
  private _variable?: string; 
  public get variable() {
    return this.getStringAttribute('variable');
  }
  public set variable(value: string) {
    this._variable = value;
  }
  // Temporarily expose input value. Use with caution.
  public get variableInput() {
    return this._variable;
  }
}

export class ClusterClusterTemplateQuestionsList extends cdktf.ComplexList {
  public internalValue? : ClusterClusterTemplateQuestions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterClusterTemplateQuestionsOutputReference {
    return new ClusterClusterTemplateQuestionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterEksConfigV2NodeGroupsLaunchTemplate {
  /**
  * The EKS node group launch template ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#id Cluster#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * The EKS node group launch template name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * The EKS node group launch template version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#version Cluster#version}
  */
  readonly version: number;
}

export function clusterEksConfigV2NodeGroupsLaunchTemplateToTerraform(struct?: ClusterEksConfigV2NodeGroupsLaunchTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    name: cdktf.stringToTerraform(struct!.name),
    version: cdktf.numberToTerraform(struct!.version),
  }
}


export function clusterEksConfigV2NodeGroupsLaunchTemplateToHclTerraform(struct?: ClusterEksConfigV2NodeGroupsLaunchTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.numberToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterEksConfigV2NodeGroupsLaunchTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterEksConfigV2NodeGroupsLaunchTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterEksConfigV2NodeGroupsLaunchTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._name = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._name = value.name;
      this._version = value.version;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // version - computed: false, optional: false, required: true
  private _version?: number; 
  public get version() {
    return this.getNumberAttribute('version');
  }
  public set version(value: number) {
    this._version = value;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}

export class ClusterEksConfigV2NodeGroupsLaunchTemplateList extends cdktf.ComplexList {
  public internalValue? : ClusterEksConfigV2NodeGroupsLaunchTemplate[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterEksConfigV2NodeGroupsLaunchTemplateOutputReference {
    return new ClusterEksConfigV2NodeGroupsLaunchTemplateOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterEksConfigV2NodeGroups {
  /**
  * The EKS node group desired size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#desired_size Cluster#desired_size}
  */
  readonly desiredSize?: number;
  /**
  * The EKS node group disk size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#disk_size Cluster#disk_size}
  */
  readonly diskSize?: number;
  /**
  * The EKS node group ssh key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ec2_ssh_key Cluster#ec2_ssh_key}
  */
  readonly ec2SshKey?: string;
  /**
  * Is EKS cluster using gpu?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#gpu Cluster#gpu}
  */
  readonly gpu?: boolean | cdktf.IResolvable;
  /**
  * The EKS node group image ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image_id Cluster#image_id}
  */
  readonly imageId?: string;
  /**
  * The EKS node group instance type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#instance_type Cluster#instance_type}
  */
  readonly instanceType?: string;
  /**
  * The EKS node group tags
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#labels Cluster#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * The EKS node group maximum size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_size Cluster#max_size}
  */
  readonly maxSize?: number;
  /**
  * The EKS node group minimum size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#min_size Cluster#min_size}
  */
  readonly minSize?: number;
  /**
  * The EKS node group name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * The EKS node group node role ARN
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_role Cluster#node_role}
  */
  readonly nodeRole?: string;
  /**
  * Enable EKS node group request spot instances
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#request_spot_instances Cluster#request_spot_instances}
  */
  readonly requestSpotInstances?: boolean | cdktf.IResolvable;
  /**
  * The EKS node group resource tags
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#resource_tags Cluster#resource_tags}
  */
  readonly resourceTags?: { [key: string]: string };
  /**
  * The EKS node group spot instance types
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#spot_instance_types Cluster#spot_instance_types}
  */
  readonly spotInstanceTypes?: string[];
  /**
  * The EKS node group subnets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#subnets Cluster#subnets}
  */
  readonly subnets?: string[];
  /**
  * The EKS node group tags
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tags Cluster#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The EKS node group user data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#user_data Cluster#user_data}
  */
  readonly userData?: string;
  /**
  * launch_template block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#launch_template Cluster#launch_template}
  */
  readonly launchTemplate?: ClusterEksConfigV2NodeGroupsLaunchTemplate[] | cdktf.IResolvable;
}

export function clusterEksConfigV2NodeGroupsToTerraform(struct?: ClusterEksConfigV2NodeGroups | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    desired_size: cdktf.numberToTerraform(struct!.desiredSize),
    disk_size: cdktf.numberToTerraform(struct!.diskSize),
    ec2_ssh_key: cdktf.stringToTerraform(struct!.ec2SshKey),
    gpu: cdktf.booleanToTerraform(struct!.gpu),
    image_id: cdktf.stringToTerraform(struct!.imageId),
    instance_type: cdktf.stringToTerraform(struct!.instanceType),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    max_size: cdktf.numberToTerraform(struct!.maxSize),
    min_size: cdktf.numberToTerraform(struct!.minSize),
    name: cdktf.stringToTerraform(struct!.name),
    node_role: cdktf.stringToTerraform(struct!.nodeRole),
    request_spot_instances: cdktf.booleanToTerraform(struct!.requestSpotInstances),
    resource_tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.resourceTags),
    spot_instance_types: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.spotInstanceTypes),
    subnets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subnets),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    user_data: cdktf.stringToTerraform(struct!.userData),
    launch_template: cdktf.listMapper(clusterEksConfigV2NodeGroupsLaunchTemplateToTerraform, true)(struct!.launchTemplate),
  }
}


export function clusterEksConfigV2NodeGroupsToHclTerraform(struct?: ClusterEksConfigV2NodeGroups | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    desired_size: {
      value: cdktf.numberToHclTerraform(struct!.desiredSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disk_size: {
      value: cdktf.numberToHclTerraform(struct!.diskSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ec2_ssh_key: {
      value: cdktf.stringToHclTerraform(struct!.ec2SshKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gpu: {
      value: cdktf.booleanToHclTerraform(struct!.gpu),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    image_id: {
      value: cdktf.stringToHclTerraform(struct!.imageId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    instance_type: {
      value: cdktf.stringToHclTerraform(struct!.instanceType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    max_size: {
      value: cdktf.numberToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min_size: {
      value: cdktf.numberToHclTerraform(struct!.minSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_role: {
      value: cdktf.stringToHclTerraform(struct!.nodeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_spot_instances: {
      value: cdktf.booleanToHclTerraform(struct!.requestSpotInstances),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    resource_tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.resourceTags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    spot_instance_types: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.spotInstanceTypes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    subnets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subnets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    user_data: {
      value: cdktf.stringToHclTerraform(struct!.userData),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    launch_template: {
      value: cdktf.listMapperHcl(clusterEksConfigV2NodeGroupsLaunchTemplateToHclTerraform, true)(struct!.launchTemplate),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterEksConfigV2NodeGroupsLaunchTemplateList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterEksConfigV2NodeGroupsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterEksConfigV2NodeGroups | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._desiredSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.desiredSize = this._desiredSize;
    }
    if (this._diskSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.diskSize = this._diskSize;
    }
    if (this._ec2SshKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.ec2SshKey = this._ec2SshKey;
    }
    if (this._gpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.gpu = this._gpu;
    }
    if (this._imageId !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageId = this._imageId;
    }
    if (this._instanceType !== undefined) {
      hasAnyValues = true;
      internalValueResult.instanceType = this._instanceType;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._minSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.minSize = this._minSize;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._nodeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeRole = this._nodeRole;
    }
    if (this._requestSpotInstances !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestSpotInstances = this._requestSpotInstances;
    }
    if (this._resourceTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceTags = this._resourceTags;
    }
    if (this._spotInstanceTypes !== undefined) {
      hasAnyValues = true;
      internalValueResult.spotInstanceTypes = this._spotInstanceTypes;
    }
    if (this._subnets !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnets = this._subnets;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._userData !== undefined) {
      hasAnyValues = true;
      internalValueResult.userData = this._userData;
    }
    if (this._launchTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.launchTemplate = this._launchTemplate?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterEksConfigV2NodeGroups | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._desiredSize = undefined;
      this._diskSize = undefined;
      this._ec2SshKey = undefined;
      this._gpu = undefined;
      this._imageId = undefined;
      this._instanceType = undefined;
      this._labels = undefined;
      this._maxSize = undefined;
      this._minSize = undefined;
      this._name = undefined;
      this._nodeRole = undefined;
      this._requestSpotInstances = undefined;
      this._resourceTags = undefined;
      this._spotInstanceTypes = undefined;
      this._subnets = undefined;
      this._tags = undefined;
      this._userData = undefined;
      this._launchTemplate.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._desiredSize = value.desiredSize;
      this._diskSize = value.diskSize;
      this._ec2SshKey = value.ec2SshKey;
      this._gpu = value.gpu;
      this._imageId = value.imageId;
      this._instanceType = value.instanceType;
      this._labels = value.labels;
      this._maxSize = value.maxSize;
      this._minSize = value.minSize;
      this._name = value.name;
      this._nodeRole = value.nodeRole;
      this._requestSpotInstances = value.requestSpotInstances;
      this._resourceTags = value.resourceTags;
      this._spotInstanceTypes = value.spotInstanceTypes;
      this._subnets = value.subnets;
      this._tags = value.tags;
      this._userData = value.userData;
      this._launchTemplate.internalValue = value.launchTemplate;
    }
  }

  // desired_size - computed: false, optional: true, required: false
  private _desiredSize?: number; 
  public get desiredSize() {
    return this.getNumberAttribute('desired_size');
  }
  public set desiredSize(value: number) {
    this._desiredSize = value;
  }
  public resetDesiredSize() {
    this._desiredSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get desiredSizeInput() {
    return this._desiredSize;
  }

  // disk_size - computed: false, optional: true, required: false
  private _diskSize?: number; 
  public get diskSize() {
    return this.getNumberAttribute('disk_size');
  }
  public set diskSize(value: number) {
    this._diskSize = value;
  }
  public resetDiskSize() {
    this._diskSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskSizeInput() {
    return this._diskSize;
  }

  // ec2_ssh_key - computed: false, optional: true, required: false
  private _ec2SshKey?: string; 
  public get ec2SshKey() {
    return this.getStringAttribute('ec2_ssh_key');
  }
  public set ec2SshKey(value: string) {
    this._ec2SshKey = value;
  }
  public resetEc2SshKey() {
    this._ec2SshKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ec2SshKeyInput() {
    return this._ec2SshKey;
  }

  // gpu - computed: false, optional: true, required: false
  private _gpu?: boolean | cdktf.IResolvable; 
  public get gpu() {
    return this.getBooleanAttribute('gpu');
  }
  public set gpu(value: boolean | cdktf.IResolvable) {
    this._gpu = value;
  }
  public resetGpu() {
    this._gpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gpuInput() {
    return this._gpu;
  }

  // image_id - computed: false, optional: true, required: false
  private _imageId?: string; 
  public get imageId() {
    return this.getStringAttribute('image_id');
  }
  public set imageId(value: string) {
    this._imageId = value;
  }
  public resetImageId() {
    this._imageId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageIdInput() {
    return this._imageId;
  }

  // instance_type - computed: false, optional: true, required: false
  private _instanceType?: string; 
  public get instanceType() {
    return this.getStringAttribute('instance_type');
  }
  public set instanceType(value: string) {
    this._instanceType = value;
  }
  public resetInstanceType() {
    this._instanceType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get instanceTypeInput() {
    return this._instanceType;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize?: number; 
  public get maxSize() {
    return this.getNumberAttribute('max_size');
  }
  public set maxSize(value: number) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // min_size - computed: false, optional: true, required: false
  private _minSize?: number; 
  public get minSize() {
    return this.getNumberAttribute('min_size');
  }
  public set minSize(value: number) {
    this._minSize = value;
  }
  public resetMinSize() {
    this._minSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minSizeInput() {
    return this._minSize;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // node_role - computed: false, optional: true, required: false
  private _nodeRole?: string; 
  public get nodeRole() {
    return this.getStringAttribute('node_role');
  }
  public set nodeRole(value: string) {
    this._nodeRole = value;
  }
  public resetNodeRole() {
    this._nodeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeRoleInput() {
    return this._nodeRole;
  }

  // request_spot_instances - computed: false, optional: true, required: false
  private _requestSpotInstances?: boolean | cdktf.IResolvable; 
  public get requestSpotInstances() {
    return this.getBooleanAttribute('request_spot_instances');
  }
  public set requestSpotInstances(value: boolean | cdktf.IResolvable) {
    this._requestSpotInstances = value;
  }
  public resetRequestSpotInstances() {
    this._requestSpotInstances = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestSpotInstancesInput() {
    return this._requestSpotInstances;
  }

  // resource_tags - computed: false, optional: true, required: false
  private _resourceTags?: { [key: string]: string }; 
  public get resourceTags() {
    return this.getStringMapAttribute('resource_tags');
  }
  public set resourceTags(value: { [key: string]: string }) {
    this._resourceTags = value;
  }
  public resetResourceTags() {
    this._resourceTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceTagsInput() {
    return this._resourceTags;
  }

  // spot_instance_types - computed: false, optional: true, required: false
  private _spotInstanceTypes?: string[]; 
  public get spotInstanceTypes() {
    return this.getListAttribute('spot_instance_types');
  }
  public set spotInstanceTypes(value: string[]) {
    this._spotInstanceTypes = value;
  }
  public resetSpotInstanceTypes() {
    this._spotInstanceTypes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spotInstanceTypesInput() {
    return this._spotInstanceTypes;
  }

  // subnets - computed: true, optional: true, required: false
  private _subnets?: string[]; 
  public get subnets() {
    return this.getListAttribute('subnets');
  }
  public set subnets(value: string[]) {
    this._subnets = value;
  }
  public resetSubnets() {
    this._subnets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetsInput() {
    return this._subnets;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // user_data - computed: true, optional: true, required: false
  private _userData?: string; 
  public get userData() {
    return this.getStringAttribute('user_data');
  }
  public set userData(value: string) {
    this._userData = value;
  }
  public resetUserData() {
    this._userData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userDataInput() {
    return this._userData;
  }

  // version - computed: true, optional: false, required: false
  public get version() {
    return this.getStringAttribute('version');
  }

  // launch_template - computed: false, optional: true, required: false
  private _launchTemplate = new ClusterEksConfigV2NodeGroupsLaunchTemplateList(this, "launch_template", false);
  public get launchTemplate() {
    return this._launchTemplate;
  }
  public putLaunchTemplate(value: ClusterEksConfigV2NodeGroupsLaunchTemplate[] | cdktf.IResolvable) {
    this._launchTemplate.internalValue = value;
  }
  public resetLaunchTemplate() {
    this._launchTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get launchTemplateInput() {
    return this._launchTemplate.internalValue;
  }
}

export class ClusterEksConfigV2NodeGroupsList extends cdktf.ComplexList {
  public internalValue? : ClusterEksConfigV2NodeGroups[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterEksConfigV2NodeGroupsOutputReference {
    return new ClusterEksConfigV2NodeGroupsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterEksConfigV2 {
  /**
  * The AWS Cloud Credential ID to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_credential_id Cluster#cloud_credential_id}
  */
  readonly cloudCredentialId: string;
  /**
  * Is EKS cluster imported?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#imported Cluster#imported}
  */
  readonly imported?: boolean | cdktf.IResolvable;
  /**
  * The AWS kms key to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kms_key Cluster#kms_key}
  */
  readonly kmsKey?: string;
  /**
  * The kubernetes master version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kubernetes_version Cluster#kubernetes_version}
  */
  readonly kubernetesVersion?: string;
  /**
  * The AWS logging types
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#logging_types Cluster#logging_types}
  */
  readonly loggingTypes?: string[];
  /**
  * The EKS cluster name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name?: string;
  /**
  * The EKS cluster has private access
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#private_access Cluster#private_access}
  */
  readonly privateAccess?: boolean | cdktf.IResolvable;
  /**
  * The EKS cluster has public access
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#public_access Cluster#public_access}
  */
  readonly publicAccess?: boolean | cdktf.IResolvable;
  /**
  * The EKS cluster public access sources
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#public_access_sources Cluster#public_access_sources}
  */
  readonly publicAccessSources?: string[];
  /**
  * The AWS Region to create the EKS cluster in
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#region Cluster#region}
  */
  readonly region?: string;
  /**
  * Enable EKS cluster secret encryption
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#secrets_encryption Cluster#secrets_encryption}
  */
  readonly secretsEncryption?: boolean | cdktf.IResolvable;
  /**
  * List of security groups to use for the cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#security_groups Cluster#security_groups}
  */
  readonly securityGroups?: string[];
  /**
  * The AWS service role to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service_role Cluster#service_role}
  */
  readonly serviceRole?: string;
  /**
  * List of subnets in the virtual network to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#subnets Cluster#subnets}
  */
  readonly subnets?: string[];
  /**
  * The EKS cluster tags
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tags Cluster#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * node_groups block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_groups Cluster#node_groups}
  */
  readonly nodeGroups?: ClusterEksConfigV2NodeGroups[] | cdktf.IResolvable;
}

export function clusterEksConfigV2ToTerraform(struct?: ClusterEksConfigV2OutputReference | ClusterEksConfigV2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cloud_credential_id: cdktf.stringToTerraform(struct!.cloudCredentialId),
    imported: cdktf.booleanToTerraform(struct!.imported),
    kms_key: cdktf.stringToTerraform(struct!.kmsKey),
    kubernetes_version: cdktf.stringToTerraform(struct!.kubernetesVersion),
    logging_types: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.loggingTypes),
    name: cdktf.stringToTerraform(struct!.name),
    private_access: cdktf.booleanToTerraform(struct!.privateAccess),
    public_access: cdktf.booleanToTerraform(struct!.publicAccess),
    public_access_sources: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.publicAccessSources),
    region: cdktf.stringToTerraform(struct!.region),
    secrets_encryption: cdktf.booleanToTerraform(struct!.secretsEncryption),
    security_groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.securityGroups),
    service_role: cdktf.stringToTerraform(struct!.serviceRole),
    subnets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subnets),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    node_groups: cdktf.listMapper(clusterEksConfigV2NodeGroupsToTerraform, true)(struct!.nodeGroups),
  }
}


export function clusterEksConfigV2ToHclTerraform(struct?: ClusterEksConfigV2OutputReference | ClusterEksConfigV2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cloud_credential_id: {
      value: cdktf.stringToHclTerraform(struct!.cloudCredentialId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    imported: {
      value: cdktf.booleanToHclTerraform(struct!.imported),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kms_key: {
      value: cdktf.stringToHclTerraform(struct!.kmsKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubernetes_version: {
      value: cdktf.stringToHclTerraform(struct!.kubernetesVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logging_types: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.loggingTypes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_access: {
      value: cdktf.booleanToHclTerraform(struct!.privateAccess),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    public_access: {
      value: cdktf.booleanToHclTerraform(struct!.publicAccess),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    public_access_sources: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.publicAccessSources),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets_encryption: {
      value: cdktf.booleanToHclTerraform(struct!.secretsEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    security_groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.securityGroups),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    service_role: {
      value: cdktf.stringToHclTerraform(struct!.serviceRole),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subnets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subnets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    node_groups: {
      value: cdktf.listMapperHcl(clusterEksConfigV2NodeGroupsToHclTerraform, true)(struct!.nodeGroups),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterEksConfigV2NodeGroupsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterEksConfigV2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterEksConfigV2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cloudCredentialId !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudCredentialId = this._cloudCredentialId;
    }
    if (this._imported !== undefined) {
      hasAnyValues = true;
      internalValueResult.imported = this._imported;
    }
    if (this._kmsKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.kmsKey = this._kmsKey;
    }
    if (this._kubernetesVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesVersion = this._kubernetesVersion;
    }
    if (this._loggingTypes !== undefined) {
      hasAnyValues = true;
      internalValueResult.loggingTypes = this._loggingTypes;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._privateAccess !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateAccess = this._privateAccess;
    }
    if (this._publicAccess !== undefined) {
      hasAnyValues = true;
      internalValueResult.publicAccess = this._publicAccess;
    }
    if (this._publicAccessSources !== undefined) {
      hasAnyValues = true;
      internalValueResult.publicAccessSources = this._publicAccessSources;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._secretsEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretsEncryption = this._secretsEncryption;
    }
    if (this._securityGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityGroups = this._securityGroups;
    }
    if (this._serviceRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceRole = this._serviceRole;
    }
    if (this._subnets !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnets = this._subnets;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._nodeGroups?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeGroups = this._nodeGroups?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterEksConfigV2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._cloudCredentialId = undefined;
      this._imported = undefined;
      this._kmsKey = undefined;
      this._kubernetesVersion = undefined;
      this._loggingTypes = undefined;
      this._name = undefined;
      this._privateAccess = undefined;
      this._publicAccess = undefined;
      this._publicAccessSources = undefined;
      this._region = undefined;
      this._secretsEncryption = undefined;
      this._securityGroups = undefined;
      this._serviceRole = undefined;
      this._subnets = undefined;
      this._tags = undefined;
      this._nodeGroups.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._cloudCredentialId = value.cloudCredentialId;
      this._imported = value.imported;
      this._kmsKey = value.kmsKey;
      this._kubernetesVersion = value.kubernetesVersion;
      this._loggingTypes = value.loggingTypes;
      this._name = value.name;
      this._privateAccess = value.privateAccess;
      this._publicAccess = value.publicAccess;
      this._publicAccessSources = value.publicAccessSources;
      this._region = value.region;
      this._secretsEncryption = value.secretsEncryption;
      this._securityGroups = value.securityGroups;
      this._serviceRole = value.serviceRole;
      this._subnets = value.subnets;
      this._tags = value.tags;
      this._nodeGroups.internalValue = value.nodeGroups;
    }
  }

  // cloud_credential_id - computed: false, optional: false, required: true
  private _cloudCredentialId?: string; 
  public get cloudCredentialId() {
    return this.getStringAttribute('cloud_credential_id');
  }
  public set cloudCredentialId(value: string) {
    this._cloudCredentialId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudCredentialIdInput() {
    return this._cloudCredentialId;
  }

  // imported - computed: false, optional: true, required: false
  private _imported?: boolean | cdktf.IResolvable; 
  public get imported() {
    return this.getBooleanAttribute('imported');
  }
  public set imported(value: boolean | cdktf.IResolvable) {
    this._imported = value;
  }
  public resetImported() {
    this._imported = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importedInput() {
    return this._imported;
  }

  // kms_key - computed: false, optional: true, required: false
  private _kmsKey?: string; 
  public get kmsKey() {
    return this.getStringAttribute('kms_key');
  }
  public set kmsKey(value: string) {
    this._kmsKey = value;
  }
  public resetKmsKey() {
    this._kmsKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kmsKeyInput() {
    return this._kmsKey;
  }

  // kubernetes_version - computed: true, optional: true, required: false
  private _kubernetesVersion?: string; 
  public get kubernetesVersion() {
    return this.getStringAttribute('kubernetes_version');
  }
  public set kubernetesVersion(value: string) {
    this._kubernetesVersion = value;
  }
  public resetKubernetesVersion() {
    this._kubernetesVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesVersionInput() {
    return this._kubernetesVersion;
  }

  // logging_types - computed: false, optional: true, required: false
  private _loggingTypes?: string[]; 
  public get loggingTypes() {
    return this.getListAttribute('logging_types');
  }
  public set loggingTypes(value: string[]) {
    this._loggingTypes = value;
  }
  public resetLoggingTypes() {
    this._loggingTypes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loggingTypesInput() {
    return this._loggingTypes;
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // private_access - computed: true, optional: true, required: false
  private _privateAccess?: boolean | cdktf.IResolvable; 
  public get privateAccess() {
    return this.getBooleanAttribute('private_access');
  }
  public set privateAccess(value: boolean | cdktf.IResolvable) {
    this._privateAccess = value;
  }
  public resetPrivateAccess() {
    this._privateAccess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateAccessInput() {
    return this._privateAccess;
  }

  // public_access - computed: true, optional: true, required: false
  private _publicAccess?: boolean | cdktf.IResolvable; 
  public get publicAccess() {
    return this.getBooleanAttribute('public_access');
  }
  public set publicAccess(value: boolean | cdktf.IResolvable) {
    this._publicAccess = value;
  }
  public resetPublicAccess() {
    this._publicAccess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publicAccessInput() {
    return this._publicAccess;
  }

  // public_access_sources - computed: true, optional: true, required: false
  private _publicAccessSources?: string[]; 
  public get publicAccessSources() {
    return this.getListAttribute('public_access_sources');
  }
  public set publicAccessSources(value: string[]) {
    this._publicAccessSources = value;
  }
  public resetPublicAccessSources() {
    this._publicAccessSources = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publicAccessSourcesInput() {
    return this._publicAccessSources;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // secrets_encryption - computed: true, optional: true, required: false
  private _secretsEncryption?: boolean | cdktf.IResolvable; 
  public get secretsEncryption() {
    return this.getBooleanAttribute('secrets_encryption');
  }
  public set secretsEncryption(value: boolean | cdktf.IResolvable) {
    this._secretsEncryption = value;
  }
  public resetSecretsEncryption() {
    this._secretsEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsEncryptionInput() {
    return this._secretsEncryption;
  }

  // security_groups - computed: false, optional: true, required: false
  private _securityGroups?: string[]; 
  public get securityGroups() {
    return this.getListAttribute('security_groups');
  }
  public set securityGroups(value: string[]) {
    this._securityGroups = value;
  }
  public resetSecurityGroups() {
    this._securityGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityGroupsInput() {
    return this._securityGroups;
  }

  // service_role - computed: false, optional: true, required: false
  private _serviceRole?: string; 
  public get serviceRole() {
    return this.getStringAttribute('service_role');
  }
  public set serviceRole(value: string) {
    this._serviceRole = value;
  }
  public resetServiceRole() {
    this._serviceRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceRoleInput() {
    return this._serviceRole;
  }

  // subnets - computed: false, optional: true, required: false
  private _subnets?: string[]; 
  public get subnets() {
    return this.getListAttribute('subnets');
  }
  public set subnets(value: string[]) {
    this._subnets = value;
  }
  public resetSubnets() {
    this._subnets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetsInput() {
    return this._subnets;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // node_groups - computed: false, optional: true, required: false
  private _nodeGroups = new ClusterEksConfigV2NodeGroupsList(this, "node_groups", false);
  public get nodeGroups() {
    return this._nodeGroups;
  }
  public putNodeGroups(value: ClusterEksConfigV2NodeGroups[] | cdktf.IResolvable) {
    this._nodeGroups.internalValue = value;
  }
  public resetNodeGroups() {
    this._nodeGroups.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeGroupsInput() {
    return this._nodeGroups.internalValue;
  }
}
export interface ClusterFleetAgentDeploymentCustomizationAppendTolerations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#effect Cluster#effect}
  */
  readonly effect?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#key Cluster#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#seconds Cluster#seconds}
  */
  readonly seconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: string;
}

export function clusterFleetAgentDeploymentCustomizationAppendTolerationsToTerraform(struct?: ClusterFleetAgentDeploymentCustomizationAppendTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    seconds: cdktf.numberToTerraform(struct!.seconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterFleetAgentDeploymentCustomizationAppendTolerationsToHclTerraform(struct?: ClusterFleetAgentDeploymentCustomizationAppendTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seconds: {
      value: cdktf.numberToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterFleetAgentDeploymentCustomizationAppendTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterFleetAgentDeploymentCustomizationAppendTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterFleetAgentDeploymentCustomizationAppendTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._seconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._seconds = value.seconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // seconds - computed: true, optional: true, required: false
  private _seconds?: number; 
  public get seconds() {
    return this.getNumberAttribute('seconds');
  }
  public set seconds(value: number) {
    this._seconds = value;
  }
  public resetSeconds() {
    this._seconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterFleetAgentDeploymentCustomizationAppendTolerationsList extends cdktf.ComplexList {
  public internalValue? : ClusterFleetAgentDeploymentCustomizationAppendTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterFleetAgentDeploymentCustomizationAppendTolerationsOutputReference {
    return new ClusterFleetAgentDeploymentCustomizationAppendTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirements {
  /**
  * The maximum CPU limit for agent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cpu_limit Cluster#cpu_limit}
  */
  readonly cpuLimit?: string;
  /**
  * The minimum CPU required for agent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * The maximum memory limit for agent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#memory_limit Cluster#memory_limit}
  */
  readonly memoryLimit?: string;
  /**
  * The minimum memory required for agent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#memory_request Cluster#memory_request}
  */
  readonly memoryRequest?: string;
}

export function clusterFleetAgentDeploymentCustomizationOverrideResourceRequirementsToTerraform(struct?: ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu_limit: cdktf.stringToTerraform(struct!.cpuLimit),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    memory_limit: cdktf.stringToTerraform(struct!.memoryLimit),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
  }
}


export function clusterFleetAgentDeploymentCustomizationOverrideResourceRequirementsToHclTerraform(struct?: ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.memoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuLimit = this._cpuLimit;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._memoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLimit = this._memoryLimit;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpuLimit = undefined;
      this._cpuRequest = undefined;
      this._memoryLimit = undefined;
      this._memoryRequest = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpuLimit = value.cpuLimit;
      this._cpuRequest = value.cpuRequest;
      this._memoryLimit = value.memoryLimit;
      this._memoryRequest = value.memoryRequest;
    }
  }

  // cpu_limit - computed: false, optional: true, required: false
  private _cpuLimit?: string; 
  public get cpuLimit() {
    return this.getStringAttribute('cpu_limit');
  }
  public set cpuLimit(value: string) {
    this._cpuLimit = value;
  }
  public resetCpuLimit() {
    this._cpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuLimitInput() {
    return this._cpuLimit;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // memory_limit - computed: false, optional: true, required: false
  private _memoryLimit?: string; 
  public get memoryLimit() {
    return this.getStringAttribute('memory_limit');
  }
  public set memoryLimit(value: string) {
    this._memoryLimit = value;
  }
  public resetMemoryLimit() {
    this._memoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLimitInput() {
    return this._memoryLimit;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }
}

export class ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementsList extends cdktf.ComplexList {
  public internalValue? : ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirements[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementsOutputReference {
    return new ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterFleetAgentDeploymentCustomization {
  /**
  * User defined affinity to override default agent affinity
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#override_affinity Cluster#override_affinity}
  */
  readonly overrideAffinity?: string;
  /**
  * append_tolerations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#append_tolerations Cluster#append_tolerations}
  */
  readonly appendTolerations?: ClusterFleetAgentDeploymentCustomizationAppendTolerations[] | cdktf.IResolvable;
  /**
  * override_resource_requirements block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#override_resource_requirements Cluster#override_resource_requirements}
  */
  readonly overrideResourceRequirements?: ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirements[] | cdktf.IResolvable;
}

export function clusterFleetAgentDeploymentCustomizationToTerraform(struct?: ClusterFleetAgentDeploymentCustomization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_affinity: cdktf.stringToTerraform(struct!.overrideAffinity),
    append_tolerations: cdktf.listMapper(clusterFleetAgentDeploymentCustomizationAppendTolerationsToTerraform, true)(struct!.appendTolerations),
    override_resource_requirements: cdktf.listMapper(clusterFleetAgentDeploymentCustomizationOverrideResourceRequirementsToTerraform, true)(struct!.overrideResourceRequirements),
  }
}


export function clusterFleetAgentDeploymentCustomizationToHclTerraform(struct?: ClusterFleetAgentDeploymentCustomization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_affinity: {
      value: cdktf.stringToHclTerraform(struct!.overrideAffinity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    append_tolerations: {
      value: cdktf.listMapperHcl(clusterFleetAgentDeploymentCustomizationAppendTolerationsToHclTerraform, true)(struct!.appendTolerations),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterFleetAgentDeploymentCustomizationAppendTolerationsList",
    },
    override_resource_requirements: {
      value: cdktf.listMapperHcl(clusterFleetAgentDeploymentCustomizationOverrideResourceRequirementsToHclTerraform, true)(struct!.overrideResourceRequirements),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterFleetAgentDeploymentCustomizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterFleetAgentDeploymentCustomization | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideAffinity !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideAffinity = this._overrideAffinity;
    }
    if (this._appendTolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appendTolerations = this._appendTolerations?.internalValue;
    }
    if (this._overrideResourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideResourceRequirements = this._overrideResourceRequirements?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterFleetAgentDeploymentCustomization | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideAffinity = undefined;
      this._appendTolerations.internalValue = undefined;
      this._overrideResourceRequirements.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideAffinity = value.overrideAffinity;
      this._appendTolerations.internalValue = value.appendTolerations;
      this._overrideResourceRequirements.internalValue = value.overrideResourceRequirements;
    }
  }

  // override_affinity - computed: false, optional: true, required: false
  private _overrideAffinity?: string; 
  public get overrideAffinity() {
    return this.getStringAttribute('override_affinity');
  }
  public set overrideAffinity(value: string) {
    this._overrideAffinity = value;
  }
  public resetOverrideAffinity() {
    this._overrideAffinity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideAffinityInput() {
    return this._overrideAffinity;
  }

  // append_tolerations - computed: false, optional: true, required: false
  private _appendTolerations = new ClusterFleetAgentDeploymentCustomizationAppendTolerationsList(this, "append_tolerations", false);
  public get appendTolerations() {
    return this._appendTolerations;
  }
  public putAppendTolerations(value: ClusterFleetAgentDeploymentCustomizationAppendTolerations[] | cdktf.IResolvable) {
    this._appendTolerations.internalValue = value;
  }
  public resetAppendTolerations() {
    this._appendTolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendTolerationsInput() {
    return this._appendTolerations.internalValue;
  }

  // override_resource_requirements - computed: false, optional: true, required: false
  private _overrideResourceRequirements = new ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementsList(this, "override_resource_requirements", false);
  public get overrideResourceRequirements() {
    return this._overrideResourceRequirements;
  }
  public putOverrideResourceRequirements(value: ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirements[] | cdktf.IResolvable) {
    this._overrideResourceRequirements.internalValue = value;
  }
  public resetOverrideResourceRequirements() {
    this._overrideResourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideResourceRequirementsInput() {
    return this._overrideResourceRequirements.internalValue;
  }
}

export class ClusterFleetAgentDeploymentCustomizationList extends cdktf.ComplexList {
  public internalValue? : ClusterFleetAgentDeploymentCustomization[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterFleetAgentDeploymentCustomizationOutputReference {
    return new ClusterFleetAgentDeploymentCustomizationOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterGkeConfigV2ClusterAddons {
  /**
  * Enable GKE horizontal pod autoscaling
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#horizontal_pod_autoscaling Cluster#horizontal_pod_autoscaling}
  */
  readonly horizontalPodAutoscaling?: boolean | cdktf.IResolvable;
  /**
  * Enable GKE HTTP load balancing
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#http_load_balancing Cluster#http_load_balancing}
  */
  readonly httpLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Enable GKE network policy config
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network_policy_config Cluster#network_policy_config}
  */
  readonly networkPolicyConfig?: boolean | cdktf.IResolvable;
}

export function clusterGkeConfigV2ClusterAddonsToTerraform(struct?: ClusterGkeConfigV2ClusterAddonsOutputReference | ClusterGkeConfigV2ClusterAddons): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    horizontal_pod_autoscaling: cdktf.booleanToTerraform(struct!.horizontalPodAutoscaling),
    http_load_balancing: cdktf.booleanToTerraform(struct!.httpLoadBalancing),
    network_policy_config: cdktf.booleanToTerraform(struct!.networkPolicyConfig),
  }
}


export function clusterGkeConfigV2ClusterAddonsToHclTerraform(struct?: ClusterGkeConfigV2ClusterAddonsOutputReference | ClusterGkeConfigV2ClusterAddons): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    horizontal_pod_autoscaling: {
      value: cdktf.booleanToHclTerraform(struct!.horizontalPodAutoscaling),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    http_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.httpLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    network_policy_config: {
      value: cdktf.booleanToHclTerraform(struct!.networkPolicyConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2ClusterAddonsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterGkeConfigV2ClusterAddons | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._horizontalPodAutoscaling !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalPodAutoscaling = this._horizontalPodAutoscaling;
    }
    if (this._httpLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpLoadBalancing = this._httpLoadBalancing;
    }
    if (this._networkPolicyConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkPolicyConfig = this._networkPolicyConfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2ClusterAddons | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._horizontalPodAutoscaling = undefined;
      this._httpLoadBalancing = undefined;
      this._networkPolicyConfig = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._horizontalPodAutoscaling = value.horizontalPodAutoscaling;
      this._httpLoadBalancing = value.httpLoadBalancing;
      this._networkPolicyConfig = value.networkPolicyConfig;
    }
  }

  // horizontal_pod_autoscaling - computed: true, optional: true, required: false
  private _horizontalPodAutoscaling?: boolean | cdktf.IResolvable; 
  public get horizontalPodAutoscaling() {
    return this.getBooleanAttribute('horizontal_pod_autoscaling');
  }
  public set horizontalPodAutoscaling(value: boolean | cdktf.IResolvable) {
    this._horizontalPodAutoscaling = value;
  }
  public resetHorizontalPodAutoscaling() {
    this._horizontalPodAutoscaling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalPodAutoscalingInput() {
    return this._horizontalPodAutoscaling;
  }

  // http_load_balancing - computed: true, optional: true, required: false
  private _httpLoadBalancing?: boolean | cdktf.IResolvable; 
  public get httpLoadBalancing() {
    return this.getBooleanAttribute('http_load_balancing');
  }
  public set httpLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._httpLoadBalancing = value;
  }
  public resetHttpLoadBalancing() {
    this._httpLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpLoadBalancingInput() {
    return this._httpLoadBalancing;
  }

  // network_policy_config - computed: true, optional: true, required: false
  private _networkPolicyConfig?: boolean | cdktf.IResolvable; 
  public get networkPolicyConfig() {
    return this.getBooleanAttribute('network_policy_config');
  }
  public set networkPolicyConfig(value: boolean | cdktf.IResolvable) {
    this._networkPolicyConfig = value;
  }
  public resetNetworkPolicyConfig() {
    this._networkPolicyConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkPolicyConfigInput() {
    return this._networkPolicyConfig;
  }
}
export interface ClusterGkeConfigV2IpAllocationPolicy {
  /**
  * The GKE cluster ip v4 allocation cidr block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_ipv4_cidr_block Cluster#cluster_ipv4_cidr_block}
  */
  readonly clusterIpv4CidrBlock?: string;
  /**
  * The GKE cluster ip v4 allocation secondary range name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_secondary_range_name Cluster#cluster_secondary_range_name}
  */
  readonly clusterSecondaryRangeName?: string;
  /**
  * Create GKE subnetwork?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#create_subnetwork Cluster#create_subnetwork}
  */
  readonly createSubnetwork?: boolean | cdktf.IResolvable;
  /**
  * The GKE node ip v4 allocation cidr block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_ipv4_cidr_block Cluster#node_ipv4_cidr_block}
  */
  readonly nodeIpv4CidrBlock?: string;
  /**
  * The GKE services ip v4 allocation cidr block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#services_ipv4_cidr_block Cluster#services_ipv4_cidr_block}
  */
  readonly servicesIpv4CidrBlock?: string;
  /**
  * The GKE services ip v4 allocation secondary range name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#services_secondary_range_name Cluster#services_secondary_range_name}
  */
  readonly servicesSecondaryRangeName?: string;
  /**
  * The GKE cluster subnetwork name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#subnetwork_name Cluster#subnetwork_name}
  */
  readonly subnetworkName?: string;
  /**
  * Use GKE ip aliases?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#use_ip_aliases Cluster#use_ip_aliases}
  */
  readonly useIpAliases?: boolean | cdktf.IResolvable;
}

export function clusterGkeConfigV2IpAllocationPolicyToTerraform(struct?: ClusterGkeConfigV2IpAllocationPolicyOutputReference | ClusterGkeConfigV2IpAllocationPolicy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_ipv4_cidr_block: cdktf.stringToTerraform(struct!.clusterIpv4CidrBlock),
    cluster_secondary_range_name: cdktf.stringToTerraform(struct!.clusterSecondaryRangeName),
    create_subnetwork: cdktf.booleanToTerraform(struct!.createSubnetwork),
    node_ipv4_cidr_block: cdktf.stringToTerraform(struct!.nodeIpv4CidrBlock),
    services_ipv4_cidr_block: cdktf.stringToTerraform(struct!.servicesIpv4CidrBlock),
    services_secondary_range_name: cdktf.stringToTerraform(struct!.servicesSecondaryRangeName),
    subnetwork_name: cdktf.stringToTerraform(struct!.subnetworkName),
    use_ip_aliases: cdktf.booleanToTerraform(struct!.useIpAliases),
  }
}


export function clusterGkeConfigV2IpAllocationPolicyToHclTerraform(struct?: ClusterGkeConfigV2IpAllocationPolicyOutputReference | ClusterGkeConfigV2IpAllocationPolicy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_ipv4_cidr_block: {
      value: cdktf.stringToHclTerraform(struct!.clusterIpv4CidrBlock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_secondary_range_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterSecondaryRangeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    create_subnetwork: {
      value: cdktf.booleanToHclTerraform(struct!.createSubnetwork),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    node_ipv4_cidr_block: {
      value: cdktf.stringToHclTerraform(struct!.nodeIpv4CidrBlock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    services_ipv4_cidr_block: {
      value: cdktf.stringToHclTerraform(struct!.servicesIpv4CidrBlock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    services_secondary_range_name: {
      value: cdktf.stringToHclTerraform(struct!.servicesSecondaryRangeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subnetwork_name: {
      value: cdktf.stringToHclTerraform(struct!.subnetworkName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_ip_aliases: {
      value: cdktf.booleanToHclTerraform(struct!.useIpAliases),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2IpAllocationPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterGkeConfigV2IpAllocationPolicy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterIpv4CidrBlock !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterIpv4CidrBlock = this._clusterIpv4CidrBlock;
    }
    if (this._clusterSecondaryRangeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterSecondaryRangeName = this._clusterSecondaryRangeName;
    }
    if (this._createSubnetwork !== undefined) {
      hasAnyValues = true;
      internalValueResult.createSubnetwork = this._createSubnetwork;
    }
    if (this._nodeIpv4CidrBlock !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeIpv4CidrBlock = this._nodeIpv4CidrBlock;
    }
    if (this._servicesIpv4CidrBlock !== undefined) {
      hasAnyValues = true;
      internalValueResult.servicesIpv4CidrBlock = this._servicesIpv4CidrBlock;
    }
    if (this._servicesSecondaryRangeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.servicesSecondaryRangeName = this._servicesSecondaryRangeName;
    }
    if (this._subnetworkName !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnetworkName = this._subnetworkName;
    }
    if (this._useIpAliases !== undefined) {
      hasAnyValues = true;
      internalValueResult.useIpAliases = this._useIpAliases;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2IpAllocationPolicy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clusterIpv4CidrBlock = undefined;
      this._clusterSecondaryRangeName = undefined;
      this._createSubnetwork = undefined;
      this._nodeIpv4CidrBlock = undefined;
      this._servicesIpv4CidrBlock = undefined;
      this._servicesSecondaryRangeName = undefined;
      this._subnetworkName = undefined;
      this._useIpAliases = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clusterIpv4CidrBlock = value.clusterIpv4CidrBlock;
      this._clusterSecondaryRangeName = value.clusterSecondaryRangeName;
      this._createSubnetwork = value.createSubnetwork;
      this._nodeIpv4CidrBlock = value.nodeIpv4CidrBlock;
      this._servicesIpv4CidrBlock = value.servicesIpv4CidrBlock;
      this._servicesSecondaryRangeName = value.servicesSecondaryRangeName;
      this._subnetworkName = value.subnetworkName;
      this._useIpAliases = value.useIpAliases;
    }
  }

  // cluster_ipv4_cidr_block - computed: true, optional: true, required: false
  private _clusterIpv4CidrBlock?: string; 
  public get clusterIpv4CidrBlock() {
    return this.getStringAttribute('cluster_ipv4_cidr_block');
  }
  public set clusterIpv4CidrBlock(value: string) {
    this._clusterIpv4CidrBlock = value;
  }
  public resetClusterIpv4CidrBlock() {
    this._clusterIpv4CidrBlock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIpv4CidrBlockInput() {
    return this._clusterIpv4CidrBlock;
  }

  // cluster_secondary_range_name - computed: true, optional: true, required: false
  private _clusterSecondaryRangeName?: string; 
  public get clusterSecondaryRangeName() {
    return this.getStringAttribute('cluster_secondary_range_name');
  }
  public set clusterSecondaryRangeName(value: string) {
    this._clusterSecondaryRangeName = value;
  }
  public resetClusterSecondaryRangeName() {
    this._clusterSecondaryRangeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterSecondaryRangeNameInput() {
    return this._clusterSecondaryRangeName;
  }

  // create_subnetwork - computed: true, optional: true, required: false
  private _createSubnetwork?: boolean | cdktf.IResolvable; 
  public get createSubnetwork() {
    return this.getBooleanAttribute('create_subnetwork');
  }
  public set createSubnetwork(value: boolean | cdktf.IResolvable) {
    this._createSubnetwork = value;
  }
  public resetCreateSubnetwork() {
    this._createSubnetwork = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createSubnetworkInput() {
    return this._createSubnetwork;
  }

  // node_ipv4_cidr_block - computed: true, optional: true, required: false
  private _nodeIpv4CidrBlock?: string; 
  public get nodeIpv4CidrBlock() {
    return this.getStringAttribute('node_ipv4_cidr_block');
  }
  public set nodeIpv4CidrBlock(value: string) {
    this._nodeIpv4CidrBlock = value;
  }
  public resetNodeIpv4CidrBlock() {
    this._nodeIpv4CidrBlock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeIpv4CidrBlockInput() {
    return this._nodeIpv4CidrBlock;
  }

  // services_ipv4_cidr_block - computed: true, optional: true, required: false
  private _servicesIpv4CidrBlock?: string; 
  public get servicesIpv4CidrBlock() {
    return this.getStringAttribute('services_ipv4_cidr_block');
  }
  public set servicesIpv4CidrBlock(value: string) {
    this._servicesIpv4CidrBlock = value;
  }
  public resetServicesIpv4CidrBlock() {
    this._servicesIpv4CidrBlock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesIpv4CidrBlockInput() {
    return this._servicesIpv4CidrBlock;
  }

  // services_secondary_range_name - computed: true, optional: true, required: false
  private _servicesSecondaryRangeName?: string; 
  public get servicesSecondaryRangeName() {
    return this.getStringAttribute('services_secondary_range_name');
  }
  public set servicesSecondaryRangeName(value: string) {
    this._servicesSecondaryRangeName = value;
  }
  public resetServicesSecondaryRangeName() {
    this._servicesSecondaryRangeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesSecondaryRangeNameInput() {
    return this._servicesSecondaryRangeName;
  }

  // subnetwork_name - computed: true, optional: true, required: false
  private _subnetworkName?: string; 
  public get subnetworkName() {
    return this.getStringAttribute('subnetwork_name');
  }
  public set subnetworkName(value: string) {
    this._subnetworkName = value;
  }
  public resetSubnetworkName() {
    this._subnetworkName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetworkNameInput() {
    return this._subnetworkName;
  }

  // use_ip_aliases - computed: true, optional: true, required: false
  private _useIpAliases?: boolean | cdktf.IResolvable; 
  public get useIpAliases() {
    return this.getBooleanAttribute('use_ip_aliases');
  }
  public set useIpAliases(value: boolean | cdktf.IResolvable) {
    this._useIpAliases = value;
  }
  public resetUseIpAliases() {
    this._useIpAliases = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useIpAliasesInput() {
    return this._useIpAliases;
  }
}
export interface ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocks {
  /**
  * The GKE master authorized network config cidr block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cidr_block Cluster#cidr_block}
  */
  readonly cidrBlock: string;
  /**
  * The GKE master authorized network config cidr block dispaly name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#display_name Cluster#display_name}
  */
  readonly displayName?: string;
}

export function clusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocksToTerraform(struct?: ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr_block: cdktf.stringToTerraform(struct!.cidrBlock),
    display_name: cdktf.stringToTerraform(struct!.displayName),
  }
}


export function clusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocksToHclTerraform(struct?: ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr_block: {
      value: cdktf.stringToHclTerraform(struct!.cidrBlock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    display_name: {
      value: cdktf.stringToHclTerraform(struct!.displayName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidrBlock !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidrBlock = this._cidrBlock;
    }
    if (this._displayName !== undefined) {
      hasAnyValues = true;
      internalValueResult.displayName = this._displayName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidrBlock = undefined;
      this._displayName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidrBlock = value.cidrBlock;
      this._displayName = value.displayName;
    }
  }

  // cidr_block - computed: false, optional: false, required: true
  private _cidrBlock?: string; 
  public get cidrBlock() {
    return this.getStringAttribute('cidr_block');
  }
  public set cidrBlock(value: string) {
    this._cidrBlock = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrBlockInput() {
    return this._cidrBlock;
  }

  // display_name - computed: false, optional: true, required: false
  private _displayName?: string; 
  public get displayName() {
    return this.getStringAttribute('display_name');
  }
  public set displayName(value: string) {
    this._displayName = value;
  }
  public resetDisplayName() {
    this._displayName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get displayNameInput() {
    return this._displayName;
  }
}

export class ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocksList extends cdktf.ComplexList {
  public internalValue? : ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocks[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocksOutputReference {
    return new ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocksOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterGkeConfigV2MasterAuthorizedNetworksConfig {
  /**
  * Enable GKE master authorized network config
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * cidr_blocks block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cidr_blocks Cluster#cidr_blocks}
  */
  readonly cidrBlocks: ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocks[] | cdktf.IResolvable;
}

export function clusterGkeConfigV2MasterAuthorizedNetworksConfigToTerraform(struct?: ClusterGkeConfigV2MasterAuthorizedNetworksConfigOutputReference | ClusterGkeConfigV2MasterAuthorizedNetworksConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    cidr_blocks: cdktf.listMapper(clusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocksToTerraform, true)(struct!.cidrBlocks),
  }
}


export function clusterGkeConfigV2MasterAuthorizedNetworksConfigToHclTerraform(struct?: ClusterGkeConfigV2MasterAuthorizedNetworksConfigOutputReference | ClusterGkeConfigV2MasterAuthorizedNetworksConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    cidr_blocks: {
      value: cdktf.listMapperHcl(clusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocksToHclTerraform, true)(struct!.cidrBlocks),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocksList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2MasterAuthorizedNetworksConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterGkeConfigV2MasterAuthorizedNetworksConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._cidrBlocks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidrBlocks = this._cidrBlocks?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2MasterAuthorizedNetworksConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enabled = undefined;
      this._cidrBlocks.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enabled = value.enabled;
      this._cidrBlocks.internalValue = value.cidrBlocks;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // cidr_blocks - computed: false, optional: false, required: true
  private _cidrBlocks = new ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocksList(this, "cidr_blocks", false);
  public get cidrBlocks() {
    return this._cidrBlocks;
  }
  public putCidrBlocks(value: ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlocks[] | cdktf.IResolvable) {
    this._cidrBlocks.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrBlocksInput() {
    return this._cidrBlocks.internalValue;
  }
}
export interface ClusterGkeConfigV2NodePoolsAutoscaling {
  /**
  * Enable GKE node pool config autoscaling
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * The GKE node pool config max node count
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_node_count Cluster#max_node_count}
  */
  readonly maxNodeCount?: number;
  /**
  * The GKE node pool config min node count
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#min_node_count Cluster#min_node_count}
  */
  readonly minNodeCount?: number;
}

export function clusterGkeConfigV2NodePoolsAutoscalingToTerraform(struct?: ClusterGkeConfigV2NodePoolsAutoscalingOutputReference | ClusterGkeConfigV2NodePoolsAutoscaling): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    max_node_count: cdktf.numberToTerraform(struct!.maxNodeCount),
    min_node_count: cdktf.numberToTerraform(struct!.minNodeCount),
  }
}


export function clusterGkeConfigV2NodePoolsAutoscalingToHclTerraform(struct?: ClusterGkeConfigV2NodePoolsAutoscalingOutputReference | ClusterGkeConfigV2NodePoolsAutoscaling): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_node_count: {
      value: cdktf.numberToHclTerraform(struct!.maxNodeCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min_node_count: {
      value: cdktf.numberToHclTerraform(struct!.minNodeCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2NodePoolsAutoscalingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterGkeConfigV2NodePoolsAutoscaling | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._maxNodeCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNodeCount = this._maxNodeCount;
    }
    if (this._minNodeCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.minNodeCount = this._minNodeCount;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2NodePoolsAutoscaling | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enabled = undefined;
      this._maxNodeCount = undefined;
      this._minNodeCount = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enabled = value.enabled;
      this._maxNodeCount = value.maxNodeCount;
      this._minNodeCount = value.minNodeCount;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // max_node_count - computed: true, optional: true, required: false
  private _maxNodeCount?: number; 
  public get maxNodeCount() {
    return this.getNumberAttribute('max_node_count');
  }
  public set maxNodeCount(value: number) {
    this._maxNodeCount = value;
  }
  public resetMaxNodeCount() {
    this._maxNodeCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNodeCountInput() {
    return this._maxNodeCount;
  }

  // min_node_count - computed: true, optional: true, required: false
  private _minNodeCount?: number; 
  public get minNodeCount() {
    return this.getNumberAttribute('min_node_count');
  }
  public set minNodeCount(value: number) {
    this._minNodeCount = value;
  }
  public resetMinNodeCount() {
    this._minNodeCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minNodeCountInput() {
    return this._minNodeCount;
  }
}
export interface ClusterGkeConfigV2NodePoolsConfigTaints {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#effect Cluster#effect}
  */
  readonly effect: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#key Cluster#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#value Cluster#value}
  */
  readonly value: string;
}

export function clusterGkeConfigV2NodePoolsConfigTaintsToTerraform(struct?: ClusterGkeConfigV2NodePoolsConfigTaints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterGkeConfigV2NodePoolsConfigTaintsToHclTerraform(struct?: ClusterGkeConfigV2NodePoolsConfigTaints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2NodePoolsConfigTaintsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterGkeConfigV2NodePoolsConfigTaints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2NodePoolsConfigTaints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: false, required: true
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterGkeConfigV2NodePoolsConfigTaintsList extends cdktf.ComplexList {
  public internalValue? : ClusterGkeConfigV2NodePoolsConfigTaints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterGkeConfigV2NodePoolsConfigTaintsOutputReference {
    return new ClusterGkeConfigV2NodePoolsConfigTaintsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterGkeConfigV2NodePoolsConfig {
  /**
  * The GKE node config disk size (Gb)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#disk_size_gb Cluster#disk_size_gb}
  */
  readonly diskSizeGb?: number;
  /**
  * The GKE node config disk type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#disk_type Cluster#disk_type}
  */
  readonly diskType?: string;
  /**
  * The GKE node config image type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image_type Cluster#image_type}
  */
  readonly imageType?: string;
  /**
  * The GKE node config labels
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#labels Cluster#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * The GKE node config local ssd count
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#local_ssd_count Cluster#local_ssd_count}
  */
  readonly localSsdCount?: number;
  /**
  * The GKE node config machine type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#machine_type Cluster#machine_type}
  */
  readonly machineType?: string;
  /**
  * The GKE node config oauth scopes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#oauth_scopes Cluster#oauth_scopes}
  */
  readonly oauthScopes?: string[];
  /**
  * Enable GKE node config preemptible
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#preemptible Cluster#preemptible}
  */
  readonly preemptible?: boolean | cdktf.IResolvable;
  /**
  * The GKE node config service account
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service_account Cluster#service_account}
  */
  readonly serviceAccount?: string;
  /**
  * The GKE node config tags
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tags Cluster#tags}
  */
  readonly tags?: string[];
  /**
  * taints block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#taints Cluster#taints}
  */
  readonly taints?: ClusterGkeConfigV2NodePoolsConfigTaints[] | cdktf.IResolvable;
}

export function clusterGkeConfigV2NodePoolsConfigToTerraform(struct?: ClusterGkeConfigV2NodePoolsConfigOutputReference | ClusterGkeConfigV2NodePoolsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disk_size_gb: cdktf.numberToTerraform(struct!.diskSizeGb),
    disk_type: cdktf.stringToTerraform(struct!.diskType),
    image_type: cdktf.stringToTerraform(struct!.imageType),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    local_ssd_count: cdktf.numberToTerraform(struct!.localSsdCount),
    machine_type: cdktf.stringToTerraform(struct!.machineType),
    oauth_scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.oauthScopes),
    preemptible: cdktf.booleanToTerraform(struct!.preemptible),
    service_account: cdktf.stringToTerraform(struct!.serviceAccount),
    tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.tags),
    taints: cdktf.listMapper(clusterGkeConfigV2NodePoolsConfigTaintsToTerraform, true)(struct!.taints),
  }
}


export function clusterGkeConfigV2NodePoolsConfigToHclTerraform(struct?: ClusterGkeConfigV2NodePoolsConfigOutputReference | ClusterGkeConfigV2NodePoolsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disk_size_gb: {
      value: cdktf.numberToHclTerraform(struct!.diskSizeGb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disk_type: {
      value: cdktf.stringToHclTerraform(struct!.diskType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_type: {
      value: cdktf.stringToHclTerraform(struct!.imageType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    local_ssd_count: {
      value: cdktf.numberToHclTerraform(struct!.localSsdCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    machine_type: {
      value: cdktf.stringToHclTerraform(struct!.machineType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth_scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.oauthScopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    preemptible: {
      value: cdktf.booleanToHclTerraform(struct!.preemptible),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    service_account: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccount),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.tags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    taints: {
      value: cdktf.listMapperHcl(clusterGkeConfigV2NodePoolsConfigTaintsToHclTerraform, true)(struct!.taints),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterGkeConfigV2NodePoolsConfigTaintsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2NodePoolsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterGkeConfigV2NodePoolsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._diskSizeGb !== undefined) {
      hasAnyValues = true;
      internalValueResult.diskSizeGb = this._diskSizeGb;
    }
    if (this._diskType !== undefined) {
      hasAnyValues = true;
      internalValueResult.diskType = this._diskType;
    }
    if (this._imageType !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageType = this._imageType;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._localSsdCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.localSsdCount = this._localSsdCount;
    }
    if (this._machineType !== undefined) {
      hasAnyValues = true;
      internalValueResult.machineType = this._machineType;
    }
    if (this._oauthScopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthScopes = this._oauthScopes;
    }
    if (this._preemptible !== undefined) {
      hasAnyValues = true;
      internalValueResult.preemptible = this._preemptible;
    }
    if (this._serviceAccount !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._taints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.taints = this._taints?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2NodePoolsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._diskSizeGb = undefined;
      this._diskType = undefined;
      this._imageType = undefined;
      this._labels = undefined;
      this._localSsdCount = undefined;
      this._machineType = undefined;
      this._oauthScopes = undefined;
      this._preemptible = undefined;
      this._serviceAccount = undefined;
      this._tags = undefined;
      this._taints.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._diskSizeGb = value.diskSizeGb;
      this._diskType = value.diskType;
      this._imageType = value.imageType;
      this._labels = value.labels;
      this._localSsdCount = value.localSsdCount;
      this._machineType = value.machineType;
      this._oauthScopes = value.oauthScopes;
      this._preemptible = value.preemptible;
      this._serviceAccount = value.serviceAccount;
      this._tags = value.tags;
      this._taints.internalValue = value.taints;
    }
  }

  // disk_size_gb - computed: false, optional: true, required: false
  private _diskSizeGb?: number; 
  public get diskSizeGb() {
    return this.getNumberAttribute('disk_size_gb');
  }
  public set diskSizeGb(value: number) {
    this._diskSizeGb = value;
  }
  public resetDiskSizeGb() {
    this._diskSizeGb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskSizeGbInput() {
    return this._diskSizeGb;
  }

  // disk_type - computed: false, optional: true, required: false
  private _diskType?: string; 
  public get diskType() {
    return this.getStringAttribute('disk_type');
  }
  public set diskType(value: string) {
    this._diskType = value;
  }
  public resetDiskType() {
    this._diskType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskTypeInput() {
    return this._diskType;
  }

  // image_type - computed: false, optional: true, required: false
  private _imageType?: string; 
  public get imageType() {
    return this.getStringAttribute('image_type');
  }
  public set imageType(value: string) {
    this._imageType = value;
  }
  public resetImageType() {
    this._imageType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageTypeInput() {
    return this._imageType;
  }

  // labels - computed: true, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // local_ssd_count - computed: false, optional: true, required: false
  private _localSsdCount?: number; 
  public get localSsdCount() {
    return this.getNumberAttribute('local_ssd_count');
  }
  public set localSsdCount(value: number) {
    this._localSsdCount = value;
  }
  public resetLocalSsdCount() {
    this._localSsdCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localSsdCountInput() {
    return this._localSsdCount;
  }

  // machine_type - computed: false, optional: true, required: false
  private _machineType?: string; 
  public get machineType() {
    return this.getStringAttribute('machine_type');
  }
  public set machineType(value: string) {
    this._machineType = value;
  }
  public resetMachineType() {
    this._machineType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get machineTypeInput() {
    return this._machineType;
  }

  // oauth_scopes - computed: true, optional: true, required: false
  private _oauthScopes?: string[]; 
  public get oauthScopes() {
    return this.getListAttribute('oauth_scopes');
  }
  public set oauthScopes(value: string[]) {
    this._oauthScopes = value;
  }
  public resetOauthScopes() {
    this._oauthScopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthScopesInput() {
    return this._oauthScopes;
  }

  // preemptible - computed: false, optional: true, required: false
  private _preemptible?: boolean | cdktf.IResolvable; 
  public get preemptible() {
    return this.getBooleanAttribute('preemptible');
  }
  public set preemptible(value: boolean | cdktf.IResolvable) {
    this._preemptible = value;
  }
  public resetPreemptible() {
    this._preemptible = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preemptibleInput() {
    return this._preemptible;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount?: string; 
  public get serviceAccount() {
    return this.getStringAttribute('service_account');
  }
  public set serviceAccount(value: string) {
    this._serviceAccount = value;
  }
  public resetServiceAccount() {
    this._serviceAccount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount;
  }

  // tags - computed: true, optional: true, required: false
  private _tags?: string[]; 
  public get tags() {
    return this.getListAttribute('tags');
  }
  public set tags(value: string[]) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // taints - computed: false, optional: true, required: false
  private _taints = new ClusterGkeConfigV2NodePoolsConfigTaintsList(this, "taints", false);
  public get taints() {
    return this._taints;
  }
  public putTaints(value: ClusterGkeConfigV2NodePoolsConfigTaints[] | cdktf.IResolvable) {
    this._taints.internalValue = value;
  }
  public resetTaints() {
    this._taints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taintsInput() {
    return this._taints.internalValue;
  }
}
export interface ClusterGkeConfigV2NodePoolsManagement {
  /**
  * Enable GKE node pool config management auto repair
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#auto_repair Cluster#auto_repair}
  */
  readonly autoRepair?: boolean | cdktf.IResolvable;
  /**
  * Enable GKE node pool config management auto upgrade
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#auto_upgrade Cluster#auto_upgrade}
  */
  readonly autoUpgrade?: boolean | cdktf.IResolvable;
}

export function clusterGkeConfigV2NodePoolsManagementToTerraform(struct?: ClusterGkeConfigV2NodePoolsManagementOutputReference | ClusterGkeConfigV2NodePoolsManagement): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_repair: cdktf.booleanToTerraform(struct!.autoRepair),
    auto_upgrade: cdktf.booleanToTerraform(struct!.autoUpgrade),
  }
}


export function clusterGkeConfigV2NodePoolsManagementToHclTerraform(struct?: ClusterGkeConfigV2NodePoolsManagementOutputReference | ClusterGkeConfigV2NodePoolsManagement): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_repair: {
      value: cdktf.booleanToHclTerraform(struct!.autoRepair),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    auto_upgrade: {
      value: cdktf.booleanToHclTerraform(struct!.autoUpgrade),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2NodePoolsManagementOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterGkeConfigV2NodePoolsManagement | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoRepair !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoRepair = this._autoRepair;
    }
    if (this._autoUpgrade !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoUpgrade = this._autoUpgrade;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2NodePoolsManagement | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._autoRepair = undefined;
      this._autoUpgrade = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._autoRepair = value.autoRepair;
      this._autoUpgrade = value.autoUpgrade;
    }
  }

  // auto_repair - computed: true, optional: true, required: false
  private _autoRepair?: boolean | cdktf.IResolvable; 
  public get autoRepair() {
    return this.getBooleanAttribute('auto_repair');
  }
  public set autoRepair(value: boolean | cdktf.IResolvable) {
    this._autoRepair = value;
  }
  public resetAutoRepair() {
    this._autoRepair = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoRepairInput() {
    return this._autoRepair;
  }

  // auto_upgrade - computed: true, optional: true, required: false
  private _autoUpgrade?: boolean | cdktf.IResolvable; 
  public get autoUpgrade() {
    return this.getBooleanAttribute('auto_upgrade');
  }
  public set autoUpgrade(value: boolean | cdktf.IResolvable) {
    this._autoUpgrade = value;
  }
  public resetAutoUpgrade() {
    this._autoUpgrade = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoUpgradeInput() {
    return this._autoUpgrade;
  }
}
export interface ClusterGkeConfigV2NodePools {
  /**
  * The GKE node pool config initial node count
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#initial_node_count Cluster#initial_node_count}
  */
  readonly initialNodeCount: number;
  /**
  * The GKE node pool config max pods constraint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_pods_constraint Cluster#max_pods_constraint}
  */
  readonly maxPodsConstraint?: number;
  /**
  * The GKE node pool config name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * The GKE node pool config version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#version Cluster#version}
  */
  readonly version: string;
  /**
  * autoscaling block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#autoscaling Cluster#autoscaling}
  */
  readonly autoscaling?: ClusterGkeConfigV2NodePoolsAutoscaling;
  /**
  * config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#config Cluster#config}
  */
  readonly config?: ClusterGkeConfigV2NodePoolsConfig;
  /**
  * management block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#management Cluster#management}
  */
  readonly management?: ClusterGkeConfigV2NodePoolsManagement;
}

export function clusterGkeConfigV2NodePoolsToTerraform(struct?: ClusterGkeConfigV2NodePools | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    initial_node_count: cdktf.numberToTerraform(struct!.initialNodeCount),
    max_pods_constraint: cdktf.numberToTerraform(struct!.maxPodsConstraint),
    name: cdktf.stringToTerraform(struct!.name),
    version: cdktf.stringToTerraform(struct!.version),
    autoscaling: clusterGkeConfigV2NodePoolsAutoscalingToTerraform(struct!.autoscaling),
    config: clusterGkeConfigV2NodePoolsConfigToTerraform(struct!.config),
    management: clusterGkeConfigV2NodePoolsManagementToTerraform(struct!.management),
  }
}


export function clusterGkeConfigV2NodePoolsToHclTerraform(struct?: ClusterGkeConfigV2NodePools | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    initial_node_count: {
      value: cdktf.numberToHclTerraform(struct!.initialNodeCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_pods_constraint: {
      value: cdktf.numberToHclTerraform(struct!.maxPodsConstraint),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    autoscaling: {
      value: clusterGkeConfigV2NodePoolsAutoscalingToHclTerraform(struct!.autoscaling),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterGkeConfigV2NodePoolsAutoscalingList",
    },
    config: {
      value: clusterGkeConfigV2NodePoolsConfigToHclTerraform(struct!.config),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterGkeConfigV2NodePoolsConfigList",
    },
    management: {
      value: clusterGkeConfigV2NodePoolsManagementToHclTerraform(struct!.management),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterGkeConfigV2NodePoolsManagementList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2NodePoolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterGkeConfigV2NodePools | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._initialNodeCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialNodeCount = this._initialNodeCount;
    }
    if (this._maxPodsConstraint !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPodsConstraint = this._maxPodsConstraint;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._autoscaling?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoscaling = this._autoscaling?.internalValue;
    }
    if (this._config?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config?.internalValue;
    }
    if (this._management?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.management = this._management?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2NodePools | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._initialNodeCount = undefined;
      this._maxPodsConstraint = undefined;
      this._name = undefined;
      this._version = undefined;
      this._autoscaling.internalValue = undefined;
      this._config.internalValue = undefined;
      this._management.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._initialNodeCount = value.initialNodeCount;
      this._maxPodsConstraint = value.maxPodsConstraint;
      this._name = value.name;
      this._version = value.version;
      this._autoscaling.internalValue = value.autoscaling;
      this._config.internalValue = value.config;
      this._management.internalValue = value.management;
    }
  }

  // initial_node_count - computed: false, optional: false, required: true
  private _initialNodeCount?: number; 
  public get initialNodeCount() {
    return this.getNumberAttribute('initial_node_count');
  }
  public set initialNodeCount(value: number) {
    this._initialNodeCount = value;
  }
  // Temporarily expose input value. Use with caution.
  public get initialNodeCountInput() {
    return this._initialNodeCount;
  }

  // max_pods_constraint - computed: true, optional: true, required: false
  private _maxPodsConstraint?: number; 
  public get maxPodsConstraint() {
    return this.getNumberAttribute('max_pods_constraint');
  }
  public set maxPodsConstraint(value: number) {
    this._maxPodsConstraint = value;
  }
  public resetMaxPodsConstraint() {
    this._maxPodsConstraint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPodsConstraintInput() {
    return this._maxPodsConstraint;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // version - computed: false, optional: false, required: true
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // autoscaling - computed: false, optional: true, required: false
  private _autoscaling = new ClusterGkeConfigV2NodePoolsAutoscalingOutputReference(this, "autoscaling");
  public get autoscaling() {
    return this._autoscaling;
  }
  public putAutoscaling(value: ClusterGkeConfigV2NodePoolsAutoscaling) {
    this._autoscaling.internalValue = value;
  }
  public resetAutoscaling() {
    this._autoscaling.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoscalingInput() {
    return this._autoscaling.internalValue;
  }

  // config - computed: false, optional: true, required: false
  private _config = new ClusterGkeConfigV2NodePoolsConfigOutputReference(this, "config");
  public get config() {
    return this._config;
  }
  public putConfig(value: ClusterGkeConfigV2NodePoolsConfig) {
    this._config.internalValue = value;
  }
  public resetConfig() {
    this._config.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config.internalValue;
  }

  // management - computed: false, optional: true, required: false
  private _management = new ClusterGkeConfigV2NodePoolsManagementOutputReference(this, "management");
  public get management() {
    return this._management;
  }
  public putManagement(value: ClusterGkeConfigV2NodePoolsManagement) {
    this._management.internalValue = value;
  }
  public resetManagement() {
    this._management.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managementInput() {
    return this._management.internalValue;
  }
}

export class ClusterGkeConfigV2NodePoolsList extends cdktf.ComplexList {
  public internalValue? : ClusterGkeConfigV2NodePools[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterGkeConfigV2NodePoolsOutputReference {
    return new ClusterGkeConfigV2NodePoolsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterGkeConfigV2PrivateClusterConfig {
  /**
  * Enable GKE cluster private endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enable_private_endpoint Cluster#enable_private_endpoint}
  */
  readonly enablePrivateEndpoint?: boolean | cdktf.IResolvable;
  /**
  * Enable GKE cluster private nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enable_private_nodes Cluster#enable_private_nodes}
  */
  readonly enablePrivateNodes?: boolean | cdktf.IResolvable;
  /**
  * The GKE cluster private master ip v4 cidr block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#master_ipv4_cidr_block Cluster#master_ipv4_cidr_block}
  */
  readonly masterIpv4CidrBlock: string;
}

export function clusterGkeConfigV2PrivateClusterConfigToTerraform(struct?: ClusterGkeConfigV2PrivateClusterConfigOutputReference | ClusterGkeConfigV2PrivateClusterConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable_private_endpoint: cdktf.booleanToTerraform(struct!.enablePrivateEndpoint),
    enable_private_nodes: cdktf.booleanToTerraform(struct!.enablePrivateNodes),
    master_ipv4_cidr_block: cdktf.stringToTerraform(struct!.masterIpv4CidrBlock),
  }
}


export function clusterGkeConfigV2PrivateClusterConfigToHclTerraform(struct?: ClusterGkeConfigV2PrivateClusterConfigOutputReference | ClusterGkeConfigV2PrivateClusterConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable_private_endpoint: {
      value: cdktf.booleanToHclTerraform(struct!.enablePrivateEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_private_nodes: {
      value: cdktf.booleanToHclTerraform(struct!.enablePrivateNodes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    master_ipv4_cidr_block: {
      value: cdktf.stringToHclTerraform(struct!.masterIpv4CidrBlock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2PrivateClusterConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterGkeConfigV2PrivateClusterConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enablePrivateEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePrivateEndpoint = this._enablePrivateEndpoint;
    }
    if (this._enablePrivateNodes !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePrivateNodes = this._enablePrivateNodes;
    }
    if (this._masterIpv4CidrBlock !== undefined) {
      hasAnyValues = true;
      internalValueResult.masterIpv4CidrBlock = this._masterIpv4CidrBlock;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2PrivateClusterConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enablePrivateEndpoint = undefined;
      this._enablePrivateNodes = undefined;
      this._masterIpv4CidrBlock = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enablePrivateEndpoint = value.enablePrivateEndpoint;
      this._enablePrivateNodes = value.enablePrivateNodes;
      this._masterIpv4CidrBlock = value.masterIpv4CidrBlock;
    }
  }

  // enable_private_endpoint - computed: false, optional: true, required: false
  private _enablePrivateEndpoint?: boolean | cdktf.IResolvable; 
  public get enablePrivateEndpoint() {
    return this.getBooleanAttribute('enable_private_endpoint');
  }
  public set enablePrivateEndpoint(value: boolean | cdktf.IResolvable) {
    this._enablePrivateEndpoint = value;
  }
  public resetEnablePrivateEndpoint() {
    this._enablePrivateEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePrivateEndpointInput() {
    return this._enablePrivateEndpoint;
  }

  // enable_private_nodes - computed: false, optional: true, required: false
  private _enablePrivateNodes?: boolean | cdktf.IResolvable; 
  public get enablePrivateNodes() {
    return this.getBooleanAttribute('enable_private_nodes');
  }
  public set enablePrivateNodes(value: boolean | cdktf.IResolvable) {
    this._enablePrivateNodes = value;
  }
  public resetEnablePrivateNodes() {
    this._enablePrivateNodes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePrivateNodesInput() {
    return this._enablePrivateNodes;
  }

  // master_ipv4_cidr_block - computed: false, optional: false, required: true
  private _masterIpv4CidrBlock?: string; 
  public get masterIpv4CidrBlock() {
    return this.getStringAttribute('master_ipv4_cidr_block');
  }
  public set masterIpv4CidrBlock(value: string) {
    this._masterIpv4CidrBlock = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterIpv4CidrBlockInput() {
    return this._masterIpv4CidrBlock;
  }
}
export interface ClusterGkeConfigV2 {
  /**
  * The GKE ip v4 cidr block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_ipv4_cidr_block Cluster#cluster_ipv4_cidr_block}
  */
  readonly clusterIpv4CidrBlock?: string;
  /**
  * The GKE cluster description
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#description Cluster#description}
  */
  readonly description?: string;
  /**
  * Enable Kubernetes alpha
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enable_kubernetes_alpha Cluster#enable_kubernetes_alpha}
  */
  readonly enableKubernetesAlpha?: boolean | cdktf.IResolvable;
  /**
  * Google credential secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#google_credential_secret Cluster#google_credential_secret}
  */
  readonly googleCredentialSecret: string;
  /**
  * Is GKE cluster imported?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#imported Cluster#imported}
  */
  readonly imported?: boolean | cdktf.IResolvable;
  /**
  * The kubernetes master version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kubernetes_version Cluster#kubernetes_version}
  */
  readonly kubernetesVersion?: string;
  /**
  * The GKE cluster labels
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#labels Cluster#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * The GKE cluster locations
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#locations Cluster#locations}
  */
  readonly locations?: string[];
  /**
  * The GKE cluster logging service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#logging_service Cluster#logging_service}
  */
  readonly loggingService?: string;
  /**
  * The GKE cluster maintenance window
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#maintenance_window Cluster#maintenance_window}
  */
  readonly maintenanceWindow?: string;
  /**
  * The GKE cluster monitoring service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#monitoring_service Cluster#monitoring_service}
  */
  readonly monitoringService?: string;
  /**
  * The GKE cluster name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * The GKE cluster network
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network Cluster#network}
  */
  readonly network?: string;
  /**
  * Is GKE cluster network policy enabled?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network_policy_enabled Cluster#network_policy_enabled}
  */
  readonly networkPolicyEnabled?: boolean | cdktf.IResolvable;
  /**
  * The GKE project id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#project_id Cluster#project_id}
  */
  readonly projectId: string;
  /**
  * The GKE cluster region. Required if `zone` is empty
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#region Cluster#region}
  */
  readonly region?: string;
  /**
  * The GKE cluster subnetwork
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#subnetwork Cluster#subnetwork}
  */
  readonly subnetwork?: string;
  /**
  * The GKE cluster zone. Required if `region` is empty
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#zone Cluster#zone}
  */
  readonly zone?: string;
  /**
  * cluster_addons block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_addons Cluster#cluster_addons}
  */
  readonly clusterAddons?: ClusterGkeConfigV2ClusterAddons;
  /**
  * ip_allocation_policy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ip_allocation_policy Cluster#ip_allocation_policy}
  */
  readonly ipAllocationPolicy?: ClusterGkeConfigV2IpAllocationPolicy;
  /**
  * master_authorized_networks_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#master_authorized_networks_config Cluster#master_authorized_networks_config}
  */
  readonly masterAuthorizedNetworksConfig?: ClusterGkeConfigV2MasterAuthorizedNetworksConfig;
  /**
  * node_pools block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_pools Cluster#node_pools}
  */
  readonly nodePools?: ClusterGkeConfigV2NodePools[] | cdktf.IResolvable;
  /**
  * private_cluster_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#private_cluster_config Cluster#private_cluster_config}
  */
  readonly privateClusterConfig?: ClusterGkeConfigV2PrivateClusterConfig;
}

export function clusterGkeConfigV2ToTerraform(struct?: ClusterGkeConfigV2OutputReference | ClusterGkeConfigV2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_ipv4_cidr_block: cdktf.stringToTerraform(struct!.clusterIpv4CidrBlock),
    description: cdktf.stringToTerraform(struct!.description),
    enable_kubernetes_alpha: cdktf.booleanToTerraform(struct!.enableKubernetesAlpha),
    google_credential_secret: cdktf.stringToTerraform(struct!.googleCredentialSecret),
    imported: cdktf.booleanToTerraform(struct!.imported),
    kubernetes_version: cdktf.stringToTerraform(struct!.kubernetesVersion),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    locations: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.locations),
    logging_service: cdktf.stringToTerraform(struct!.loggingService),
    maintenance_window: cdktf.stringToTerraform(struct!.maintenanceWindow),
    monitoring_service: cdktf.stringToTerraform(struct!.monitoringService),
    name: cdktf.stringToTerraform(struct!.name),
    network: cdktf.stringToTerraform(struct!.network),
    network_policy_enabled: cdktf.booleanToTerraform(struct!.networkPolicyEnabled),
    project_id: cdktf.stringToTerraform(struct!.projectId),
    region: cdktf.stringToTerraform(struct!.region),
    subnetwork: cdktf.stringToTerraform(struct!.subnetwork),
    zone: cdktf.stringToTerraform(struct!.zone),
    cluster_addons: clusterGkeConfigV2ClusterAddonsToTerraform(struct!.clusterAddons),
    ip_allocation_policy: clusterGkeConfigV2IpAllocationPolicyToTerraform(struct!.ipAllocationPolicy),
    master_authorized_networks_config: clusterGkeConfigV2MasterAuthorizedNetworksConfigToTerraform(struct!.masterAuthorizedNetworksConfig),
    node_pools: cdktf.listMapper(clusterGkeConfigV2NodePoolsToTerraform, true)(struct!.nodePools),
    private_cluster_config: clusterGkeConfigV2PrivateClusterConfigToTerraform(struct!.privateClusterConfig),
  }
}


export function clusterGkeConfigV2ToHclTerraform(struct?: ClusterGkeConfigV2OutputReference | ClusterGkeConfigV2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_ipv4_cidr_block: {
      value: cdktf.stringToHclTerraform(struct!.clusterIpv4CidrBlock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_kubernetes_alpha: {
      value: cdktf.booleanToHclTerraform(struct!.enableKubernetesAlpha),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    google_credential_secret: {
      value: cdktf.stringToHclTerraform(struct!.googleCredentialSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    imported: {
      value: cdktf.booleanToHclTerraform(struct!.imported),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kubernetes_version: {
      value: cdktf.stringToHclTerraform(struct!.kubernetesVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    locations: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.locations),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    logging_service: {
      value: cdktf.stringToHclTerraform(struct!.loggingService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    maintenance_window: {
      value: cdktf.stringToHclTerraform(struct!.maintenanceWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    monitoring_service: {
      value: cdktf.stringToHclTerraform(struct!.monitoringService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network: {
      value: cdktf.stringToHclTerraform(struct!.network),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_policy_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.networkPolicyEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subnetwork: {
      value: cdktf.stringToHclTerraform(struct!.subnetwork),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    zone: {
      value: cdktf.stringToHclTerraform(struct!.zone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_addons: {
      value: clusterGkeConfigV2ClusterAddonsToHclTerraform(struct!.clusterAddons),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterGkeConfigV2ClusterAddonsList",
    },
    ip_allocation_policy: {
      value: clusterGkeConfigV2IpAllocationPolicyToHclTerraform(struct!.ipAllocationPolicy),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterGkeConfigV2IpAllocationPolicyList",
    },
    master_authorized_networks_config: {
      value: clusterGkeConfigV2MasterAuthorizedNetworksConfigToHclTerraform(struct!.masterAuthorizedNetworksConfig),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterGkeConfigV2MasterAuthorizedNetworksConfigList",
    },
    node_pools: {
      value: cdktf.listMapperHcl(clusterGkeConfigV2NodePoolsToHclTerraform, true)(struct!.nodePools),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterGkeConfigV2NodePoolsList",
    },
    private_cluster_config: {
      value: clusterGkeConfigV2PrivateClusterConfigToHclTerraform(struct!.privateClusterConfig),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterGkeConfigV2PrivateClusterConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterGkeConfigV2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterGkeConfigV2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterIpv4CidrBlock !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterIpv4CidrBlock = this._clusterIpv4CidrBlock;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enableKubernetesAlpha !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableKubernetesAlpha = this._enableKubernetesAlpha;
    }
    if (this._googleCredentialSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleCredentialSecret = this._googleCredentialSecret;
    }
    if (this._imported !== undefined) {
      hasAnyValues = true;
      internalValueResult.imported = this._imported;
    }
    if (this._kubernetesVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesVersion = this._kubernetesVersion;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._locations !== undefined) {
      hasAnyValues = true;
      internalValueResult.locations = this._locations;
    }
    if (this._loggingService !== undefined) {
      hasAnyValues = true;
      internalValueResult.loggingService = this._loggingService;
    }
    if (this._maintenanceWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.maintenanceWindow = this._maintenanceWindow;
    }
    if (this._monitoringService !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringService = this._monitoringService;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._network !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network;
    }
    if (this._networkPolicyEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkPolicyEnabled = this._networkPolicyEnabled;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._subnetwork !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnetwork = this._subnetwork;
    }
    if (this._zone !== undefined) {
      hasAnyValues = true;
      internalValueResult.zone = this._zone;
    }
    if (this._clusterAddons?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterAddons = this._clusterAddons?.internalValue;
    }
    if (this._ipAllocationPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllocationPolicy = this._ipAllocationPolicy?.internalValue;
    }
    if (this._masterAuthorizedNetworksConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.masterAuthorizedNetworksConfig = this._masterAuthorizedNetworksConfig?.internalValue;
    }
    if (this._nodePools?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodePools = this._nodePools?.internalValue;
    }
    if (this._privateClusterConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateClusterConfig = this._privateClusterConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterGkeConfigV2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clusterIpv4CidrBlock = undefined;
      this._description = undefined;
      this._enableKubernetesAlpha = undefined;
      this._googleCredentialSecret = undefined;
      this._imported = undefined;
      this._kubernetesVersion = undefined;
      this._labels = undefined;
      this._locations = undefined;
      this._loggingService = undefined;
      this._maintenanceWindow = undefined;
      this._monitoringService = undefined;
      this._name = undefined;
      this._network = undefined;
      this._networkPolicyEnabled = undefined;
      this._projectId = undefined;
      this._region = undefined;
      this._subnetwork = undefined;
      this._zone = undefined;
      this._clusterAddons.internalValue = undefined;
      this._ipAllocationPolicy.internalValue = undefined;
      this._masterAuthorizedNetworksConfig.internalValue = undefined;
      this._nodePools.internalValue = undefined;
      this._privateClusterConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clusterIpv4CidrBlock = value.clusterIpv4CidrBlock;
      this._description = value.description;
      this._enableKubernetesAlpha = value.enableKubernetesAlpha;
      this._googleCredentialSecret = value.googleCredentialSecret;
      this._imported = value.imported;
      this._kubernetesVersion = value.kubernetesVersion;
      this._labels = value.labels;
      this._locations = value.locations;
      this._loggingService = value.loggingService;
      this._maintenanceWindow = value.maintenanceWindow;
      this._monitoringService = value.monitoringService;
      this._name = value.name;
      this._network = value.network;
      this._networkPolicyEnabled = value.networkPolicyEnabled;
      this._projectId = value.projectId;
      this._region = value.region;
      this._subnetwork = value.subnetwork;
      this._zone = value.zone;
      this._clusterAddons.internalValue = value.clusterAddons;
      this._ipAllocationPolicy.internalValue = value.ipAllocationPolicy;
      this._masterAuthorizedNetworksConfig.internalValue = value.masterAuthorizedNetworksConfig;
      this._nodePools.internalValue = value.nodePools;
      this._privateClusterConfig.internalValue = value.privateClusterConfig;
    }
  }

  // cluster_ipv4_cidr_block - computed: true, optional: true, required: false
  private _clusterIpv4CidrBlock?: string; 
  public get clusterIpv4CidrBlock() {
    return this.getStringAttribute('cluster_ipv4_cidr_block');
  }
  public set clusterIpv4CidrBlock(value: string) {
    this._clusterIpv4CidrBlock = value;
  }
  public resetClusterIpv4CidrBlock() {
    this._clusterIpv4CidrBlock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIpv4CidrBlockInput() {
    return this._clusterIpv4CidrBlock;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enable_kubernetes_alpha - computed: true, optional: true, required: false
  private _enableKubernetesAlpha?: boolean | cdktf.IResolvable; 
  public get enableKubernetesAlpha() {
    return this.getBooleanAttribute('enable_kubernetes_alpha');
  }
  public set enableKubernetesAlpha(value: boolean | cdktf.IResolvable) {
    this._enableKubernetesAlpha = value;
  }
  public resetEnableKubernetesAlpha() {
    this._enableKubernetesAlpha = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableKubernetesAlphaInput() {
    return this._enableKubernetesAlpha;
  }

  // google_credential_secret - computed: false, optional: false, required: true
  private _googleCredentialSecret?: string; 
  public get googleCredentialSecret() {
    return this.getStringAttribute('google_credential_secret');
  }
  public set googleCredentialSecret(value: string) {
    this._googleCredentialSecret = value;
  }
  // Temporarily expose input value. Use with caution.
  public get googleCredentialSecretInput() {
    return this._googleCredentialSecret;
  }

  // imported - computed: false, optional: true, required: false
  private _imported?: boolean | cdktf.IResolvable; 
  public get imported() {
    return this.getBooleanAttribute('imported');
  }
  public set imported(value: boolean | cdktf.IResolvable) {
    this._imported = value;
  }
  public resetImported() {
    this._imported = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importedInput() {
    return this._imported;
  }

  // kubernetes_version - computed: true, optional: true, required: false
  private _kubernetesVersion?: string; 
  public get kubernetesVersion() {
    return this.getStringAttribute('kubernetes_version');
  }
  public set kubernetesVersion(value: string) {
    this._kubernetesVersion = value;
  }
  public resetKubernetesVersion() {
    this._kubernetesVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesVersionInput() {
    return this._kubernetesVersion;
  }

  // labels - computed: true, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // locations - computed: true, optional: true, required: false
  private _locations?: string[]; 
  public get locations() {
    return this.getListAttribute('locations');
  }
  public set locations(value: string[]) {
    this._locations = value;
  }
  public resetLocations() {
    this._locations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationsInput() {
    return this._locations;
  }

  // logging_service - computed: true, optional: true, required: false
  private _loggingService?: string; 
  public get loggingService() {
    return this.getStringAttribute('logging_service');
  }
  public set loggingService(value: string) {
    this._loggingService = value;
  }
  public resetLoggingService() {
    this._loggingService = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loggingServiceInput() {
    return this._loggingService;
  }

  // maintenance_window - computed: true, optional: true, required: false
  private _maintenanceWindow?: string; 
  public get maintenanceWindow() {
    return this.getStringAttribute('maintenance_window');
  }
  public set maintenanceWindow(value: string) {
    this._maintenanceWindow = value;
  }
  public resetMaintenanceWindow() {
    this._maintenanceWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maintenanceWindowInput() {
    return this._maintenanceWindow;
  }

  // monitoring_service - computed: true, optional: true, required: false
  private _monitoringService?: string; 
  public get monitoringService() {
    return this.getStringAttribute('monitoring_service');
  }
  public set monitoringService(value: string) {
    this._monitoringService = value;
  }
  public resetMonitoringService() {
    this._monitoringService = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringServiceInput() {
    return this._monitoringService;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // network - computed: true, optional: true, required: false
  private _network?: string; 
  public get network() {
    return this.getStringAttribute('network');
  }
  public set network(value: string) {
    this._network = value;
  }
  public resetNetwork() {
    this._network = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network;
  }

  // network_policy_enabled - computed: true, optional: true, required: false
  private _networkPolicyEnabled?: boolean | cdktf.IResolvable; 
  public get networkPolicyEnabled() {
    return this.getBooleanAttribute('network_policy_enabled');
  }
  public set networkPolicyEnabled(value: boolean | cdktf.IResolvable) {
    this._networkPolicyEnabled = value;
  }
  public resetNetworkPolicyEnabled() {
    this._networkPolicyEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkPolicyEnabledInput() {
    return this._networkPolicyEnabled;
  }

  // project_id - computed: false, optional: false, required: true
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }

  // region - computed: true, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // subnetwork - computed: true, optional: true, required: false
  private _subnetwork?: string; 
  public get subnetwork() {
    return this.getStringAttribute('subnetwork');
  }
  public set subnetwork(value: string) {
    this._subnetwork = value;
  }
  public resetSubnetwork() {
    this._subnetwork = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetworkInput() {
    return this._subnetwork;
  }

  // zone - computed: true, optional: true, required: false
  private _zone?: string; 
  public get zone() {
    return this.getStringAttribute('zone');
  }
  public set zone(value: string) {
    this._zone = value;
  }
  public resetZone() {
    this._zone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zoneInput() {
    return this._zone;
  }

  // cluster_addons - computed: false, optional: true, required: false
  private _clusterAddons = new ClusterGkeConfigV2ClusterAddonsOutputReference(this, "cluster_addons");
  public get clusterAddons() {
    return this._clusterAddons;
  }
  public putClusterAddons(value: ClusterGkeConfigV2ClusterAddons) {
    this._clusterAddons.internalValue = value;
  }
  public resetClusterAddons() {
    this._clusterAddons.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterAddonsInput() {
    return this._clusterAddons.internalValue;
  }

  // ip_allocation_policy - computed: false, optional: true, required: false
  private _ipAllocationPolicy = new ClusterGkeConfigV2IpAllocationPolicyOutputReference(this, "ip_allocation_policy");
  public get ipAllocationPolicy() {
    return this._ipAllocationPolicy;
  }
  public putIpAllocationPolicy(value: ClusterGkeConfigV2IpAllocationPolicy) {
    this._ipAllocationPolicy.internalValue = value;
  }
  public resetIpAllocationPolicy() {
    this._ipAllocationPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllocationPolicyInput() {
    return this._ipAllocationPolicy.internalValue;
  }

  // master_authorized_networks_config - computed: false, optional: true, required: false
  private _masterAuthorizedNetworksConfig = new ClusterGkeConfigV2MasterAuthorizedNetworksConfigOutputReference(this, "master_authorized_networks_config");
  public get masterAuthorizedNetworksConfig() {
    return this._masterAuthorizedNetworksConfig;
  }
  public putMasterAuthorizedNetworksConfig(value: ClusterGkeConfigV2MasterAuthorizedNetworksConfig) {
    this._masterAuthorizedNetworksConfig.internalValue = value;
  }
  public resetMasterAuthorizedNetworksConfig() {
    this._masterAuthorizedNetworksConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get masterAuthorizedNetworksConfigInput() {
    return this._masterAuthorizedNetworksConfig.internalValue;
  }

  // node_pools - computed: false, optional: true, required: false
  private _nodePools = new ClusterGkeConfigV2NodePoolsList(this, "node_pools", false);
  public get nodePools() {
    return this._nodePools;
  }
  public putNodePools(value: ClusterGkeConfigV2NodePools[] | cdktf.IResolvable) {
    this._nodePools.internalValue = value;
  }
  public resetNodePools() {
    this._nodePools.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodePoolsInput() {
    return this._nodePools.internalValue;
  }

  // private_cluster_config - computed: false, optional: true, required: false
  private _privateClusterConfig = new ClusterGkeConfigV2PrivateClusterConfigOutputReference(this, "private_cluster_config");
  public get privateClusterConfig() {
    return this._privateClusterConfig;
  }
  public putPrivateClusterConfig(value: ClusterGkeConfigV2PrivateClusterConfig) {
    this._privateClusterConfig.internalValue = value;
  }
  public resetPrivateClusterConfig() {
    this._privateClusterConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateClusterConfigInput() {
    return this._privateClusterConfig.internalValue;
  }
}
export interface ClusterImportedConfig {
  /**
  * Private registry URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#private_registry_url Cluster#private_registry_url}
  */
  readonly privateRegistryUrl?: string;
}

export function clusterImportedConfigToTerraform(struct?: ClusterImportedConfigOutputReference | ClusterImportedConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    private_registry_url: cdktf.stringToTerraform(struct!.privateRegistryUrl),
  }
}


export function clusterImportedConfigToHclTerraform(struct?: ClusterImportedConfigOutputReference | ClusterImportedConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    private_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.privateRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterImportedConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterImportedConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._privateRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateRegistryUrl = this._privateRegistryUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterImportedConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._privateRegistryUrl = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._privateRegistryUrl = value.privateRegistryUrl;
    }
  }

  // private_registry_url - computed: true, optional: true, required: false
  private _privateRegistryUrl?: string; 
  public get privateRegistryUrl() {
    return this.getStringAttribute('private_registry_url');
  }
  public set privateRegistryUrl(value: string) {
    this._privateRegistryUrl = value;
  }
  public resetPrivateRegistryUrl() {
    this._privateRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateRegistryUrlInput() {
    return this._privateRegistryUrl;
  }
}
export interface ClusterK3SConfigUpgradeStrategy {
  /**
  * Drain server nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#drain_server_nodes Cluster#drain_server_nodes}
  */
  readonly drainServerNodes?: boolean | cdktf.IResolvable;
  /**
  * Drain worker nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#drain_worker_nodes Cluster#drain_worker_nodes}
  */
  readonly drainWorkerNodes?: boolean | cdktf.IResolvable;
  /**
  * Server concurrency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#server_concurrency Cluster#server_concurrency}
  */
  readonly serverConcurrency?: number;
  /**
  * Worker concurrency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#worker_concurrency Cluster#worker_concurrency}
  */
  readonly workerConcurrency?: number;
}

export function clusterK3SConfigUpgradeStrategyToTerraform(struct?: ClusterK3SConfigUpgradeStrategyOutputReference | ClusterK3SConfigUpgradeStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    drain_server_nodes: cdktf.booleanToTerraform(struct!.drainServerNodes),
    drain_worker_nodes: cdktf.booleanToTerraform(struct!.drainWorkerNodes),
    server_concurrency: cdktf.numberToTerraform(struct!.serverConcurrency),
    worker_concurrency: cdktf.numberToTerraform(struct!.workerConcurrency),
  }
}


export function clusterK3SConfigUpgradeStrategyToHclTerraform(struct?: ClusterK3SConfigUpgradeStrategyOutputReference | ClusterK3SConfigUpgradeStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    drain_server_nodes: {
      value: cdktf.booleanToHclTerraform(struct!.drainServerNodes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    drain_worker_nodes: {
      value: cdktf.booleanToHclTerraform(struct!.drainWorkerNodes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_concurrency: {
      value: cdktf.numberToHclTerraform(struct!.serverConcurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    worker_concurrency: {
      value: cdktf.numberToHclTerraform(struct!.workerConcurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterK3SConfigUpgradeStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterK3SConfigUpgradeStrategy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._drainServerNodes !== undefined) {
      hasAnyValues = true;
      internalValueResult.drainServerNodes = this._drainServerNodes;
    }
    if (this._drainWorkerNodes !== undefined) {
      hasAnyValues = true;
      internalValueResult.drainWorkerNodes = this._drainWorkerNodes;
    }
    if (this._serverConcurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverConcurrency = this._serverConcurrency;
    }
    if (this._workerConcurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.workerConcurrency = this._workerConcurrency;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterK3SConfigUpgradeStrategy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._drainServerNodes = undefined;
      this._drainWorkerNodes = undefined;
      this._serverConcurrency = undefined;
      this._workerConcurrency = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._drainServerNodes = value.drainServerNodes;
      this._drainWorkerNodes = value.drainWorkerNodes;
      this._serverConcurrency = value.serverConcurrency;
      this._workerConcurrency = value.workerConcurrency;
    }
  }

  // drain_server_nodes - computed: false, optional: true, required: false
  private _drainServerNodes?: boolean | cdktf.IResolvable; 
  public get drainServerNodes() {
    return this.getBooleanAttribute('drain_server_nodes');
  }
  public set drainServerNodes(value: boolean | cdktf.IResolvable) {
    this._drainServerNodes = value;
  }
  public resetDrainServerNodes() {
    this._drainServerNodes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drainServerNodesInput() {
    return this._drainServerNodes;
  }

  // drain_worker_nodes - computed: false, optional: true, required: false
  private _drainWorkerNodes?: boolean | cdktf.IResolvable; 
  public get drainWorkerNodes() {
    return this.getBooleanAttribute('drain_worker_nodes');
  }
  public set drainWorkerNodes(value: boolean | cdktf.IResolvable) {
    this._drainWorkerNodes = value;
  }
  public resetDrainWorkerNodes() {
    this._drainWorkerNodes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drainWorkerNodesInput() {
    return this._drainWorkerNodes;
  }

  // server_concurrency - computed: false, optional: true, required: false
  private _serverConcurrency?: number; 
  public get serverConcurrency() {
    return this.getNumberAttribute('server_concurrency');
  }
  public set serverConcurrency(value: number) {
    this._serverConcurrency = value;
  }
  public resetServerConcurrency() {
    this._serverConcurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverConcurrencyInput() {
    return this._serverConcurrency;
  }

  // worker_concurrency - computed: false, optional: true, required: false
  private _workerConcurrency?: number; 
  public get workerConcurrency() {
    return this.getNumberAttribute('worker_concurrency');
  }
  public set workerConcurrency(value: number) {
    this._workerConcurrency = value;
  }
  public resetWorkerConcurrency() {
    this._workerConcurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workerConcurrencyInput() {
    return this._workerConcurrency;
  }
}
export interface ClusterK3SConfig {
  /**
  * The K3S kubernetes version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
  /**
  * upgrade_strategy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#upgrade_strategy Cluster#upgrade_strategy}
  */
  readonly upgradeStrategy?: ClusterK3SConfigUpgradeStrategy;
}

export function clusterK3SConfigToTerraform(struct?: ClusterK3SConfigOutputReference | ClusterK3SConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    version: cdktf.stringToTerraform(struct!.version),
    upgrade_strategy: clusterK3SConfigUpgradeStrategyToTerraform(struct!.upgradeStrategy),
  }
}


export function clusterK3SConfigToHclTerraform(struct?: ClusterK3SConfigOutputReference | ClusterK3SConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    upgrade_strategy: {
      value: clusterK3SConfigUpgradeStrategyToHclTerraform(struct!.upgradeStrategy),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterK3SConfigUpgradeStrategyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterK3SConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterK3SConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._upgradeStrategy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upgradeStrategy = this._upgradeStrategy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterK3SConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._version = undefined;
      this._upgradeStrategy.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._version = value.version;
      this._upgradeStrategy.internalValue = value.upgradeStrategy;
    }
  }

  // version - computed: true, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // upgrade_strategy - computed: false, optional: true, required: false
  private _upgradeStrategy = new ClusterK3SConfigUpgradeStrategyOutputReference(this, "upgrade_strategy");
  public get upgradeStrategy() {
    return this._upgradeStrategy;
  }
  public putUpgradeStrategy(value: ClusterK3SConfigUpgradeStrategy) {
    this._upgradeStrategy.internalValue = value;
  }
  public resetUpgradeStrategy() {
    this._upgradeStrategy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upgradeStrategyInput() {
    return this._upgradeStrategy.internalValue;
  }
}
export interface ClusterOkeConfig {
  /**
  * Optionally specify a cluster type of basic or enhanced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_type Cluster#cluster_type}
  */
  readonly clusterType?: string;
  /**
  * The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#compartment_id Cluster#compartment_id}
  */
  readonly compartmentId: string;
  /**
  * The (optional) name of a pre-existing subnet (public or private) for the Kubernetes API endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#control_plane_subnet_name Cluster#control_plane_subnet_name}
  */
  readonly controlPlaneSubnetName?: string;
  /**
  * An optional custom boot volume size (in GB) for the nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#custom_boot_volume_size Cluster#custom_boot_volume_size}
  */
  readonly customBootVolumeSize?: number;
  /**
  * An optional description of this cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#description Cluster#description}
  */
  readonly description?: string;
  /**
  * Enable the kubernetes dashboard
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enable_kubernetes_dashboard Cluster#enable_kubernetes_dashboard}
  */
  readonly enableKubernetesDashboard?: boolean | cdktf.IResolvable;
  /**
  * Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enable_private_control_plane Cluster#enable_private_control_plane}
  */
  readonly enablePrivateControlPlane?: boolean | cdktf.IResolvable;
  /**
  * Whether worker nodes are deployed into a new private subnet
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enable_private_nodes Cluster#enable_private_nodes}
  */
  readonly enablePrivateNodes?: boolean | cdktf.IResolvable;
  /**
  * The optional grace period in minutes to allow cordon and drain to complete successfuly
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#eviction_grace_duration Cluster#eviction_grace_duration}
  */
  readonly evictionGraceDuration?: string;
  /**
  * The fingerprint corresponding to the specified user's private API Key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#fingerprint Cluster#fingerprint}
  */
  readonly fingerprint?: string;
  /**
  * Optional amount of memory in GB for nodes (requires flexible node_shape)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#flex_memory_in_gbs Cluster#flex_memory_in_gbs}
  */
  readonly flexMemoryInGbs?: number;
  /**
  * Optional number of OCPUs for nodes (requires flexible node_shape)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#flex_ocpus Cluster#flex_ocpus}
  */
  readonly flexOcpus?: number;
  /**
  * Whether to send a SIGKILL signal if a pod does not terminate within the specified grace period
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#force_delete_after_grace_duration Cluster#force_delete_after_grace_duration}
  */
  readonly forceDeleteAfterGraceDuration?: boolean | cdktf.IResolvable;
  /**
  * Optional specify a comma separated list of master encryption key OCID(s) to verify images
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image_verification_kms_key_id Cluster#image_verification_kms_key_id}
  */
  readonly imageVerificationKmsKeyId?: string;
  /**
  * Optional specify the OCID of the KMS Vault master key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kms_key_id Cluster#kms_key_id}
  */
  readonly kmsKeyId?: string;
  /**
  * The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.33.1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kubernetes_version Cluster#kubernetes_version}
  */
  readonly kubernetesVersion: string;
  /**
  * Optional limit on the total number of nodes in the pool
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#limit_node_count Cluster#limit_node_count}
  */
  readonly limitNodeCount?: number;
  /**
  * The name of the first existing subnet to use for Kubernetes services / LB
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#load_balancer_subnet_name_1 Cluster#load_balancer_subnet_name_1}
  */
  readonly loadBalancerSubnetName1?: string;
  /**
  * The (optional) name of a second existing subnet to use for Kubernetes services / LB
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#load_balancer_subnet_name_2 Cluster#load_balancer_subnet_name_2}
  */
  readonly loadBalancerSubnetName2?: string;
  /**
  * The OS for the node image
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_image Cluster#node_image}
  */
  readonly nodeImage: string;
  /**
  * Optional name for DNS domain of node pool subnet
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_pool_dns_domain_name Cluster#node_pool_dns_domain_name}
  */
  readonly nodePoolDnsDomainName?: string;
  /**
  * Optional pre-existing subnet (public or private) for nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_pool_subnet_name Cluster#node_pool_subnet_name}
  */
  readonly nodePoolSubnetName?: string;
  /**
  * The contents of the SSH public key file to use for the nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_public_key_contents Cluster#node_public_key_contents}
  */
  readonly nodePublicKeyContents?: string;
  /**
  * The shape of the node (determines number of CPUs and  amount of memory on each node)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_shape Cluster#node_shape}
  */
  readonly nodeShape: string;
  /**
  * The contents of custom cloud-init / user_data for the nodes - will be base64 encoded internally if it is not already
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_user_data_contents Cluster#node_user_data_contents}
  */
  readonly nodeUserDataContents?: string;
  /**
  * Optional specify the pod CIDR, defaults to 10.244.0.0/16
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#pod_cidr Cluster#pod_cidr}
  */
  readonly podCidr?: string;
  /**
  * Optional Pod Network plugin. Choose flannel or native. Defaults to flannel
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#pod_network Cluster#pod_network}
  */
  readonly podNetwork?: string;
  /**
  * The (optional) name of a pre-existing subnet that pods will be assigned IPs from when using native pod networking
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#pod_subnet_name Cluster#pod_subnet_name}
  */
  readonly podSubnetName?: string;
  /**
  * The private API key file contents for the specified user, in PEM format
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#private_key_contents Cluster#private_key_contents}
  */
  readonly privateKeyContents?: string;
  /**
  * The passphrase of the private key for the OKE cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#private_key_passphrase Cluster#private_key_passphrase}
  */
  readonly privateKeyPassphrase?: string;
  /**
  * Number of node subnets (defaults to creating 1 regional subnet)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#quantity_of_node_subnets Cluster#quantity_of_node_subnets}
  */
  readonly quantityOfNodeSubnets?: number;
  /**
  * Number of worker nodes in each subnet / availability domain
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#quantity_per_subnet Cluster#quantity_per_subnet}
  */
  readonly quantityPerSubnet?: number;
  /**
  * The availability domain within the region to host the OKE cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#region Cluster#region}
  */
  readonly region: string;
  /**
  * Optional specify the service CIDR, defaults to 10.96.0.0/16
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service_cidr Cluster#service_cidr}
  */
  readonly serviceCidr?: string;
  /**
  * Optional name for DNS domain of service subnet
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service_dns_domain_name Cluster#service_dns_domain_name}
  */
  readonly serviceDnsDomainName?: string;
  /**
  * Whether to skip deleting VCN
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#skip_vcn_delete Cluster#skip_vcn_delete}
  */
  readonly skipVcnDelete?: boolean | cdktf.IResolvable;
  /**
  * The OCID of the tenancy in which to create resources
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tenancy_id Cluster#tenancy_id}
  */
  readonly tenancyId: string;
  /**
  * The OCID of a user who has access to the tenancy/compartment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#user_ocid Cluster#user_ocid}
  */
  readonly userOcid?: string;
  /**
  * The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vcn_compartment_id Cluster#vcn_compartment_id}
  */
  readonly vcnCompartmentId?: string;
  /**
  * The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vcn_name Cluster#vcn_name}
  */
  readonly vcnName?: string;
  /**
  * Additional CIDR from which to allow ingress to worker nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#worker_node_ingress_cidr Cluster#worker_node_ingress_cidr}
  */
  readonly workerNodeIngressCidr?: string;
}

export function clusterOkeConfigToTerraform(struct?: ClusterOkeConfigOutputReference | ClusterOkeConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_type: cdktf.stringToTerraform(struct!.clusterType),
    compartment_id: cdktf.stringToTerraform(struct!.compartmentId),
    control_plane_subnet_name: cdktf.stringToTerraform(struct!.controlPlaneSubnetName),
    custom_boot_volume_size: cdktf.numberToTerraform(struct!.customBootVolumeSize),
    description: cdktf.stringToTerraform(struct!.description),
    enable_kubernetes_dashboard: cdktf.booleanToTerraform(struct!.enableKubernetesDashboard),
    enable_private_control_plane: cdktf.booleanToTerraform(struct!.enablePrivateControlPlane),
    enable_private_nodes: cdktf.booleanToTerraform(struct!.enablePrivateNodes),
    eviction_grace_duration: cdktf.stringToTerraform(struct!.evictionGraceDuration),
    fingerprint: cdktf.stringToTerraform(struct!.fingerprint),
    flex_memory_in_gbs: cdktf.numberToTerraform(struct!.flexMemoryInGbs),
    flex_ocpus: cdktf.numberToTerraform(struct!.flexOcpus),
    force_delete_after_grace_duration: cdktf.booleanToTerraform(struct!.forceDeleteAfterGraceDuration),
    image_verification_kms_key_id: cdktf.stringToTerraform(struct!.imageVerificationKmsKeyId),
    kms_key_id: cdktf.stringToTerraform(struct!.kmsKeyId),
    kubernetes_version: cdktf.stringToTerraform(struct!.kubernetesVersion),
    limit_node_count: cdktf.numberToTerraform(struct!.limitNodeCount),
    load_balancer_subnet_name_1: cdktf.stringToTerraform(struct!.loadBalancerSubnetName1),
    load_balancer_subnet_name_2: cdktf.stringToTerraform(struct!.loadBalancerSubnetName2),
    node_image: cdktf.stringToTerraform(struct!.nodeImage),
    node_pool_dns_domain_name: cdktf.stringToTerraform(struct!.nodePoolDnsDomainName),
    node_pool_subnet_name: cdktf.stringToTerraform(struct!.nodePoolSubnetName),
    node_public_key_contents: cdktf.stringToTerraform(struct!.nodePublicKeyContents),
    node_shape: cdktf.stringToTerraform(struct!.nodeShape),
    node_user_data_contents: cdktf.stringToTerraform(struct!.nodeUserDataContents),
    pod_cidr: cdktf.stringToTerraform(struct!.podCidr),
    pod_network: cdktf.stringToTerraform(struct!.podNetwork),
    pod_subnet_name: cdktf.stringToTerraform(struct!.podSubnetName),
    private_key_contents: cdktf.stringToTerraform(struct!.privateKeyContents),
    private_key_passphrase: cdktf.stringToTerraform(struct!.privateKeyPassphrase),
    quantity_of_node_subnets: cdktf.numberToTerraform(struct!.quantityOfNodeSubnets),
    quantity_per_subnet: cdktf.numberToTerraform(struct!.quantityPerSubnet),
    region: cdktf.stringToTerraform(struct!.region),
    service_cidr: cdktf.stringToTerraform(struct!.serviceCidr),
    service_dns_domain_name: cdktf.stringToTerraform(struct!.serviceDnsDomainName),
    skip_vcn_delete: cdktf.booleanToTerraform(struct!.skipVcnDelete),
    tenancy_id: cdktf.stringToTerraform(struct!.tenancyId),
    user_ocid: cdktf.stringToTerraform(struct!.userOcid),
    vcn_compartment_id: cdktf.stringToTerraform(struct!.vcnCompartmentId),
    vcn_name: cdktf.stringToTerraform(struct!.vcnName),
    worker_node_ingress_cidr: cdktf.stringToTerraform(struct!.workerNodeIngressCidr),
  }
}


export function clusterOkeConfigToHclTerraform(struct?: ClusterOkeConfigOutputReference | ClusterOkeConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_type: {
      value: cdktf.stringToHclTerraform(struct!.clusterType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compartment_id: {
      value: cdktf.stringToHclTerraform(struct!.compartmentId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    control_plane_subnet_name: {
      value: cdktf.stringToHclTerraform(struct!.controlPlaneSubnetName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_boot_volume_size: {
      value: cdktf.numberToHclTerraform(struct!.customBootVolumeSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_kubernetes_dashboard: {
      value: cdktf.booleanToHclTerraform(struct!.enableKubernetesDashboard),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_private_control_plane: {
      value: cdktf.booleanToHclTerraform(struct!.enablePrivateControlPlane),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_private_nodes: {
      value: cdktf.booleanToHclTerraform(struct!.enablePrivateNodes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    eviction_grace_duration: {
      value: cdktf.stringToHclTerraform(struct!.evictionGraceDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    fingerprint: {
      value: cdktf.stringToHclTerraform(struct!.fingerprint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flex_memory_in_gbs: {
      value: cdktf.numberToHclTerraform(struct!.flexMemoryInGbs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    flex_ocpus: {
      value: cdktf.numberToHclTerraform(struct!.flexOcpus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    force_delete_after_grace_duration: {
      value: cdktf.booleanToHclTerraform(struct!.forceDeleteAfterGraceDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    image_verification_kms_key_id: {
      value: cdktf.stringToHclTerraform(struct!.imageVerificationKmsKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kms_key_id: {
      value: cdktf.stringToHclTerraform(struct!.kmsKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubernetes_version: {
      value: cdktf.stringToHclTerraform(struct!.kubernetesVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    limit_node_count: {
      value: cdktf.numberToHclTerraform(struct!.limitNodeCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balancer_subnet_name_1: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancerSubnetName1),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancer_subnet_name_2: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancerSubnetName2),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_image: {
      value: cdktf.stringToHclTerraform(struct!.nodeImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_pool_dns_domain_name: {
      value: cdktf.stringToHclTerraform(struct!.nodePoolDnsDomainName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_pool_subnet_name: {
      value: cdktf.stringToHclTerraform(struct!.nodePoolSubnetName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_public_key_contents: {
      value: cdktf.stringToHclTerraform(struct!.nodePublicKeyContents),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_shape: {
      value: cdktf.stringToHclTerraform(struct!.nodeShape),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_user_data_contents: {
      value: cdktf.stringToHclTerraform(struct!.nodeUserDataContents),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_cidr: {
      value: cdktf.stringToHclTerraform(struct!.podCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_network: {
      value: cdktf.stringToHclTerraform(struct!.podNetwork),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_subnet_name: {
      value: cdktf.stringToHclTerraform(struct!.podSubnetName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_key_contents: {
      value: cdktf.stringToHclTerraform(struct!.privateKeyContents),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_key_passphrase: {
      value: cdktf.stringToHclTerraform(struct!.privateKeyPassphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    quantity_of_node_subnets: {
      value: cdktf.numberToHclTerraform(struct!.quantityOfNodeSubnets),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    quantity_per_subnet: {
      value: cdktf.numberToHclTerraform(struct!.quantityPerSubnet),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_cidr: {
      value: cdktf.stringToHclTerraform(struct!.serviceCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_dns_domain_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceDnsDomainName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_vcn_delete: {
      value: cdktf.booleanToHclTerraform(struct!.skipVcnDelete),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tenancy_id: {
      value: cdktf.stringToHclTerraform(struct!.tenancyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_ocid: {
      value: cdktf.stringToHclTerraform(struct!.userOcid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vcn_compartment_id: {
      value: cdktf.stringToHclTerraform(struct!.vcnCompartmentId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vcn_name: {
      value: cdktf.stringToHclTerraform(struct!.vcnName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    worker_node_ingress_cidr: {
      value: cdktf.stringToHclTerraform(struct!.workerNodeIngressCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterOkeConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterOkeConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterType !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterType = this._clusterType;
    }
    if (this._compartmentId !== undefined) {
      hasAnyValues = true;
      internalValueResult.compartmentId = this._compartmentId;
    }
    if (this._controlPlaneSubnetName !== undefined) {
      hasAnyValues = true;
      internalValueResult.controlPlaneSubnetName = this._controlPlaneSubnetName;
    }
    if (this._customBootVolumeSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.customBootVolumeSize = this._customBootVolumeSize;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enableKubernetesDashboard !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableKubernetesDashboard = this._enableKubernetesDashboard;
    }
    if (this._enablePrivateControlPlane !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePrivateControlPlane = this._enablePrivateControlPlane;
    }
    if (this._enablePrivateNodes !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePrivateNodes = this._enablePrivateNodes;
    }
    if (this._evictionGraceDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionGraceDuration = this._evictionGraceDuration;
    }
    if (this._fingerprint !== undefined) {
      hasAnyValues = true;
      internalValueResult.fingerprint = this._fingerprint;
    }
    if (this._flexMemoryInGbs !== undefined) {
      hasAnyValues = true;
      internalValueResult.flexMemoryInGbs = this._flexMemoryInGbs;
    }
    if (this._flexOcpus !== undefined) {
      hasAnyValues = true;
      internalValueResult.flexOcpus = this._flexOcpus;
    }
    if (this._forceDeleteAfterGraceDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceDeleteAfterGraceDuration = this._forceDeleteAfterGraceDuration;
    }
    if (this._imageVerificationKmsKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageVerificationKmsKeyId = this._imageVerificationKmsKeyId;
    }
    if (this._kmsKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.kmsKeyId = this._kmsKeyId;
    }
    if (this._kubernetesVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesVersion = this._kubernetesVersion;
    }
    if (this._limitNodeCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.limitNodeCount = this._limitNodeCount;
    }
    if (this._loadBalancerSubnetName1 !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerSubnetName1 = this._loadBalancerSubnetName1;
    }
    if (this._loadBalancerSubnetName2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerSubnetName2 = this._loadBalancerSubnetName2;
    }
    if (this._nodeImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeImage = this._nodeImage;
    }
    if (this._nodePoolDnsDomainName !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodePoolDnsDomainName = this._nodePoolDnsDomainName;
    }
    if (this._nodePoolSubnetName !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodePoolSubnetName = this._nodePoolSubnetName;
    }
    if (this._nodePublicKeyContents !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodePublicKeyContents = this._nodePublicKeyContents;
    }
    if (this._nodeShape !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeShape = this._nodeShape;
    }
    if (this._nodeUserDataContents !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeUserDataContents = this._nodeUserDataContents;
    }
    if (this._podCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.podCidr = this._podCidr;
    }
    if (this._podNetwork !== undefined) {
      hasAnyValues = true;
      internalValueResult.podNetwork = this._podNetwork;
    }
    if (this._podSubnetName !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSubnetName = this._podSubnetName;
    }
    if (this._privateKeyContents !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKeyContents = this._privateKeyContents;
    }
    if (this._privateKeyPassphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKeyPassphrase = this._privateKeyPassphrase;
    }
    if (this._quantityOfNodeSubnets !== undefined) {
      hasAnyValues = true;
      internalValueResult.quantityOfNodeSubnets = this._quantityOfNodeSubnets;
    }
    if (this._quantityPerSubnet !== undefined) {
      hasAnyValues = true;
      internalValueResult.quantityPerSubnet = this._quantityPerSubnet;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._serviceCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceCidr = this._serviceCidr;
    }
    if (this._serviceDnsDomainName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceDnsDomainName = this._serviceDnsDomainName;
    }
    if (this._skipVcnDelete !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipVcnDelete = this._skipVcnDelete;
    }
    if (this._tenancyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenancyId = this._tenancyId;
    }
    if (this._userOcid !== undefined) {
      hasAnyValues = true;
      internalValueResult.userOcid = this._userOcid;
    }
    if (this._vcnCompartmentId !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcnCompartmentId = this._vcnCompartmentId;
    }
    if (this._vcnName !== undefined) {
      hasAnyValues = true;
      internalValueResult.vcnName = this._vcnName;
    }
    if (this._workerNodeIngressCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.workerNodeIngressCidr = this._workerNodeIngressCidr;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterOkeConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clusterType = undefined;
      this._compartmentId = undefined;
      this._controlPlaneSubnetName = undefined;
      this._customBootVolumeSize = undefined;
      this._description = undefined;
      this._enableKubernetesDashboard = undefined;
      this._enablePrivateControlPlane = undefined;
      this._enablePrivateNodes = undefined;
      this._evictionGraceDuration = undefined;
      this._fingerprint = undefined;
      this._flexMemoryInGbs = undefined;
      this._flexOcpus = undefined;
      this._forceDeleteAfterGraceDuration = undefined;
      this._imageVerificationKmsKeyId = undefined;
      this._kmsKeyId = undefined;
      this._kubernetesVersion = undefined;
      this._limitNodeCount = undefined;
      this._loadBalancerSubnetName1 = undefined;
      this._loadBalancerSubnetName2 = undefined;
      this._nodeImage = undefined;
      this._nodePoolDnsDomainName = undefined;
      this._nodePoolSubnetName = undefined;
      this._nodePublicKeyContents = undefined;
      this._nodeShape = undefined;
      this._nodeUserDataContents = undefined;
      this._podCidr = undefined;
      this._podNetwork = undefined;
      this._podSubnetName = undefined;
      this._privateKeyContents = undefined;
      this._privateKeyPassphrase = undefined;
      this._quantityOfNodeSubnets = undefined;
      this._quantityPerSubnet = undefined;
      this._region = undefined;
      this._serviceCidr = undefined;
      this._serviceDnsDomainName = undefined;
      this._skipVcnDelete = undefined;
      this._tenancyId = undefined;
      this._userOcid = undefined;
      this._vcnCompartmentId = undefined;
      this._vcnName = undefined;
      this._workerNodeIngressCidr = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clusterType = value.clusterType;
      this._compartmentId = value.compartmentId;
      this._controlPlaneSubnetName = value.controlPlaneSubnetName;
      this._customBootVolumeSize = value.customBootVolumeSize;
      this._description = value.description;
      this._enableKubernetesDashboard = value.enableKubernetesDashboard;
      this._enablePrivateControlPlane = value.enablePrivateControlPlane;
      this._enablePrivateNodes = value.enablePrivateNodes;
      this._evictionGraceDuration = value.evictionGraceDuration;
      this._fingerprint = value.fingerprint;
      this._flexMemoryInGbs = value.flexMemoryInGbs;
      this._flexOcpus = value.flexOcpus;
      this._forceDeleteAfterGraceDuration = value.forceDeleteAfterGraceDuration;
      this._imageVerificationKmsKeyId = value.imageVerificationKmsKeyId;
      this._kmsKeyId = value.kmsKeyId;
      this._kubernetesVersion = value.kubernetesVersion;
      this._limitNodeCount = value.limitNodeCount;
      this._loadBalancerSubnetName1 = value.loadBalancerSubnetName1;
      this._loadBalancerSubnetName2 = value.loadBalancerSubnetName2;
      this._nodeImage = value.nodeImage;
      this._nodePoolDnsDomainName = value.nodePoolDnsDomainName;
      this._nodePoolSubnetName = value.nodePoolSubnetName;
      this._nodePublicKeyContents = value.nodePublicKeyContents;
      this._nodeShape = value.nodeShape;
      this._nodeUserDataContents = value.nodeUserDataContents;
      this._podCidr = value.podCidr;
      this._podNetwork = value.podNetwork;
      this._podSubnetName = value.podSubnetName;
      this._privateKeyContents = value.privateKeyContents;
      this._privateKeyPassphrase = value.privateKeyPassphrase;
      this._quantityOfNodeSubnets = value.quantityOfNodeSubnets;
      this._quantityPerSubnet = value.quantityPerSubnet;
      this._region = value.region;
      this._serviceCidr = value.serviceCidr;
      this._serviceDnsDomainName = value.serviceDnsDomainName;
      this._skipVcnDelete = value.skipVcnDelete;
      this._tenancyId = value.tenancyId;
      this._userOcid = value.userOcid;
      this._vcnCompartmentId = value.vcnCompartmentId;
      this._vcnName = value.vcnName;
      this._workerNodeIngressCidr = value.workerNodeIngressCidr;
    }
  }

  // cluster_type - computed: false, optional: true, required: false
  private _clusterType?: string; 
  public get clusterType() {
    return this.getStringAttribute('cluster_type');
  }
  public set clusterType(value: string) {
    this._clusterType = value;
  }
  public resetClusterType() {
    this._clusterType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterTypeInput() {
    return this._clusterType;
  }

  // compartment_id - computed: false, optional: false, required: true
  private _compartmentId?: string; 
  public get compartmentId() {
    return this.getStringAttribute('compartment_id');
  }
  public set compartmentId(value: string) {
    this._compartmentId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get compartmentIdInput() {
    return this._compartmentId;
  }

  // control_plane_subnet_name - computed: false, optional: true, required: false
  private _controlPlaneSubnetName?: string; 
  public get controlPlaneSubnetName() {
    return this.getStringAttribute('control_plane_subnet_name');
  }
  public set controlPlaneSubnetName(value: string) {
    this._controlPlaneSubnetName = value;
  }
  public resetControlPlaneSubnetName() {
    this._controlPlaneSubnetName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get controlPlaneSubnetNameInput() {
    return this._controlPlaneSubnetName;
  }

  // custom_boot_volume_size - computed: false, optional: true, required: false
  private _customBootVolumeSize?: number; 
  public get customBootVolumeSize() {
    return this.getNumberAttribute('custom_boot_volume_size');
  }
  public set customBootVolumeSize(value: number) {
    this._customBootVolumeSize = value;
  }
  public resetCustomBootVolumeSize() {
    this._customBootVolumeSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customBootVolumeSizeInput() {
    return this._customBootVolumeSize;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enable_kubernetes_dashboard - computed: false, optional: true, required: false
  private _enableKubernetesDashboard?: boolean | cdktf.IResolvable; 
  public get enableKubernetesDashboard() {
    return this.getBooleanAttribute('enable_kubernetes_dashboard');
  }
  public set enableKubernetesDashboard(value: boolean | cdktf.IResolvable) {
    this._enableKubernetesDashboard = value;
  }
  public resetEnableKubernetesDashboard() {
    this._enableKubernetesDashboard = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableKubernetesDashboardInput() {
    return this._enableKubernetesDashboard;
  }

  // enable_private_control_plane - computed: false, optional: true, required: false
  private _enablePrivateControlPlane?: boolean | cdktf.IResolvable; 
  public get enablePrivateControlPlane() {
    return this.getBooleanAttribute('enable_private_control_plane');
  }
  public set enablePrivateControlPlane(value: boolean | cdktf.IResolvable) {
    this._enablePrivateControlPlane = value;
  }
  public resetEnablePrivateControlPlane() {
    this._enablePrivateControlPlane = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePrivateControlPlaneInput() {
    return this._enablePrivateControlPlane;
  }

  // enable_private_nodes - computed: false, optional: true, required: false
  private _enablePrivateNodes?: boolean | cdktf.IResolvable; 
  public get enablePrivateNodes() {
    return this.getBooleanAttribute('enable_private_nodes');
  }
  public set enablePrivateNodes(value: boolean | cdktf.IResolvable) {
    this._enablePrivateNodes = value;
  }
  public resetEnablePrivateNodes() {
    this._enablePrivateNodes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePrivateNodesInput() {
    return this._enablePrivateNodes;
  }

  // eviction_grace_duration - computed: false, optional: true, required: false
  private _evictionGraceDuration?: string; 
  public get evictionGraceDuration() {
    return this.getStringAttribute('eviction_grace_duration');
  }
  public set evictionGraceDuration(value: string) {
    this._evictionGraceDuration = value;
  }
  public resetEvictionGraceDuration() {
    this._evictionGraceDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionGraceDurationInput() {
    return this._evictionGraceDuration;
  }

  // fingerprint - computed: false, optional: true, required: false
  private _fingerprint?: string; 
  public get fingerprint() {
    return this.getStringAttribute('fingerprint');
  }
  public set fingerprint(value: string) {
    this._fingerprint = value;
  }
  public resetFingerprint() {
    this._fingerprint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fingerprintInput() {
    return this._fingerprint;
  }

  // flex_memory_in_gbs - computed: false, optional: true, required: false
  private _flexMemoryInGbs?: number; 
  public get flexMemoryInGbs() {
    return this.getNumberAttribute('flex_memory_in_gbs');
  }
  public set flexMemoryInGbs(value: number) {
    this._flexMemoryInGbs = value;
  }
  public resetFlexMemoryInGbs() {
    this._flexMemoryInGbs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flexMemoryInGbsInput() {
    return this._flexMemoryInGbs;
  }

  // flex_ocpus - computed: false, optional: true, required: false
  private _flexOcpus?: number; 
  public get flexOcpus() {
    return this.getNumberAttribute('flex_ocpus');
  }
  public set flexOcpus(value: number) {
    this._flexOcpus = value;
  }
  public resetFlexOcpus() {
    this._flexOcpus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flexOcpusInput() {
    return this._flexOcpus;
  }

  // force_delete_after_grace_duration - computed: false, optional: true, required: false
  private _forceDeleteAfterGraceDuration?: boolean | cdktf.IResolvable; 
  public get forceDeleteAfterGraceDuration() {
    return this.getBooleanAttribute('force_delete_after_grace_duration');
  }
  public set forceDeleteAfterGraceDuration(value: boolean | cdktf.IResolvable) {
    this._forceDeleteAfterGraceDuration = value;
  }
  public resetForceDeleteAfterGraceDuration() {
    this._forceDeleteAfterGraceDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceDeleteAfterGraceDurationInput() {
    return this._forceDeleteAfterGraceDuration;
  }

  // image_verification_kms_key_id - computed: false, optional: true, required: false
  private _imageVerificationKmsKeyId?: string; 
  public get imageVerificationKmsKeyId() {
    return this.getStringAttribute('image_verification_kms_key_id');
  }
  public set imageVerificationKmsKeyId(value: string) {
    this._imageVerificationKmsKeyId = value;
  }
  public resetImageVerificationKmsKeyId() {
    this._imageVerificationKmsKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageVerificationKmsKeyIdInput() {
    return this._imageVerificationKmsKeyId;
  }

  // kms_key_id - computed: false, optional: true, required: false
  private _kmsKeyId?: string; 
  public get kmsKeyId() {
    return this.getStringAttribute('kms_key_id');
  }
  public set kmsKeyId(value: string) {
    this._kmsKeyId = value;
  }
  public resetKmsKeyId() {
    this._kmsKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kmsKeyIdInput() {
    return this._kmsKeyId;
  }

  // kubernetes_version - computed: false, optional: false, required: true
  private _kubernetesVersion?: string; 
  public get kubernetesVersion() {
    return this.getStringAttribute('kubernetes_version');
  }
  public set kubernetesVersion(value: string) {
    this._kubernetesVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesVersionInput() {
    return this._kubernetesVersion;
  }

  // limit_node_count - computed: false, optional: true, required: false
  private _limitNodeCount?: number; 
  public get limitNodeCount() {
    return this.getNumberAttribute('limit_node_count');
  }
  public set limitNodeCount(value: number) {
    this._limitNodeCount = value;
  }
  public resetLimitNodeCount() {
    this._limitNodeCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitNodeCountInput() {
    return this._limitNodeCount;
  }

  // load_balancer_subnet_name_1 - computed: false, optional: true, required: false
  private _loadBalancerSubnetName1?: string; 
  public get loadBalancerSubnetName1() {
    return this.getStringAttribute('load_balancer_subnet_name_1');
  }
  public set loadBalancerSubnetName1(value: string) {
    this._loadBalancerSubnetName1 = value;
  }
  public resetLoadBalancerSubnetName1() {
    this._loadBalancerSubnetName1 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerSubnetName1Input() {
    return this._loadBalancerSubnetName1;
  }

  // load_balancer_subnet_name_2 - computed: false, optional: true, required: false
  private _loadBalancerSubnetName2?: string; 
  public get loadBalancerSubnetName2() {
    return this.getStringAttribute('load_balancer_subnet_name_2');
  }
  public set loadBalancerSubnetName2(value: string) {
    this._loadBalancerSubnetName2 = value;
  }
  public resetLoadBalancerSubnetName2() {
    this._loadBalancerSubnetName2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerSubnetName2Input() {
    return this._loadBalancerSubnetName2;
  }

  // node_image - computed: false, optional: false, required: true
  private _nodeImage?: string; 
  public get nodeImage() {
    return this.getStringAttribute('node_image');
  }
  public set nodeImage(value: string) {
    this._nodeImage = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeImageInput() {
    return this._nodeImage;
  }

  // node_pool_dns_domain_name - computed: false, optional: true, required: false
  private _nodePoolDnsDomainName?: string; 
  public get nodePoolDnsDomainName() {
    return this.getStringAttribute('node_pool_dns_domain_name');
  }
  public set nodePoolDnsDomainName(value: string) {
    this._nodePoolDnsDomainName = value;
  }
  public resetNodePoolDnsDomainName() {
    this._nodePoolDnsDomainName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodePoolDnsDomainNameInput() {
    return this._nodePoolDnsDomainName;
  }

  // node_pool_subnet_name - computed: false, optional: true, required: false
  private _nodePoolSubnetName?: string; 
  public get nodePoolSubnetName() {
    return this.getStringAttribute('node_pool_subnet_name');
  }
  public set nodePoolSubnetName(value: string) {
    this._nodePoolSubnetName = value;
  }
  public resetNodePoolSubnetName() {
    this._nodePoolSubnetName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodePoolSubnetNameInput() {
    return this._nodePoolSubnetName;
  }

  // node_public_key_contents - computed: false, optional: true, required: false
  private _nodePublicKeyContents?: string; 
  public get nodePublicKeyContents() {
    return this.getStringAttribute('node_public_key_contents');
  }
  public set nodePublicKeyContents(value: string) {
    this._nodePublicKeyContents = value;
  }
  public resetNodePublicKeyContents() {
    this._nodePublicKeyContents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodePublicKeyContentsInput() {
    return this._nodePublicKeyContents;
  }

  // node_shape - computed: false, optional: false, required: true
  private _nodeShape?: string; 
  public get nodeShape() {
    return this.getStringAttribute('node_shape');
  }
  public set nodeShape(value: string) {
    this._nodeShape = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeShapeInput() {
    return this._nodeShape;
  }

  // node_user_data_contents - computed: false, optional: true, required: false
  private _nodeUserDataContents?: string; 
  public get nodeUserDataContents() {
    return this.getStringAttribute('node_user_data_contents');
  }
  public set nodeUserDataContents(value: string) {
    this._nodeUserDataContents = value;
  }
  public resetNodeUserDataContents() {
    this._nodeUserDataContents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeUserDataContentsInput() {
    return this._nodeUserDataContents;
  }

  // pod_cidr - computed: false, optional: true, required: false
  private _podCidr?: string; 
  public get podCidr() {
    return this.getStringAttribute('pod_cidr');
  }
  public set podCidr(value: string) {
    this._podCidr = value;
  }
  public resetPodCidr() {
    this._podCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podCidrInput() {
    return this._podCidr;
  }

  // pod_network - computed: false, optional: true, required: false
  private _podNetwork?: string; 
  public get podNetwork() {
    return this.getStringAttribute('pod_network');
  }
  public set podNetwork(value: string) {
    this._podNetwork = value;
  }
  public resetPodNetwork() {
    this._podNetwork = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podNetworkInput() {
    return this._podNetwork;
  }

  // pod_subnet_name - computed: false, optional: true, required: false
  private _podSubnetName?: string; 
  public get podSubnetName() {
    return this.getStringAttribute('pod_subnet_name');
  }
  public set podSubnetName(value: string) {
    this._podSubnetName = value;
  }
  public resetPodSubnetName() {
    this._podSubnetName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSubnetNameInput() {
    return this._podSubnetName;
  }

  // private_key_contents - computed: false, optional: true, required: false
  private _privateKeyContents?: string; 
  public get privateKeyContents() {
    return this.getStringAttribute('private_key_contents');
  }
  public set privateKeyContents(value: string) {
    this._privateKeyContents = value;
  }
  public resetPrivateKeyContents() {
    this._privateKeyContents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyContentsInput() {
    return this._privateKeyContents;
  }

  // private_key_passphrase - computed: false, optional: true, required: false
  private _privateKeyPassphrase?: string; 
  public get privateKeyPassphrase() {
    return this.getStringAttribute('private_key_passphrase');
  }
  public set privateKeyPassphrase(value: string) {
    this._privateKeyPassphrase = value;
  }
  public resetPrivateKeyPassphrase() {
    this._privateKeyPassphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyPassphraseInput() {
    return this._privateKeyPassphrase;
  }

  // quantity_of_node_subnets - computed: false, optional: true, required: false
  private _quantityOfNodeSubnets?: number; 
  public get quantityOfNodeSubnets() {
    return this.getNumberAttribute('quantity_of_node_subnets');
  }
  public set quantityOfNodeSubnets(value: number) {
    this._quantityOfNodeSubnets = value;
  }
  public resetQuantityOfNodeSubnets() {
    this._quantityOfNodeSubnets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get quantityOfNodeSubnetsInput() {
    return this._quantityOfNodeSubnets;
  }

  // quantity_per_subnet - computed: false, optional: true, required: false
  private _quantityPerSubnet?: number; 
  public get quantityPerSubnet() {
    return this.getNumberAttribute('quantity_per_subnet');
  }
  public set quantityPerSubnet(value: number) {
    this._quantityPerSubnet = value;
  }
  public resetQuantityPerSubnet() {
    this._quantityPerSubnet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get quantityPerSubnetInput() {
    return this._quantityPerSubnet;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // service_cidr - computed: false, optional: true, required: false
  private _serviceCidr?: string; 
  public get serviceCidr() {
    return this.getStringAttribute('service_cidr');
  }
  public set serviceCidr(value: string) {
    this._serviceCidr = value;
  }
  public resetServiceCidr() {
    this._serviceCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceCidrInput() {
    return this._serviceCidr;
  }

  // service_dns_domain_name - computed: false, optional: true, required: false
  private _serviceDnsDomainName?: string; 
  public get serviceDnsDomainName() {
    return this.getStringAttribute('service_dns_domain_name');
  }
  public set serviceDnsDomainName(value: string) {
    this._serviceDnsDomainName = value;
  }
  public resetServiceDnsDomainName() {
    this._serviceDnsDomainName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceDnsDomainNameInput() {
    return this._serviceDnsDomainName;
  }

  // skip_vcn_delete - computed: false, optional: true, required: false
  private _skipVcnDelete?: boolean | cdktf.IResolvable; 
  public get skipVcnDelete() {
    return this.getBooleanAttribute('skip_vcn_delete');
  }
  public set skipVcnDelete(value: boolean | cdktf.IResolvable) {
    this._skipVcnDelete = value;
  }
  public resetSkipVcnDelete() {
    this._skipVcnDelete = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipVcnDeleteInput() {
    return this._skipVcnDelete;
  }

  // tenancy_id - computed: false, optional: false, required: true
  private _tenancyId?: string; 
  public get tenancyId() {
    return this.getStringAttribute('tenancy_id');
  }
  public set tenancyId(value: string) {
    this._tenancyId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenancyIdInput() {
    return this._tenancyId;
  }

  // user_ocid - computed: false, optional: true, required: false
  private _userOcid?: string; 
  public get userOcid() {
    return this.getStringAttribute('user_ocid');
  }
  public set userOcid(value: string) {
    this._userOcid = value;
  }
  public resetUserOcid() {
    this._userOcid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userOcidInput() {
    return this._userOcid;
  }

  // vcn_compartment_id - computed: false, optional: true, required: false
  private _vcnCompartmentId?: string; 
  public get vcnCompartmentId() {
    return this.getStringAttribute('vcn_compartment_id');
  }
  public set vcnCompartmentId(value: string) {
    this._vcnCompartmentId = value;
  }
  public resetVcnCompartmentId() {
    this._vcnCompartmentId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcnCompartmentIdInput() {
    return this._vcnCompartmentId;
  }

  // vcn_name - computed: false, optional: true, required: false
  private _vcnName?: string; 
  public get vcnName() {
    return this.getStringAttribute('vcn_name');
  }
  public set vcnName(value: string) {
    this._vcnName = value;
  }
  public resetVcnName() {
    this._vcnName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vcnNameInput() {
    return this._vcnName;
  }

  // worker_node_ingress_cidr - computed: false, optional: true, required: false
  private _workerNodeIngressCidr?: string; 
  public get workerNodeIngressCidr() {
    return this.getStringAttribute('worker_node_ingress_cidr');
  }
  public set workerNodeIngressCidr(value: string) {
    this._workerNodeIngressCidr = value;
  }
  public resetWorkerNodeIngressCidr() {
    this._workerNodeIngressCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workerNodeIngressCidrInput() {
    return this._workerNodeIngressCidr;
  }
}
export interface ClusterRke2ConfigUpgradeStrategy {
  /**
  * Drain server nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#drain_server_nodes Cluster#drain_server_nodes}
  */
  readonly drainServerNodes?: boolean | cdktf.IResolvable;
  /**
  * Drain worker nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#drain_worker_nodes Cluster#drain_worker_nodes}
  */
  readonly drainWorkerNodes?: boolean | cdktf.IResolvable;
  /**
  * Server concurrency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#server_concurrency Cluster#server_concurrency}
  */
  readonly serverConcurrency?: number;
  /**
  * Worker concurrency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#worker_concurrency Cluster#worker_concurrency}
  */
  readonly workerConcurrency?: number;
}

export function clusterRke2ConfigUpgradeStrategyToTerraform(struct?: ClusterRke2ConfigUpgradeStrategyOutputReference | ClusterRke2ConfigUpgradeStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    drain_server_nodes: cdktf.booleanToTerraform(struct!.drainServerNodes),
    drain_worker_nodes: cdktf.booleanToTerraform(struct!.drainWorkerNodes),
    server_concurrency: cdktf.numberToTerraform(struct!.serverConcurrency),
    worker_concurrency: cdktf.numberToTerraform(struct!.workerConcurrency),
  }
}


export function clusterRke2ConfigUpgradeStrategyToHclTerraform(struct?: ClusterRke2ConfigUpgradeStrategyOutputReference | ClusterRke2ConfigUpgradeStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    drain_server_nodes: {
      value: cdktf.booleanToHclTerraform(struct!.drainServerNodes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    drain_worker_nodes: {
      value: cdktf.booleanToHclTerraform(struct!.drainWorkerNodes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_concurrency: {
      value: cdktf.numberToHclTerraform(struct!.serverConcurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    worker_concurrency: {
      value: cdktf.numberToHclTerraform(struct!.workerConcurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRke2ConfigUpgradeStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRke2ConfigUpgradeStrategy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._drainServerNodes !== undefined) {
      hasAnyValues = true;
      internalValueResult.drainServerNodes = this._drainServerNodes;
    }
    if (this._drainWorkerNodes !== undefined) {
      hasAnyValues = true;
      internalValueResult.drainWorkerNodes = this._drainWorkerNodes;
    }
    if (this._serverConcurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverConcurrency = this._serverConcurrency;
    }
    if (this._workerConcurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.workerConcurrency = this._workerConcurrency;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRke2ConfigUpgradeStrategy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._drainServerNodes = undefined;
      this._drainWorkerNodes = undefined;
      this._serverConcurrency = undefined;
      this._workerConcurrency = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._drainServerNodes = value.drainServerNodes;
      this._drainWorkerNodes = value.drainWorkerNodes;
      this._serverConcurrency = value.serverConcurrency;
      this._workerConcurrency = value.workerConcurrency;
    }
  }

  // drain_server_nodes - computed: false, optional: true, required: false
  private _drainServerNodes?: boolean | cdktf.IResolvable; 
  public get drainServerNodes() {
    return this.getBooleanAttribute('drain_server_nodes');
  }
  public set drainServerNodes(value: boolean | cdktf.IResolvable) {
    this._drainServerNodes = value;
  }
  public resetDrainServerNodes() {
    this._drainServerNodes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drainServerNodesInput() {
    return this._drainServerNodes;
  }

  // drain_worker_nodes - computed: false, optional: true, required: false
  private _drainWorkerNodes?: boolean | cdktf.IResolvable; 
  public get drainWorkerNodes() {
    return this.getBooleanAttribute('drain_worker_nodes');
  }
  public set drainWorkerNodes(value: boolean | cdktf.IResolvable) {
    this._drainWorkerNodes = value;
  }
  public resetDrainWorkerNodes() {
    this._drainWorkerNodes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drainWorkerNodesInput() {
    return this._drainWorkerNodes;
  }

  // server_concurrency - computed: false, optional: true, required: false
  private _serverConcurrency?: number; 
  public get serverConcurrency() {
    return this.getNumberAttribute('server_concurrency');
  }
  public set serverConcurrency(value: number) {
    this._serverConcurrency = value;
  }
  public resetServerConcurrency() {
    this._serverConcurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverConcurrencyInput() {
    return this._serverConcurrency;
  }

  // worker_concurrency - computed: false, optional: true, required: false
  private _workerConcurrency?: number; 
  public get workerConcurrency() {
    return this.getNumberAttribute('worker_concurrency');
  }
  public set workerConcurrency(value: number) {
    this._workerConcurrency = value;
  }
  public resetWorkerConcurrency() {
    this._workerConcurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workerConcurrencyInput() {
    return this._workerConcurrency;
  }
}
export interface ClusterRke2Config {
  /**
  * The RKE2 kubernetes version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
  /**
  * upgrade_strategy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#upgrade_strategy Cluster#upgrade_strategy}
  */
  readonly upgradeStrategy?: ClusterRke2ConfigUpgradeStrategy;
}

export function clusterRke2ConfigToTerraform(struct?: ClusterRke2ConfigOutputReference | ClusterRke2Config): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    version: cdktf.stringToTerraform(struct!.version),
    upgrade_strategy: clusterRke2ConfigUpgradeStrategyToTerraform(struct!.upgradeStrategy),
  }
}


export function clusterRke2ConfigToHclTerraform(struct?: ClusterRke2ConfigOutputReference | ClusterRke2Config): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    upgrade_strategy: {
      value: clusterRke2ConfigUpgradeStrategyToHclTerraform(struct!.upgradeStrategy),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRke2ConfigUpgradeStrategyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRke2ConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRke2Config | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._upgradeStrategy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upgradeStrategy = this._upgradeStrategy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRke2Config | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._version = undefined;
      this._upgradeStrategy.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._version = value.version;
      this._upgradeStrategy.internalValue = value.upgradeStrategy;
    }
  }

  // version - computed: true, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // upgrade_strategy - computed: false, optional: true, required: false
  private _upgradeStrategy = new ClusterRke2ConfigUpgradeStrategyOutputReference(this, "upgrade_strategy");
  public get upgradeStrategy() {
    return this._upgradeStrategy;
  }
  public putUpgradeStrategy(value: ClusterRke2ConfigUpgradeStrategy) {
    this._upgradeStrategy.internalValue = value;
  }
  public resetUpgradeStrategy() {
    this._upgradeStrategy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upgradeStrategyInput() {
    return this._upgradeStrategy.internalValue;
  }
}
export interface ClusterRkeConfigAuthentication {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#sans Cluster#sans}
  */
  readonly sans?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#strategy Cluster#strategy}
  */
  readonly strategy?: string;
}

export function clusterRkeConfigAuthenticationToTerraform(struct?: ClusterRkeConfigAuthenticationOutputReference | ClusterRkeConfigAuthentication): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sans: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sans),
    strategy: cdktf.stringToTerraform(struct!.strategy),
  }
}


export function clusterRkeConfigAuthenticationToHclTerraform(struct?: ClusterRkeConfigAuthenticationOutputReference | ClusterRkeConfigAuthentication): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sans: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sans),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    strategy: {
      value: cdktf.stringToHclTerraform(struct!.strategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigAuthenticationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigAuthentication | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sans !== undefined) {
      hasAnyValues = true;
      internalValueResult.sans = this._sans;
    }
    if (this._strategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.strategy = this._strategy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigAuthentication | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._sans = undefined;
      this._strategy = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._sans = value.sans;
      this._strategy = value.strategy;
    }
  }

  // sans - computed: true, optional: true, required: false
  private _sans?: string[]; 
  public get sans() {
    return this.getListAttribute('sans');
  }
  public set sans(value: string[]) {
    this._sans = value;
  }
  public resetSans() {
    this._sans = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sansInput() {
    return this._sans;
  }

  // strategy - computed: true, optional: true, required: false
  private _strategy?: string; 
  public get strategy() {
    return this.getStringAttribute('strategy');
  }
  public set strategy(value: string) {
    this._strategy = value;
  }
  public resetStrategy() {
    this._strategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strategyInput() {
    return this._strategy;
  }
}
export interface ClusterRkeConfigAuthorization {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#mode Cluster#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#options Cluster#options}
  */
  readonly options?: { [key: string]: string };
}

export function clusterRkeConfigAuthorizationToTerraform(struct?: ClusterRkeConfigAuthorizationOutputReference | ClusterRkeConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    options: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.options),
  }
}


export function clusterRkeConfigAuthorizationToHclTerraform(struct?: ClusterRkeConfigAuthorizationOutputReference | ClusterRkeConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    options: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.options),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._options !== undefined) {
      hasAnyValues = true;
      internalValueResult.options = this._options;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._mode = undefined;
      this._options = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._mode = value.mode;
      this._options = value.options;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // options - computed: true, optional: true, required: false
  private _options?: { [key: string]: string }; 
  public get options() {
    return this.getStringMapAttribute('options');
  }
  public set options(value: { [key: string]: string }) {
    this._options = value;
  }
  public resetOptions() {
    this._options = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionsInput() {
    return this._options;
  }
}
export interface ClusterRkeConfigBastionHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#address Cluster#address}
  */
  readonly address: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#port Cluster#port}
  */
  readonly port?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ssh_agent_auth Cluster#ssh_agent_auth}
  */
  readonly sshAgentAuth?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ssh_key Cluster#ssh_key}
  */
  readonly sshKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ssh_key_path Cluster#ssh_key_path}
  */
  readonly sshKeyPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#user Cluster#user}
  */
  readonly user: string;
}

export function clusterRkeConfigBastionHostToTerraform(struct?: ClusterRkeConfigBastionHostOutputReference | ClusterRkeConfigBastionHost): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    port: cdktf.stringToTerraform(struct!.port),
    ssh_agent_auth: cdktf.booleanToTerraform(struct!.sshAgentAuth),
    ssh_key: cdktf.stringToTerraform(struct!.sshKey),
    ssh_key_path: cdktf.stringToTerraform(struct!.sshKeyPath),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function clusterRkeConfigBastionHostToHclTerraform(struct?: ClusterRkeConfigBastionHostOutputReference | ClusterRkeConfigBastionHost): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssh_agent_auth: {
      value: cdktf.booleanToHclTerraform(struct!.sshAgentAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ssh_key: {
      value: cdktf.stringToHclTerraform(struct!.sshKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssh_key_path: {
      value: cdktf.stringToHclTerraform(struct!.sshKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigBastionHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigBastionHost | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._sshAgentAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.sshAgentAuth = this._sshAgentAuth;
    }
    if (this._sshKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.sshKey = this._sshKey;
    }
    if (this._sshKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.sshKeyPath = this._sshKeyPath;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigBastionHost | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._address = undefined;
      this._port = undefined;
      this._sshAgentAuth = undefined;
      this._sshKey = undefined;
      this._sshKeyPath = undefined;
      this._user = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._address = value.address;
      this._port = value.port;
      this._sshAgentAuth = value.sshAgentAuth;
      this._sshKey = value.sshKey;
      this._sshKeyPath = value.sshKeyPath;
      this._user = value.user;
    }
  }

  // address - computed: false, optional: false, required: true
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // ssh_agent_auth - computed: false, optional: true, required: false
  private _sshAgentAuth?: boolean | cdktf.IResolvable; 
  public get sshAgentAuth() {
    return this.getBooleanAttribute('ssh_agent_auth');
  }
  public set sshAgentAuth(value: boolean | cdktf.IResolvable) {
    this._sshAgentAuth = value;
  }
  public resetSshAgentAuth() {
    this._sshAgentAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshAgentAuthInput() {
    return this._sshAgentAuth;
  }

  // ssh_key - computed: true, optional: true, required: false
  private _sshKey?: string; 
  public get sshKey() {
    return this.getStringAttribute('ssh_key');
  }
  public set sshKey(value: string) {
    this._sshKey = value;
  }
  public resetSshKey() {
    this._sshKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshKeyInput() {
    return this._sshKey;
  }

  // ssh_key_path - computed: true, optional: true, required: false
  private _sshKeyPath?: string; 
  public get sshKeyPath() {
    return this.getStringAttribute('ssh_key_path');
  }
  public set sshKeyPath(value: string) {
    this._sshKeyPath = value;
  }
  public resetSshKeyPath() {
    this._sshKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshKeyPathInput() {
    return this._sshKeyPath;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface ClusterRkeConfigCloudProviderAwsCloudProviderGlobal {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#disable_security_group_ingress Cluster#disable_security_group_ingress}
  */
  readonly disableSecurityGroupIngress?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#disable_strict_zone_check Cluster#disable_strict_zone_check}
  */
  readonly disableStrictZoneCheck?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#elb_security_group Cluster#elb_security_group}
  */
  readonly elbSecurityGroup?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kubernetes_cluster_id Cluster#kubernetes_cluster_id}
  */
  readonly kubernetesClusterId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kubernetes_cluster_tag Cluster#kubernetes_cluster_tag}
  */
  readonly kubernetesClusterTag?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#role_arn Cluster#role_arn}
  */
  readonly roleArn?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#route_table_id Cluster#route_table_id}
  */
  readonly routeTableId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#subnet_id Cluster#subnet_id}
  */
  readonly subnetId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vpc Cluster#vpc}
  */
  readonly vpc?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#zone Cluster#zone}
  */
  readonly zone?: string;
}

export function clusterRkeConfigCloudProviderAwsCloudProviderGlobalToTerraform(struct?: ClusterRkeConfigCloudProviderAwsCloudProviderGlobalOutputReference | ClusterRkeConfigCloudProviderAwsCloudProviderGlobal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable_security_group_ingress: cdktf.booleanToTerraform(struct!.disableSecurityGroupIngress),
    disable_strict_zone_check: cdktf.booleanToTerraform(struct!.disableStrictZoneCheck),
    elb_security_group: cdktf.stringToTerraform(struct!.elbSecurityGroup),
    kubernetes_cluster_id: cdktf.stringToTerraform(struct!.kubernetesClusterId),
    kubernetes_cluster_tag: cdktf.stringToTerraform(struct!.kubernetesClusterTag),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    route_table_id: cdktf.stringToTerraform(struct!.routeTableId),
    subnet_id: cdktf.stringToTerraform(struct!.subnetId),
    vpc: cdktf.stringToTerraform(struct!.vpc),
    zone: cdktf.stringToTerraform(struct!.zone),
  }
}


export function clusterRkeConfigCloudProviderAwsCloudProviderGlobalToHclTerraform(struct?: ClusterRkeConfigCloudProviderAwsCloudProviderGlobalOutputReference | ClusterRkeConfigCloudProviderAwsCloudProviderGlobal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable_security_group_ingress: {
      value: cdktf.booleanToHclTerraform(struct!.disableSecurityGroupIngress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_strict_zone_check: {
      value: cdktf.booleanToHclTerraform(struct!.disableStrictZoneCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    elb_security_group: {
      value: cdktf.stringToHclTerraform(struct!.elbSecurityGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubernetes_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.kubernetesClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubernetes_cluster_tag: {
      value: cdktf.stringToHclTerraform(struct!.kubernetesClusterTag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    route_table_id: {
      value: cdktf.stringToHclTerraform(struct!.routeTableId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subnet_id: {
      value: cdktf.stringToHclTerraform(struct!.subnetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vpc: {
      value: cdktf.stringToHclTerraform(struct!.vpc),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    zone: {
      value: cdktf.stringToHclTerraform(struct!.zone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderAwsCloudProviderGlobalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderAwsCloudProviderGlobal | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disableSecurityGroupIngress !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableSecurityGroupIngress = this._disableSecurityGroupIngress;
    }
    if (this._disableStrictZoneCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStrictZoneCheck = this._disableStrictZoneCheck;
    }
    if (this._elbSecurityGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.elbSecurityGroup = this._elbSecurityGroup;
    }
    if (this._kubernetesClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesClusterId = this._kubernetesClusterId;
    }
    if (this._kubernetesClusterTag !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesClusterTag = this._kubernetesClusterTag;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._routeTableId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTableId = this._routeTableId;
    }
    if (this._subnetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnetId = this._subnetId;
    }
    if (this._vpc !== undefined) {
      hasAnyValues = true;
      internalValueResult.vpc = this._vpc;
    }
    if (this._zone !== undefined) {
      hasAnyValues = true;
      internalValueResult.zone = this._zone;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderAwsCloudProviderGlobal | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._disableSecurityGroupIngress = undefined;
      this._disableStrictZoneCheck = undefined;
      this._elbSecurityGroup = undefined;
      this._kubernetesClusterId = undefined;
      this._kubernetesClusterTag = undefined;
      this._roleArn = undefined;
      this._routeTableId = undefined;
      this._subnetId = undefined;
      this._vpc = undefined;
      this._zone = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._disableSecurityGroupIngress = value.disableSecurityGroupIngress;
      this._disableStrictZoneCheck = value.disableStrictZoneCheck;
      this._elbSecurityGroup = value.elbSecurityGroup;
      this._kubernetesClusterId = value.kubernetesClusterId;
      this._kubernetesClusterTag = value.kubernetesClusterTag;
      this._roleArn = value.roleArn;
      this._routeTableId = value.routeTableId;
      this._subnetId = value.subnetId;
      this._vpc = value.vpc;
      this._zone = value.zone;
    }
  }

  // disable_security_group_ingress - computed: false, optional: true, required: false
  private _disableSecurityGroupIngress?: boolean | cdktf.IResolvable; 
  public get disableSecurityGroupIngress() {
    return this.getBooleanAttribute('disable_security_group_ingress');
  }
  public set disableSecurityGroupIngress(value: boolean | cdktf.IResolvable) {
    this._disableSecurityGroupIngress = value;
  }
  public resetDisableSecurityGroupIngress() {
    this._disableSecurityGroupIngress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableSecurityGroupIngressInput() {
    return this._disableSecurityGroupIngress;
  }

  // disable_strict_zone_check - computed: false, optional: true, required: false
  private _disableStrictZoneCheck?: boolean | cdktf.IResolvable; 
  public get disableStrictZoneCheck() {
    return this.getBooleanAttribute('disable_strict_zone_check');
  }
  public set disableStrictZoneCheck(value: boolean | cdktf.IResolvable) {
    this._disableStrictZoneCheck = value;
  }
  public resetDisableStrictZoneCheck() {
    this._disableStrictZoneCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStrictZoneCheckInput() {
    return this._disableStrictZoneCheck;
  }

  // elb_security_group - computed: true, optional: true, required: false
  private _elbSecurityGroup?: string; 
  public get elbSecurityGroup() {
    return this.getStringAttribute('elb_security_group');
  }
  public set elbSecurityGroup(value: string) {
    this._elbSecurityGroup = value;
  }
  public resetElbSecurityGroup() {
    this._elbSecurityGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elbSecurityGroupInput() {
    return this._elbSecurityGroup;
  }

  // kubernetes_cluster_id - computed: true, optional: true, required: false
  private _kubernetesClusterId?: string; 
  public get kubernetesClusterId() {
    return this.getStringAttribute('kubernetes_cluster_id');
  }
  public set kubernetesClusterId(value: string) {
    this._kubernetesClusterId = value;
  }
  public resetKubernetesClusterId() {
    this._kubernetesClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesClusterIdInput() {
    return this._kubernetesClusterId;
  }

  // kubernetes_cluster_tag - computed: true, optional: true, required: false
  private _kubernetesClusterTag?: string; 
  public get kubernetesClusterTag() {
    return this.getStringAttribute('kubernetes_cluster_tag');
  }
  public set kubernetesClusterTag(value: string) {
    this._kubernetesClusterTag = value;
  }
  public resetKubernetesClusterTag() {
    this._kubernetesClusterTag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesClusterTagInput() {
    return this._kubernetesClusterTag;
  }

  // role_arn - computed: true, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // route_table_id - computed: true, optional: true, required: false
  private _routeTableId?: string; 
  public get routeTableId() {
    return this.getStringAttribute('route_table_id');
  }
  public set routeTableId(value: string) {
    this._routeTableId = value;
  }
  public resetRouteTableId() {
    this._routeTableId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableIdInput() {
    return this._routeTableId;
  }

  // subnet_id - computed: true, optional: true, required: false
  private _subnetId?: string; 
  public get subnetId() {
    return this.getStringAttribute('subnet_id');
  }
  public set subnetId(value: string) {
    this._subnetId = value;
  }
  public resetSubnetId() {
    this._subnetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetIdInput() {
    return this._subnetId;
  }

  // vpc - computed: true, optional: true, required: false
  private _vpc?: string; 
  public get vpc() {
    return this.getStringAttribute('vpc');
  }
  public set vpc(value: string) {
    this._vpc = value;
  }
  public resetVpc() {
    this._vpc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vpcInput() {
    return this._vpc;
  }

  // zone - computed: true, optional: true, required: false
  private _zone?: string; 
  public get zone() {
    return this.getStringAttribute('zone');
  }
  public set zone(value: string) {
    this._zone = value;
  }
  public resetZone() {
    this._zone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zoneInput() {
    return this._zone;
  }
}
export interface ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#region Cluster#region}
  */
  readonly region?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service Cluster#service}
  */
  readonly service: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#signing_method Cluster#signing_method}
  */
  readonly signingMethod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#signing_name Cluster#signing_name}
  */
  readonly signingName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#signing_region Cluster#signing_region}
  */
  readonly signingRegion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#url Cluster#url}
  */
  readonly url?: string;
}

export function clusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideToTerraform(struct?: ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    region: cdktf.stringToTerraform(struct!.region),
    service: cdktf.stringToTerraform(struct!.service),
    signing_method: cdktf.stringToTerraform(struct!.signingMethod),
    signing_name: cdktf.stringToTerraform(struct!.signingName),
    signing_region: cdktf.stringToTerraform(struct!.signingRegion),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function clusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideToHclTerraform(struct?: ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    signing_method: {
      value: cdktf.stringToHclTerraform(struct!.signingMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    signing_name: {
      value: cdktf.stringToHclTerraform(struct!.signingName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    signing_region: {
      value: cdktf.stringToHclTerraform(struct!.signingRegion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._signingMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.signingMethod = this._signingMethod;
    }
    if (this._signingName !== undefined) {
      hasAnyValues = true;
      internalValueResult.signingName = this._signingName;
    }
    if (this._signingRegion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signingRegion = this._signingRegion;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._region = undefined;
      this._service = undefined;
      this._signingMethod = undefined;
      this._signingName = undefined;
      this._signingRegion = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._region = value.region;
      this._service = value.service;
      this._signingMethod = value.signingMethod;
      this._signingName = value.signingName;
      this._signingRegion = value.signingRegion;
      this._url = value.url;
    }
  }

  // region - computed: true, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // service - computed: false, optional: false, required: true
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // signing_method - computed: true, optional: true, required: false
  private _signingMethod?: string; 
  public get signingMethod() {
    return this.getStringAttribute('signing_method');
  }
  public set signingMethod(value: string) {
    this._signingMethod = value;
  }
  public resetSigningMethod() {
    this._signingMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signingMethodInput() {
    return this._signingMethod;
  }

  // signing_name - computed: true, optional: true, required: false
  private _signingName?: string; 
  public get signingName() {
    return this.getStringAttribute('signing_name');
  }
  public set signingName(value: string) {
    this._signingName = value;
  }
  public resetSigningName() {
    this._signingName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signingNameInput() {
    return this._signingName;
  }

  // signing_region - computed: true, optional: true, required: false
  private _signingRegion?: string; 
  public get signingRegion() {
    return this.getStringAttribute('signing_region');
  }
  public set signingRegion(value: string) {
    this._signingRegion = value;
  }
  public resetSigningRegion() {
    this._signingRegion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signingRegionInput() {
    return this._signingRegion;
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}

export class ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideList extends cdktf.ComplexList {
  public internalValue? : ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideOutputReference {
    return new ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterRkeConfigCloudProviderAwsCloudProvider {
  /**
  * global block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#global Cluster#global}
  */
  readonly global?: ClusterRkeConfigCloudProviderAwsCloudProviderGlobal;
  /**
  * service_override block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service_override Cluster#service_override}
  */
  readonly serviceOverride?: ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride[] | cdktf.IResolvable;
}

export function clusterRkeConfigCloudProviderAwsCloudProviderToTerraform(struct?: ClusterRkeConfigCloudProviderAwsCloudProviderOutputReference | ClusterRkeConfigCloudProviderAwsCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    global: clusterRkeConfigCloudProviderAwsCloudProviderGlobalToTerraform(struct!.global),
    service_override: cdktf.listMapper(clusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideToTerraform, true)(struct!.serviceOverride),
  }
}


export function clusterRkeConfigCloudProviderAwsCloudProviderToHclTerraform(struct?: ClusterRkeConfigCloudProviderAwsCloudProviderOutputReference | ClusterRkeConfigCloudProviderAwsCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    global: {
      value: clusterRkeConfigCloudProviderAwsCloudProviderGlobalToHclTerraform(struct!.global),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderAwsCloudProviderGlobalList",
    },
    service_override: {
      value: cdktf.listMapperHcl(clusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideToHclTerraform, true)(struct!.serviceOverride),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderAwsCloudProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderAwsCloudProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._global?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.global = this._global?.internalValue;
    }
    if (this._serviceOverride?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceOverride = this._serviceOverride?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderAwsCloudProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._global.internalValue = undefined;
      this._serviceOverride.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._global.internalValue = value.global;
      this._serviceOverride.internalValue = value.serviceOverride;
    }
  }

  // global - computed: false, optional: true, required: false
  private _global = new ClusterRkeConfigCloudProviderAwsCloudProviderGlobalOutputReference(this, "global");
  public get global() {
    return this._global;
  }
  public putGlobal(value: ClusterRkeConfigCloudProviderAwsCloudProviderGlobal) {
    this._global.internalValue = value;
  }
  public resetGlobal() {
    this._global.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalInput() {
    return this._global.internalValue;
  }

  // service_override - computed: false, optional: true, required: false
  private _serviceOverride = new ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideList(this, "service_override", false);
  public get serviceOverride() {
    return this._serviceOverride;
  }
  public putServiceOverride(value: ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride[] | cdktf.IResolvable) {
    this._serviceOverride.internalValue = value;
  }
  public resetServiceOverride() {
    this._serviceOverride.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceOverrideInput() {
    return this._serviceOverride.internalValue;
  }
}
export interface ClusterRkeConfigCloudProviderAzureCloudProvider {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aad_client_cert_password Cluster#aad_client_cert_password}
  */
  readonly aadClientCertPassword?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aad_client_cert_path Cluster#aad_client_cert_path}
  */
  readonly aadClientCertPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aad_client_id Cluster#aad_client_id}
  */
  readonly aadClientId: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aad_client_secret Cluster#aad_client_secret}
  */
  readonly aadClientSecret: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud Cluster#cloud}
  */
  readonly cloud?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_provider_backoff Cluster#cloud_provider_backoff}
  */
  readonly cloudProviderBackoff?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_provider_backoff_duration Cluster#cloud_provider_backoff_duration}
  */
  readonly cloudProviderBackoffDuration?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_provider_backoff_exponent Cluster#cloud_provider_backoff_exponent}
  */
  readonly cloudProviderBackoffExponent?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_provider_backoff_jitter Cluster#cloud_provider_backoff_jitter}
  */
  readonly cloudProviderBackoffJitter?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_provider_backoff_retries Cluster#cloud_provider_backoff_retries}
  */
  readonly cloudProviderBackoffRetries?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_provider_rate_limit Cluster#cloud_provider_rate_limit}
  */
  readonly cloudProviderRateLimit?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_provider_rate_limit_bucket Cluster#cloud_provider_rate_limit_bucket}
  */
  readonly cloudProviderRateLimitBucket?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_provider_rate_limit_qps Cluster#cloud_provider_rate_limit_qps}
  */
  readonly cloudProviderRateLimitQps?: number;
  /**
  * Load balancer type (basic | standard). Must be standard for auto-scaling
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#load_balancer_sku Cluster#load_balancer_sku}
  */
  readonly loadBalancerSku?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#location Cluster#location}
  */
  readonly location?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#maximum_load_balancer_rule_count Cluster#maximum_load_balancer_rule_count}
  */
  readonly maximumLoadBalancerRuleCount?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#primary_availability_set_name Cluster#primary_availability_set_name}
  */
  readonly primaryAvailabilitySetName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#primary_scale_set_name Cluster#primary_scale_set_name}
  */
  readonly primaryScaleSetName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#resource_group Cluster#resource_group}
  */
  readonly resourceGroup?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#route_table_name Cluster#route_table_name}
  */
  readonly routeTableName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#security_group_name Cluster#security_group_name}
  */
  readonly securityGroupName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#subnet_name Cluster#subnet_name}
  */
  readonly subnetName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#subscription_id Cluster#subscription_id}
  */
  readonly subscriptionId: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tenant_id Cluster#tenant_id}
  */
  readonly tenantId: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#use_instance_metadata Cluster#use_instance_metadata}
  */
  readonly useInstanceMetadata?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#use_managed_identity_extension Cluster#use_managed_identity_extension}
  */
  readonly useManagedIdentityExtension?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vm_type Cluster#vm_type}
  */
  readonly vmType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vnet_name Cluster#vnet_name}
  */
  readonly vnetName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vnet_resource_group Cluster#vnet_resource_group}
  */
  readonly vnetResourceGroup?: string;
}

export function clusterRkeConfigCloudProviderAzureCloudProviderToTerraform(struct?: ClusterRkeConfigCloudProviderAzureCloudProviderOutputReference | ClusterRkeConfigCloudProviderAzureCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aad_client_cert_password: cdktf.stringToTerraform(struct!.aadClientCertPassword),
    aad_client_cert_path: cdktf.stringToTerraform(struct!.aadClientCertPath),
    aad_client_id: cdktf.stringToTerraform(struct!.aadClientId),
    aad_client_secret: cdktf.stringToTerraform(struct!.aadClientSecret),
    cloud: cdktf.stringToTerraform(struct!.cloud),
    cloud_provider_backoff: cdktf.booleanToTerraform(struct!.cloudProviderBackoff),
    cloud_provider_backoff_duration: cdktf.numberToTerraform(struct!.cloudProviderBackoffDuration),
    cloud_provider_backoff_exponent: cdktf.numberToTerraform(struct!.cloudProviderBackoffExponent),
    cloud_provider_backoff_jitter: cdktf.numberToTerraform(struct!.cloudProviderBackoffJitter),
    cloud_provider_backoff_retries: cdktf.numberToTerraform(struct!.cloudProviderBackoffRetries),
    cloud_provider_rate_limit: cdktf.booleanToTerraform(struct!.cloudProviderRateLimit),
    cloud_provider_rate_limit_bucket: cdktf.numberToTerraform(struct!.cloudProviderRateLimitBucket),
    cloud_provider_rate_limit_qps: cdktf.numberToTerraform(struct!.cloudProviderRateLimitQps),
    load_balancer_sku: cdktf.stringToTerraform(struct!.loadBalancerSku),
    location: cdktf.stringToTerraform(struct!.location),
    maximum_load_balancer_rule_count: cdktf.numberToTerraform(struct!.maximumLoadBalancerRuleCount),
    primary_availability_set_name: cdktf.stringToTerraform(struct!.primaryAvailabilitySetName),
    primary_scale_set_name: cdktf.stringToTerraform(struct!.primaryScaleSetName),
    resource_group: cdktf.stringToTerraform(struct!.resourceGroup),
    route_table_name: cdktf.stringToTerraform(struct!.routeTableName),
    security_group_name: cdktf.stringToTerraform(struct!.securityGroupName),
    subnet_name: cdktf.stringToTerraform(struct!.subnetName),
    subscription_id: cdktf.stringToTerraform(struct!.subscriptionId),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    use_instance_metadata: cdktf.booleanToTerraform(struct!.useInstanceMetadata),
    use_managed_identity_extension: cdktf.booleanToTerraform(struct!.useManagedIdentityExtension),
    vm_type: cdktf.stringToTerraform(struct!.vmType),
    vnet_name: cdktf.stringToTerraform(struct!.vnetName),
    vnet_resource_group: cdktf.stringToTerraform(struct!.vnetResourceGroup),
  }
}


export function clusterRkeConfigCloudProviderAzureCloudProviderToHclTerraform(struct?: ClusterRkeConfigCloudProviderAzureCloudProviderOutputReference | ClusterRkeConfigCloudProviderAzureCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aad_client_cert_password: {
      value: cdktf.stringToHclTerraform(struct!.aadClientCertPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aad_client_cert_path: {
      value: cdktf.stringToHclTerraform(struct!.aadClientCertPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aad_client_id: {
      value: cdktf.stringToHclTerraform(struct!.aadClientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aad_client_secret: {
      value: cdktf.stringToHclTerraform(struct!.aadClientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cloud: {
      value: cdktf.stringToHclTerraform(struct!.cloud),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cloud_provider_backoff: {
      value: cdktf.booleanToHclTerraform(struct!.cloudProviderBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    cloud_provider_backoff_duration: {
      value: cdktf.numberToHclTerraform(struct!.cloudProviderBackoffDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    cloud_provider_backoff_exponent: {
      value: cdktf.numberToHclTerraform(struct!.cloudProviderBackoffExponent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    cloud_provider_backoff_jitter: {
      value: cdktf.numberToHclTerraform(struct!.cloudProviderBackoffJitter),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    cloud_provider_backoff_retries: {
      value: cdktf.numberToHclTerraform(struct!.cloudProviderBackoffRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    cloud_provider_rate_limit: {
      value: cdktf.booleanToHclTerraform(struct!.cloudProviderRateLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    cloud_provider_rate_limit_bucket: {
      value: cdktf.numberToHclTerraform(struct!.cloudProviderRateLimitBucket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    cloud_provider_rate_limit_qps: {
      value: cdktf.numberToHclTerraform(struct!.cloudProviderRateLimitQps),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balancer_sku: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancerSku),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location: {
      value: cdktf.stringToHclTerraform(struct!.location),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    maximum_load_balancer_rule_count: {
      value: cdktf.numberToHclTerraform(struct!.maximumLoadBalancerRuleCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    primary_availability_set_name: {
      value: cdktf.stringToHclTerraform(struct!.primaryAvailabilitySetName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    primary_scale_set_name: {
      value: cdktf.stringToHclTerraform(struct!.primaryScaleSetName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_group: {
      value: cdktf.stringToHclTerraform(struct!.resourceGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    route_table_name: {
      value: cdktf.stringToHclTerraform(struct!.routeTableName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    security_group_name: {
      value: cdktf.stringToHclTerraform(struct!.securityGroupName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subnet_name: {
      value: cdktf.stringToHclTerraform(struct!.subnetName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subscription_id: {
      value: cdktf.stringToHclTerraform(struct!.subscriptionId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_instance_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.useInstanceMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    use_managed_identity_extension: {
      value: cdktf.booleanToHclTerraform(struct!.useManagedIdentityExtension),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vm_type: {
      value: cdktf.stringToHclTerraform(struct!.vmType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vnet_name: {
      value: cdktf.stringToHclTerraform(struct!.vnetName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vnet_resource_group: {
      value: cdktf.stringToHclTerraform(struct!.vnetResourceGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderAzureCloudProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderAzureCloudProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aadClientCertPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.aadClientCertPassword = this._aadClientCertPassword;
    }
    if (this._aadClientCertPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.aadClientCertPath = this._aadClientCertPath;
    }
    if (this._aadClientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.aadClientId = this._aadClientId;
    }
    if (this._aadClientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.aadClientSecret = this._aadClientSecret;
    }
    if (this._cloud !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloud = this._cloud;
    }
    if (this._cloudProviderBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProviderBackoff = this._cloudProviderBackoff;
    }
    if (this._cloudProviderBackoffDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProviderBackoffDuration = this._cloudProviderBackoffDuration;
    }
    if (this._cloudProviderBackoffExponent !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProviderBackoffExponent = this._cloudProviderBackoffExponent;
    }
    if (this._cloudProviderBackoffJitter !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProviderBackoffJitter = this._cloudProviderBackoffJitter;
    }
    if (this._cloudProviderBackoffRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProviderBackoffRetries = this._cloudProviderBackoffRetries;
    }
    if (this._cloudProviderRateLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProviderRateLimit = this._cloudProviderRateLimit;
    }
    if (this._cloudProviderRateLimitBucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProviderRateLimitBucket = this._cloudProviderRateLimitBucket;
    }
    if (this._cloudProviderRateLimitQps !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProviderRateLimitQps = this._cloudProviderRateLimitQps;
    }
    if (this._loadBalancerSku !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerSku = this._loadBalancerSku;
    }
    if (this._location !== undefined) {
      hasAnyValues = true;
      internalValueResult.location = this._location;
    }
    if (this._maximumLoadBalancerRuleCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.maximumLoadBalancerRuleCount = this._maximumLoadBalancerRuleCount;
    }
    if (this._primaryAvailabilitySetName !== undefined) {
      hasAnyValues = true;
      internalValueResult.primaryAvailabilitySetName = this._primaryAvailabilitySetName;
    }
    if (this._primaryScaleSetName !== undefined) {
      hasAnyValues = true;
      internalValueResult.primaryScaleSetName = this._primaryScaleSetName;
    }
    if (this._resourceGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceGroup = this._resourceGroup;
    }
    if (this._routeTableName !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTableName = this._routeTableName;
    }
    if (this._securityGroupName !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityGroupName = this._securityGroupName;
    }
    if (this._subnetName !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnetName = this._subnetName;
    }
    if (this._subscriptionId !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscriptionId = this._subscriptionId;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._useInstanceMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.useInstanceMetadata = this._useInstanceMetadata;
    }
    if (this._useManagedIdentityExtension !== undefined) {
      hasAnyValues = true;
      internalValueResult.useManagedIdentityExtension = this._useManagedIdentityExtension;
    }
    if (this._vmType !== undefined) {
      hasAnyValues = true;
      internalValueResult.vmType = this._vmType;
    }
    if (this._vnetName !== undefined) {
      hasAnyValues = true;
      internalValueResult.vnetName = this._vnetName;
    }
    if (this._vnetResourceGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.vnetResourceGroup = this._vnetResourceGroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderAzureCloudProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._aadClientCertPassword = undefined;
      this._aadClientCertPath = undefined;
      this._aadClientId = undefined;
      this._aadClientSecret = undefined;
      this._cloud = undefined;
      this._cloudProviderBackoff = undefined;
      this._cloudProviderBackoffDuration = undefined;
      this._cloudProviderBackoffExponent = undefined;
      this._cloudProviderBackoffJitter = undefined;
      this._cloudProviderBackoffRetries = undefined;
      this._cloudProviderRateLimit = undefined;
      this._cloudProviderRateLimitBucket = undefined;
      this._cloudProviderRateLimitQps = undefined;
      this._loadBalancerSku = undefined;
      this._location = undefined;
      this._maximumLoadBalancerRuleCount = undefined;
      this._primaryAvailabilitySetName = undefined;
      this._primaryScaleSetName = undefined;
      this._resourceGroup = undefined;
      this._routeTableName = undefined;
      this._securityGroupName = undefined;
      this._subnetName = undefined;
      this._subscriptionId = undefined;
      this._tenantId = undefined;
      this._useInstanceMetadata = undefined;
      this._useManagedIdentityExtension = undefined;
      this._vmType = undefined;
      this._vnetName = undefined;
      this._vnetResourceGroup = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._aadClientCertPassword = value.aadClientCertPassword;
      this._aadClientCertPath = value.aadClientCertPath;
      this._aadClientId = value.aadClientId;
      this._aadClientSecret = value.aadClientSecret;
      this._cloud = value.cloud;
      this._cloudProviderBackoff = value.cloudProviderBackoff;
      this._cloudProviderBackoffDuration = value.cloudProviderBackoffDuration;
      this._cloudProviderBackoffExponent = value.cloudProviderBackoffExponent;
      this._cloudProviderBackoffJitter = value.cloudProviderBackoffJitter;
      this._cloudProviderBackoffRetries = value.cloudProviderBackoffRetries;
      this._cloudProviderRateLimit = value.cloudProviderRateLimit;
      this._cloudProviderRateLimitBucket = value.cloudProviderRateLimitBucket;
      this._cloudProviderRateLimitQps = value.cloudProviderRateLimitQps;
      this._loadBalancerSku = value.loadBalancerSku;
      this._location = value.location;
      this._maximumLoadBalancerRuleCount = value.maximumLoadBalancerRuleCount;
      this._primaryAvailabilitySetName = value.primaryAvailabilitySetName;
      this._primaryScaleSetName = value.primaryScaleSetName;
      this._resourceGroup = value.resourceGroup;
      this._routeTableName = value.routeTableName;
      this._securityGroupName = value.securityGroupName;
      this._subnetName = value.subnetName;
      this._subscriptionId = value.subscriptionId;
      this._tenantId = value.tenantId;
      this._useInstanceMetadata = value.useInstanceMetadata;
      this._useManagedIdentityExtension = value.useManagedIdentityExtension;
      this._vmType = value.vmType;
      this._vnetName = value.vnetName;
      this._vnetResourceGroup = value.vnetResourceGroup;
    }
  }

  // aad_client_cert_password - computed: true, optional: true, required: false
  private _aadClientCertPassword?: string; 
  public get aadClientCertPassword() {
    return this.getStringAttribute('aad_client_cert_password');
  }
  public set aadClientCertPassword(value: string) {
    this._aadClientCertPassword = value;
  }
  public resetAadClientCertPassword() {
    this._aadClientCertPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aadClientCertPasswordInput() {
    return this._aadClientCertPassword;
  }

  // aad_client_cert_path - computed: true, optional: true, required: false
  private _aadClientCertPath?: string; 
  public get aadClientCertPath() {
    return this.getStringAttribute('aad_client_cert_path');
  }
  public set aadClientCertPath(value: string) {
    this._aadClientCertPath = value;
  }
  public resetAadClientCertPath() {
    this._aadClientCertPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aadClientCertPathInput() {
    return this._aadClientCertPath;
  }

  // aad_client_id - computed: false, optional: false, required: true
  private _aadClientId?: string; 
  public get aadClientId() {
    return this.getStringAttribute('aad_client_id');
  }
  public set aadClientId(value: string) {
    this._aadClientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get aadClientIdInput() {
    return this._aadClientId;
  }

  // aad_client_secret - computed: false, optional: false, required: true
  private _aadClientSecret?: string; 
  public get aadClientSecret() {
    return this.getStringAttribute('aad_client_secret');
  }
  public set aadClientSecret(value: string) {
    this._aadClientSecret = value;
  }
  // Temporarily expose input value. Use with caution.
  public get aadClientSecretInput() {
    return this._aadClientSecret;
  }

  // cloud - computed: true, optional: true, required: false
  private _cloud?: string; 
  public get cloud() {
    return this.getStringAttribute('cloud');
  }
  public set cloud(value: string) {
    this._cloud = value;
  }
  public resetCloud() {
    this._cloud = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudInput() {
    return this._cloud;
  }

  // cloud_provider_backoff - computed: true, optional: true, required: false
  private _cloudProviderBackoff?: boolean | cdktf.IResolvable; 
  public get cloudProviderBackoff() {
    return this.getBooleanAttribute('cloud_provider_backoff');
  }
  public set cloudProviderBackoff(value: boolean | cdktf.IResolvable) {
    this._cloudProviderBackoff = value;
  }
  public resetCloudProviderBackoff() {
    this._cloudProviderBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderBackoffInput() {
    return this._cloudProviderBackoff;
  }

  // cloud_provider_backoff_duration - computed: true, optional: true, required: false
  private _cloudProviderBackoffDuration?: number; 
  public get cloudProviderBackoffDuration() {
    return this.getNumberAttribute('cloud_provider_backoff_duration');
  }
  public set cloudProviderBackoffDuration(value: number) {
    this._cloudProviderBackoffDuration = value;
  }
  public resetCloudProviderBackoffDuration() {
    this._cloudProviderBackoffDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderBackoffDurationInput() {
    return this._cloudProviderBackoffDuration;
  }

  // cloud_provider_backoff_exponent - computed: true, optional: true, required: false
  private _cloudProviderBackoffExponent?: number; 
  public get cloudProviderBackoffExponent() {
    return this.getNumberAttribute('cloud_provider_backoff_exponent');
  }
  public set cloudProviderBackoffExponent(value: number) {
    this._cloudProviderBackoffExponent = value;
  }
  public resetCloudProviderBackoffExponent() {
    this._cloudProviderBackoffExponent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderBackoffExponentInput() {
    return this._cloudProviderBackoffExponent;
  }

  // cloud_provider_backoff_jitter - computed: true, optional: true, required: false
  private _cloudProviderBackoffJitter?: number; 
  public get cloudProviderBackoffJitter() {
    return this.getNumberAttribute('cloud_provider_backoff_jitter');
  }
  public set cloudProviderBackoffJitter(value: number) {
    this._cloudProviderBackoffJitter = value;
  }
  public resetCloudProviderBackoffJitter() {
    this._cloudProviderBackoffJitter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderBackoffJitterInput() {
    return this._cloudProviderBackoffJitter;
  }

  // cloud_provider_backoff_retries - computed: true, optional: true, required: false
  private _cloudProviderBackoffRetries?: number; 
  public get cloudProviderBackoffRetries() {
    return this.getNumberAttribute('cloud_provider_backoff_retries');
  }
  public set cloudProviderBackoffRetries(value: number) {
    this._cloudProviderBackoffRetries = value;
  }
  public resetCloudProviderBackoffRetries() {
    this._cloudProviderBackoffRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderBackoffRetriesInput() {
    return this._cloudProviderBackoffRetries;
  }

  // cloud_provider_rate_limit - computed: true, optional: true, required: false
  private _cloudProviderRateLimit?: boolean | cdktf.IResolvable; 
  public get cloudProviderRateLimit() {
    return this.getBooleanAttribute('cloud_provider_rate_limit');
  }
  public set cloudProviderRateLimit(value: boolean | cdktf.IResolvable) {
    this._cloudProviderRateLimit = value;
  }
  public resetCloudProviderRateLimit() {
    this._cloudProviderRateLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderRateLimitInput() {
    return this._cloudProviderRateLimit;
  }

  // cloud_provider_rate_limit_bucket - computed: true, optional: true, required: false
  private _cloudProviderRateLimitBucket?: number; 
  public get cloudProviderRateLimitBucket() {
    return this.getNumberAttribute('cloud_provider_rate_limit_bucket');
  }
  public set cloudProviderRateLimitBucket(value: number) {
    this._cloudProviderRateLimitBucket = value;
  }
  public resetCloudProviderRateLimitBucket() {
    this._cloudProviderRateLimitBucket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderRateLimitBucketInput() {
    return this._cloudProviderRateLimitBucket;
  }

  // cloud_provider_rate_limit_qps - computed: true, optional: true, required: false
  private _cloudProviderRateLimitQps?: number; 
  public get cloudProviderRateLimitQps() {
    return this.getNumberAttribute('cloud_provider_rate_limit_qps');
  }
  public set cloudProviderRateLimitQps(value: number) {
    this._cloudProviderRateLimitQps = value;
  }
  public resetCloudProviderRateLimitQps() {
    this._cloudProviderRateLimitQps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderRateLimitQpsInput() {
    return this._cloudProviderRateLimitQps;
  }

  // load_balancer_sku - computed: false, optional: true, required: false
  private _loadBalancerSku?: string; 
  public get loadBalancerSku() {
    return this.getStringAttribute('load_balancer_sku');
  }
  public set loadBalancerSku(value: string) {
    this._loadBalancerSku = value;
  }
  public resetLoadBalancerSku() {
    this._loadBalancerSku = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerSkuInput() {
    return this._loadBalancerSku;
  }

  // location - computed: true, optional: true, required: false
  private _location?: string; 
  public get location() {
    return this.getStringAttribute('location');
  }
  public set location(value: string) {
    this._location = value;
  }
  public resetLocation() {
    this._location = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationInput() {
    return this._location;
  }

  // maximum_load_balancer_rule_count - computed: true, optional: true, required: false
  private _maximumLoadBalancerRuleCount?: number; 
  public get maximumLoadBalancerRuleCount() {
    return this.getNumberAttribute('maximum_load_balancer_rule_count');
  }
  public set maximumLoadBalancerRuleCount(value: number) {
    this._maximumLoadBalancerRuleCount = value;
  }
  public resetMaximumLoadBalancerRuleCount() {
    this._maximumLoadBalancerRuleCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maximumLoadBalancerRuleCountInput() {
    return this._maximumLoadBalancerRuleCount;
  }

  // primary_availability_set_name - computed: true, optional: true, required: false
  private _primaryAvailabilitySetName?: string; 
  public get primaryAvailabilitySetName() {
    return this.getStringAttribute('primary_availability_set_name');
  }
  public set primaryAvailabilitySetName(value: string) {
    this._primaryAvailabilitySetName = value;
  }
  public resetPrimaryAvailabilitySetName() {
    this._primaryAvailabilitySetName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get primaryAvailabilitySetNameInput() {
    return this._primaryAvailabilitySetName;
  }

  // primary_scale_set_name - computed: true, optional: true, required: false
  private _primaryScaleSetName?: string; 
  public get primaryScaleSetName() {
    return this.getStringAttribute('primary_scale_set_name');
  }
  public set primaryScaleSetName(value: string) {
    this._primaryScaleSetName = value;
  }
  public resetPrimaryScaleSetName() {
    this._primaryScaleSetName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get primaryScaleSetNameInput() {
    return this._primaryScaleSetName;
  }

  // resource_group - computed: true, optional: true, required: false
  private _resourceGroup?: string; 
  public get resourceGroup() {
    return this.getStringAttribute('resource_group');
  }
  public set resourceGroup(value: string) {
    this._resourceGroup = value;
  }
  public resetResourceGroup() {
    this._resourceGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceGroupInput() {
    return this._resourceGroup;
  }

  // route_table_name - computed: true, optional: true, required: false
  private _routeTableName?: string; 
  public get routeTableName() {
    return this.getStringAttribute('route_table_name');
  }
  public set routeTableName(value: string) {
    this._routeTableName = value;
  }
  public resetRouteTableName() {
    this._routeTableName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableNameInput() {
    return this._routeTableName;
  }

  // security_group_name - computed: true, optional: true, required: false
  private _securityGroupName?: string; 
  public get securityGroupName() {
    return this.getStringAttribute('security_group_name');
  }
  public set securityGroupName(value: string) {
    this._securityGroupName = value;
  }
  public resetSecurityGroupName() {
    this._securityGroupName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityGroupNameInput() {
    return this._securityGroupName;
  }

  // subnet_name - computed: true, optional: true, required: false
  private _subnetName?: string; 
  public get subnetName() {
    return this.getStringAttribute('subnet_name');
  }
  public set subnetName(value: string) {
    this._subnetName = value;
  }
  public resetSubnetName() {
    this._subnetName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetNameInput() {
    return this._subnetName;
  }

  // subscription_id - computed: false, optional: false, required: true
  private _subscriptionId?: string; 
  public get subscriptionId() {
    return this.getStringAttribute('subscription_id');
  }
  public set subscriptionId(value: string) {
    this._subscriptionId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionIdInput() {
    return this._subscriptionId;
  }

  // tenant_id - computed: false, optional: false, required: true
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // use_instance_metadata - computed: true, optional: true, required: false
  private _useInstanceMetadata?: boolean | cdktf.IResolvable; 
  public get useInstanceMetadata() {
    return this.getBooleanAttribute('use_instance_metadata');
  }
  public set useInstanceMetadata(value: boolean | cdktf.IResolvable) {
    this._useInstanceMetadata = value;
  }
  public resetUseInstanceMetadata() {
    this._useInstanceMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useInstanceMetadataInput() {
    return this._useInstanceMetadata;
  }

  // use_managed_identity_extension - computed: true, optional: true, required: false
  private _useManagedIdentityExtension?: boolean | cdktf.IResolvable; 
  public get useManagedIdentityExtension() {
    return this.getBooleanAttribute('use_managed_identity_extension');
  }
  public set useManagedIdentityExtension(value: boolean | cdktf.IResolvable) {
    this._useManagedIdentityExtension = value;
  }
  public resetUseManagedIdentityExtension() {
    this._useManagedIdentityExtension = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useManagedIdentityExtensionInput() {
    return this._useManagedIdentityExtension;
  }

  // vm_type - computed: true, optional: true, required: false
  private _vmType?: string; 
  public get vmType() {
    return this.getStringAttribute('vm_type');
  }
  public set vmType(value: string) {
    this._vmType = value;
  }
  public resetVmType() {
    this._vmType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vmTypeInput() {
    return this._vmType;
  }

  // vnet_name - computed: true, optional: true, required: false
  private _vnetName?: string; 
  public get vnetName() {
    return this.getStringAttribute('vnet_name');
  }
  public set vnetName(value: string) {
    this._vnetName = value;
  }
  public resetVnetName() {
    this._vnetName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vnetNameInput() {
    return this._vnetName;
  }

  // vnet_resource_group - computed: true, optional: true, required: false
  private _vnetResourceGroup?: string; 
  public get vnetResourceGroup() {
    return this.getStringAttribute('vnet_resource_group');
  }
  public set vnetResourceGroup(value: string) {
    this._vnetResourceGroup = value;
  }
  public resetVnetResourceGroup() {
    this._vnetResourceGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vnetResourceGroupInput() {
    return this._vnetResourceGroup;
  }
}
export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#bs_version Cluster#bs_version}
  */
  readonly bsVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ignore_volume_az Cluster#ignore_volume_az}
  */
  readonly ignoreVolumeAz?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#trust_device_path Cluster#trust_device_path}
  */
  readonly trustDevicePath?: boolean | cdktf.IResolvable;
}

export function clusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageToTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bs_version: cdktf.stringToTerraform(struct!.bsVersion),
    ignore_volume_az: cdktf.booleanToTerraform(struct!.ignoreVolumeAz),
    trust_device_path: cdktf.booleanToTerraform(struct!.trustDevicePath),
  }
}


export function clusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageToHclTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bs_version: {
      value: cdktf.stringToHclTerraform(struct!.bsVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_volume_az: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreVolumeAz),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    trust_device_path: {
      value: cdktf.booleanToHclTerraform(struct!.trustDevicePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bsVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.bsVersion = this._bsVersion;
    }
    if (this._ignoreVolumeAz !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreVolumeAz = this._ignoreVolumeAz;
    }
    if (this._trustDevicePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.trustDevicePath = this._trustDevicePath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bsVersion = undefined;
      this._ignoreVolumeAz = undefined;
      this._trustDevicePath = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bsVersion = value.bsVersion;
      this._ignoreVolumeAz = value.ignoreVolumeAz;
      this._trustDevicePath = value.trustDevicePath;
    }
  }

  // bs_version - computed: true, optional: true, required: false
  private _bsVersion?: string; 
  public get bsVersion() {
    return this.getStringAttribute('bs_version');
  }
  public set bsVersion(value: string) {
    this._bsVersion = value;
  }
  public resetBsVersion() {
    this._bsVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bsVersionInput() {
    return this._bsVersion;
  }

  // ignore_volume_az - computed: true, optional: true, required: false
  private _ignoreVolumeAz?: boolean | cdktf.IResolvable; 
  public get ignoreVolumeAz() {
    return this.getBooleanAttribute('ignore_volume_az');
  }
  public set ignoreVolumeAz(value: boolean | cdktf.IResolvable) {
    this._ignoreVolumeAz = value;
  }
  public resetIgnoreVolumeAz() {
    this._ignoreVolumeAz = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreVolumeAzInput() {
    return this._ignoreVolumeAz;
  }

  // trust_device_path - computed: true, optional: true, required: false
  private _trustDevicePath?: boolean | cdktf.IResolvable; 
  public get trustDevicePath() {
    return this.getBooleanAttribute('trust_device_path');
  }
  public set trustDevicePath(value: boolean | cdktf.IResolvable) {
    this._trustDevicePath = value;
  }
  public resetTrustDevicePath() {
    this._trustDevicePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trustDevicePathInput() {
    return this._trustDevicePath;
  }
}
export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#auth_url Cluster#auth_url}
  */
  readonly authUrl: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ca_file Cluster#ca_file}
  */
  readonly caFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#domain_id Cluster#domain_id}
  */
  readonly domainId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#domain_name Cluster#domain_name}
  */
  readonly domainName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#password Cluster#password}
  */
  readonly password: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#region Cluster#region}
  */
  readonly region?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tenant_id Cluster#tenant_id}
  */
  readonly tenantId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tenant_name Cluster#tenant_name}
  */
  readonly tenantName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#trust_id Cluster#trust_id}
  */
  readonly trustId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#username Cluster#username}
  */
  readonly username: string;
}

export function clusterRkeConfigCloudProviderOpenstackCloudProviderGlobalToTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_url: cdktf.stringToTerraform(struct!.authUrl),
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    domain_id: cdktf.stringToTerraform(struct!.domainId),
    domain_name: cdktf.stringToTerraform(struct!.domainName),
    password: cdktf.stringToTerraform(struct!.password),
    region: cdktf.stringToTerraform(struct!.region),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    tenant_name: cdktf.stringToTerraform(struct!.tenantName),
    trust_id: cdktf.stringToTerraform(struct!.trustId),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function clusterRkeConfigCloudProviderOpenstackCloudProviderGlobalToHclTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_url: {
      value: cdktf.stringToHclTerraform(struct!.authUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    domain_id: {
      value: cdktf.stringToHclTerraform(struct!.domainId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    domain_name: {
      value: cdktf.stringToHclTerraform(struct!.domainName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tenant_name: {
      value: cdktf.stringToHclTerraform(struct!.tenantName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trust_id: {
      value: cdktf.stringToHclTerraform(struct!.trustId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.authUrl = this._authUrl;
    }
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._domainId !== undefined) {
      hasAnyValues = true;
      internalValueResult.domainId = this._domainId;
    }
    if (this._domainName !== undefined) {
      hasAnyValues = true;
      internalValueResult.domainName = this._domainName;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._tenantName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantName = this._tenantName;
    }
    if (this._trustId !== undefined) {
      hasAnyValues = true;
      internalValueResult.trustId = this._trustId;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authUrl = undefined;
      this._caFile = undefined;
      this._domainId = undefined;
      this._domainName = undefined;
      this._password = undefined;
      this._region = undefined;
      this._tenantId = undefined;
      this._tenantName = undefined;
      this._trustId = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authUrl = value.authUrl;
      this._caFile = value.caFile;
      this._domainId = value.domainId;
      this._domainName = value.domainName;
      this._password = value.password;
      this._region = value.region;
      this._tenantId = value.tenantId;
      this._tenantName = value.tenantName;
      this._trustId = value.trustId;
      this._username = value.username;
    }
  }

  // auth_url - computed: false, optional: false, required: true
  private _authUrl?: string; 
  public get authUrl() {
    return this.getStringAttribute('auth_url');
  }
  public set authUrl(value: string) {
    this._authUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authUrlInput() {
    return this._authUrl;
  }

  // ca_file - computed: true, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // domain_id - computed: true, optional: true, required: false
  private _domainId?: string; 
  public get domainId() {
    return this.getStringAttribute('domain_id');
  }
  public set domainId(value: string) {
    this._domainId = value;
  }
  public resetDomainId() {
    this._domainId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainIdInput() {
    return this._domainId;
  }

  // domain_name - computed: true, optional: true, required: false
  private _domainName?: string; 
  public get domainName() {
    return this.getStringAttribute('domain_name');
  }
  public set domainName(value: string) {
    this._domainName = value;
  }
  public resetDomainName() {
    this._domainName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainNameInput() {
    return this._domainName;
  }

  // password - computed: false, optional: false, required: true
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // region - computed: true, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // tenant_id - computed: true, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // tenant_name - computed: true, optional: true, required: false
  private _tenantName?: string; 
  public get tenantName() {
    return this.getStringAttribute('tenant_name');
  }
  public set tenantName(value: string) {
    this._tenantName = value;
  }
  public resetTenantName() {
    this._tenantName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantNameInput() {
    return this._tenantName;
  }

  // trust_id - computed: true, optional: true, required: false
  private _trustId?: string; 
  public get trustId() {
    return this.getStringAttribute('trust_id');
  }
  public set trustId(value: string) {
    this._trustId = value;
  }
  public resetTrustId() {
    this._trustId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trustIdInput() {
    return this._trustId;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#create_monitor Cluster#create_monitor}
  */
  readonly createMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#floating_network_id Cluster#floating_network_id}
  */
  readonly floatingNetworkId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#lb_method Cluster#lb_method}
  */
  readonly lbMethod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#lb_provider Cluster#lb_provider}
  */
  readonly lbProvider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#lb_version Cluster#lb_version}
  */
  readonly lbVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#manage_security_groups Cluster#manage_security_groups}
  */
  readonly manageSecurityGroups?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#monitor_delay Cluster#monitor_delay}
  */
  readonly monitorDelay?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#monitor_max_retries Cluster#monitor_max_retries}
  */
  readonly monitorMaxRetries?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#monitor_timeout Cluster#monitor_timeout}
  */
  readonly monitorTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#subnet_id Cluster#subnet_id}
  */
  readonly subnetId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#use_octavia Cluster#use_octavia}
  */
  readonly useOctavia?: boolean | cdktf.IResolvable;
}

export function clusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerToTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    create_monitor: cdktf.booleanToTerraform(struct!.createMonitor),
    floating_network_id: cdktf.stringToTerraform(struct!.floatingNetworkId),
    lb_method: cdktf.stringToTerraform(struct!.lbMethod),
    lb_provider: cdktf.stringToTerraform(struct!.lbProvider),
    lb_version: cdktf.stringToTerraform(struct!.lbVersion),
    manage_security_groups: cdktf.booleanToTerraform(struct!.manageSecurityGroups),
    monitor_delay: cdktf.stringToTerraform(struct!.monitorDelay),
    monitor_max_retries: cdktf.numberToTerraform(struct!.monitorMaxRetries),
    monitor_timeout: cdktf.stringToTerraform(struct!.monitorTimeout),
    subnet_id: cdktf.stringToTerraform(struct!.subnetId),
    use_octavia: cdktf.booleanToTerraform(struct!.useOctavia),
  }
}


export function clusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerToHclTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    create_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.createMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    floating_network_id: {
      value: cdktf.stringToHclTerraform(struct!.floatingNetworkId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lb_method: {
      value: cdktf.stringToHclTerraform(struct!.lbMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lb_provider: {
      value: cdktf.stringToHclTerraform(struct!.lbProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lb_version: {
      value: cdktf.stringToHclTerraform(struct!.lbVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    manage_security_groups: {
      value: cdktf.booleanToHclTerraform(struct!.manageSecurityGroups),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitor_delay: {
      value: cdktf.stringToHclTerraform(struct!.monitorDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    monitor_max_retries: {
      value: cdktf.numberToHclTerraform(struct!.monitorMaxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    monitor_timeout: {
      value: cdktf.stringToHclTerraform(struct!.monitorTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subnet_id: {
      value: cdktf.stringToHclTerraform(struct!.subnetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_octavia: {
      value: cdktf.booleanToHclTerraform(struct!.useOctavia),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._createMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.createMonitor = this._createMonitor;
    }
    if (this._floatingNetworkId !== undefined) {
      hasAnyValues = true;
      internalValueResult.floatingNetworkId = this._floatingNetworkId;
    }
    if (this._lbMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.lbMethod = this._lbMethod;
    }
    if (this._lbProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.lbProvider = this._lbProvider;
    }
    if (this._lbVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.lbVersion = this._lbVersion;
    }
    if (this._manageSecurityGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.manageSecurityGroups = this._manageSecurityGroups;
    }
    if (this._monitorDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitorDelay = this._monitorDelay;
    }
    if (this._monitorMaxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitorMaxRetries = this._monitorMaxRetries;
    }
    if (this._monitorTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitorTimeout = this._monitorTimeout;
    }
    if (this._subnetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnetId = this._subnetId;
    }
    if (this._useOctavia !== undefined) {
      hasAnyValues = true;
      internalValueResult.useOctavia = this._useOctavia;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._createMonitor = undefined;
      this._floatingNetworkId = undefined;
      this._lbMethod = undefined;
      this._lbProvider = undefined;
      this._lbVersion = undefined;
      this._manageSecurityGroups = undefined;
      this._monitorDelay = undefined;
      this._monitorMaxRetries = undefined;
      this._monitorTimeout = undefined;
      this._subnetId = undefined;
      this._useOctavia = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._createMonitor = value.createMonitor;
      this._floatingNetworkId = value.floatingNetworkId;
      this._lbMethod = value.lbMethod;
      this._lbProvider = value.lbProvider;
      this._lbVersion = value.lbVersion;
      this._manageSecurityGroups = value.manageSecurityGroups;
      this._monitorDelay = value.monitorDelay;
      this._monitorMaxRetries = value.monitorMaxRetries;
      this._monitorTimeout = value.monitorTimeout;
      this._subnetId = value.subnetId;
      this._useOctavia = value.useOctavia;
    }
  }

  // create_monitor - computed: true, optional: true, required: false
  private _createMonitor?: boolean | cdktf.IResolvable; 
  public get createMonitor() {
    return this.getBooleanAttribute('create_monitor');
  }
  public set createMonitor(value: boolean | cdktf.IResolvable) {
    this._createMonitor = value;
  }
  public resetCreateMonitor() {
    this._createMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createMonitorInput() {
    return this._createMonitor;
  }

  // floating_network_id - computed: true, optional: true, required: false
  private _floatingNetworkId?: string; 
  public get floatingNetworkId() {
    return this.getStringAttribute('floating_network_id');
  }
  public set floatingNetworkId(value: string) {
    this._floatingNetworkId = value;
  }
  public resetFloatingNetworkId() {
    this._floatingNetworkId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get floatingNetworkIdInput() {
    return this._floatingNetworkId;
  }

  // lb_method - computed: true, optional: true, required: false
  private _lbMethod?: string; 
  public get lbMethod() {
    return this.getStringAttribute('lb_method');
  }
  public set lbMethod(value: string) {
    this._lbMethod = value;
  }
  public resetLbMethod() {
    this._lbMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lbMethodInput() {
    return this._lbMethod;
  }

  // lb_provider - computed: true, optional: true, required: false
  private _lbProvider?: string; 
  public get lbProvider() {
    return this.getStringAttribute('lb_provider');
  }
  public set lbProvider(value: string) {
    this._lbProvider = value;
  }
  public resetLbProvider() {
    this._lbProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lbProviderInput() {
    return this._lbProvider;
  }

  // lb_version - computed: true, optional: true, required: false
  private _lbVersion?: string; 
  public get lbVersion() {
    return this.getStringAttribute('lb_version');
  }
  public set lbVersion(value: string) {
    this._lbVersion = value;
  }
  public resetLbVersion() {
    this._lbVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lbVersionInput() {
    return this._lbVersion;
  }

  // manage_security_groups - computed: true, optional: true, required: false
  private _manageSecurityGroups?: boolean | cdktf.IResolvable; 
  public get manageSecurityGroups() {
    return this.getBooleanAttribute('manage_security_groups');
  }
  public set manageSecurityGroups(value: boolean | cdktf.IResolvable) {
    this._manageSecurityGroups = value;
  }
  public resetManageSecurityGroups() {
    this._manageSecurityGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get manageSecurityGroupsInput() {
    return this._manageSecurityGroups;
  }

  // monitor_delay - computed: false, optional: true, required: false
  private _monitorDelay?: string; 
  public get monitorDelay() {
    return this.getStringAttribute('monitor_delay');
  }
  public set monitorDelay(value: string) {
    this._monitorDelay = value;
  }
  public resetMonitorDelay() {
    this._monitorDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitorDelayInput() {
    return this._monitorDelay;
  }

  // monitor_max_retries - computed: false, optional: true, required: false
  private _monitorMaxRetries?: number; 
  public get monitorMaxRetries() {
    return this.getNumberAttribute('monitor_max_retries');
  }
  public set monitorMaxRetries(value: number) {
    this._monitorMaxRetries = value;
  }
  public resetMonitorMaxRetries() {
    this._monitorMaxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitorMaxRetriesInput() {
    return this._monitorMaxRetries;
  }

  // monitor_timeout - computed: false, optional: true, required: false
  private _monitorTimeout?: string; 
  public get monitorTimeout() {
    return this.getStringAttribute('monitor_timeout');
  }
  public set monitorTimeout(value: string) {
    this._monitorTimeout = value;
  }
  public resetMonitorTimeout() {
    this._monitorTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitorTimeoutInput() {
    return this._monitorTimeout;
  }

  // subnet_id - computed: true, optional: true, required: false
  private _subnetId?: string; 
  public get subnetId() {
    return this.getStringAttribute('subnet_id');
  }
  public set subnetId(value: string) {
    this._subnetId = value;
  }
  public resetSubnetId() {
    this._subnetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetIdInput() {
    return this._subnetId;
  }

  // use_octavia - computed: true, optional: true, required: false
  private _useOctavia?: boolean | cdktf.IResolvable; 
  public get useOctavia() {
    return this.getBooleanAttribute('use_octavia');
  }
  public set useOctavia(value: boolean | cdktf.IResolvable) {
    this._useOctavia = value;
  }
  public resetUseOctavia() {
    this._useOctavia = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useOctaviaInput() {
    return this._useOctavia;
  }
}
export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#request_timeout Cluster#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#search_order Cluster#search_order}
  */
  readonly searchOrder?: string;
}

export function clusterRkeConfigCloudProviderOpenstackCloudProviderMetadataToTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    search_order: cdktf.stringToTerraform(struct!.searchOrder),
  }
}


export function clusterRkeConfigCloudProviderOpenstackCloudProviderMetadataToHclTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    search_order: {
      value: cdktf.stringToHclTerraform(struct!.searchOrder),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._searchOrder !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchOrder = this._searchOrder;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._requestTimeout = undefined;
      this._searchOrder = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._requestTimeout = value.requestTimeout;
      this._searchOrder = value.searchOrder;
    }
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // search_order - computed: true, optional: true, required: false
  private _searchOrder?: string; 
  public get searchOrder() {
    return this.getStringAttribute('search_order');
  }
  public set searchOrder(value: string) {
    this._searchOrder = value;
  }
  public resetSearchOrder() {
    this._searchOrder = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchOrderInput() {
    return this._searchOrder;
  }
}
export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#router_id Cluster#router_id}
  */
  readonly routerId?: string;
}

export function clusterRkeConfigCloudProviderOpenstackCloudProviderRouteToTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    router_id: cdktf.stringToTerraform(struct!.routerId),
  }
}


export function clusterRkeConfigCloudProviderOpenstackCloudProviderRouteToHclTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._routerId = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._routerId = value.routerId;
    }
  }

  // router_id - computed: true, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }
}
export interface ClusterRkeConfigCloudProviderOpenstackCloudProvider {
  /**
  * block_storage block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#block_storage Cluster#block_storage}
  */
  readonly blockStorage?: ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
  /**
  * global block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#global Cluster#global}
  */
  readonly global: ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal;
  /**
  * load_balancer block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#load_balancer Cluster#load_balancer}
  */
  readonly loadBalancer?: ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
  /**
  * metadata block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#metadata Cluster#metadata}
  */
  readonly metadata?: ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata;
  /**
  * route block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#route Cluster#route}
  */
  readonly route?: ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export function clusterRkeConfigCloudProviderOpenstackCloudProviderToTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block_storage: clusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageToTerraform(struct!.blockStorage),
    global: clusterRkeConfigCloudProviderOpenstackCloudProviderGlobalToTerraform(struct!.global),
    load_balancer: clusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerToTerraform(struct!.loadBalancer),
    metadata: clusterRkeConfigCloudProviderOpenstackCloudProviderMetadataToTerraform(struct!.metadata),
    route: clusterRkeConfigCloudProviderOpenstackCloudProviderRouteToTerraform(struct!.route),
  }
}


export function clusterRkeConfigCloudProviderOpenstackCloudProviderToHclTerraform(struct?: ClusterRkeConfigCloudProviderOpenstackCloudProviderOutputReference | ClusterRkeConfigCloudProviderOpenstackCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block_storage: {
      value: clusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageToHclTerraform(struct!.blockStorage),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageList",
    },
    global: {
      value: clusterRkeConfigCloudProviderOpenstackCloudProviderGlobalToHclTerraform(struct!.global),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalList",
    },
    load_balancer: {
      value: clusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerToHclTerraform(struct!.loadBalancer),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerList",
    },
    metadata: {
      value: clusterRkeConfigCloudProviderOpenstackCloudProviderMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataList",
    },
    route: {
      value: clusterRkeConfigCloudProviderOpenstackCloudProviderRouteToHclTerraform(struct!.route),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderOpenstackCloudProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderOpenstackCloudProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._blockStorage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blockStorage = this._blockStorage?.internalValue;
    }
    if (this._global?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.global = this._global?.internalValue;
    }
    if (this._loadBalancer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancer = this._loadBalancer?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._route?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.route = this._route?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderOpenstackCloudProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._blockStorage.internalValue = undefined;
      this._global.internalValue = undefined;
      this._loadBalancer.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._route.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._blockStorage.internalValue = value.blockStorage;
      this._global.internalValue = value.global;
      this._loadBalancer.internalValue = value.loadBalancer;
      this._metadata.internalValue = value.metadata;
      this._route.internalValue = value.route;
    }
  }

  // block_storage - computed: false, optional: true, required: false
  private _blockStorage = new ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageOutputReference(this, "block_storage");
  public get blockStorage() {
    return this._blockStorage;
  }
  public putBlockStorage(value: ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage) {
    this._blockStorage.internalValue = value;
  }
  public resetBlockStorage() {
    this._blockStorage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockStorageInput() {
    return this._blockStorage.internalValue;
  }

  // global - computed: false, optional: false, required: true
  private _global = new ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalOutputReference(this, "global");
  public get global() {
    return this._global;
  }
  public putGlobal(value: ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal) {
    this._global.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get globalInput() {
    return this._global.internalValue;
  }

  // load_balancer - computed: false, optional: true, required: false
  private _loadBalancer = new ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerOutputReference(this, "load_balancer");
  public get loadBalancer() {
    return this._loadBalancer;
  }
  public putLoadBalancer(value: ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer) {
    this._loadBalancer.internalValue = value;
  }
  public resetLoadBalancer() {
    this._loadBalancer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerInput() {
    return this._loadBalancer.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // route - computed: false, optional: true, required: false
  private _route = new ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteOutputReference(this, "route");
  public get route() {
    return this._route;
  }
  public putRoute(value: ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute) {
    this._route.internalValue = value;
  }
  public resetRoute() {
    this._route.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeInput() {
    return this._route.internalValue;
  }
}
export interface ClusterRkeConfigCloudProviderVsphereCloudProviderDisk {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#scsi_controller_type Cluster#scsi_controller_type}
  */
  readonly scsiControllerType?: string;
}

export function clusterRkeConfigCloudProviderVsphereCloudProviderDiskToTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderDiskOutputReference | ClusterRkeConfigCloudProviderVsphereCloudProviderDisk): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    scsi_controller_type: cdktf.stringToTerraform(struct!.scsiControllerType),
  }
}


export function clusterRkeConfigCloudProviderVsphereCloudProviderDiskToHclTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderDiskOutputReference | ClusterRkeConfigCloudProviderVsphereCloudProviderDisk): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    scsi_controller_type: {
      value: cdktf.stringToHclTerraform(struct!.scsiControllerType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderVsphereCloudProviderDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderVsphereCloudProviderDisk | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._scsiControllerType !== undefined) {
      hasAnyValues = true;
      internalValueResult.scsiControllerType = this._scsiControllerType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderVsphereCloudProviderDisk | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._scsiControllerType = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._scsiControllerType = value.scsiControllerType;
    }
  }

  // scsi_controller_type - computed: true, optional: true, required: false
  private _scsiControllerType?: string; 
  public get scsiControllerType() {
    return this.getStringAttribute('scsi_controller_type');
  }
  public set scsiControllerType(value: string) {
    this._scsiControllerType = value;
  }
  public resetScsiControllerType() {
    this._scsiControllerType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scsiControllerTypeInput() {
    return this._scsiControllerType;
  }
}
export interface ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#datacenters Cluster#datacenters}
  */
  readonly datacenters?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#graceful_shutdown_timeout Cluster#graceful_shutdown_timeout}
  */
  readonly gracefulShutdownTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#insecure_flag Cluster#insecure_flag}
  */
  readonly insecureFlag?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#password Cluster#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#port Cluster#port}
  */
  readonly port?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#soap_roundtrip_count Cluster#soap_roundtrip_count}
  */
  readonly soapRoundtripCount?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#user Cluster#user}
  */
  readonly user?: string;
}

export function clusterRkeConfigCloudProviderVsphereCloudProviderGlobalToTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalOutputReference | ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    datacenters: cdktf.stringToTerraform(struct!.datacenters),
    graceful_shutdown_timeout: cdktf.stringToTerraform(struct!.gracefulShutdownTimeout),
    insecure_flag: cdktf.booleanToTerraform(struct!.insecureFlag),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.stringToTerraform(struct!.port),
    soap_roundtrip_count: cdktf.numberToTerraform(struct!.soapRoundtripCount),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function clusterRkeConfigCloudProviderVsphereCloudProviderGlobalToHclTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalOutputReference | ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    datacenters: {
      value: cdktf.stringToHclTerraform(struct!.datacenters),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    graceful_shutdown_timeout: {
      value: cdktf.stringToHclTerraform(struct!.gracefulShutdownTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure_flag: {
      value: cdktf.booleanToHclTerraform(struct!.insecureFlag),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    soap_roundtrip_count: {
      value: cdktf.numberToHclTerraform(struct!.soapRoundtripCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._datacenters !== undefined) {
      hasAnyValues = true;
      internalValueResult.datacenters = this._datacenters;
    }
    if (this._gracefulShutdownTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.gracefulShutdownTimeout = this._gracefulShutdownTimeout;
    }
    if (this._insecureFlag !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureFlag = this._insecureFlag;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._soapRoundtripCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.soapRoundtripCount = this._soapRoundtripCount;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._datacenters = undefined;
      this._gracefulShutdownTimeout = undefined;
      this._insecureFlag = undefined;
      this._password = undefined;
      this._port = undefined;
      this._soapRoundtripCount = undefined;
      this._user = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._datacenters = value.datacenters;
      this._gracefulShutdownTimeout = value.gracefulShutdownTimeout;
      this._insecureFlag = value.insecureFlag;
      this._password = value.password;
      this._port = value.port;
      this._soapRoundtripCount = value.soapRoundtripCount;
      this._user = value.user;
    }
  }

  // datacenters - computed: true, optional: true, required: false
  private _datacenters?: string; 
  public get datacenters() {
    return this.getStringAttribute('datacenters');
  }
  public set datacenters(value: string) {
    this._datacenters = value;
  }
  public resetDatacenters() {
    this._datacenters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datacentersInput() {
    return this._datacenters;
  }

  // graceful_shutdown_timeout - computed: false, optional: true, required: false
  private _gracefulShutdownTimeout?: string; 
  public get gracefulShutdownTimeout() {
    return this.getStringAttribute('graceful_shutdown_timeout');
  }
  public set gracefulShutdownTimeout(value: string) {
    this._gracefulShutdownTimeout = value;
  }
  public resetGracefulShutdownTimeout() {
    this._gracefulShutdownTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gracefulShutdownTimeoutInput() {
    return this._gracefulShutdownTimeout;
  }

  // insecure_flag - computed: true, optional: true, required: false
  private _insecureFlag?: boolean | cdktf.IResolvable; 
  public get insecureFlag() {
    return this.getBooleanAttribute('insecure_flag');
  }
  public set insecureFlag(value: boolean | cdktf.IResolvable) {
    this._insecureFlag = value;
  }
  public resetInsecureFlag() {
    this._insecureFlag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureFlagInput() {
    return this._insecureFlag;
  }

  // password - computed: true, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: true, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // soap_roundtrip_count - computed: true, optional: true, required: false
  private _soapRoundtripCount?: number; 
  public get soapRoundtripCount() {
    return this.getNumberAttribute('soap_roundtrip_count');
  }
  public set soapRoundtripCount(value: number) {
    this._soapRoundtripCount = value;
  }
  public resetSoapRoundtripCount() {
    this._soapRoundtripCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get soapRoundtripCountInput() {
    return this._soapRoundtripCount;
  }

  // user - computed: true, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#public_network Cluster#public_network}
  */
  readonly publicNetwork?: string;
}

export function clusterRkeConfigCloudProviderVsphereCloudProviderNetworkToTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkOutputReference | ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    public_network: cdktf.stringToTerraform(struct!.publicNetwork),
  }
}


export function clusterRkeConfigCloudProviderVsphereCloudProviderNetworkToHclTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkOutputReference | ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    public_network: {
      value: cdktf.stringToHclTerraform(struct!.publicNetwork),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._publicNetwork !== undefined) {
      hasAnyValues = true;
      internalValueResult.publicNetwork = this._publicNetwork;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._publicNetwork = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._publicNetwork = value.publicNetwork;
    }
  }

  // public_network - computed: true, optional: true, required: false
  private _publicNetwork?: string; 
  public get publicNetwork() {
    return this.getStringAttribute('public_network');
  }
  public set publicNetwork(value: string) {
    this._publicNetwork = value;
  }
  public resetPublicNetwork() {
    this._publicNetwork = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publicNetworkInput() {
    return this._publicNetwork;
  }
}
export interface ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#datacenters Cluster#datacenters}
  */
  readonly datacenters: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#password Cluster#password}
  */
  readonly password: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#port Cluster#port}
  */
  readonly port?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#soap_roundtrip_count Cluster#soap_roundtrip_count}
  */
  readonly soapRoundtripCount?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#user Cluster#user}
  */
  readonly user: string;
}

export function clusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterToTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    datacenters: cdktf.stringToTerraform(struct!.datacenters),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.stringToTerraform(struct!.port),
    soap_roundtrip_count: cdktf.numberToTerraform(struct!.soapRoundtripCount),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function clusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterToHclTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    datacenters: {
      value: cdktf.stringToHclTerraform(struct!.datacenters),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    soap_roundtrip_count: {
      value: cdktf.numberToHclTerraform(struct!.soapRoundtripCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._datacenters !== undefined) {
      hasAnyValues = true;
      internalValueResult.datacenters = this._datacenters;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._soapRoundtripCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.soapRoundtripCount = this._soapRoundtripCount;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._datacenters = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._soapRoundtripCount = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._datacenters = value.datacenters;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._soapRoundtripCount = value.soapRoundtripCount;
      this._user = value.user;
    }
  }

  // datacenters - computed: false, optional: false, required: true
  private _datacenters?: string; 
  public get datacenters() {
    return this.getStringAttribute('datacenters');
  }
  public set datacenters(value: string) {
    this._datacenters = value;
  }
  // Temporarily expose input value. Use with caution.
  public get datacentersInput() {
    return this._datacenters;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: false, required: true
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: true, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // soap_roundtrip_count - computed: true, optional: true, required: false
  private _soapRoundtripCount?: number; 
  public get soapRoundtripCount() {
    return this.getNumberAttribute('soap_roundtrip_count');
  }
  public set soapRoundtripCount(value: number) {
    this._soapRoundtripCount = value;
  }
  public resetSoapRoundtripCount() {
    this._soapRoundtripCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get soapRoundtripCountInput() {
    return this._soapRoundtripCount;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}

export class ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterList extends cdktf.ComplexList {
  public internalValue? : ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterOutputReference {
    return new ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#datacenter Cluster#datacenter}
  */
  readonly datacenter: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#default_datastore Cluster#default_datastore}
  */
  readonly defaultDatastore?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#folder Cluster#folder}
  */
  readonly folder: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#resourcepool_path Cluster#resourcepool_path}
  */
  readonly resourcepoolPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#server Cluster#server}
  */
  readonly server: string;
}

export function clusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceToTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceOutputReference | ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    datacenter: cdktf.stringToTerraform(struct!.datacenter),
    default_datastore: cdktf.stringToTerraform(struct!.defaultDatastore),
    folder: cdktf.stringToTerraform(struct!.folder),
    resourcepool_path: cdktf.stringToTerraform(struct!.resourcepoolPath),
    server: cdktf.stringToTerraform(struct!.server),
  }
}


export function clusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceToHclTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceOutputReference | ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    datacenter: {
      value: cdktf.stringToHclTerraform(struct!.datacenter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_datastore: {
      value: cdktf.stringToHclTerraform(struct!.defaultDatastore),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    folder: {
      value: cdktf.stringToHclTerraform(struct!.folder),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resourcepool_path: {
      value: cdktf.stringToHclTerraform(struct!.resourcepoolPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server: {
      value: cdktf.stringToHclTerraform(struct!.server),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._datacenter !== undefined) {
      hasAnyValues = true;
      internalValueResult.datacenter = this._datacenter;
    }
    if (this._defaultDatastore !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultDatastore = this._defaultDatastore;
    }
    if (this._folder !== undefined) {
      hasAnyValues = true;
      internalValueResult.folder = this._folder;
    }
    if (this._resourcepoolPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourcepoolPath = this._resourcepoolPath;
    }
    if (this._server !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._datacenter = undefined;
      this._defaultDatastore = undefined;
      this._folder = undefined;
      this._resourcepoolPath = undefined;
      this._server = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._datacenter = value.datacenter;
      this._defaultDatastore = value.defaultDatastore;
      this._folder = value.folder;
      this._resourcepoolPath = value.resourcepoolPath;
      this._server = value.server;
    }
  }

  // datacenter - computed: false, optional: false, required: true
  private _datacenter?: string; 
  public get datacenter() {
    return this.getStringAttribute('datacenter');
  }
  public set datacenter(value: string) {
    this._datacenter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get datacenterInput() {
    return this._datacenter;
  }

  // default_datastore - computed: true, optional: true, required: false
  private _defaultDatastore?: string; 
  public get defaultDatastore() {
    return this.getStringAttribute('default_datastore');
  }
  public set defaultDatastore(value: string) {
    this._defaultDatastore = value;
  }
  public resetDefaultDatastore() {
    this._defaultDatastore = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultDatastoreInput() {
    return this._defaultDatastore;
  }

  // folder - computed: false, optional: false, required: true
  private _folder?: string; 
  public get folder() {
    return this.getStringAttribute('folder');
  }
  public set folder(value: string) {
    this._folder = value;
  }
  // Temporarily expose input value. Use with caution.
  public get folderInput() {
    return this._folder;
  }

  // resourcepool_path - computed: true, optional: true, required: false
  private _resourcepoolPath?: string; 
  public get resourcepoolPath() {
    return this.getStringAttribute('resourcepool_path');
  }
  public set resourcepoolPath(value: string) {
    this._resourcepoolPath = value;
  }
  public resetResourcepoolPath() {
    this._resourcepoolPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcepoolPathInput() {
    return this._resourcepoolPath;
  }

  // server - computed: false, optional: false, required: true
  private _server?: string; 
  public get server() {
    return this.getStringAttribute('server');
  }
  public set server(value: string) {
    this._server = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server;
  }
}
export interface ClusterRkeConfigCloudProviderVsphereCloudProvider {
  /**
  * disk block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#disk Cluster#disk}
  */
  readonly disk?: ClusterRkeConfigCloudProviderVsphereCloudProviderDisk;
  /**
  * global block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#global Cluster#global}
  */
  readonly global?: ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal;
  /**
  * network block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network Cluster#network}
  */
  readonly network?: ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork;
  /**
  * virtual_center block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#virtual_center Cluster#virtual_center}
  */
  readonly virtualCenter: ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[] | cdktf.IResolvable;
  /**
  * workspace block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#workspace Cluster#workspace}
  */
  readonly workspace: ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export function clusterRkeConfigCloudProviderVsphereCloudProviderToTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderOutputReference | ClusterRkeConfigCloudProviderVsphereCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disk: clusterRkeConfigCloudProviderVsphereCloudProviderDiskToTerraform(struct!.disk),
    global: clusterRkeConfigCloudProviderVsphereCloudProviderGlobalToTerraform(struct!.global),
    network: clusterRkeConfigCloudProviderVsphereCloudProviderNetworkToTerraform(struct!.network),
    virtual_center: cdktf.listMapper(clusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterToTerraform, true)(struct!.virtualCenter),
    workspace: clusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceToTerraform(struct!.workspace),
  }
}


export function clusterRkeConfigCloudProviderVsphereCloudProviderToHclTerraform(struct?: ClusterRkeConfigCloudProviderVsphereCloudProviderOutputReference | ClusterRkeConfigCloudProviderVsphereCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disk: {
      value: clusterRkeConfigCloudProviderVsphereCloudProviderDiskToHclTerraform(struct!.disk),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderVsphereCloudProviderDiskList",
    },
    global: {
      value: clusterRkeConfigCloudProviderVsphereCloudProviderGlobalToHclTerraform(struct!.global),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalList",
    },
    network: {
      value: clusterRkeConfigCloudProviderVsphereCloudProviderNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkList",
    },
    virtual_center: {
      value: cdktf.listMapperHcl(clusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterToHclTerraform, true)(struct!.virtualCenter),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterList",
    },
    workspace: {
      value: clusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceToHclTerraform(struct!.workspace),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderVsphereCloudProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProviderVsphereCloudProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disk = this._disk?.internalValue;
    }
    if (this._global?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.global = this._global?.internalValue;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._virtualCenter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualCenter = this._virtualCenter?.internalValue;
    }
    if (this._workspace?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspace = this._workspace?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProviderVsphereCloudProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._disk.internalValue = undefined;
      this._global.internalValue = undefined;
      this._network.internalValue = undefined;
      this._virtualCenter.internalValue = undefined;
      this._workspace.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._disk.internalValue = value.disk;
      this._global.internalValue = value.global;
      this._network.internalValue = value.network;
      this._virtualCenter.internalValue = value.virtualCenter;
      this._workspace.internalValue = value.workspace;
    }
  }

  // disk - computed: false, optional: true, required: false
  private _disk = new ClusterRkeConfigCloudProviderVsphereCloudProviderDiskOutputReference(this, "disk");
  public get disk() {
    return this._disk;
  }
  public putDisk(value: ClusterRkeConfigCloudProviderVsphereCloudProviderDisk) {
    this._disk.internalValue = value;
  }
  public resetDisk() {
    this._disk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskInput() {
    return this._disk.internalValue;
  }

  // global - computed: false, optional: true, required: false
  private _global = new ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalOutputReference(this, "global");
  public get global() {
    return this._global;
  }
  public putGlobal(value: ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal) {
    this._global.internalValue = value;
  }
  public resetGlobal() {
    this._global.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalInput() {
    return this._global.internalValue;
  }

  // network - computed: false, optional: true, required: false
  private _network = new ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // virtual_center - computed: false, optional: false, required: true
  private _virtualCenter = new ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterList(this, "virtual_center", false);
  public get virtualCenter() {
    return this._virtualCenter;
  }
  public putVirtualCenter(value: ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[] | cdktf.IResolvable) {
    this._virtualCenter.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualCenterInput() {
    return this._virtualCenter.internalValue;
  }

  // workspace - computed: false, optional: false, required: true
  private _workspace = new ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceOutputReference(this, "workspace");
  public get workspace() {
    return this._workspace;
  }
  public putWorkspace(value: ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace) {
    this._workspace.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get workspaceInput() {
    return this._workspace.internalValue;
  }
}
export interface ClusterRkeConfigCloudProvider {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#custom_cloud_provider Cluster#custom_cloud_provider}
  */
  readonly customCloudProvider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name?: string;
  /**
  * aws_cloud_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aws_cloud_provider Cluster#aws_cloud_provider}
  */
  readonly awsCloudProvider?: ClusterRkeConfigCloudProviderAwsCloudProvider;
  /**
  * azure_cloud_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#azure_cloud_provider Cluster#azure_cloud_provider}
  */
  readonly azureCloudProvider?: ClusterRkeConfigCloudProviderAzureCloudProvider;
  /**
  * openstack_cloud_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#openstack_cloud_provider Cluster#openstack_cloud_provider}
  */
  readonly openstackCloudProvider?: ClusterRkeConfigCloudProviderOpenstackCloudProvider;
  /**
  * vsphere_cloud_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vsphere_cloud_provider Cluster#vsphere_cloud_provider}
  */
  readonly vsphereCloudProvider?: ClusterRkeConfigCloudProviderVsphereCloudProvider;
}

export function clusterRkeConfigCloudProviderToTerraform(struct?: ClusterRkeConfigCloudProviderOutputReference | ClusterRkeConfigCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_cloud_provider: cdktf.stringToTerraform(struct!.customCloudProvider),
    name: cdktf.stringToTerraform(struct!.name),
    aws_cloud_provider: clusterRkeConfigCloudProviderAwsCloudProviderToTerraform(struct!.awsCloudProvider),
    azure_cloud_provider: clusterRkeConfigCloudProviderAzureCloudProviderToTerraform(struct!.azureCloudProvider),
    openstack_cloud_provider: clusterRkeConfigCloudProviderOpenstackCloudProviderToTerraform(struct!.openstackCloudProvider),
    vsphere_cloud_provider: clusterRkeConfigCloudProviderVsphereCloudProviderToTerraform(struct!.vsphereCloudProvider),
  }
}


export function clusterRkeConfigCloudProviderToHclTerraform(struct?: ClusterRkeConfigCloudProviderOutputReference | ClusterRkeConfigCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_cloud_provider: {
      value: cdktf.stringToHclTerraform(struct!.customCloudProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_cloud_provider: {
      value: clusterRkeConfigCloudProviderAwsCloudProviderToHclTerraform(struct!.awsCloudProvider),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderAwsCloudProviderList",
    },
    azure_cloud_provider: {
      value: clusterRkeConfigCloudProviderAzureCloudProviderToHclTerraform(struct!.azureCloudProvider),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderAzureCloudProviderList",
    },
    openstack_cloud_provider: {
      value: clusterRkeConfigCloudProviderOpenstackCloudProviderToHclTerraform(struct!.openstackCloudProvider),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderOpenstackCloudProviderList",
    },
    vsphere_cloud_provider: {
      value: clusterRkeConfigCloudProviderVsphereCloudProviderToHclTerraform(struct!.vsphereCloudProvider),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderVsphereCloudProviderList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigCloudProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigCloudProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customCloudProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.customCloudProvider = this._customCloudProvider;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._awsCloudProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsCloudProvider = this._awsCloudProvider?.internalValue;
    }
    if (this._azureCloudProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureCloudProvider = this._azureCloudProvider?.internalValue;
    }
    if (this._openstackCloudProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openstackCloudProvider = this._openstackCloudProvider?.internalValue;
    }
    if (this._vsphereCloudProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.vsphereCloudProvider = this._vsphereCloudProvider?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigCloudProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._customCloudProvider = undefined;
      this._name = undefined;
      this._awsCloudProvider.internalValue = undefined;
      this._azureCloudProvider.internalValue = undefined;
      this._openstackCloudProvider.internalValue = undefined;
      this._vsphereCloudProvider.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._customCloudProvider = value.customCloudProvider;
      this._name = value.name;
      this._awsCloudProvider.internalValue = value.awsCloudProvider;
      this._azureCloudProvider.internalValue = value.azureCloudProvider;
      this._openstackCloudProvider.internalValue = value.openstackCloudProvider;
      this._vsphereCloudProvider.internalValue = value.vsphereCloudProvider;
    }
  }

  // custom_cloud_provider - computed: true, optional: true, required: false
  private _customCloudProvider?: string; 
  public get customCloudProvider() {
    return this.getStringAttribute('custom_cloud_provider');
  }
  public set customCloudProvider(value: string) {
    this._customCloudProvider = value;
  }
  public resetCustomCloudProvider() {
    this._customCloudProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customCloudProviderInput() {
    return this._customCloudProvider;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // aws_cloud_provider - computed: false, optional: true, required: false
  private _awsCloudProvider = new ClusterRkeConfigCloudProviderAwsCloudProviderOutputReference(this, "aws_cloud_provider");
  public get awsCloudProvider() {
    return this._awsCloudProvider;
  }
  public putAwsCloudProvider(value: ClusterRkeConfigCloudProviderAwsCloudProvider) {
    this._awsCloudProvider.internalValue = value;
  }
  public resetAwsCloudProvider() {
    this._awsCloudProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsCloudProviderInput() {
    return this._awsCloudProvider.internalValue;
  }

  // azure_cloud_provider - computed: false, optional: true, required: false
  private _azureCloudProvider = new ClusterRkeConfigCloudProviderAzureCloudProviderOutputReference(this, "azure_cloud_provider");
  public get azureCloudProvider() {
    return this._azureCloudProvider;
  }
  public putAzureCloudProvider(value: ClusterRkeConfigCloudProviderAzureCloudProvider) {
    this._azureCloudProvider.internalValue = value;
  }
  public resetAzureCloudProvider() {
    this._azureCloudProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureCloudProviderInput() {
    return this._azureCloudProvider.internalValue;
  }

  // openstack_cloud_provider - computed: false, optional: true, required: false
  private _openstackCloudProvider = new ClusterRkeConfigCloudProviderOpenstackCloudProviderOutputReference(this, "openstack_cloud_provider");
  public get openstackCloudProvider() {
    return this._openstackCloudProvider;
  }
  public putOpenstackCloudProvider(value: ClusterRkeConfigCloudProviderOpenstackCloudProvider) {
    this._openstackCloudProvider.internalValue = value;
  }
  public resetOpenstackCloudProvider() {
    this._openstackCloudProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openstackCloudProviderInput() {
    return this._openstackCloudProvider.internalValue;
  }

  // vsphere_cloud_provider - computed: false, optional: true, required: false
  private _vsphereCloudProvider = new ClusterRkeConfigCloudProviderVsphereCloudProviderOutputReference(this, "vsphere_cloud_provider");
  public get vsphereCloudProvider() {
    return this._vsphereCloudProvider;
  }
  public putVsphereCloudProvider(value: ClusterRkeConfigCloudProviderVsphereCloudProvider) {
    this._vsphereCloudProvider.internalValue = value;
  }
  public resetVsphereCloudProvider() {
    this._vsphereCloudProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vsphereCloudProviderInput() {
    return this._vsphereCloudProvider.internalValue;
  }
}
export interface ClusterRkeConfigDnsLinearAutoscalerParams {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cores_per_replica Cluster#cores_per_replica}
  */
  readonly coresPerReplica?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max Cluster#max}
  */
  readonly max?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#min Cluster#min}
  */
  readonly min?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#nodes_per_replica Cluster#nodes_per_replica}
  */
  readonly nodesPerReplica?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#prevent_single_point_failure Cluster#prevent_single_point_failure}
  */
  readonly preventSinglePointFailure?: boolean | cdktf.IResolvable;
}

export function clusterRkeConfigDnsLinearAutoscalerParamsToTerraform(struct?: ClusterRkeConfigDnsLinearAutoscalerParamsOutputReference | ClusterRkeConfigDnsLinearAutoscalerParams): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cores_per_replica: cdktf.numberToTerraform(struct!.coresPerReplica),
    max: cdktf.numberToTerraform(struct!.max),
    min: cdktf.numberToTerraform(struct!.min),
    nodes_per_replica: cdktf.numberToTerraform(struct!.nodesPerReplica),
    prevent_single_point_failure: cdktf.booleanToTerraform(struct!.preventSinglePointFailure),
  }
}


export function clusterRkeConfigDnsLinearAutoscalerParamsToHclTerraform(struct?: ClusterRkeConfigDnsLinearAutoscalerParamsOutputReference | ClusterRkeConfigDnsLinearAutoscalerParams): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cores_per_replica: {
      value: cdktf.numberToHclTerraform(struct!.coresPerReplica),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max: {
      value: cdktf.numberToHclTerraform(struct!.max),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min: {
      value: cdktf.numberToHclTerraform(struct!.min),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nodes_per_replica: {
      value: cdktf.numberToHclTerraform(struct!.nodesPerReplica),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    prevent_single_point_failure: {
      value: cdktf.booleanToHclTerraform(struct!.preventSinglePointFailure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigDnsLinearAutoscalerParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigDnsLinearAutoscalerParams | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._coresPerReplica !== undefined) {
      hasAnyValues = true;
      internalValueResult.coresPerReplica = this._coresPerReplica;
    }
    if (this._max !== undefined) {
      hasAnyValues = true;
      internalValueResult.max = this._max;
    }
    if (this._min !== undefined) {
      hasAnyValues = true;
      internalValueResult.min = this._min;
    }
    if (this._nodesPerReplica !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodesPerReplica = this._nodesPerReplica;
    }
    if (this._preventSinglePointFailure !== undefined) {
      hasAnyValues = true;
      internalValueResult.preventSinglePointFailure = this._preventSinglePointFailure;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigDnsLinearAutoscalerParams | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._coresPerReplica = undefined;
      this._max = undefined;
      this._min = undefined;
      this._nodesPerReplica = undefined;
      this._preventSinglePointFailure = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._coresPerReplica = value.coresPerReplica;
      this._max = value.max;
      this._min = value.min;
      this._nodesPerReplica = value.nodesPerReplica;
      this._preventSinglePointFailure = value.preventSinglePointFailure;
    }
  }

  // cores_per_replica - computed: false, optional: true, required: false
  private _coresPerReplica?: number; 
  public get coresPerReplica() {
    return this.getNumberAttribute('cores_per_replica');
  }
  public set coresPerReplica(value: number) {
    this._coresPerReplica = value;
  }
  public resetCoresPerReplica() {
    this._coresPerReplica = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get coresPerReplicaInput() {
    return this._coresPerReplica;
  }

  // max - computed: false, optional: true, required: false
  private _max?: number; 
  public get max() {
    return this.getNumberAttribute('max');
  }
  public set max(value: number) {
    this._max = value;
  }
  public resetMax() {
    this._max = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxInput() {
    return this._max;
  }

  // min - computed: false, optional: true, required: false
  private _min?: number; 
  public get min() {
    return this.getNumberAttribute('min');
  }
  public set min(value: number) {
    this._min = value;
  }
  public resetMin() {
    this._min = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minInput() {
    return this._min;
  }

  // nodes_per_replica - computed: false, optional: true, required: false
  private _nodesPerReplica?: number; 
  public get nodesPerReplica() {
    return this.getNumberAttribute('nodes_per_replica');
  }
  public set nodesPerReplica(value: number) {
    this._nodesPerReplica = value;
  }
  public resetNodesPerReplica() {
    this._nodesPerReplica = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodesPerReplicaInput() {
    return this._nodesPerReplica;
  }

  // prevent_single_point_failure - computed: false, optional: true, required: false
  private _preventSinglePointFailure?: boolean | cdktf.IResolvable; 
  public get preventSinglePointFailure() {
    return this.getBooleanAttribute('prevent_single_point_failure');
  }
  public set preventSinglePointFailure(value: boolean | cdktf.IResolvable) {
    this._preventSinglePointFailure = value;
  }
  public resetPreventSinglePointFailure() {
    this._preventSinglePointFailure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preventSinglePointFailureInput() {
    return this._preventSinglePointFailure;
  }
}
export interface ClusterRkeConfigDnsNodelocal {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ip_address Cluster#ip_address}
  */
  readonly ipAddress?: string;
  /**
  * Node selector key pair
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_selector Cluster#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
}

export function clusterRkeConfigDnsNodelocalToTerraform(struct?: ClusterRkeConfigDnsNodelocalOutputReference | ClusterRkeConfigDnsNodelocal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ip_address: cdktf.stringToTerraform(struct!.ipAddress),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
  }
}


export function clusterRkeConfigDnsNodelocalToHclTerraform(struct?: ClusterRkeConfigDnsNodelocalOutputReference | ClusterRkeConfigDnsNodelocal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ip_address: {
      value: cdktf.stringToHclTerraform(struct!.ipAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigDnsNodelocalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigDnsNodelocal | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ipAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAddress = this._ipAddress;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigDnsNodelocal | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._ipAddress = undefined;
      this._nodeSelector = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._ipAddress = value.ipAddress;
      this._nodeSelector = value.nodeSelector;
    }
  }

  // ip_address - computed: false, optional: true, required: false
  private _ipAddress?: string; 
  public get ipAddress() {
    return this.getStringAttribute('ip_address');
  }
  public set ipAddress(value: string) {
    this._ipAddress = value;
  }
  public resetIpAddress() {
    this._ipAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAddressInput() {
    return this._ipAddress;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }
}
export interface ClusterRkeConfigDnsTolerations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#effect Cluster#effect}
  */
  readonly effect?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#key Cluster#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#seconds Cluster#seconds}
  */
  readonly seconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: string;
}

export function clusterRkeConfigDnsTolerationsToTerraform(struct?: ClusterRkeConfigDnsTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    seconds: cdktf.numberToTerraform(struct!.seconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterRkeConfigDnsTolerationsToHclTerraform(struct?: ClusterRkeConfigDnsTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seconds: {
      value: cdktf.numberToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigDnsTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterRkeConfigDnsTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigDnsTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._seconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._seconds = value.seconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // seconds - computed: true, optional: true, required: false
  private _seconds?: number; 
  public get seconds() {
    return this.getNumberAttribute('seconds');
  }
  public set seconds(value: number) {
    this._seconds = value;
  }
  public resetSeconds() {
    this._seconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterRkeConfigDnsTolerationsList extends cdktf.ComplexList {
  public internalValue? : ClusterRkeConfigDnsTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterRkeConfigDnsTolerationsOutputReference {
    return new ClusterRkeConfigDnsTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterRkeConfigDnsUpdateStrategyRollingUpdate {
  /**
  * Rolling update max surge
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_surge Cluster#max_surge}
  */
  readonly maxSurge?: number;
  /**
  * Rolling update max unavailable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_unavailable Cluster#max_unavailable}
  */
  readonly maxUnavailable?: number;
}

export function clusterRkeConfigDnsUpdateStrategyRollingUpdateToTerraform(struct?: ClusterRkeConfigDnsUpdateStrategyRollingUpdateOutputReference | ClusterRkeConfigDnsUpdateStrategyRollingUpdate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_surge: cdktf.numberToTerraform(struct!.maxSurge),
    max_unavailable: cdktf.numberToTerraform(struct!.maxUnavailable),
  }
}


export function clusterRkeConfigDnsUpdateStrategyRollingUpdateToHclTerraform(struct?: ClusterRkeConfigDnsUpdateStrategyRollingUpdateOutputReference | ClusterRkeConfigDnsUpdateStrategyRollingUpdate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_surge: {
      value: cdktf.numberToHclTerraform(struct!.maxSurge),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_unavailable: {
      value: cdktf.numberToHclTerraform(struct!.maxUnavailable),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigDnsUpdateStrategyRollingUpdateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigDnsUpdateStrategyRollingUpdate | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSurge !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSurge = this._maxSurge;
    }
    if (this._maxUnavailable !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxUnavailable = this._maxUnavailable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigDnsUpdateStrategyRollingUpdate | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._maxSurge = undefined;
      this._maxUnavailable = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._maxSurge = value.maxSurge;
      this._maxUnavailable = value.maxUnavailable;
    }
  }

  // max_surge - computed: false, optional: true, required: false
  private _maxSurge?: number; 
  public get maxSurge() {
    return this.getNumberAttribute('max_surge');
  }
  public set maxSurge(value: number) {
    this._maxSurge = value;
  }
  public resetMaxSurge() {
    this._maxSurge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSurgeInput() {
    return this._maxSurge;
  }

  // max_unavailable - computed: false, optional: true, required: false
  private _maxUnavailable?: number; 
  public get maxUnavailable() {
    return this.getNumberAttribute('max_unavailable');
  }
  public set maxUnavailable(value: number) {
    this._maxUnavailable = value;
  }
  public resetMaxUnavailable() {
    this._maxUnavailable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxUnavailableInput() {
    return this._maxUnavailable;
  }
}
export interface ClusterRkeConfigDnsUpdateStrategy {
  /**
  * Strategy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#strategy Cluster#strategy}
  */
  readonly strategy?: string;
  /**
  * rolling_update block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#rolling_update Cluster#rolling_update}
  */
  readonly rollingUpdate?: ClusterRkeConfigDnsUpdateStrategyRollingUpdate;
}

export function clusterRkeConfigDnsUpdateStrategyToTerraform(struct?: ClusterRkeConfigDnsUpdateStrategyOutputReference | ClusterRkeConfigDnsUpdateStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    strategy: cdktf.stringToTerraform(struct!.strategy),
    rolling_update: clusterRkeConfigDnsUpdateStrategyRollingUpdateToTerraform(struct!.rollingUpdate),
  }
}


export function clusterRkeConfigDnsUpdateStrategyToHclTerraform(struct?: ClusterRkeConfigDnsUpdateStrategyOutputReference | ClusterRkeConfigDnsUpdateStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    strategy: {
      value: cdktf.stringToHclTerraform(struct!.strategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rolling_update: {
      value: clusterRkeConfigDnsUpdateStrategyRollingUpdateToHclTerraform(struct!.rollingUpdate),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigDnsUpdateStrategyRollingUpdateList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigDnsUpdateStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigDnsUpdateStrategy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._strategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.strategy = this._strategy;
    }
    if (this._rollingUpdate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rollingUpdate = this._rollingUpdate?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigDnsUpdateStrategy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._strategy = undefined;
      this._rollingUpdate.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._strategy = value.strategy;
      this._rollingUpdate.internalValue = value.rollingUpdate;
    }
  }

  // strategy - computed: false, optional: true, required: false
  private _strategy?: string; 
  public get strategy() {
    return this.getStringAttribute('strategy');
  }
  public set strategy(value: string) {
    this._strategy = value;
  }
  public resetStrategy() {
    this._strategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strategyInput() {
    return this._strategy;
  }

  // rolling_update - computed: false, optional: true, required: false
  private _rollingUpdate = new ClusterRkeConfigDnsUpdateStrategyRollingUpdateOutputReference(this, "rolling_update");
  public get rollingUpdate() {
    return this._rollingUpdate;
  }
  public putRollingUpdate(value: ClusterRkeConfigDnsUpdateStrategyRollingUpdate) {
    this._rollingUpdate.internalValue = value;
  }
  public resetRollingUpdate() {
    this._rollingUpdate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rollingUpdateInput() {
    return this._rollingUpdate.internalValue;
  }
}
export interface ClusterRkeConfigDns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_selector Cluster#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#options Cluster#options}
  */
  readonly options?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#provider Cluster#provider}
  */
  readonly provider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#reverse_cidrs Cluster#reverse_cidrs}
  */
  readonly reverseCidrs?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#upstream_nameservers Cluster#upstream_nameservers}
  */
  readonly upstreamNameservers?: string[];
  /**
  * linear_autoscaler_params block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#linear_autoscaler_params Cluster#linear_autoscaler_params}
  */
  readonly linearAutoscalerParams?: ClusterRkeConfigDnsLinearAutoscalerParams;
  /**
  * nodelocal block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#nodelocal Cluster#nodelocal}
  */
  readonly nodelocal?: ClusterRkeConfigDnsNodelocal;
  /**
  * tolerations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tolerations Cluster#tolerations}
  */
  readonly tolerations?: ClusterRkeConfigDnsTolerations[] | cdktf.IResolvable;
  /**
  * update_strategy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#update_strategy Cluster#update_strategy}
  */
  readonly updateStrategy?: ClusterRkeConfigDnsUpdateStrategy;
}

export function clusterRkeConfigDnsToTerraform(struct?: ClusterRkeConfigDnsOutputReference | ClusterRkeConfigDns): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    options: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.options),
    provider: cdktf.stringToTerraform(struct!.provider),
    reverse_cidrs: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.reverseCidrs),
    upstream_nameservers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.upstreamNameservers),
    linear_autoscaler_params: clusterRkeConfigDnsLinearAutoscalerParamsToTerraform(struct!.linearAutoscalerParams),
    nodelocal: clusterRkeConfigDnsNodelocalToTerraform(struct!.nodelocal),
    tolerations: cdktf.listMapper(clusterRkeConfigDnsTolerationsToTerraform, true)(struct!.tolerations),
    update_strategy: clusterRkeConfigDnsUpdateStrategyToTerraform(struct!.updateStrategy),
  }
}


export function clusterRkeConfigDnsToHclTerraform(struct?: ClusterRkeConfigDnsOutputReference | ClusterRkeConfigDns): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    options: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.options),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    provider: {
      value: cdktf.stringToHclTerraform(struct!.provider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reverse_cidrs: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.reverseCidrs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    upstream_nameservers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.upstreamNameservers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    linear_autoscaler_params: {
      value: clusterRkeConfigDnsLinearAutoscalerParamsToHclTerraform(struct!.linearAutoscalerParams),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigDnsLinearAutoscalerParamsList",
    },
    nodelocal: {
      value: clusterRkeConfigDnsNodelocalToHclTerraform(struct!.nodelocal),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigDnsNodelocalList",
    },
    tolerations: {
      value: cdktf.listMapperHcl(clusterRkeConfigDnsTolerationsToHclTerraform, true)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigDnsTolerationsList",
    },
    update_strategy: {
      value: clusterRkeConfigDnsUpdateStrategyToHclTerraform(struct!.updateStrategy),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigDnsUpdateStrategyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigDnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigDns | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._options !== undefined) {
      hasAnyValues = true;
      internalValueResult.options = this._options;
    }
    if (this._provider !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider;
    }
    if (this._reverseCidrs !== undefined) {
      hasAnyValues = true;
      internalValueResult.reverseCidrs = this._reverseCidrs;
    }
    if (this._upstreamNameservers !== undefined) {
      hasAnyValues = true;
      internalValueResult.upstreamNameservers = this._upstreamNameservers;
    }
    if (this._linearAutoscalerParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.linearAutoscalerParams = this._linearAutoscalerParams?.internalValue;
    }
    if (this._nodelocal?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodelocal = this._nodelocal?.internalValue;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._updateStrategy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.updateStrategy = this._updateStrategy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigDns | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._nodeSelector = undefined;
      this._options = undefined;
      this._provider = undefined;
      this._reverseCidrs = undefined;
      this._upstreamNameservers = undefined;
      this._linearAutoscalerParams.internalValue = undefined;
      this._nodelocal.internalValue = undefined;
      this._tolerations.internalValue = undefined;
      this._updateStrategy.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._nodeSelector = value.nodeSelector;
      this._options = value.options;
      this._provider = value.provider;
      this._reverseCidrs = value.reverseCidrs;
      this._upstreamNameservers = value.upstreamNameservers;
      this._linearAutoscalerParams.internalValue = value.linearAutoscalerParams;
      this._nodelocal.internalValue = value.nodelocal;
      this._tolerations.internalValue = value.tolerations;
      this._updateStrategy.internalValue = value.updateStrategy;
    }
  }

  // node_selector - computed: true, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // options - computed: true, optional: true, required: false
  private _options?: { [key: string]: string }; 
  public get options() {
    return this.getStringMapAttribute('options');
  }
  public set options(value: { [key: string]: string }) {
    this._options = value;
  }
  public resetOptions() {
    this._options = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionsInput() {
    return this._options;
  }

  // provider - computed: false, optional: true, required: false
  private _provider?: string; 
  public get provider() {
    return this.getStringAttribute('provider');
  }
  public set provider(value: string) {
    this._provider = value;
  }
  public resetProvider() {
    this._provider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider;
  }

  // reverse_cidrs - computed: true, optional: true, required: false
  private _reverseCidrs?: string[]; 
  public get reverseCidrs() {
    return this.getListAttribute('reverse_cidrs');
  }
  public set reverseCidrs(value: string[]) {
    this._reverseCidrs = value;
  }
  public resetReverseCidrs() {
    this._reverseCidrs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reverseCidrsInput() {
    return this._reverseCidrs;
  }

  // upstream_nameservers - computed: true, optional: true, required: false
  private _upstreamNameservers?: string[]; 
  public get upstreamNameservers() {
    return this.getListAttribute('upstream_nameservers');
  }
  public set upstreamNameservers(value: string[]) {
    this._upstreamNameservers = value;
  }
  public resetUpstreamNameservers() {
    this._upstreamNameservers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upstreamNameserversInput() {
    return this._upstreamNameservers;
  }

  // linear_autoscaler_params - computed: false, optional: true, required: false
  private _linearAutoscalerParams = new ClusterRkeConfigDnsLinearAutoscalerParamsOutputReference(this, "linear_autoscaler_params");
  public get linearAutoscalerParams() {
    return this._linearAutoscalerParams;
  }
  public putLinearAutoscalerParams(value: ClusterRkeConfigDnsLinearAutoscalerParams) {
    this._linearAutoscalerParams.internalValue = value;
  }
  public resetLinearAutoscalerParams() {
    this._linearAutoscalerParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get linearAutoscalerParamsInput() {
    return this._linearAutoscalerParams.internalValue;
  }

  // nodelocal - computed: false, optional: true, required: false
  private _nodelocal = new ClusterRkeConfigDnsNodelocalOutputReference(this, "nodelocal");
  public get nodelocal() {
    return this._nodelocal;
  }
  public putNodelocal(value: ClusterRkeConfigDnsNodelocal) {
    this._nodelocal.internalValue = value;
  }
  public resetNodelocal() {
    this._nodelocal.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodelocalInput() {
    return this._nodelocal.internalValue;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new ClusterRkeConfigDnsTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: ClusterRkeConfigDnsTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // update_strategy - computed: false, optional: true, required: false
  private _updateStrategy = new ClusterRkeConfigDnsUpdateStrategyOutputReference(this, "update_strategy");
  public get updateStrategy() {
    return this._updateStrategy;
  }
  public putUpdateStrategy(value: ClusterRkeConfigDnsUpdateStrategy) {
    this._updateStrategy.internalValue = value;
  }
  public resetUpdateStrategy() {
    this._updateStrategy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateStrategyInput() {
    return this._updateStrategy.internalValue;
  }
}
export interface ClusterRkeConfigIngressTolerations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#effect Cluster#effect}
  */
  readonly effect?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#key Cluster#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#seconds Cluster#seconds}
  */
  readonly seconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: string;
}

export function clusterRkeConfigIngressTolerationsToTerraform(struct?: ClusterRkeConfigIngressTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    seconds: cdktf.numberToTerraform(struct!.seconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterRkeConfigIngressTolerationsToHclTerraform(struct?: ClusterRkeConfigIngressTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seconds: {
      value: cdktf.numberToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigIngressTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterRkeConfigIngressTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigIngressTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._seconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._seconds = value.seconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // seconds - computed: true, optional: true, required: false
  private _seconds?: number; 
  public get seconds() {
    return this.getNumberAttribute('seconds');
  }
  public set seconds(value: number) {
    this._seconds = value;
  }
  public resetSeconds() {
    this._seconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterRkeConfigIngressTolerationsList extends cdktf.ComplexList {
  public internalValue? : ClusterRkeConfigIngressTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterRkeConfigIngressTolerationsOutputReference {
    return new ClusterRkeConfigIngressTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterRkeConfigIngressUpdateStrategyRollingUpdate {
  /**
  * Rolling update max unavailable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_unavailable Cluster#max_unavailable}
  */
  readonly maxUnavailable?: number;
}

export function clusterRkeConfigIngressUpdateStrategyRollingUpdateToTerraform(struct?: ClusterRkeConfigIngressUpdateStrategyRollingUpdateOutputReference | ClusterRkeConfigIngressUpdateStrategyRollingUpdate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_unavailable: cdktf.numberToTerraform(struct!.maxUnavailable),
  }
}


export function clusterRkeConfigIngressUpdateStrategyRollingUpdateToHclTerraform(struct?: ClusterRkeConfigIngressUpdateStrategyRollingUpdateOutputReference | ClusterRkeConfigIngressUpdateStrategyRollingUpdate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_unavailable: {
      value: cdktf.numberToHclTerraform(struct!.maxUnavailable),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigIngressUpdateStrategyRollingUpdateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigIngressUpdateStrategyRollingUpdate | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxUnavailable !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxUnavailable = this._maxUnavailable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigIngressUpdateStrategyRollingUpdate | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._maxUnavailable = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._maxUnavailable = value.maxUnavailable;
    }
  }

  // max_unavailable - computed: false, optional: true, required: false
  private _maxUnavailable?: number; 
  public get maxUnavailable() {
    return this.getNumberAttribute('max_unavailable');
  }
  public set maxUnavailable(value: number) {
    this._maxUnavailable = value;
  }
  public resetMaxUnavailable() {
    this._maxUnavailable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxUnavailableInput() {
    return this._maxUnavailable;
  }
}
export interface ClusterRkeConfigIngressUpdateStrategy {
  /**
  * Strategy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#strategy Cluster#strategy}
  */
  readonly strategy?: string;
  /**
  * rolling_update block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#rolling_update Cluster#rolling_update}
  */
  readonly rollingUpdate?: ClusterRkeConfigIngressUpdateStrategyRollingUpdate;
}

export function clusterRkeConfigIngressUpdateStrategyToTerraform(struct?: ClusterRkeConfigIngressUpdateStrategyOutputReference | ClusterRkeConfigIngressUpdateStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    strategy: cdktf.stringToTerraform(struct!.strategy),
    rolling_update: clusterRkeConfigIngressUpdateStrategyRollingUpdateToTerraform(struct!.rollingUpdate),
  }
}


export function clusterRkeConfigIngressUpdateStrategyToHclTerraform(struct?: ClusterRkeConfigIngressUpdateStrategyOutputReference | ClusterRkeConfigIngressUpdateStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    strategy: {
      value: cdktf.stringToHclTerraform(struct!.strategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rolling_update: {
      value: clusterRkeConfigIngressUpdateStrategyRollingUpdateToHclTerraform(struct!.rollingUpdate),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigIngressUpdateStrategyRollingUpdateList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigIngressUpdateStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigIngressUpdateStrategy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._strategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.strategy = this._strategy;
    }
    if (this._rollingUpdate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rollingUpdate = this._rollingUpdate?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigIngressUpdateStrategy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._strategy = undefined;
      this._rollingUpdate.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._strategy = value.strategy;
      this._rollingUpdate.internalValue = value.rollingUpdate;
    }
  }

  // strategy - computed: false, optional: true, required: false
  private _strategy?: string; 
  public get strategy() {
    return this.getStringAttribute('strategy');
  }
  public set strategy(value: string) {
    this._strategy = value;
  }
  public resetStrategy() {
    this._strategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strategyInput() {
    return this._strategy;
  }

  // rolling_update - computed: false, optional: true, required: false
  private _rollingUpdate = new ClusterRkeConfigIngressUpdateStrategyRollingUpdateOutputReference(this, "rolling_update");
  public get rollingUpdate() {
    return this._rollingUpdate;
  }
  public putRollingUpdate(value: ClusterRkeConfigIngressUpdateStrategyRollingUpdate) {
    this._rollingUpdate.internalValue = value;
  }
  public resetRollingUpdate() {
    this._rollingUpdate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rollingUpdateInput() {
    return this._rollingUpdate.internalValue;
  }
}
export interface ClusterRkeConfigIngress {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#default_backend Cluster#default_backend}
  */
  readonly defaultBackend?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#dns_policy Cluster#dns_policy}
  */
  readonly dnsPolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_args Cluster#extra_args}
  */
  readonly extraArgs?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#http_port Cluster#http_port}
  */
  readonly httpPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#https_port Cluster#https_port}
  */
  readonly httpsPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network_mode Cluster#network_mode}
  */
  readonly networkMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_selector Cluster#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#options Cluster#options}
  */
  readonly options?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#provider Cluster#provider}
  */
  readonly provider?: string;
  /**
  * tolerations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tolerations Cluster#tolerations}
  */
  readonly tolerations?: ClusterRkeConfigIngressTolerations[] | cdktf.IResolvable;
  /**
  * update_strategy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#update_strategy Cluster#update_strategy}
  */
  readonly updateStrategy?: ClusterRkeConfigIngressUpdateStrategy;
}

export function clusterRkeConfigIngressToTerraform(struct?: ClusterRkeConfigIngressOutputReference | ClusterRkeConfigIngress): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_backend: cdktf.booleanToTerraform(struct!.defaultBackend),
    dns_policy: cdktf.stringToTerraform(struct!.dnsPolicy),
    extra_args: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraArgs),
    http_port: cdktf.numberToTerraform(struct!.httpPort),
    https_port: cdktf.numberToTerraform(struct!.httpsPort),
    network_mode: cdktf.stringToTerraform(struct!.networkMode),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    options: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.options),
    provider: cdktf.stringToTerraform(struct!.provider),
    tolerations: cdktf.listMapper(clusterRkeConfigIngressTolerationsToTerraform, true)(struct!.tolerations),
    update_strategy: clusterRkeConfigIngressUpdateStrategyToTerraform(struct!.updateStrategy),
  }
}


export function clusterRkeConfigIngressToHclTerraform(struct?: ClusterRkeConfigIngressOutputReference | ClusterRkeConfigIngress): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_backend: {
      value: cdktf.booleanToHclTerraform(struct!.defaultBackend),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_policy: {
      value: cdktf.stringToHclTerraform(struct!.dnsPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_args: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraArgs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    http_port: {
      value: cdktf.numberToHclTerraform(struct!.httpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    https_port: {
      value: cdktf.numberToHclTerraform(struct!.httpsPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    network_mode: {
      value: cdktf.stringToHclTerraform(struct!.networkMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    options: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.options),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    provider: {
      value: cdktf.stringToHclTerraform(struct!.provider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerations: {
      value: cdktf.listMapperHcl(clusterRkeConfigIngressTolerationsToHclTerraform, true)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigIngressTolerationsList",
    },
    update_strategy: {
      value: clusterRkeConfigIngressUpdateStrategyToHclTerraform(struct!.updateStrategy),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigIngressUpdateStrategyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigIngressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigIngress | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultBackend !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultBackend = this._defaultBackend;
    }
    if (this._dnsPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPolicy = this._dnsPolicy;
    }
    if (this._extraArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraArgs = this._extraArgs;
    }
    if (this._httpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPort = this._httpPort;
    }
    if (this._httpsPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpsPort = this._httpsPort;
    }
    if (this._networkMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkMode = this._networkMode;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._options !== undefined) {
      hasAnyValues = true;
      internalValueResult.options = this._options;
    }
    if (this._provider !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._updateStrategy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.updateStrategy = this._updateStrategy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigIngress | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._defaultBackend = undefined;
      this._dnsPolicy = undefined;
      this._extraArgs = undefined;
      this._httpPort = undefined;
      this._httpsPort = undefined;
      this._networkMode = undefined;
      this._nodeSelector = undefined;
      this._options = undefined;
      this._provider = undefined;
      this._tolerations.internalValue = undefined;
      this._updateStrategy.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._defaultBackend = value.defaultBackend;
      this._dnsPolicy = value.dnsPolicy;
      this._extraArgs = value.extraArgs;
      this._httpPort = value.httpPort;
      this._httpsPort = value.httpsPort;
      this._networkMode = value.networkMode;
      this._nodeSelector = value.nodeSelector;
      this._options = value.options;
      this._provider = value.provider;
      this._tolerations.internalValue = value.tolerations;
      this._updateStrategy.internalValue = value.updateStrategy;
    }
  }

  // default_backend - computed: false, optional: true, required: false
  private _defaultBackend?: boolean | cdktf.IResolvable; 
  public get defaultBackend() {
    return this.getBooleanAttribute('default_backend');
  }
  public set defaultBackend(value: boolean | cdktf.IResolvable) {
    this._defaultBackend = value;
  }
  public resetDefaultBackend() {
    this._defaultBackend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultBackendInput() {
    return this._defaultBackend;
  }

  // dns_policy - computed: true, optional: true, required: false
  private _dnsPolicy?: string; 
  public get dnsPolicy() {
    return this.getStringAttribute('dns_policy');
  }
  public set dnsPolicy(value: string) {
    this._dnsPolicy = value;
  }
  public resetDnsPolicy() {
    this._dnsPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPolicyInput() {
    return this._dnsPolicy;
  }

  // extra_args - computed: true, optional: true, required: false
  private _extraArgs?: { [key: string]: string }; 
  public get extraArgs() {
    return this.getStringMapAttribute('extra_args');
  }
  public set extraArgs(value: { [key: string]: string }) {
    this._extraArgs = value;
  }
  public resetExtraArgs() {
    this._extraArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraArgsInput() {
    return this._extraArgs;
  }

  // http_port - computed: true, optional: true, required: false
  private _httpPort?: number; 
  public get httpPort() {
    return this.getNumberAttribute('http_port');
  }
  public set httpPort(value: number) {
    this._httpPort = value;
  }
  public resetHttpPort() {
    this._httpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPortInput() {
    return this._httpPort;
  }

  // https_port - computed: true, optional: true, required: false
  private _httpsPort?: number; 
  public get httpsPort() {
    return this.getNumberAttribute('https_port');
  }
  public set httpsPort(value: number) {
    this._httpsPort = value;
  }
  public resetHttpsPort() {
    this._httpsPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpsPortInput() {
    return this._httpsPort;
  }

  // network_mode - computed: true, optional: true, required: false
  private _networkMode?: string; 
  public get networkMode() {
    return this.getStringAttribute('network_mode');
  }
  public set networkMode(value: string) {
    this._networkMode = value;
  }
  public resetNetworkMode() {
    this._networkMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkModeInput() {
    return this._networkMode;
  }

  // node_selector - computed: true, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // options - computed: true, optional: true, required: false
  private _options?: { [key: string]: string }; 
  public get options() {
    return this.getStringMapAttribute('options');
  }
  public set options(value: { [key: string]: string }) {
    this._options = value;
  }
  public resetOptions() {
    this._options = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionsInput() {
    return this._options;
  }

  // provider - computed: true, optional: true, required: false
  private _provider?: string; 
  public get provider() {
    return this.getStringAttribute('provider');
  }
  public set provider(value: string) {
    this._provider = value;
  }
  public resetProvider() {
    this._provider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new ClusterRkeConfigIngressTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: ClusterRkeConfigIngressTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // update_strategy - computed: false, optional: true, required: false
  private _updateStrategy = new ClusterRkeConfigIngressUpdateStrategyOutputReference(this, "update_strategy");
  public get updateStrategy() {
    return this._updateStrategy;
  }
  public putUpdateStrategy(value: ClusterRkeConfigIngressUpdateStrategy) {
    this._updateStrategy.internalValue = value;
  }
  public resetUpdateStrategy() {
    this._updateStrategy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateStrategyInput() {
    return this._updateStrategy.internalValue;
  }
}
export interface ClusterRkeConfigMonitoringTolerations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#effect Cluster#effect}
  */
  readonly effect?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#key Cluster#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#seconds Cluster#seconds}
  */
  readonly seconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: string;
}

export function clusterRkeConfigMonitoringTolerationsToTerraform(struct?: ClusterRkeConfigMonitoringTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    seconds: cdktf.numberToTerraform(struct!.seconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterRkeConfigMonitoringTolerationsToHclTerraform(struct?: ClusterRkeConfigMonitoringTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seconds: {
      value: cdktf.numberToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigMonitoringTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterRkeConfigMonitoringTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigMonitoringTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._seconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._seconds = value.seconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // seconds - computed: true, optional: true, required: false
  private _seconds?: number; 
  public get seconds() {
    return this.getNumberAttribute('seconds');
  }
  public set seconds(value: number) {
    this._seconds = value;
  }
  public resetSeconds() {
    this._seconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterRkeConfigMonitoringTolerationsList extends cdktf.ComplexList {
  public internalValue? : ClusterRkeConfigMonitoringTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterRkeConfigMonitoringTolerationsOutputReference {
    return new ClusterRkeConfigMonitoringTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate {
  /**
  * Rolling update max surge
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_surge Cluster#max_surge}
  */
  readonly maxSurge?: number;
  /**
  * Rolling update max unavailable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_unavailable Cluster#max_unavailable}
  */
  readonly maxUnavailable?: number;
}

export function clusterRkeConfigMonitoringUpdateStrategyRollingUpdateToTerraform(struct?: ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateOutputReference | ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_surge: cdktf.numberToTerraform(struct!.maxSurge),
    max_unavailable: cdktf.numberToTerraform(struct!.maxUnavailable),
  }
}


export function clusterRkeConfigMonitoringUpdateStrategyRollingUpdateToHclTerraform(struct?: ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateOutputReference | ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_surge: {
      value: cdktf.numberToHclTerraform(struct!.maxSurge),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_unavailable: {
      value: cdktf.numberToHclTerraform(struct!.maxUnavailable),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSurge !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSurge = this._maxSurge;
    }
    if (this._maxUnavailable !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxUnavailable = this._maxUnavailable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._maxSurge = undefined;
      this._maxUnavailable = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._maxSurge = value.maxSurge;
      this._maxUnavailable = value.maxUnavailable;
    }
  }

  // max_surge - computed: false, optional: true, required: false
  private _maxSurge?: number; 
  public get maxSurge() {
    return this.getNumberAttribute('max_surge');
  }
  public set maxSurge(value: number) {
    this._maxSurge = value;
  }
  public resetMaxSurge() {
    this._maxSurge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSurgeInput() {
    return this._maxSurge;
  }

  // max_unavailable - computed: false, optional: true, required: false
  private _maxUnavailable?: number; 
  public get maxUnavailable() {
    return this.getNumberAttribute('max_unavailable');
  }
  public set maxUnavailable(value: number) {
    this._maxUnavailable = value;
  }
  public resetMaxUnavailable() {
    this._maxUnavailable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxUnavailableInput() {
    return this._maxUnavailable;
  }
}
export interface ClusterRkeConfigMonitoringUpdateStrategy {
  /**
  * Strategy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#strategy Cluster#strategy}
  */
  readonly strategy?: string;
  /**
  * rolling_update block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#rolling_update Cluster#rolling_update}
  */
  readonly rollingUpdate?: ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate;
}

export function clusterRkeConfigMonitoringUpdateStrategyToTerraform(struct?: ClusterRkeConfigMonitoringUpdateStrategyOutputReference | ClusterRkeConfigMonitoringUpdateStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    strategy: cdktf.stringToTerraform(struct!.strategy),
    rolling_update: clusterRkeConfigMonitoringUpdateStrategyRollingUpdateToTerraform(struct!.rollingUpdate),
  }
}


export function clusterRkeConfigMonitoringUpdateStrategyToHclTerraform(struct?: ClusterRkeConfigMonitoringUpdateStrategyOutputReference | ClusterRkeConfigMonitoringUpdateStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    strategy: {
      value: cdktf.stringToHclTerraform(struct!.strategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rolling_update: {
      value: clusterRkeConfigMonitoringUpdateStrategyRollingUpdateToHclTerraform(struct!.rollingUpdate),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigMonitoringUpdateStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigMonitoringUpdateStrategy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._strategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.strategy = this._strategy;
    }
    if (this._rollingUpdate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rollingUpdate = this._rollingUpdate?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigMonitoringUpdateStrategy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._strategy = undefined;
      this._rollingUpdate.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._strategy = value.strategy;
      this._rollingUpdate.internalValue = value.rollingUpdate;
    }
  }

  // strategy - computed: false, optional: true, required: false
  private _strategy?: string; 
  public get strategy() {
    return this.getStringAttribute('strategy');
  }
  public set strategy(value: string) {
    this._strategy = value;
  }
  public resetStrategy() {
    this._strategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strategyInput() {
    return this._strategy;
  }

  // rolling_update - computed: false, optional: true, required: false
  private _rollingUpdate = new ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateOutputReference(this, "rolling_update");
  public get rollingUpdate() {
    return this._rollingUpdate;
  }
  public putRollingUpdate(value: ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate) {
    this._rollingUpdate.internalValue = value;
  }
  public resetRollingUpdate() {
    this._rollingUpdate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rollingUpdateInput() {
    return this._rollingUpdate.internalValue;
  }
}
export interface ClusterRkeConfigMonitoring {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_selector Cluster#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#options Cluster#options}
  */
  readonly options?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#provider Cluster#provider}
  */
  readonly provider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#replicas Cluster#replicas}
  */
  readonly replicas?: number;
  /**
  * tolerations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tolerations Cluster#tolerations}
  */
  readonly tolerations?: ClusterRkeConfigMonitoringTolerations[] | cdktf.IResolvable;
  /**
  * update_strategy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#update_strategy Cluster#update_strategy}
  */
  readonly updateStrategy?: ClusterRkeConfigMonitoringUpdateStrategy;
}

export function clusterRkeConfigMonitoringToTerraform(struct?: ClusterRkeConfigMonitoringOutputReference | ClusterRkeConfigMonitoring): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    options: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.options),
    provider: cdktf.stringToTerraform(struct!.provider),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    tolerations: cdktf.listMapper(clusterRkeConfigMonitoringTolerationsToTerraform, true)(struct!.tolerations),
    update_strategy: clusterRkeConfigMonitoringUpdateStrategyToTerraform(struct!.updateStrategy),
  }
}


export function clusterRkeConfigMonitoringToHclTerraform(struct?: ClusterRkeConfigMonitoringOutputReference | ClusterRkeConfigMonitoring): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    options: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.options),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    provider: {
      value: cdktf.stringToHclTerraform(struct!.provider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tolerations: {
      value: cdktf.listMapperHcl(clusterRkeConfigMonitoringTolerationsToHclTerraform, true)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigMonitoringTolerationsList",
    },
    update_strategy: {
      value: clusterRkeConfigMonitoringUpdateStrategyToHclTerraform(struct!.updateStrategy),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigMonitoringUpdateStrategyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigMonitoringOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigMonitoring | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._options !== undefined) {
      hasAnyValues = true;
      internalValueResult.options = this._options;
    }
    if (this._provider !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._updateStrategy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.updateStrategy = this._updateStrategy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigMonitoring | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._nodeSelector = undefined;
      this._options = undefined;
      this._provider = undefined;
      this._replicas = undefined;
      this._tolerations.internalValue = undefined;
      this._updateStrategy.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._nodeSelector = value.nodeSelector;
      this._options = value.options;
      this._provider = value.provider;
      this._replicas = value.replicas;
      this._tolerations.internalValue = value.tolerations;
      this._updateStrategy.internalValue = value.updateStrategy;
    }
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // options - computed: true, optional: true, required: false
  private _options?: { [key: string]: string }; 
  public get options() {
    return this.getStringMapAttribute('options');
  }
  public set options(value: { [key: string]: string }) {
    this._options = value;
  }
  public resetOptions() {
    this._options = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionsInput() {
    return this._options;
  }

  // provider - computed: true, optional: true, required: false
  private _provider?: string; 
  public get provider() {
    return this.getStringAttribute('provider');
  }
  public set provider(value: string) {
    this._provider = value;
  }
  public resetProvider() {
    this._provider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider;
  }

  // replicas - computed: true, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new ClusterRkeConfigMonitoringTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: ClusterRkeConfigMonitoringTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // update_strategy - computed: false, optional: true, required: false
  private _updateStrategy = new ClusterRkeConfigMonitoringUpdateStrategyOutputReference(this, "update_strategy");
  public get updateStrategy() {
    return this._updateStrategy;
  }
  public putUpdateStrategy(value: ClusterRkeConfigMonitoringUpdateStrategy) {
    this._updateStrategy.internalValue = value;
  }
  public resetUpdateStrategy() {
    this._updateStrategy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateStrategyInput() {
    return this._updateStrategy.internalValue;
  }
}
export interface ClusterRkeConfigNetworkAciNetworkProvider {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aep Cluster#aep}
  */
  readonly aep: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#apic_hosts Cluster#apic_hosts}
  */
  readonly apicHosts: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#apic_refresh_ticker_adjust Cluster#apic_refresh_ticker_adjust}
  */
  readonly apicRefreshTickerAdjust?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#apic_refresh_time Cluster#apic_refresh_time}
  */
  readonly apicRefreshTime?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#apic_subscription_delay Cluster#apic_subscription_delay}
  */
  readonly apicSubscriptionDelay?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#apic_user_crt Cluster#apic_user_crt}
  */
  readonly apicUserCrt: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#apic_user_key Cluster#apic_user_key}
  */
  readonly apicUserKey: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#apic_user_name Cluster#apic_user_name}
  */
  readonly apicUserName: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#capic Cluster#capic}
  */
  readonly capic?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#controller_log_level Cluster#controller_log_level}
  */
  readonly controllerLogLevel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#disable_periodic_snat_global_info_sync Cluster#disable_periodic_snat_global_info_sync}
  */
  readonly disablePeriodicSnatGlobalInfoSync?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#disable_wait_for_network Cluster#disable_wait_for_network}
  */
  readonly disableWaitForNetwork?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#drop_log_enable Cluster#drop_log_enable}
  */
  readonly dropLogEnable?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#duration_wait_for_network Cluster#duration_wait_for_network}
  */
  readonly durationWaitForNetwork?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enable_endpoint_slice Cluster#enable_endpoint_slice}
  */
  readonly enableEndpointSlice?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#encap_type Cluster#encap_type}
  */
  readonly encapType: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ep_registry Cluster#ep_registry}
  */
  readonly epRegistry?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extern_dynamic Cluster#extern_dynamic}
  */
  readonly externDynamic: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extern_static Cluster#extern_static}
  */
  readonly externStatic: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#gbp_pod_subnet Cluster#gbp_pod_subnet}
  */
  readonly gbpPodSubnet?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#host_agent_log_level Cluster#host_agent_log_level}
  */
  readonly hostAgentLogLevel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image_pull_policy Cluster#image_pull_policy}
  */
  readonly imagePullPolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image_pull_secret Cluster#image_pull_secret}
  */
  readonly imagePullSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#infra_vlan Cluster#infra_vlan}
  */
  readonly infraVlan?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#install_istio Cluster#install_istio}
  */
  readonly installIstio?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#istio_profile Cluster#istio_profile}
  */
  readonly istioProfile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kafka_brokers Cluster#kafka_brokers}
  */
  readonly kafkaBrokers?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kafka_client_crt Cluster#kafka_client_crt}
  */
  readonly kafkaClientCrt?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kafka_client_key Cluster#kafka_client_key}
  */
  readonly kafkaClientKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kube_api_vlan Cluster#kube_api_vlan}
  */
  readonly kubeApiVlan: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#l3out Cluster#l3out}
  */
  readonly l3Out: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#l3out_external_networks Cluster#l3out_external_networks}
  */
  readonly l3OutExternalNetworks: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_nodes_svc_graph Cluster#max_nodes_svc_graph}
  */
  readonly maxNodesSvcGraph?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#mcast_range_end Cluster#mcast_range_end}
  */
  readonly mcastRangeEnd: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#mcast_range_start Cluster#mcast_range_start}
  */
  readonly mcastRangeStart: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#mtu_head_room Cluster#mtu_head_room}
  */
  readonly mtuHeadRoom?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#multus_disable Cluster#multus_disable}
  */
  readonly multusDisable?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#no_priority_class Cluster#no_priority_class}
  */
  readonly noPriorityClass?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_pod_if_enable Cluster#node_pod_if_enable}
  */
  readonly nodePodIfEnable?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_subnet Cluster#node_subnet}
  */
  readonly nodeSubnet: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_svc_subnet Cluster#node_svc_subnet}
  */
  readonly nodeSvcSubnet: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#opflex_client_ssl Cluster#opflex_client_ssl}
  */
  readonly opflexClientSsl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#opflex_device_delete_timeout Cluster#opflex_device_delete_timeout}
  */
  readonly opflexDeviceDeleteTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#opflex_log_level Cluster#opflex_log_level}
  */
  readonly opflexLogLevel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#opflex_mode Cluster#opflex_mode}
  */
  readonly opflexMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#opflex_server_port Cluster#opflex_server_port}
  */
  readonly opflexServerPort?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#overlay_vrf_name Cluster#overlay_vrf_name}
  */
  readonly overlayVrfName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ovs_memory_limit Cluster#ovs_memory_limit}
  */
  readonly ovsMemoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#pbr_tracking_non_snat Cluster#pbr_tracking_non_snat}
  */
  readonly pbrTrackingNonSnat?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#pod_subnet_chunk_size Cluster#pod_subnet_chunk_size}
  */
  readonly podSubnetChunkSize?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#run_gbp_container Cluster#run_gbp_container}
  */
  readonly runGbpContainer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#run_opflex_server_container Cluster#run_opflex_server_container}
  */
  readonly runOpflexServerContainer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service_monitor_interval Cluster#service_monitor_interval}
  */
  readonly serviceMonitorInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service_vlan Cluster#service_vlan}
  */
  readonly serviceVlan: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#snat_contract_scope Cluster#snat_contract_scope}
  */
  readonly snatContractScope?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#snat_namespace Cluster#snat_namespace}
  */
  readonly snatNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#snat_port_range_end Cluster#snat_port_range_end}
  */
  readonly snatPortRangeEnd?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#snat_port_range_start Cluster#snat_port_range_start}
  */
  readonly snatPortRangeStart?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#snat_ports_per_node Cluster#snat_ports_per_node}
  */
  readonly snatPortsPerNode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#sriov_enable Cluster#sriov_enable}
  */
  readonly sriovEnable?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#subnet_domain_name Cluster#subnet_domain_name}
  */
  readonly subnetDomainName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#system_id Cluster#system_id}
  */
  readonly systemId: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tenant Cluster#tenant}
  */
  readonly tenant?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#token Cluster#token}
  */
  readonly token: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#use_aci_anywhere_crd Cluster#use_aci_anywhere_crd}
  */
  readonly useAciAnywhereCrd?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#use_aci_cni_priority_class Cluster#use_aci_cni_priority_class}
  */
  readonly useAciCniPriorityClass?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#use_cluster_role Cluster#use_cluster_role}
  */
  readonly useClusterRole?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#use_host_netns_volume Cluster#use_host_netns_volume}
  */
  readonly useHostNetnsVolume?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#use_opflex_server_volume Cluster#use_opflex_server_volume}
  */
  readonly useOpflexServerVolume?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#use_privileged_container Cluster#use_privileged_container}
  */
  readonly usePrivilegedContainer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vmm_controller Cluster#vmm_controller}
  */
  readonly vmmController?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vmm_domain Cluster#vmm_domain}
  */
  readonly vmmDomain?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vrf_name Cluster#vrf_name}
  */
  readonly vrfName: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#vrf_tenant Cluster#vrf_tenant}
  */
  readonly vrfTenant: string;
}

export function clusterRkeConfigNetworkAciNetworkProviderToTerraform(struct?: ClusterRkeConfigNetworkAciNetworkProviderOutputReference | ClusterRkeConfigNetworkAciNetworkProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aep: cdktf.stringToTerraform(struct!.aep),
    apic_hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.apicHosts),
    apic_refresh_ticker_adjust: cdktf.stringToTerraform(struct!.apicRefreshTickerAdjust),
    apic_refresh_time: cdktf.stringToTerraform(struct!.apicRefreshTime),
    apic_subscription_delay: cdktf.stringToTerraform(struct!.apicSubscriptionDelay),
    apic_user_crt: cdktf.stringToTerraform(struct!.apicUserCrt),
    apic_user_key: cdktf.stringToTerraform(struct!.apicUserKey),
    apic_user_name: cdktf.stringToTerraform(struct!.apicUserName),
    capic: cdktf.stringToTerraform(struct!.capic),
    controller_log_level: cdktf.stringToTerraform(struct!.controllerLogLevel),
    disable_periodic_snat_global_info_sync: cdktf.stringToTerraform(struct!.disablePeriodicSnatGlobalInfoSync),
    disable_wait_for_network: cdktf.stringToTerraform(struct!.disableWaitForNetwork),
    drop_log_enable: cdktf.stringToTerraform(struct!.dropLogEnable),
    duration_wait_for_network: cdktf.stringToTerraform(struct!.durationWaitForNetwork),
    enable_endpoint_slice: cdktf.stringToTerraform(struct!.enableEndpointSlice),
    encap_type: cdktf.stringToTerraform(struct!.encapType),
    ep_registry: cdktf.stringToTerraform(struct!.epRegistry),
    extern_dynamic: cdktf.stringToTerraform(struct!.externDynamic),
    extern_static: cdktf.stringToTerraform(struct!.externStatic),
    gbp_pod_subnet: cdktf.stringToTerraform(struct!.gbpPodSubnet),
    host_agent_log_level: cdktf.stringToTerraform(struct!.hostAgentLogLevel),
    image_pull_policy: cdktf.stringToTerraform(struct!.imagePullPolicy),
    image_pull_secret: cdktf.stringToTerraform(struct!.imagePullSecret),
    infra_vlan: cdktf.stringToTerraform(struct!.infraVlan),
    install_istio: cdktf.stringToTerraform(struct!.installIstio),
    istio_profile: cdktf.stringToTerraform(struct!.istioProfile),
    kafka_brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.kafkaBrokers),
    kafka_client_crt: cdktf.stringToTerraform(struct!.kafkaClientCrt),
    kafka_client_key: cdktf.stringToTerraform(struct!.kafkaClientKey),
    kube_api_vlan: cdktf.stringToTerraform(struct!.kubeApiVlan),
    l3out: cdktf.stringToTerraform(struct!.l3Out),
    l3out_external_networks: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.l3OutExternalNetworks),
    max_nodes_svc_graph: cdktf.stringToTerraform(struct!.maxNodesSvcGraph),
    mcast_range_end: cdktf.stringToTerraform(struct!.mcastRangeEnd),
    mcast_range_start: cdktf.stringToTerraform(struct!.mcastRangeStart),
    mtu_head_room: cdktf.stringToTerraform(struct!.mtuHeadRoom),
    multus_disable: cdktf.stringToTerraform(struct!.multusDisable),
    no_priority_class: cdktf.stringToTerraform(struct!.noPriorityClass),
    node_pod_if_enable: cdktf.stringToTerraform(struct!.nodePodIfEnable),
    node_subnet: cdktf.stringToTerraform(struct!.nodeSubnet),
    node_svc_subnet: cdktf.stringToTerraform(struct!.nodeSvcSubnet),
    opflex_client_ssl: cdktf.stringToTerraform(struct!.opflexClientSsl),
    opflex_device_delete_timeout: cdktf.stringToTerraform(struct!.opflexDeviceDeleteTimeout),
    opflex_log_level: cdktf.stringToTerraform(struct!.opflexLogLevel),
    opflex_mode: cdktf.stringToTerraform(struct!.opflexMode),
    opflex_server_port: cdktf.stringToTerraform(struct!.opflexServerPort),
    overlay_vrf_name: cdktf.stringToTerraform(struct!.overlayVrfName),
    ovs_memory_limit: cdktf.stringToTerraform(struct!.ovsMemoryLimit),
    pbr_tracking_non_snat: cdktf.stringToTerraform(struct!.pbrTrackingNonSnat),
    pod_subnet_chunk_size: cdktf.stringToTerraform(struct!.podSubnetChunkSize),
    run_gbp_container: cdktf.stringToTerraform(struct!.runGbpContainer),
    run_opflex_server_container: cdktf.stringToTerraform(struct!.runOpflexServerContainer),
    service_monitor_interval: cdktf.stringToTerraform(struct!.serviceMonitorInterval),
    service_vlan: cdktf.stringToTerraform(struct!.serviceVlan),
    snat_contract_scope: cdktf.stringToTerraform(struct!.snatContractScope),
    snat_namespace: cdktf.stringToTerraform(struct!.snatNamespace),
    snat_port_range_end: cdktf.stringToTerraform(struct!.snatPortRangeEnd),
    snat_port_range_start: cdktf.stringToTerraform(struct!.snatPortRangeStart),
    snat_ports_per_node: cdktf.stringToTerraform(struct!.snatPortsPerNode),
    sriov_enable: cdktf.stringToTerraform(struct!.sriovEnable),
    subnet_domain_name: cdktf.stringToTerraform(struct!.subnetDomainName),
    system_id: cdktf.stringToTerraform(struct!.systemId),
    tenant: cdktf.stringToTerraform(struct!.tenant),
    token: cdktf.stringToTerraform(struct!.token),
    use_aci_anywhere_crd: cdktf.stringToTerraform(struct!.useAciAnywhereCrd),
    use_aci_cni_priority_class: cdktf.stringToTerraform(struct!.useAciCniPriorityClass),
    use_cluster_role: cdktf.stringToTerraform(struct!.useClusterRole),
    use_host_netns_volume: cdktf.stringToTerraform(struct!.useHostNetnsVolume),
    use_opflex_server_volume: cdktf.stringToTerraform(struct!.useOpflexServerVolume),
    use_privileged_container: cdktf.stringToTerraform(struct!.usePrivilegedContainer),
    vmm_controller: cdktf.stringToTerraform(struct!.vmmController),
    vmm_domain: cdktf.stringToTerraform(struct!.vmmDomain),
    vrf_name: cdktf.stringToTerraform(struct!.vrfName),
    vrf_tenant: cdktf.stringToTerraform(struct!.vrfTenant),
  }
}


export function clusterRkeConfigNetworkAciNetworkProviderToHclTerraform(struct?: ClusterRkeConfigNetworkAciNetworkProviderOutputReference | ClusterRkeConfigNetworkAciNetworkProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aep: {
      value: cdktf.stringToHclTerraform(struct!.aep),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    apic_hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.apicHosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    apic_refresh_ticker_adjust: {
      value: cdktf.stringToHclTerraform(struct!.apicRefreshTickerAdjust),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    apic_refresh_time: {
      value: cdktf.stringToHclTerraform(struct!.apicRefreshTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    apic_subscription_delay: {
      value: cdktf.stringToHclTerraform(struct!.apicSubscriptionDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    apic_user_crt: {
      value: cdktf.stringToHclTerraform(struct!.apicUserCrt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    apic_user_key: {
      value: cdktf.stringToHclTerraform(struct!.apicUserKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    apic_user_name: {
      value: cdktf.stringToHclTerraform(struct!.apicUserName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    capic: {
      value: cdktf.stringToHclTerraform(struct!.capic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    controller_log_level: {
      value: cdktf.stringToHclTerraform(struct!.controllerLogLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_periodic_snat_global_info_sync: {
      value: cdktf.stringToHclTerraform(struct!.disablePeriodicSnatGlobalInfoSync),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_wait_for_network: {
      value: cdktf.stringToHclTerraform(struct!.disableWaitForNetwork),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    drop_log_enable: {
      value: cdktf.stringToHclTerraform(struct!.dropLogEnable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_wait_for_network: {
      value: cdktf.stringToHclTerraform(struct!.durationWaitForNetwork),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_endpoint_slice: {
      value: cdktf.stringToHclTerraform(struct!.enableEndpointSlice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    encap_type: {
      value: cdktf.stringToHclTerraform(struct!.encapType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ep_registry: {
      value: cdktf.stringToHclTerraform(struct!.epRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extern_dynamic: {
      value: cdktf.stringToHclTerraform(struct!.externDynamic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extern_static: {
      value: cdktf.stringToHclTerraform(struct!.externStatic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gbp_pod_subnet: {
      value: cdktf.stringToHclTerraform(struct!.gbpPodSubnet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_agent_log_level: {
      value: cdktf.stringToHclTerraform(struct!.hostAgentLogLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.imagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_secret: {
      value: cdktf.stringToHclTerraform(struct!.imagePullSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    infra_vlan: {
      value: cdktf.stringToHclTerraform(struct!.infraVlan),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    install_istio: {
      value: cdktf.stringToHclTerraform(struct!.installIstio),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    istio_profile: {
      value: cdktf.stringToHclTerraform(struct!.istioProfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kafka_brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.kafkaBrokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    kafka_client_crt: {
      value: cdktf.stringToHclTerraform(struct!.kafkaClientCrt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kafka_client_key: {
      value: cdktf.stringToHclTerraform(struct!.kafkaClientKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kube_api_vlan: {
      value: cdktf.stringToHclTerraform(struct!.kubeApiVlan),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    l3out: {
      value: cdktf.stringToHclTerraform(struct!.l3Out),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    l3out_external_networks: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.l3OutExternalNetworks),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_nodes_svc_graph: {
      value: cdktf.stringToHclTerraform(struct!.maxNodesSvcGraph),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mcast_range_end: {
      value: cdktf.stringToHclTerraform(struct!.mcastRangeEnd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mcast_range_start: {
      value: cdktf.stringToHclTerraform(struct!.mcastRangeStart),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mtu_head_room: {
      value: cdktf.stringToHclTerraform(struct!.mtuHeadRoom),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    multus_disable: {
      value: cdktf.stringToHclTerraform(struct!.multusDisable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    no_priority_class: {
      value: cdktf.stringToHclTerraform(struct!.noPriorityClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_pod_if_enable: {
      value: cdktf.stringToHclTerraform(struct!.nodePodIfEnable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_subnet: {
      value: cdktf.stringToHclTerraform(struct!.nodeSubnet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_svc_subnet: {
      value: cdktf.stringToHclTerraform(struct!.nodeSvcSubnet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opflex_client_ssl: {
      value: cdktf.stringToHclTerraform(struct!.opflexClientSsl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opflex_device_delete_timeout: {
      value: cdktf.stringToHclTerraform(struct!.opflexDeviceDeleteTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opflex_log_level: {
      value: cdktf.stringToHclTerraform(struct!.opflexLogLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opflex_mode: {
      value: cdktf.stringToHclTerraform(struct!.opflexMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opflex_server_port: {
      value: cdktf.stringToHclTerraform(struct!.opflexServerPort),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    overlay_vrf_name: {
      value: cdktf.stringToHclTerraform(struct!.overlayVrfName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ovs_memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.ovsMemoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pbr_tracking_non_snat: {
      value: cdktf.stringToHclTerraform(struct!.pbrTrackingNonSnat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_subnet_chunk_size: {
      value: cdktf.stringToHclTerraform(struct!.podSubnetChunkSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    run_gbp_container: {
      value: cdktf.stringToHclTerraform(struct!.runGbpContainer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    run_opflex_server_container: {
      value: cdktf.stringToHclTerraform(struct!.runOpflexServerContainer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_monitor_interval: {
      value: cdktf.stringToHclTerraform(struct!.serviceMonitorInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_vlan: {
      value: cdktf.stringToHclTerraform(struct!.serviceVlan),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    snat_contract_scope: {
      value: cdktf.stringToHclTerraform(struct!.snatContractScope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    snat_namespace: {
      value: cdktf.stringToHclTerraform(struct!.snatNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    snat_port_range_end: {
      value: cdktf.stringToHclTerraform(struct!.snatPortRangeEnd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    snat_port_range_start: {
      value: cdktf.stringToHclTerraform(struct!.snatPortRangeStart),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    snat_ports_per_node: {
      value: cdktf.stringToHclTerraform(struct!.snatPortsPerNode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sriov_enable: {
      value: cdktf.stringToHclTerraform(struct!.sriovEnable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subnet_domain_name: {
      value: cdktf.stringToHclTerraform(struct!.subnetDomainName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    system_id: {
      value: cdktf.stringToHclTerraform(struct!.systemId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tenant: {
      value: cdktf.stringToHclTerraform(struct!.tenant),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_aci_anywhere_crd: {
      value: cdktf.stringToHclTerraform(struct!.useAciAnywhereCrd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_aci_cni_priority_class: {
      value: cdktf.stringToHclTerraform(struct!.useAciCniPriorityClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_cluster_role: {
      value: cdktf.stringToHclTerraform(struct!.useClusterRole),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_host_netns_volume: {
      value: cdktf.stringToHclTerraform(struct!.useHostNetnsVolume),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_opflex_server_volume: {
      value: cdktf.stringToHclTerraform(struct!.useOpflexServerVolume),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_privileged_container: {
      value: cdktf.stringToHclTerraform(struct!.usePrivilegedContainer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vmm_controller: {
      value: cdktf.stringToHclTerraform(struct!.vmmController),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vmm_domain: {
      value: cdktf.stringToHclTerraform(struct!.vmmDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vrf_name: {
      value: cdktf.stringToHclTerraform(struct!.vrfName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vrf_tenant: {
      value: cdktf.stringToHclTerraform(struct!.vrfTenant),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigNetworkAciNetworkProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigNetworkAciNetworkProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aep !== undefined) {
      hasAnyValues = true;
      internalValueResult.aep = this._aep;
    }
    if (this._apicHosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.apicHosts = this._apicHosts;
    }
    if (this._apicRefreshTickerAdjust !== undefined) {
      hasAnyValues = true;
      internalValueResult.apicRefreshTickerAdjust = this._apicRefreshTickerAdjust;
    }
    if (this._apicRefreshTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.apicRefreshTime = this._apicRefreshTime;
    }
    if (this._apicSubscriptionDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.apicSubscriptionDelay = this._apicSubscriptionDelay;
    }
    if (this._apicUserCrt !== undefined) {
      hasAnyValues = true;
      internalValueResult.apicUserCrt = this._apicUserCrt;
    }
    if (this._apicUserKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apicUserKey = this._apicUserKey;
    }
    if (this._apicUserName !== undefined) {
      hasAnyValues = true;
      internalValueResult.apicUserName = this._apicUserName;
    }
    if (this._capic !== undefined) {
      hasAnyValues = true;
      internalValueResult.capic = this._capic;
    }
    if (this._controllerLogLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.controllerLogLevel = this._controllerLogLevel;
    }
    if (this._disablePeriodicSnatGlobalInfoSync !== undefined) {
      hasAnyValues = true;
      internalValueResult.disablePeriodicSnatGlobalInfoSync = this._disablePeriodicSnatGlobalInfoSync;
    }
    if (this._disableWaitForNetwork !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableWaitForNetwork = this._disableWaitForNetwork;
    }
    if (this._dropLogEnable !== undefined) {
      hasAnyValues = true;
      internalValueResult.dropLogEnable = this._dropLogEnable;
    }
    if (this._durationWaitForNetwork !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationWaitForNetwork = this._durationWaitForNetwork;
    }
    if (this._enableEndpointSlice !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableEndpointSlice = this._enableEndpointSlice;
    }
    if (this._encapType !== undefined) {
      hasAnyValues = true;
      internalValueResult.encapType = this._encapType;
    }
    if (this._epRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.epRegistry = this._epRegistry;
    }
    if (this._externDynamic !== undefined) {
      hasAnyValues = true;
      internalValueResult.externDynamic = this._externDynamic;
    }
    if (this._externStatic !== undefined) {
      hasAnyValues = true;
      internalValueResult.externStatic = this._externStatic;
    }
    if (this._gbpPodSubnet !== undefined) {
      hasAnyValues = true;
      internalValueResult.gbpPodSubnet = this._gbpPodSubnet;
    }
    if (this._hostAgentLogLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostAgentLogLevel = this._hostAgentLogLevel;
    }
    if (this._imagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullPolicy = this._imagePullPolicy;
    }
    if (this._imagePullSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullSecret = this._imagePullSecret;
    }
    if (this._infraVlan !== undefined) {
      hasAnyValues = true;
      internalValueResult.infraVlan = this._infraVlan;
    }
    if (this._installIstio !== undefined) {
      hasAnyValues = true;
      internalValueResult.installIstio = this._installIstio;
    }
    if (this._istioProfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.istioProfile = this._istioProfile;
    }
    if (this._kafkaBrokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaBrokers = this._kafkaBrokers;
    }
    if (this._kafkaClientCrt !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaClientCrt = this._kafkaClientCrt;
    }
    if (this._kafkaClientKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaClientKey = this._kafkaClientKey;
    }
    if (this._kubeApiVlan !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeApiVlan = this._kubeApiVlan;
    }
    if (this._l3Out !== undefined) {
      hasAnyValues = true;
      internalValueResult.l3Out = this._l3Out;
    }
    if (this._l3OutExternalNetworks !== undefined) {
      hasAnyValues = true;
      internalValueResult.l3OutExternalNetworks = this._l3OutExternalNetworks;
    }
    if (this._maxNodesSvcGraph !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNodesSvcGraph = this._maxNodesSvcGraph;
    }
    if (this._mcastRangeEnd !== undefined) {
      hasAnyValues = true;
      internalValueResult.mcastRangeEnd = this._mcastRangeEnd;
    }
    if (this._mcastRangeStart !== undefined) {
      hasAnyValues = true;
      internalValueResult.mcastRangeStart = this._mcastRangeStart;
    }
    if (this._mtuHeadRoom !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtuHeadRoom = this._mtuHeadRoom;
    }
    if (this._multusDisable !== undefined) {
      hasAnyValues = true;
      internalValueResult.multusDisable = this._multusDisable;
    }
    if (this._noPriorityClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.noPriorityClass = this._noPriorityClass;
    }
    if (this._nodePodIfEnable !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodePodIfEnable = this._nodePodIfEnable;
    }
    if (this._nodeSubnet !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSubnet = this._nodeSubnet;
    }
    if (this._nodeSvcSubnet !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSvcSubnet = this._nodeSvcSubnet;
    }
    if (this._opflexClientSsl !== undefined) {
      hasAnyValues = true;
      internalValueResult.opflexClientSsl = this._opflexClientSsl;
    }
    if (this._opflexDeviceDeleteTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.opflexDeviceDeleteTimeout = this._opflexDeviceDeleteTimeout;
    }
    if (this._opflexLogLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.opflexLogLevel = this._opflexLogLevel;
    }
    if (this._opflexMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.opflexMode = this._opflexMode;
    }
    if (this._opflexServerPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.opflexServerPort = this._opflexServerPort;
    }
    if (this._overlayVrfName !== undefined) {
      hasAnyValues = true;
      internalValueResult.overlayVrfName = this._overlayVrfName;
    }
    if (this._ovsMemoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ovsMemoryLimit = this._ovsMemoryLimit;
    }
    if (this._pbrTrackingNonSnat !== undefined) {
      hasAnyValues = true;
      internalValueResult.pbrTrackingNonSnat = this._pbrTrackingNonSnat;
    }
    if (this._podSubnetChunkSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSubnetChunkSize = this._podSubnetChunkSize;
    }
    if (this._runGbpContainer !== undefined) {
      hasAnyValues = true;
      internalValueResult.runGbpContainer = this._runGbpContainer;
    }
    if (this._runOpflexServerContainer !== undefined) {
      hasAnyValues = true;
      internalValueResult.runOpflexServerContainer = this._runOpflexServerContainer;
    }
    if (this._serviceMonitorInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceMonitorInterval = this._serviceMonitorInterval;
    }
    if (this._serviceVlan !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceVlan = this._serviceVlan;
    }
    if (this._snatContractScope !== undefined) {
      hasAnyValues = true;
      internalValueResult.snatContractScope = this._snatContractScope;
    }
    if (this._snatNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.snatNamespace = this._snatNamespace;
    }
    if (this._snatPortRangeEnd !== undefined) {
      hasAnyValues = true;
      internalValueResult.snatPortRangeEnd = this._snatPortRangeEnd;
    }
    if (this._snatPortRangeStart !== undefined) {
      hasAnyValues = true;
      internalValueResult.snatPortRangeStart = this._snatPortRangeStart;
    }
    if (this._snatPortsPerNode !== undefined) {
      hasAnyValues = true;
      internalValueResult.snatPortsPerNode = this._snatPortsPerNode;
    }
    if (this._sriovEnable !== undefined) {
      hasAnyValues = true;
      internalValueResult.sriovEnable = this._sriovEnable;
    }
    if (this._subnetDomainName !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnetDomainName = this._subnetDomainName;
    }
    if (this._systemId !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemId = this._systemId;
    }
    if (this._tenant !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenant = this._tenant;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._useAciAnywhereCrd !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAciAnywhereCrd = this._useAciAnywhereCrd;
    }
    if (this._useAciCniPriorityClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAciCniPriorityClass = this._useAciCniPriorityClass;
    }
    if (this._useClusterRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.useClusterRole = this._useClusterRole;
    }
    if (this._useHostNetnsVolume !== undefined) {
      hasAnyValues = true;
      internalValueResult.useHostNetnsVolume = this._useHostNetnsVolume;
    }
    if (this._useOpflexServerVolume !== undefined) {
      hasAnyValues = true;
      internalValueResult.useOpflexServerVolume = this._useOpflexServerVolume;
    }
    if (this._usePrivilegedContainer !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePrivilegedContainer = this._usePrivilegedContainer;
    }
    if (this._vmmController !== undefined) {
      hasAnyValues = true;
      internalValueResult.vmmController = this._vmmController;
    }
    if (this._vmmDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.vmmDomain = this._vmmDomain;
    }
    if (this._vrfName !== undefined) {
      hasAnyValues = true;
      internalValueResult.vrfName = this._vrfName;
    }
    if (this._vrfTenant !== undefined) {
      hasAnyValues = true;
      internalValueResult.vrfTenant = this._vrfTenant;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigNetworkAciNetworkProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._aep = undefined;
      this._apicHosts = undefined;
      this._apicRefreshTickerAdjust = undefined;
      this._apicRefreshTime = undefined;
      this._apicSubscriptionDelay = undefined;
      this._apicUserCrt = undefined;
      this._apicUserKey = undefined;
      this._apicUserName = undefined;
      this._capic = undefined;
      this._controllerLogLevel = undefined;
      this._disablePeriodicSnatGlobalInfoSync = undefined;
      this._disableWaitForNetwork = undefined;
      this._dropLogEnable = undefined;
      this._durationWaitForNetwork = undefined;
      this._enableEndpointSlice = undefined;
      this._encapType = undefined;
      this._epRegistry = undefined;
      this._externDynamic = undefined;
      this._externStatic = undefined;
      this._gbpPodSubnet = undefined;
      this._hostAgentLogLevel = undefined;
      this._imagePullPolicy = undefined;
      this._imagePullSecret = undefined;
      this._infraVlan = undefined;
      this._installIstio = undefined;
      this._istioProfile = undefined;
      this._kafkaBrokers = undefined;
      this._kafkaClientCrt = undefined;
      this._kafkaClientKey = undefined;
      this._kubeApiVlan = undefined;
      this._l3Out = undefined;
      this._l3OutExternalNetworks = undefined;
      this._maxNodesSvcGraph = undefined;
      this._mcastRangeEnd = undefined;
      this._mcastRangeStart = undefined;
      this._mtuHeadRoom = undefined;
      this._multusDisable = undefined;
      this._noPriorityClass = undefined;
      this._nodePodIfEnable = undefined;
      this._nodeSubnet = undefined;
      this._nodeSvcSubnet = undefined;
      this._opflexClientSsl = undefined;
      this._opflexDeviceDeleteTimeout = undefined;
      this._opflexLogLevel = undefined;
      this._opflexMode = undefined;
      this._opflexServerPort = undefined;
      this._overlayVrfName = undefined;
      this._ovsMemoryLimit = undefined;
      this._pbrTrackingNonSnat = undefined;
      this._podSubnetChunkSize = undefined;
      this._runGbpContainer = undefined;
      this._runOpflexServerContainer = undefined;
      this._serviceMonitorInterval = undefined;
      this._serviceVlan = undefined;
      this._snatContractScope = undefined;
      this._snatNamespace = undefined;
      this._snatPortRangeEnd = undefined;
      this._snatPortRangeStart = undefined;
      this._snatPortsPerNode = undefined;
      this._sriovEnable = undefined;
      this._subnetDomainName = undefined;
      this._systemId = undefined;
      this._tenant = undefined;
      this._token = undefined;
      this._useAciAnywhereCrd = undefined;
      this._useAciCniPriorityClass = undefined;
      this._useClusterRole = undefined;
      this._useHostNetnsVolume = undefined;
      this._useOpflexServerVolume = undefined;
      this._usePrivilegedContainer = undefined;
      this._vmmController = undefined;
      this._vmmDomain = undefined;
      this._vrfName = undefined;
      this._vrfTenant = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._aep = value.aep;
      this._apicHosts = value.apicHosts;
      this._apicRefreshTickerAdjust = value.apicRefreshTickerAdjust;
      this._apicRefreshTime = value.apicRefreshTime;
      this._apicSubscriptionDelay = value.apicSubscriptionDelay;
      this._apicUserCrt = value.apicUserCrt;
      this._apicUserKey = value.apicUserKey;
      this._apicUserName = value.apicUserName;
      this._capic = value.capic;
      this._controllerLogLevel = value.controllerLogLevel;
      this._disablePeriodicSnatGlobalInfoSync = value.disablePeriodicSnatGlobalInfoSync;
      this._disableWaitForNetwork = value.disableWaitForNetwork;
      this._dropLogEnable = value.dropLogEnable;
      this._durationWaitForNetwork = value.durationWaitForNetwork;
      this._enableEndpointSlice = value.enableEndpointSlice;
      this._encapType = value.encapType;
      this._epRegistry = value.epRegistry;
      this._externDynamic = value.externDynamic;
      this._externStatic = value.externStatic;
      this._gbpPodSubnet = value.gbpPodSubnet;
      this._hostAgentLogLevel = value.hostAgentLogLevel;
      this._imagePullPolicy = value.imagePullPolicy;
      this._imagePullSecret = value.imagePullSecret;
      this._infraVlan = value.infraVlan;
      this._installIstio = value.installIstio;
      this._istioProfile = value.istioProfile;
      this._kafkaBrokers = value.kafkaBrokers;
      this._kafkaClientCrt = value.kafkaClientCrt;
      this._kafkaClientKey = value.kafkaClientKey;
      this._kubeApiVlan = value.kubeApiVlan;
      this._l3Out = value.l3Out;
      this._l3OutExternalNetworks = value.l3OutExternalNetworks;
      this._maxNodesSvcGraph = value.maxNodesSvcGraph;
      this._mcastRangeEnd = value.mcastRangeEnd;
      this._mcastRangeStart = value.mcastRangeStart;
      this._mtuHeadRoom = value.mtuHeadRoom;
      this._multusDisable = value.multusDisable;
      this._noPriorityClass = value.noPriorityClass;
      this._nodePodIfEnable = value.nodePodIfEnable;
      this._nodeSubnet = value.nodeSubnet;
      this._nodeSvcSubnet = value.nodeSvcSubnet;
      this._opflexClientSsl = value.opflexClientSsl;
      this._opflexDeviceDeleteTimeout = value.opflexDeviceDeleteTimeout;
      this._opflexLogLevel = value.opflexLogLevel;
      this._opflexMode = value.opflexMode;
      this._opflexServerPort = value.opflexServerPort;
      this._overlayVrfName = value.overlayVrfName;
      this._ovsMemoryLimit = value.ovsMemoryLimit;
      this._pbrTrackingNonSnat = value.pbrTrackingNonSnat;
      this._podSubnetChunkSize = value.podSubnetChunkSize;
      this._runGbpContainer = value.runGbpContainer;
      this._runOpflexServerContainer = value.runOpflexServerContainer;
      this._serviceMonitorInterval = value.serviceMonitorInterval;
      this._serviceVlan = value.serviceVlan;
      this._snatContractScope = value.snatContractScope;
      this._snatNamespace = value.snatNamespace;
      this._snatPortRangeEnd = value.snatPortRangeEnd;
      this._snatPortRangeStart = value.snatPortRangeStart;
      this._snatPortsPerNode = value.snatPortsPerNode;
      this._sriovEnable = value.sriovEnable;
      this._subnetDomainName = value.subnetDomainName;
      this._systemId = value.systemId;
      this._tenant = value.tenant;
      this._token = value.token;
      this._useAciAnywhereCrd = value.useAciAnywhereCrd;
      this._useAciCniPriorityClass = value.useAciCniPriorityClass;
      this._useClusterRole = value.useClusterRole;
      this._useHostNetnsVolume = value.useHostNetnsVolume;
      this._useOpflexServerVolume = value.useOpflexServerVolume;
      this._usePrivilegedContainer = value.usePrivilegedContainer;
      this._vmmController = value.vmmController;
      this._vmmDomain = value.vmmDomain;
      this._vrfName = value.vrfName;
      this._vrfTenant = value.vrfTenant;
    }
  }

  // aep - computed: false, optional: false, required: true
  private _aep?: string; 
  public get aep() {
    return this.getStringAttribute('aep');
  }
  public set aep(value: string) {
    this._aep = value;
  }
  // Temporarily expose input value. Use with caution.
  public get aepInput() {
    return this._aep;
  }

  // apic_hosts - computed: false, optional: false, required: true
  private _apicHosts?: string[]; 
  public get apicHosts() {
    return this.getListAttribute('apic_hosts');
  }
  public set apicHosts(value: string[]) {
    this._apicHosts = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apicHostsInput() {
    return this._apicHosts;
  }

  // apic_refresh_ticker_adjust - computed: false, optional: true, required: false
  private _apicRefreshTickerAdjust?: string; 
  public get apicRefreshTickerAdjust() {
    return this.getStringAttribute('apic_refresh_ticker_adjust');
  }
  public set apicRefreshTickerAdjust(value: string) {
    this._apicRefreshTickerAdjust = value;
  }
  public resetApicRefreshTickerAdjust() {
    this._apicRefreshTickerAdjust = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apicRefreshTickerAdjustInput() {
    return this._apicRefreshTickerAdjust;
  }

  // apic_refresh_time - computed: false, optional: true, required: false
  private _apicRefreshTime?: string; 
  public get apicRefreshTime() {
    return this.getStringAttribute('apic_refresh_time');
  }
  public set apicRefreshTime(value: string) {
    this._apicRefreshTime = value;
  }
  public resetApicRefreshTime() {
    this._apicRefreshTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apicRefreshTimeInput() {
    return this._apicRefreshTime;
  }

  // apic_subscription_delay - computed: false, optional: true, required: false
  private _apicSubscriptionDelay?: string; 
  public get apicSubscriptionDelay() {
    return this.getStringAttribute('apic_subscription_delay');
  }
  public set apicSubscriptionDelay(value: string) {
    this._apicSubscriptionDelay = value;
  }
  public resetApicSubscriptionDelay() {
    this._apicSubscriptionDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apicSubscriptionDelayInput() {
    return this._apicSubscriptionDelay;
  }

  // apic_user_crt - computed: false, optional: false, required: true
  private _apicUserCrt?: string; 
  public get apicUserCrt() {
    return this.getStringAttribute('apic_user_crt');
  }
  public set apicUserCrt(value: string) {
    this._apicUserCrt = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apicUserCrtInput() {
    return this._apicUserCrt;
  }

  // apic_user_key - computed: false, optional: false, required: true
  private _apicUserKey?: string; 
  public get apicUserKey() {
    return this.getStringAttribute('apic_user_key');
  }
  public set apicUserKey(value: string) {
    this._apicUserKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apicUserKeyInput() {
    return this._apicUserKey;
  }

  // apic_user_name - computed: false, optional: false, required: true
  private _apicUserName?: string; 
  public get apicUserName() {
    return this.getStringAttribute('apic_user_name');
  }
  public set apicUserName(value: string) {
    this._apicUserName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apicUserNameInput() {
    return this._apicUserName;
  }

  // capic - computed: false, optional: true, required: false
  private _capic?: string; 
  public get capic() {
    return this.getStringAttribute('capic');
  }
  public set capic(value: string) {
    this._capic = value;
  }
  public resetCapic() {
    this._capic = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get capicInput() {
    return this._capic;
  }

  // controller_log_level - computed: false, optional: true, required: false
  private _controllerLogLevel?: string; 
  public get controllerLogLevel() {
    return this.getStringAttribute('controller_log_level');
  }
  public set controllerLogLevel(value: string) {
    this._controllerLogLevel = value;
  }
  public resetControllerLogLevel() {
    this._controllerLogLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get controllerLogLevelInput() {
    return this._controllerLogLevel;
  }

  // disable_periodic_snat_global_info_sync - computed: false, optional: true, required: false
  private _disablePeriodicSnatGlobalInfoSync?: string; 
  public get disablePeriodicSnatGlobalInfoSync() {
    return this.getStringAttribute('disable_periodic_snat_global_info_sync');
  }
  public set disablePeriodicSnatGlobalInfoSync(value: string) {
    this._disablePeriodicSnatGlobalInfoSync = value;
  }
  public resetDisablePeriodicSnatGlobalInfoSync() {
    this._disablePeriodicSnatGlobalInfoSync = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disablePeriodicSnatGlobalInfoSyncInput() {
    return this._disablePeriodicSnatGlobalInfoSync;
  }

  // disable_wait_for_network - computed: false, optional: true, required: false
  private _disableWaitForNetwork?: string; 
  public get disableWaitForNetwork() {
    return this.getStringAttribute('disable_wait_for_network');
  }
  public set disableWaitForNetwork(value: string) {
    this._disableWaitForNetwork = value;
  }
  public resetDisableWaitForNetwork() {
    this._disableWaitForNetwork = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableWaitForNetworkInput() {
    return this._disableWaitForNetwork;
  }

  // drop_log_enable - computed: false, optional: true, required: false
  private _dropLogEnable?: string; 
  public get dropLogEnable() {
    return this.getStringAttribute('drop_log_enable');
  }
  public set dropLogEnable(value: string) {
    this._dropLogEnable = value;
  }
  public resetDropLogEnable() {
    this._dropLogEnable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dropLogEnableInput() {
    return this._dropLogEnable;
  }

  // duration_wait_for_network - computed: false, optional: true, required: false
  private _durationWaitForNetwork?: string; 
  public get durationWaitForNetwork() {
    return this.getStringAttribute('duration_wait_for_network');
  }
  public set durationWaitForNetwork(value: string) {
    this._durationWaitForNetwork = value;
  }
  public resetDurationWaitForNetwork() {
    this._durationWaitForNetwork = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationWaitForNetworkInput() {
    return this._durationWaitForNetwork;
  }

  // enable_endpoint_slice - computed: false, optional: true, required: false
  private _enableEndpointSlice?: string; 
  public get enableEndpointSlice() {
    return this.getStringAttribute('enable_endpoint_slice');
  }
  public set enableEndpointSlice(value: string) {
    this._enableEndpointSlice = value;
  }
  public resetEnableEndpointSlice() {
    this._enableEndpointSlice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableEndpointSliceInput() {
    return this._enableEndpointSlice;
  }

  // encap_type - computed: false, optional: false, required: true
  private _encapType?: string; 
  public get encapType() {
    return this.getStringAttribute('encap_type');
  }
  public set encapType(value: string) {
    this._encapType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get encapTypeInput() {
    return this._encapType;
  }

  // ep_registry - computed: false, optional: true, required: false
  private _epRegistry?: string; 
  public get epRegistry() {
    return this.getStringAttribute('ep_registry');
  }
  public set epRegistry(value: string) {
    this._epRegistry = value;
  }
  public resetEpRegistry() {
    this._epRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get epRegistryInput() {
    return this._epRegistry;
  }

  // extern_dynamic - computed: false, optional: false, required: true
  private _externDynamic?: string; 
  public get externDynamic() {
    return this.getStringAttribute('extern_dynamic');
  }
  public set externDynamic(value: string) {
    this._externDynamic = value;
  }
  // Temporarily expose input value. Use with caution.
  public get externDynamicInput() {
    return this._externDynamic;
  }

  // extern_static - computed: false, optional: false, required: true
  private _externStatic?: string; 
  public get externStatic() {
    return this.getStringAttribute('extern_static');
  }
  public set externStatic(value: string) {
    this._externStatic = value;
  }
  // Temporarily expose input value. Use with caution.
  public get externStaticInput() {
    return this._externStatic;
  }

  // gbp_pod_subnet - computed: false, optional: true, required: false
  private _gbpPodSubnet?: string; 
  public get gbpPodSubnet() {
    return this.getStringAttribute('gbp_pod_subnet');
  }
  public set gbpPodSubnet(value: string) {
    this._gbpPodSubnet = value;
  }
  public resetGbpPodSubnet() {
    this._gbpPodSubnet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gbpPodSubnetInput() {
    return this._gbpPodSubnet;
  }

  // host_agent_log_level - computed: false, optional: true, required: false
  private _hostAgentLogLevel?: string; 
  public get hostAgentLogLevel() {
    return this.getStringAttribute('host_agent_log_level');
  }
  public set hostAgentLogLevel(value: string) {
    this._hostAgentLogLevel = value;
  }
  public resetHostAgentLogLevel() {
    this._hostAgentLogLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostAgentLogLevelInput() {
    return this._hostAgentLogLevel;
  }

  // image_pull_policy - computed: false, optional: true, required: false
  private _imagePullPolicy?: string; 
  public get imagePullPolicy() {
    return this.getStringAttribute('image_pull_policy');
  }
  public set imagePullPolicy(value: string) {
    this._imagePullPolicy = value;
  }
  public resetImagePullPolicy() {
    this._imagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullPolicyInput() {
    return this._imagePullPolicy;
  }

  // image_pull_secret - computed: false, optional: true, required: false
  private _imagePullSecret?: string; 
  public get imagePullSecret() {
    return this.getStringAttribute('image_pull_secret');
  }
  public set imagePullSecret(value: string) {
    this._imagePullSecret = value;
  }
  public resetImagePullSecret() {
    this._imagePullSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullSecretInput() {
    return this._imagePullSecret;
  }

  // infra_vlan - computed: false, optional: true, required: false
  private _infraVlan?: string; 
  public get infraVlan() {
    return this.getStringAttribute('infra_vlan');
  }
  public set infraVlan(value: string) {
    this._infraVlan = value;
  }
  public resetInfraVlan() {
    this._infraVlan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get infraVlanInput() {
    return this._infraVlan;
  }

  // install_istio - computed: false, optional: true, required: false
  private _installIstio?: string; 
  public get installIstio() {
    return this.getStringAttribute('install_istio');
  }
  public set installIstio(value: string) {
    this._installIstio = value;
  }
  public resetInstallIstio() {
    this._installIstio = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get installIstioInput() {
    return this._installIstio;
  }

  // istio_profile - computed: false, optional: true, required: false
  private _istioProfile?: string; 
  public get istioProfile() {
    return this.getStringAttribute('istio_profile');
  }
  public set istioProfile(value: string) {
    this._istioProfile = value;
  }
  public resetIstioProfile() {
    this._istioProfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get istioProfileInput() {
    return this._istioProfile;
  }

  // kafka_brokers - computed: false, optional: true, required: false
  private _kafkaBrokers?: string[]; 
  public get kafkaBrokers() {
    return this.getListAttribute('kafka_brokers');
  }
  public set kafkaBrokers(value: string[]) {
    this._kafkaBrokers = value;
  }
  public resetKafkaBrokers() {
    this._kafkaBrokers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaBrokersInput() {
    return this._kafkaBrokers;
  }

  // kafka_client_crt - computed: false, optional: true, required: false
  private _kafkaClientCrt?: string; 
  public get kafkaClientCrt() {
    return this.getStringAttribute('kafka_client_crt');
  }
  public set kafkaClientCrt(value: string) {
    this._kafkaClientCrt = value;
  }
  public resetKafkaClientCrt() {
    this._kafkaClientCrt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaClientCrtInput() {
    return this._kafkaClientCrt;
  }

  // kafka_client_key - computed: false, optional: true, required: false
  private _kafkaClientKey?: string; 
  public get kafkaClientKey() {
    return this.getStringAttribute('kafka_client_key');
  }
  public set kafkaClientKey(value: string) {
    this._kafkaClientKey = value;
  }
  public resetKafkaClientKey() {
    this._kafkaClientKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaClientKeyInput() {
    return this._kafkaClientKey;
  }

  // kube_api_vlan - computed: false, optional: false, required: true
  private _kubeApiVlan?: string; 
  public get kubeApiVlan() {
    return this.getStringAttribute('kube_api_vlan');
  }
  public set kubeApiVlan(value: string) {
    this._kubeApiVlan = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeApiVlanInput() {
    return this._kubeApiVlan;
  }

  // l3out - computed: false, optional: false, required: true
  private _l3Out?: string; 
  public get l3Out() {
    return this.getStringAttribute('l3out');
  }
  public set l3Out(value: string) {
    this._l3Out = value;
  }
  // Temporarily expose input value. Use with caution.
  public get l3OutInput() {
    return this._l3Out;
  }

  // l3out_external_networks - computed: false, optional: false, required: true
  private _l3OutExternalNetworks?: string[]; 
  public get l3OutExternalNetworks() {
    return this.getListAttribute('l3out_external_networks');
  }
  public set l3OutExternalNetworks(value: string[]) {
    this._l3OutExternalNetworks = value;
  }
  // Temporarily expose input value. Use with caution.
  public get l3OutExternalNetworksInput() {
    return this._l3OutExternalNetworks;
  }

  // max_nodes_svc_graph - computed: false, optional: true, required: false
  private _maxNodesSvcGraph?: string; 
  public get maxNodesSvcGraph() {
    return this.getStringAttribute('max_nodes_svc_graph');
  }
  public set maxNodesSvcGraph(value: string) {
    this._maxNodesSvcGraph = value;
  }
  public resetMaxNodesSvcGraph() {
    this._maxNodesSvcGraph = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNodesSvcGraphInput() {
    return this._maxNodesSvcGraph;
  }

  // mcast_range_end - computed: false, optional: false, required: true
  private _mcastRangeEnd?: string; 
  public get mcastRangeEnd() {
    return this.getStringAttribute('mcast_range_end');
  }
  public set mcastRangeEnd(value: string) {
    this._mcastRangeEnd = value;
  }
  // Temporarily expose input value. Use with caution.
  public get mcastRangeEndInput() {
    return this._mcastRangeEnd;
  }

  // mcast_range_start - computed: false, optional: false, required: true
  private _mcastRangeStart?: string; 
  public get mcastRangeStart() {
    return this.getStringAttribute('mcast_range_start');
  }
  public set mcastRangeStart(value: string) {
    this._mcastRangeStart = value;
  }
  // Temporarily expose input value. Use with caution.
  public get mcastRangeStartInput() {
    return this._mcastRangeStart;
  }

  // mtu_head_room - computed: false, optional: true, required: false
  private _mtuHeadRoom?: string; 
  public get mtuHeadRoom() {
    return this.getStringAttribute('mtu_head_room');
  }
  public set mtuHeadRoom(value: string) {
    this._mtuHeadRoom = value;
  }
  public resetMtuHeadRoom() {
    this._mtuHeadRoom = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuHeadRoomInput() {
    return this._mtuHeadRoom;
  }

  // multus_disable - computed: false, optional: true, required: false
  private _multusDisable?: string; 
  public get multusDisable() {
    return this.getStringAttribute('multus_disable');
  }
  public set multusDisable(value: string) {
    this._multusDisable = value;
  }
  public resetMultusDisable() {
    this._multusDisable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multusDisableInput() {
    return this._multusDisable;
  }

  // no_priority_class - computed: false, optional: true, required: false
  private _noPriorityClass?: string; 
  public get noPriorityClass() {
    return this.getStringAttribute('no_priority_class');
  }
  public set noPriorityClass(value: string) {
    this._noPriorityClass = value;
  }
  public resetNoPriorityClass() {
    this._noPriorityClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noPriorityClassInput() {
    return this._noPriorityClass;
  }

  // node_pod_if_enable - computed: false, optional: true, required: false
  private _nodePodIfEnable?: string; 
  public get nodePodIfEnable() {
    return this.getStringAttribute('node_pod_if_enable');
  }
  public set nodePodIfEnable(value: string) {
    this._nodePodIfEnable = value;
  }
  public resetNodePodIfEnable() {
    this._nodePodIfEnable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodePodIfEnableInput() {
    return this._nodePodIfEnable;
  }

  // node_subnet - computed: false, optional: false, required: true
  private _nodeSubnet?: string; 
  public get nodeSubnet() {
    return this.getStringAttribute('node_subnet');
  }
  public set nodeSubnet(value: string) {
    this._nodeSubnet = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSubnetInput() {
    return this._nodeSubnet;
  }

  // node_svc_subnet - computed: false, optional: false, required: true
  private _nodeSvcSubnet?: string; 
  public get nodeSvcSubnet() {
    return this.getStringAttribute('node_svc_subnet');
  }
  public set nodeSvcSubnet(value: string) {
    this._nodeSvcSubnet = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSvcSubnetInput() {
    return this._nodeSvcSubnet;
  }

  // opflex_client_ssl - computed: false, optional: true, required: false
  private _opflexClientSsl?: string; 
  public get opflexClientSsl() {
    return this.getStringAttribute('opflex_client_ssl');
  }
  public set opflexClientSsl(value: string) {
    this._opflexClientSsl = value;
  }
  public resetOpflexClientSsl() {
    this._opflexClientSsl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opflexClientSslInput() {
    return this._opflexClientSsl;
  }

  // opflex_device_delete_timeout - computed: false, optional: true, required: false
  private _opflexDeviceDeleteTimeout?: string; 
  public get opflexDeviceDeleteTimeout() {
    return this.getStringAttribute('opflex_device_delete_timeout');
  }
  public set opflexDeviceDeleteTimeout(value: string) {
    this._opflexDeviceDeleteTimeout = value;
  }
  public resetOpflexDeviceDeleteTimeout() {
    this._opflexDeviceDeleteTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opflexDeviceDeleteTimeoutInput() {
    return this._opflexDeviceDeleteTimeout;
  }

  // opflex_log_level - computed: false, optional: true, required: false
  private _opflexLogLevel?: string; 
  public get opflexLogLevel() {
    return this.getStringAttribute('opflex_log_level');
  }
  public set opflexLogLevel(value: string) {
    this._opflexLogLevel = value;
  }
  public resetOpflexLogLevel() {
    this._opflexLogLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opflexLogLevelInput() {
    return this._opflexLogLevel;
  }

  // opflex_mode - computed: false, optional: true, required: false
  private _opflexMode?: string; 
  public get opflexMode() {
    return this.getStringAttribute('opflex_mode');
  }
  public set opflexMode(value: string) {
    this._opflexMode = value;
  }
  public resetOpflexMode() {
    this._opflexMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opflexModeInput() {
    return this._opflexMode;
  }

  // opflex_server_port - computed: false, optional: true, required: false
  private _opflexServerPort?: string; 
  public get opflexServerPort() {
    return this.getStringAttribute('opflex_server_port');
  }
  public set opflexServerPort(value: string) {
    this._opflexServerPort = value;
  }
  public resetOpflexServerPort() {
    this._opflexServerPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opflexServerPortInput() {
    return this._opflexServerPort;
  }

  // overlay_vrf_name - computed: false, optional: true, required: false
  private _overlayVrfName?: string; 
  public get overlayVrfName() {
    return this.getStringAttribute('overlay_vrf_name');
  }
  public set overlayVrfName(value: string) {
    this._overlayVrfName = value;
  }
  public resetOverlayVrfName() {
    this._overlayVrfName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overlayVrfNameInput() {
    return this._overlayVrfName;
  }

  // ovs_memory_limit - computed: false, optional: true, required: false
  private _ovsMemoryLimit?: string; 
  public get ovsMemoryLimit() {
    return this.getStringAttribute('ovs_memory_limit');
  }
  public set ovsMemoryLimit(value: string) {
    this._ovsMemoryLimit = value;
  }
  public resetOvsMemoryLimit() {
    this._ovsMemoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ovsMemoryLimitInput() {
    return this._ovsMemoryLimit;
  }

  // pbr_tracking_non_snat - computed: false, optional: true, required: false
  private _pbrTrackingNonSnat?: string; 
  public get pbrTrackingNonSnat() {
    return this.getStringAttribute('pbr_tracking_non_snat');
  }
  public set pbrTrackingNonSnat(value: string) {
    this._pbrTrackingNonSnat = value;
  }
  public resetPbrTrackingNonSnat() {
    this._pbrTrackingNonSnat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pbrTrackingNonSnatInput() {
    return this._pbrTrackingNonSnat;
  }

  // pod_subnet_chunk_size - computed: false, optional: true, required: false
  private _podSubnetChunkSize?: string; 
  public get podSubnetChunkSize() {
    return this.getStringAttribute('pod_subnet_chunk_size');
  }
  public set podSubnetChunkSize(value: string) {
    this._podSubnetChunkSize = value;
  }
  public resetPodSubnetChunkSize() {
    this._podSubnetChunkSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSubnetChunkSizeInput() {
    return this._podSubnetChunkSize;
  }

  // run_gbp_container - computed: false, optional: true, required: false
  private _runGbpContainer?: string; 
  public get runGbpContainer() {
    return this.getStringAttribute('run_gbp_container');
  }
  public set runGbpContainer(value: string) {
    this._runGbpContainer = value;
  }
  public resetRunGbpContainer() {
    this._runGbpContainer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runGbpContainerInput() {
    return this._runGbpContainer;
  }

  // run_opflex_server_container - computed: false, optional: true, required: false
  private _runOpflexServerContainer?: string; 
  public get runOpflexServerContainer() {
    return this.getStringAttribute('run_opflex_server_container');
  }
  public set runOpflexServerContainer(value: string) {
    this._runOpflexServerContainer = value;
  }
  public resetRunOpflexServerContainer() {
    this._runOpflexServerContainer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runOpflexServerContainerInput() {
    return this._runOpflexServerContainer;
  }

  // service_monitor_interval - computed: false, optional: true, required: false
  private _serviceMonitorInterval?: string; 
  public get serviceMonitorInterval() {
    return this.getStringAttribute('service_monitor_interval');
  }
  public set serviceMonitorInterval(value: string) {
    this._serviceMonitorInterval = value;
  }
  public resetServiceMonitorInterval() {
    this._serviceMonitorInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceMonitorIntervalInput() {
    return this._serviceMonitorInterval;
  }

  // service_vlan - computed: false, optional: false, required: true
  private _serviceVlan?: string; 
  public get serviceVlan() {
    return this.getStringAttribute('service_vlan');
  }
  public set serviceVlan(value: string) {
    this._serviceVlan = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceVlanInput() {
    return this._serviceVlan;
  }

  // snat_contract_scope - computed: false, optional: true, required: false
  private _snatContractScope?: string; 
  public get snatContractScope() {
    return this.getStringAttribute('snat_contract_scope');
  }
  public set snatContractScope(value: string) {
    this._snatContractScope = value;
  }
  public resetSnatContractScope() {
    this._snatContractScope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snatContractScopeInput() {
    return this._snatContractScope;
  }

  // snat_namespace - computed: false, optional: true, required: false
  private _snatNamespace?: string; 
  public get snatNamespace() {
    return this.getStringAttribute('snat_namespace');
  }
  public set snatNamespace(value: string) {
    this._snatNamespace = value;
  }
  public resetSnatNamespace() {
    this._snatNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snatNamespaceInput() {
    return this._snatNamespace;
  }

  // snat_port_range_end - computed: false, optional: true, required: false
  private _snatPortRangeEnd?: string; 
  public get snatPortRangeEnd() {
    return this.getStringAttribute('snat_port_range_end');
  }
  public set snatPortRangeEnd(value: string) {
    this._snatPortRangeEnd = value;
  }
  public resetSnatPortRangeEnd() {
    this._snatPortRangeEnd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snatPortRangeEndInput() {
    return this._snatPortRangeEnd;
  }

  // snat_port_range_start - computed: false, optional: true, required: false
  private _snatPortRangeStart?: string; 
  public get snatPortRangeStart() {
    return this.getStringAttribute('snat_port_range_start');
  }
  public set snatPortRangeStart(value: string) {
    this._snatPortRangeStart = value;
  }
  public resetSnatPortRangeStart() {
    this._snatPortRangeStart = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snatPortRangeStartInput() {
    return this._snatPortRangeStart;
  }

  // snat_ports_per_node - computed: false, optional: true, required: false
  private _snatPortsPerNode?: string; 
  public get snatPortsPerNode() {
    return this.getStringAttribute('snat_ports_per_node');
  }
  public set snatPortsPerNode(value: string) {
    this._snatPortsPerNode = value;
  }
  public resetSnatPortsPerNode() {
    this._snatPortsPerNode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snatPortsPerNodeInput() {
    return this._snatPortsPerNode;
  }

  // sriov_enable - computed: false, optional: true, required: false
  private _sriovEnable?: string; 
  public get sriovEnable() {
    return this.getStringAttribute('sriov_enable');
  }
  public set sriovEnable(value: string) {
    this._sriovEnable = value;
  }
  public resetSriovEnable() {
    this._sriovEnable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sriovEnableInput() {
    return this._sriovEnable;
  }

  // subnet_domain_name - computed: false, optional: true, required: false
  private _subnetDomainName?: string; 
  public get subnetDomainName() {
    return this.getStringAttribute('subnet_domain_name');
  }
  public set subnetDomainName(value: string) {
    this._subnetDomainName = value;
  }
  public resetSubnetDomainName() {
    this._subnetDomainName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetDomainNameInput() {
    return this._subnetDomainName;
  }

  // system_id - computed: false, optional: false, required: true
  private _systemId?: string; 
  public get systemId() {
    return this.getStringAttribute('system_id');
  }
  public set systemId(value: string) {
    this._systemId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get systemIdInput() {
    return this._systemId;
  }

  // tenant - computed: false, optional: true, required: false
  private _tenant?: string; 
  public get tenant() {
    return this.getStringAttribute('tenant');
  }
  public set tenant(value: string) {
    this._tenant = value;
  }
  public resetTenant() {
    this._tenant = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantInput() {
    return this._tenant;
  }

  // token - computed: false, optional: false, required: true
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // use_aci_anywhere_crd - computed: false, optional: true, required: false
  private _useAciAnywhereCrd?: string; 
  public get useAciAnywhereCrd() {
    return this.getStringAttribute('use_aci_anywhere_crd');
  }
  public set useAciAnywhereCrd(value: string) {
    this._useAciAnywhereCrd = value;
  }
  public resetUseAciAnywhereCrd() {
    this._useAciAnywhereCrd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAciAnywhereCrdInput() {
    return this._useAciAnywhereCrd;
  }

  // use_aci_cni_priority_class - computed: false, optional: true, required: false
  private _useAciCniPriorityClass?: string; 
  public get useAciCniPriorityClass() {
    return this.getStringAttribute('use_aci_cni_priority_class');
  }
  public set useAciCniPriorityClass(value: string) {
    this._useAciCniPriorityClass = value;
  }
  public resetUseAciCniPriorityClass() {
    this._useAciCniPriorityClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAciCniPriorityClassInput() {
    return this._useAciCniPriorityClass;
  }

  // use_cluster_role - computed: false, optional: true, required: false
  private _useClusterRole?: string; 
  public get useClusterRole() {
    return this.getStringAttribute('use_cluster_role');
  }
  public set useClusterRole(value: string) {
    this._useClusterRole = value;
  }
  public resetUseClusterRole() {
    this._useClusterRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useClusterRoleInput() {
    return this._useClusterRole;
  }

  // use_host_netns_volume - computed: false, optional: true, required: false
  private _useHostNetnsVolume?: string; 
  public get useHostNetnsVolume() {
    return this.getStringAttribute('use_host_netns_volume');
  }
  public set useHostNetnsVolume(value: string) {
    this._useHostNetnsVolume = value;
  }
  public resetUseHostNetnsVolume() {
    this._useHostNetnsVolume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useHostNetnsVolumeInput() {
    return this._useHostNetnsVolume;
  }

  // use_opflex_server_volume - computed: false, optional: true, required: false
  private _useOpflexServerVolume?: string; 
  public get useOpflexServerVolume() {
    return this.getStringAttribute('use_opflex_server_volume');
  }
  public set useOpflexServerVolume(value: string) {
    this._useOpflexServerVolume = value;
  }
  public resetUseOpflexServerVolume() {
    this._useOpflexServerVolume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useOpflexServerVolumeInput() {
    return this._useOpflexServerVolume;
  }

  // use_privileged_container - computed: false, optional: true, required: false
  private _usePrivilegedContainer?: string; 
  public get usePrivilegedContainer() {
    return this.getStringAttribute('use_privileged_container');
  }
  public set usePrivilegedContainer(value: string) {
    this._usePrivilegedContainer = value;
  }
  public resetUsePrivilegedContainer() {
    this._usePrivilegedContainer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePrivilegedContainerInput() {
    return this._usePrivilegedContainer;
  }

  // vmm_controller - computed: false, optional: true, required: false
  private _vmmController?: string; 
  public get vmmController() {
    return this.getStringAttribute('vmm_controller');
  }
  public set vmmController(value: string) {
    this._vmmController = value;
  }
  public resetVmmController() {
    this._vmmController = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vmmControllerInput() {
    return this._vmmController;
  }

  // vmm_domain - computed: false, optional: true, required: false
  private _vmmDomain?: string; 
  public get vmmDomain() {
    return this.getStringAttribute('vmm_domain');
  }
  public set vmmDomain(value: string) {
    this._vmmDomain = value;
  }
  public resetVmmDomain() {
    this._vmmDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vmmDomainInput() {
    return this._vmmDomain;
  }

  // vrf_name - computed: false, optional: false, required: true
  private _vrfName?: string; 
  public get vrfName() {
    return this.getStringAttribute('vrf_name');
  }
  public set vrfName(value: string) {
    this._vrfName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vrfNameInput() {
    return this._vrfName;
  }

  // vrf_tenant - computed: false, optional: false, required: true
  private _vrfTenant?: string; 
  public get vrfTenant() {
    return this.getStringAttribute('vrf_tenant');
  }
  public set vrfTenant(value: string) {
    this._vrfTenant = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vrfTenantInput() {
    return this._vrfTenant;
  }
}
export interface ClusterRkeConfigNetworkCalicoNetworkProvider {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_provider Cluster#cloud_provider}
  */
  readonly cloudProvider?: string;
}

export function clusterRkeConfigNetworkCalicoNetworkProviderToTerraform(struct?: ClusterRkeConfigNetworkCalicoNetworkProviderOutputReference | ClusterRkeConfigNetworkCalicoNetworkProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cloud_provider: cdktf.stringToTerraform(struct!.cloudProvider),
  }
}


export function clusterRkeConfigNetworkCalicoNetworkProviderToHclTerraform(struct?: ClusterRkeConfigNetworkCalicoNetworkProviderOutputReference | ClusterRkeConfigNetworkCalicoNetworkProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cloud_provider: {
      value: cdktf.stringToHclTerraform(struct!.cloudProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigNetworkCalicoNetworkProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigNetworkCalicoNetworkProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cloudProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProvider = this._cloudProvider;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigNetworkCalicoNetworkProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._cloudProvider = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._cloudProvider = value.cloudProvider;
    }
  }

  // cloud_provider - computed: true, optional: true, required: false
  private _cloudProvider?: string; 
  public get cloudProvider() {
    return this.getStringAttribute('cloud_provider');
  }
  public set cloudProvider(value: string) {
    this._cloudProvider = value;
  }
  public resetCloudProvider() {
    this._cloudProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderInput() {
    return this._cloudProvider;
  }
}
export interface ClusterRkeConfigNetworkCanalNetworkProvider {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#iface Cluster#iface}
  */
  readonly iface?: string;
}

export function clusterRkeConfigNetworkCanalNetworkProviderToTerraform(struct?: ClusterRkeConfigNetworkCanalNetworkProviderOutputReference | ClusterRkeConfigNetworkCanalNetworkProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    iface: cdktf.stringToTerraform(struct!.iface),
  }
}


export function clusterRkeConfigNetworkCanalNetworkProviderToHclTerraform(struct?: ClusterRkeConfigNetworkCanalNetworkProviderOutputReference | ClusterRkeConfigNetworkCanalNetworkProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    iface: {
      value: cdktf.stringToHclTerraform(struct!.iface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigNetworkCanalNetworkProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigNetworkCanalNetworkProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._iface !== undefined) {
      hasAnyValues = true;
      internalValueResult.iface = this._iface;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigNetworkCanalNetworkProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._iface = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._iface = value.iface;
    }
  }

  // iface - computed: true, optional: true, required: false
  private _iface?: string; 
  public get iface() {
    return this.getStringAttribute('iface');
  }
  public set iface(value: string) {
    this._iface = value;
  }
  public resetIface() {
    this._iface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifaceInput() {
    return this._iface;
  }
}
export interface ClusterRkeConfigNetworkFlannelNetworkProvider {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#iface Cluster#iface}
  */
  readonly iface?: string;
}

export function clusterRkeConfigNetworkFlannelNetworkProviderToTerraform(struct?: ClusterRkeConfigNetworkFlannelNetworkProviderOutputReference | ClusterRkeConfigNetworkFlannelNetworkProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    iface: cdktf.stringToTerraform(struct!.iface),
  }
}


export function clusterRkeConfigNetworkFlannelNetworkProviderToHclTerraform(struct?: ClusterRkeConfigNetworkFlannelNetworkProviderOutputReference | ClusterRkeConfigNetworkFlannelNetworkProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    iface: {
      value: cdktf.stringToHclTerraform(struct!.iface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigNetworkFlannelNetworkProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigNetworkFlannelNetworkProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._iface !== undefined) {
      hasAnyValues = true;
      internalValueResult.iface = this._iface;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigNetworkFlannelNetworkProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._iface = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._iface = value.iface;
    }
  }

  // iface - computed: true, optional: true, required: false
  private _iface?: string; 
  public get iface() {
    return this.getStringAttribute('iface');
  }
  public set iface(value: string) {
    this._iface = value;
  }
  public resetIface() {
    this._iface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifaceInput() {
    return this._iface;
  }
}
export interface ClusterRkeConfigNetworkTolerations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#effect Cluster#effect}
  */
  readonly effect?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#key Cluster#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#seconds Cluster#seconds}
  */
  readonly seconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: string;
}

export function clusterRkeConfigNetworkTolerationsToTerraform(struct?: ClusterRkeConfigNetworkTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    seconds: cdktf.numberToTerraform(struct!.seconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterRkeConfigNetworkTolerationsToHclTerraform(struct?: ClusterRkeConfigNetworkTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seconds: {
      value: cdktf.numberToHclTerraform(struct!.seconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigNetworkTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterRkeConfigNetworkTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._seconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.seconds = this._seconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigNetworkTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._seconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._seconds = value.seconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // seconds - computed: true, optional: true, required: false
  private _seconds?: number; 
  public get seconds() {
    return this.getNumberAttribute('seconds');
  }
  public set seconds(value: number) {
    this._seconds = value;
  }
  public resetSeconds() {
    this._seconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsInput() {
    return this._seconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterRkeConfigNetworkTolerationsList extends cdktf.ComplexList {
  public internalValue? : ClusterRkeConfigNetworkTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterRkeConfigNetworkTolerationsOutputReference {
    return new ClusterRkeConfigNetworkTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterRkeConfigNetworkWeaveNetworkProvider {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#password Cluster#password}
  */
  readonly password: string;
}

export function clusterRkeConfigNetworkWeaveNetworkProviderToTerraform(struct?: ClusterRkeConfigNetworkWeaveNetworkProviderOutputReference | ClusterRkeConfigNetworkWeaveNetworkProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
  }
}


export function clusterRkeConfigNetworkWeaveNetworkProviderToHclTerraform(struct?: ClusterRkeConfigNetworkWeaveNetworkProviderOutputReference | ClusterRkeConfigNetworkWeaveNetworkProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigNetworkWeaveNetworkProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigNetworkWeaveNetworkProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigNetworkWeaveNetworkProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
    }
  }

  // password - computed: false, optional: false, required: true
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }
}
export interface ClusterRkeConfigNetwork {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#mtu Cluster#mtu}
  */
  readonly mtu?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#options Cluster#options}
  */
  readonly options?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#plugin Cluster#plugin}
  */
  readonly plugin?: string;
  /**
  * aci_network_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aci_network_provider Cluster#aci_network_provider}
  */
  readonly aciNetworkProvider?: ClusterRkeConfigNetworkAciNetworkProvider;
  /**
  * calico_network_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#calico_network_provider Cluster#calico_network_provider}
  */
  readonly calicoNetworkProvider?: ClusterRkeConfigNetworkCalicoNetworkProvider;
  /**
  * canal_network_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#canal_network_provider Cluster#canal_network_provider}
  */
  readonly canalNetworkProvider?: ClusterRkeConfigNetworkCanalNetworkProvider;
  /**
  * flannel_network_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#flannel_network_provider Cluster#flannel_network_provider}
  */
  readonly flannelNetworkProvider?: ClusterRkeConfigNetworkFlannelNetworkProvider;
  /**
  * tolerations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#tolerations Cluster#tolerations}
  */
  readonly tolerations?: ClusterRkeConfigNetworkTolerations[] | cdktf.IResolvable;
  /**
  * weave_network_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#weave_network_provider Cluster#weave_network_provider}
  */
  readonly weaveNetworkProvider?: ClusterRkeConfigNetworkWeaveNetworkProvider;
}

export function clusterRkeConfigNetworkToTerraform(struct?: ClusterRkeConfigNetworkOutputReference | ClusterRkeConfigNetwork): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mtu: cdktf.numberToTerraform(struct!.mtu),
    options: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.options),
    plugin: cdktf.stringToTerraform(struct!.plugin),
    aci_network_provider: clusterRkeConfigNetworkAciNetworkProviderToTerraform(struct!.aciNetworkProvider),
    calico_network_provider: clusterRkeConfigNetworkCalicoNetworkProviderToTerraform(struct!.calicoNetworkProvider),
    canal_network_provider: clusterRkeConfigNetworkCanalNetworkProviderToTerraform(struct!.canalNetworkProvider),
    flannel_network_provider: clusterRkeConfigNetworkFlannelNetworkProviderToTerraform(struct!.flannelNetworkProvider),
    tolerations: cdktf.listMapper(clusterRkeConfigNetworkTolerationsToTerraform, true)(struct!.tolerations),
    weave_network_provider: clusterRkeConfigNetworkWeaveNetworkProviderToTerraform(struct!.weaveNetworkProvider),
  }
}


export function clusterRkeConfigNetworkToHclTerraform(struct?: ClusterRkeConfigNetworkOutputReference | ClusterRkeConfigNetwork): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mtu: {
      value: cdktf.numberToHclTerraform(struct!.mtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    options: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.options),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    plugin: {
      value: cdktf.stringToHclTerraform(struct!.plugin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aci_network_provider: {
      value: clusterRkeConfigNetworkAciNetworkProviderToHclTerraform(struct!.aciNetworkProvider),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigNetworkAciNetworkProviderList",
    },
    calico_network_provider: {
      value: clusterRkeConfigNetworkCalicoNetworkProviderToHclTerraform(struct!.calicoNetworkProvider),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigNetworkCalicoNetworkProviderList",
    },
    canal_network_provider: {
      value: clusterRkeConfigNetworkCanalNetworkProviderToHclTerraform(struct!.canalNetworkProvider),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigNetworkCanalNetworkProviderList",
    },
    flannel_network_provider: {
      value: clusterRkeConfigNetworkFlannelNetworkProviderToHclTerraform(struct!.flannelNetworkProvider),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigNetworkFlannelNetworkProviderList",
    },
    tolerations: {
      value: cdktf.listMapperHcl(clusterRkeConfigNetworkTolerationsToHclTerraform, true)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigNetworkTolerationsList",
    },
    weave_network_provider: {
      value: clusterRkeConfigNetworkWeaveNetworkProviderToHclTerraform(struct!.weaveNetworkProvider),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigNetworkWeaveNetworkProviderList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigNetwork | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtu = this._mtu;
    }
    if (this._options !== undefined) {
      hasAnyValues = true;
      internalValueResult.options = this._options;
    }
    if (this._plugin !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugin = this._plugin;
    }
    if (this._aciNetworkProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aciNetworkProvider = this._aciNetworkProvider?.internalValue;
    }
    if (this._calicoNetworkProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.calicoNetworkProvider = this._calicoNetworkProvider?.internalValue;
    }
    if (this._canalNetworkProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.canalNetworkProvider = this._canalNetworkProvider?.internalValue;
    }
    if (this._flannelNetworkProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.flannelNetworkProvider = this._flannelNetworkProvider?.internalValue;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._weaveNetworkProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.weaveNetworkProvider = this._weaveNetworkProvider?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigNetwork | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._mtu = undefined;
      this._options = undefined;
      this._plugin = undefined;
      this._aciNetworkProvider.internalValue = undefined;
      this._calicoNetworkProvider.internalValue = undefined;
      this._canalNetworkProvider.internalValue = undefined;
      this._flannelNetworkProvider.internalValue = undefined;
      this._tolerations.internalValue = undefined;
      this._weaveNetworkProvider.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._mtu = value.mtu;
      this._options = value.options;
      this._plugin = value.plugin;
      this._aciNetworkProvider.internalValue = value.aciNetworkProvider;
      this._calicoNetworkProvider.internalValue = value.calicoNetworkProvider;
      this._canalNetworkProvider.internalValue = value.canalNetworkProvider;
      this._flannelNetworkProvider.internalValue = value.flannelNetworkProvider;
      this._tolerations.internalValue = value.tolerations;
      this._weaveNetworkProvider.internalValue = value.weaveNetworkProvider;
    }
  }

  // mtu - computed: false, optional: true, required: false
  private _mtu?: number; 
  public get mtu() {
    return this.getNumberAttribute('mtu');
  }
  public set mtu(value: number) {
    this._mtu = value;
  }
  public resetMtu() {
    this._mtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuInput() {
    return this._mtu;
  }

  // options - computed: true, optional: true, required: false
  private _options?: { [key: string]: string }; 
  public get options() {
    return this.getStringMapAttribute('options');
  }
  public set options(value: { [key: string]: string }) {
    this._options = value;
  }
  public resetOptions() {
    this._options = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionsInput() {
    return this._options;
  }

  // plugin - computed: true, optional: true, required: false
  private _plugin?: string; 
  public get plugin() {
    return this.getStringAttribute('plugin');
  }
  public set plugin(value: string) {
    this._plugin = value;
  }
  public resetPlugin() {
    this._plugin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginInput() {
    return this._plugin;
  }

  // aci_network_provider - computed: false, optional: true, required: false
  private _aciNetworkProvider = new ClusterRkeConfigNetworkAciNetworkProviderOutputReference(this, "aci_network_provider");
  public get aciNetworkProvider() {
    return this._aciNetworkProvider;
  }
  public putAciNetworkProvider(value: ClusterRkeConfigNetworkAciNetworkProvider) {
    this._aciNetworkProvider.internalValue = value;
  }
  public resetAciNetworkProvider() {
    this._aciNetworkProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aciNetworkProviderInput() {
    return this._aciNetworkProvider.internalValue;
  }

  // calico_network_provider - computed: false, optional: true, required: false
  private _calicoNetworkProvider = new ClusterRkeConfigNetworkCalicoNetworkProviderOutputReference(this, "calico_network_provider");
  public get calicoNetworkProvider() {
    return this._calicoNetworkProvider;
  }
  public putCalicoNetworkProvider(value: ClusterRkeConfigNetworkCalicoNetworkProvider) {
    this._calicoNetworkProvider.internalValue = value;
  }
  public resetCalicoNetworkProvider() {
    this._calicoNetworkProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get calicoNetworkProviderInput() {
    return this._calicoNetworkProvider.internalValue;
  }

  // canal_network_provider - computed: false, optional: true, required: false
  private _canalNetworkProvider = new ClusterRkeConfigNetworkCanalNetworkProviderOutputReference(this, "canal_network_provider");
  public get canalNetworkProvider() {
    return this._canalNetworkProvider;
  }
  public putCanalNetworkProvider(value: ClusterRkeConfigNetworkCanalNetworkProvider) {
    this._canalNetworkProvider.internalValue = value;
  }
  public resetCanalNetworkProvider() {
    this._canalNetworkProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get canalNetworkProviderInput() {
    return this._canalNetworkProvider.internalValue;
  }

  // flannel_network_provider - computed: false, optional: true, required: false
  private _flannelNetworkProvider = new ClusterRkeConfigNetworkFlannelNetworkProviderOutputReference(this, "flannel_network_provider");
  public get flannelNetworkProvider() {
    return this._flannelNetworkProvider;
  }
  public putFlannelNetworkProvider(value: ClusterRkeConfigNetworkFlannelNetworkProvider) {
    this._flannelNetworkProvider.internalValue = value;
  }
  public resetFlannelNetworkProvider() {
    this._flannelNetworkProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flannelNetworkProviderInput() {
    return this._flannelNetworkProvider.internalValue;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new ClusterRkeConfigNetworkTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: ClusterRkeConfigNetworkTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // weave_network_provider - computed: false, optional: true, required: false
  private _weaveNetworkProvider = new ClusterRkeConfigNetworkWeaveNetworkProviderOutputReference(this, "weave_network_provider");
  public get weaveNetworkProvider() {
    return this._weaveNetworkProvider;
  }
  public putWeaveNetworkProvider(value: ClusterRkeConfigNetworkWeaveNetworkProvider) {
    this._weaveNetworkProvider.internalValue = value;
  }
  public resetWeaveNetworkProvider() {
    this._weaveNetworkProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weaveNetworkProviderInput() {
    return this._weaveNetworkProvider.internalValue;
  }
}
export interface ClusterRkeConfigNodes {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#address Cluster#address}
  */
  readonly address: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#docker_socket Cluster#docker_socket}
  */
  readonly dockerSocket?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#hostname_override Cluster#hostname_override}
  */
  readonly hostnameOverride?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#internal_address Cluster#internal_address}
  */
  readonly internalAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#labels Cluster#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#node_id Cluster#node_id}
  */
  readonly nodeId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#port Cluster#port}
  */
  readonly port?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#role Cluster#role}
  */
  readonly role: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ssh_agent_auth Cluster#ssh_agent_auth}
  */
  readonly sshAgentAuth?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ssh_key Cluster#ssh_key}
  */
  readonly sshKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ssh_key_path Cluster#ssh_key_path}
  */
  readonly sshKeyPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#user Cluster#user}
  */
  readonly user: string;
}

export function clusterRkeConfigNodesToTerraform(struct?: ClusterRkeConfigNodes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    docker_socket: cdktf.stringToTerraform(struct!.dockerSocket),
    hostname_override: cdktf.stringToTerraform(struct!.hostnameOverride),
    internal_address: cdktf.stringToTerraform(struct!.internalAddress),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    node_id: cdktf.stringToTerraform(struct!.nodeId),
    port: cdktf.stringToTerraform(struct!.port),
    role: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.role),
    ssh_agent_auth: cdktf.booleanToTerraform(struct!.sshAgentAuth),
    ssh_key: cdktf.stringToTerraform(struct!.sshKey),
    ssh_key_path: cdktf.stringToTerraform(struct!.sshKeyPath),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function clusterRkeConfigNodesToHclTerraform(struct?: ClusterRkeConfigNodes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    docker_socket: {
      value: cdktf.stringToHclTerraform(struct!.dockerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname_override: {
      value: cdktf.stringToHclTerraform(struct!.hostnameOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    internal_address: {
      value: cdktf.stringToHclTerraform(struct!.internalAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    node_id: {
      value: cdktf.stringToHclTerraform(struct!.nodeId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.role),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ssh_agent_auth: {
      value: cdktf.booleanToHclTerraform(struct!.sshAgentAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ssh_key: {
      value: cdktf.stringToHclTerraform(struct!.sshKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssh_key_path: {
      value: cdktf.stringToHclTerraform(struct!.sshKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigNodesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterRkeConfigNodes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._dockerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerSocket = this._dockerSocket;
    }
    if (this._hostnameOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnameOverride = this._hostnameOverride;
    }
    if (this._internalAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.internalAddress = this._internalAddress;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._nodeId !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeId = this._nodeId;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._sshAgentAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.sshAgentAuth = this._sshAgentAuth;
    }
    if (this._sshKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.sshKey = this._sshKey;
    }
    if (this._sshKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.sshKeyPath = this._sshKeyPath;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigNodes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._dockerSocket = undefined;
      this._hostnameOverride = undefined;
      this._internalAddress = undefined;
      this._labels = undefined;
      this._nodeId = undefined;
      this._port = undefined;
      this._role = undefined;
      this._sshAgentAuth = undefined;
      this._sshKey = undefined;
      this._sshKeyPath = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._dockerSocket = value.dockerSocket;
      this._hostnameOverride = value.hostnameOverride;
      this._internalAddress = value.internalAddress;
      this._labels = value.labels;
      this._nodeId = value.nodeId;
      this._port = value.port;
      this._role = value.role;
      this._sshAgentAuth = value.sshAgentAuth;
      this._sshKey = value.sshKey;
      this._sshKeyPath = value.sshKeyPath;
      this._user = value.user;
    }
  }

  // address - computed: false, optional: false, required: true
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // docker_socket - computed: true, optional: true, required: false
  private _dockerSocket?: string; 
  public get dockerSocket() {
    return this.getStringAttribute('docker_socket');
  }
  public set dockerSocket(value: string) {
    this._dockerSocket = value;
  }
  public resetDockerSocket() {
    this._dockerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerSocketInput() {
    return this._dockerSocket;
  }

  // hostname_override - computed: false, optional: true, required: false
  private _hostnameOverride?: string; 
  public get hostnameOverride() {
    return this.getStringAttribute('hostname_override');
  }
  public set hostnameOverride(value: string) {
    this._hostnameOverride = value;
  }
  public resetHostnameOverride() {
    this._hostnameOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameOverrideInput() {
    return this._hostnameOverride;
  }

  // internal_address - computed: false, optional: true, required: false
  private _internalAddress?: string; 
  public get internalAddress() {
    return this.getStringAttribute('internal_address');
  }
  public set internalAddress(value: string) {
    this._internalAddress = value;
  }
  public resetInternalAddress() {
    this._internalAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get internalAddressInput() {
    return this._internalAddress;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // node_id - computed: false, optional: true, required: false
  private _nodeId?: string; 
  public get nodeId() {
    return this.getStringAttribute('node_id');
  }
  public set nodeId(value: string) {
    this._nodeId = value;
  }
  public resetNodeId() {
    this._nodeId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeIdInput() {
    return this._nodeId;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // role - computed: false, optional: false, required: true
  private _role?: string[]; 
  public get role() {
    return this.getListAttribute('role');
  }
  public set role(value: string[]) {
    this._role = value;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // ssh_agent_auth - computed: false, optional: true, required: false
  private _sshAgentAuth?: boolean | cdktf.IResolvable; 
  public get sshAgentAuth() {
    return this.getBooleanAttribute('ssh_agent_auth');
  }
  public set sshAgentAuth(value: boolean | cdktf.IResolvable) {
    this._sshAgentAuth = value;
  }
  public resetSshAgentAuth() {
    this._sshAgentAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshAgentAuthInput() {
    return this._sshAgentAuth;
  }

  // ssh_key - computed: true, optional: true, required: false
  private _sshKey?: string; 
  public get sshKey() {
    return this.getStringAttribute('ssh_key');
  }
  public set sshKey(value: string) {
    this._sshKey = value;
  }
  public resetSshKey() {
    this._sshKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshKeyInput() {
    return this._sshKey;
  }

  // ssh_key_path - computed: true, optional: true, required: false
  private _sshKeyPath?: string; 
  public get sshKeyPath() {
    return this.getStringAttribute('ssh_key_path');
  }
  public set sshKeyPath(value: string) {
    this._sshKeyPath = value;
  }
  public resetSshKeyPath() {
    this._sshKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshKeyPathInput() {
    return this._sshKeyPath;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}

export class ClusterRkeConfigNodesList extends cdktf.ComplexList {
  public internalValue? : ClusterRkeConfigNodes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterRkeConfigNodesOutputReference {
    return new ClusterRkeConfigNodesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterRkeConfigPrivateRegistriesEcrCredentialPlugin {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aws_access_key_id Cluster#aws_access_key_id}
  */
  readonly awsAccessKeyId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aws_secret_access_key Cluster#aws_secret_access_key}
  */
  readonly awsSecretAccessKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#aws_session_token Cluster#aws_session_token}
  */
  readonly awsSessionToken?: string;
}

export function clusterRkeConfigPrivateRegistriesEcrCredentialPluginToTerraform(struct?: ClusterRkeConfigPrivateRegistriesEcrCredentialPluginOutputReference | ClusterRkeConfigPrivateRegistriesEcrCredentialPlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_access_key_id: cdktf.stringToTerraform(struct!.awsAccessKeyId),
    aws_secret_access_key: cdktf.stringToTerraform(struct!.awsSecretAccessKey),
    aws_session_token: cdktf.stringToTerraform(struct!.awsSessionToken),
  }
}


export function clusterRkeConfigPrivateRegistriesEcrCredentialPluginToHclTerraform(struct?: ClusterRkeConfigPrivateRegistriesEcrCredentialPluginOutputReference | ClusterRkeConfigPrivateRegistriesEcrCredentialPlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_access_key_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccessKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_session_token: {
      value: cdktf.stringToHclTerraform(struct!.awsSessionToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigPrivateRegistriesEcrCredentialPluginOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigPrivateRegistriesEcrCredentialPlugin | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsAccessKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccessKeyId = this._awsAccessKeyId;
    }
    if (this._awsSecretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretAccessKey = this._awsSecretAccessKey;
    }
    if (this._awsSessionToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSessionToken = this._awsSessionToken;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigPrivateRegistriesEcrCredentialPlugin | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._awsAccessKeyId = undefined;
      this._awsSecretAccessKey = undefined;
      this._awsSessionToken = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._awsAccessKeyId = value.awsAccessKeyId;
      this._awsSecretAccessKey = value.awsSecretAccessKey;
      this._awsSessionToken = value.awsSessionToken;
    }
  }

  // aws_access_key_id - computed: false, optional: true, required: false
  private _awsAccessKeyId?: string; 
  public get awsAccessKeyId() {
    return this.getStringAttribute('aws_access_key_id');
  }
  public set awsAccessKeyId(value: string) {
    this._awsAccessKeyId = value;
  }
  public resetAwsAccessKeyId() {
    this._awsAccessKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccessKeyIdInput() {
    return this._awsAccessKeyId;
  }

  // aws_secret_access_key - computed: false, optional: true, required: false
  private _awsSecretAccessKey?: string; 
  public get awsSecretAccessKey() {
    return this.getStringAttribute('aws_secret_access_key');
  }
  public set awsSecretAccessKey(value: string) {
    this._awsSecretAccessKey = value;
  }
  public resetAwsSecretAccessKey() {
    this._awsSecretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretAccessKeyInput() {
    return this._awsSecretAccessKey;
  }

  // aws_session_token - computed: false, optional: true, required: false
  private _awsSessionToken?: string; 
  public get awsSessionToken() {
    return this.getStringAttribute('aws_session_token');
  }
  public set awsSessionToken(value: string) {
    this._awsSessionToken = value;
  }
  public resetAwsSessionToken() {
    this._awsSessionToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSessionTokenInput() {
    return this._awsSessionToken;
  }
}
export interface ClusterRkeConfigPrivateRegistries {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#is_default Cluster#is_default}
  */
  readonly isDefault?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#password Cluster#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#url Cluster#url}
  */
  readonly url: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#user Cluster#user}
  */
  readonly user?: string;
  /**
  * ecr_credential_plugin block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ecr_credential_plugin Cluster#ecr_credential_plugin}
  */
  readonly ecrCredentialPlugin?: ClusterRkeConfigPrivateRegistriesEcrCredentialPlugin;
}

export function clusterRkeConfigPrivateRegistriesToTerraform(struct?: ClusterRkeConfigPrivateRegistries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    is_default: cdktf.booleanToTerraform(struct!.isDefault),
    password: cdktf.stringToTerraform(struct!.password),
    url: cdktf.stringToTerraform(struct!.url),
    user: cdktf.stringToTerraform(struct!.user),
    ecr_credential_plugin: clusterRkeConfigPrivateRegistriesEcrCredentialPluginToTerraform(struct!.ecrCredentialPlugin),
  }
}


export function clusterRkeConfigPrivateRegistriesToHclTerraform(struct?: ClusterRkeConfigPrivateRegistries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    is_default: {
      value: cdktf.booleanToHclTerraform(struct!.isDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ecr_credential_plugin: {
      value: clusterRkeConfigPrivateRegistriesEcrCredentialPluginToHclTerraform(struct!.ecrCredentialPlugin),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigPrivateRegistriesEcrCredentialPluginList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigPrivateRegistriesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterRkeConfigPrivateRegistries | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._isDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.isDefault = this._isDefault;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._ecrCredentialPlugin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecrCredentialPlugin = this._ecrCredentialPlugin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigPrivateRegistries | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._isDefault = undefined;
      this._password = undefined;
      this._url = undefined;
      this._user = undefined;
      this._ecrCredentialPlugin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._isDefault = value.isDefault;
      this._password = value.password;
      this._url = value.url;
      this._user = value.user;
      this._ecrCredentialPlugin.internalValue = value.ecrCredentialPlugin;
    }
  }

  // is_default - computed: false, optional: true, required: false
  private _isDefault?: boolean | cdktf.IResolvable; 
  public get isDefault() {
    return this.getBooleanAttribute('is_default');
  }
  public set isDefault(value: boolean | cdktf.IResolvable) {
    this._isDefault = value;
  }
  public resetIsDefault() {
    this._isDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isDefaultInput() {
    return this._isDefault;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // ecr_credential_plugin - computed: false, optional: true, required: false
  private _ecrCredentialPlugin = new ClusterRkeConfigPrivateRegistriesEcrCredentialPluginOutputReference(this, "ecr_credential_plugin");
  public get ecrCredentialPlugin() {
    return this._ecrCredentialPlugin;
  }
  public putEcrCredentialPlugin(value: ClusterRkeConfigPrivateRegistriesEcrCredentialPlugin) {
    this._ecrCredentialPlugin.internalValue = value;
  }
  public resetEcrCredentialPlugin() {
    this._ecrCredentialPlugin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecrCredentialPluginInput() {
    return this._ecrCredentialPlugin.internalValue;
  }
}

export class ClusterRkeConfigPrivateRegistriesList extends cdktf.ComplexList {
  public internalValue? : ClusterRkeConfigPrivateRegistries[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterRkeConfigPrivateRegistriesOutputReference {
    return new ClusterRkeConfigPrivateRegistriesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#access_key Cluster#access_key}
  */
  readonly accessKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#bucket_name Cluster#bucket_name}
  */
  readonly bucketName: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#custom_ca Cluster#custom_ca}
  */
  readonly customCa?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#endpoint Cluster#endpoint}
  */
  readonly endpoint: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#folder Cluster#folder}
  */
  readonly folder?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#region Cluster#region}
  */
  readonly region?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#secret_key Cluster#secret_key}
  */
  readonly secretKey?: string;
}

export function clusterRkeConfigServicesEtcdBackupConfigS3BackupConfigToTerraform(struct?: ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigOutputReference | ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: cdktf.stringToTerraform(struct!.accessKey),
    bucket_name: cdktf.stringToTerraform(struct!.bucketName),
    custom_ca: cdktf.stringToTerraform(struct!.customCa),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    folder: cdktf.stringToTerraform(struct!.folder),
    region: cdktf.stringToTerraform(struct!.region),
    secret_key: cdktf.stringToTerraform(struct!.secretKey),
  }
}


export function clusterRkeConfigServicesEtcdBackupConfigS3BackupConfigToHclTerraform(struct?: ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigOutputReference | ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: cdktf.stringToHclTerraform(struct!.accessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket_name: {
      value: cdktf.stringToHclTerraform(struct!.bucketName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_ca: {
      value: cdktf.stringToHclTerraform(struct!.customCa),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    folder: {
      value: cdktf.stringToHclTerraform(struct!.folder),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_key: {
      value: cdktf.stringToHclTerraform(struct!.secretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey;
    }
    if (this._bucketName !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucketName = this._bucketName;
    }
    if (this._customCa !== undefined) {
      hasAnyValues = true;
      internalValueResult.customCa = this._customCa;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._folder !== undefined) {
      hasAnyValues = true;
      internalValueResult.folder = this._folder;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._secretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKey = this._secretKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._accessKey = undefined;
      this._bucketName = undefined;
      this._customCa = undefined;
      this._endpoint = undefined;
      this._folder = undefined;
      this._region = undefined;
      this._secretKey = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._accessKey = value.accessKey;
      this._bucketName = value.bucketName;
      this._customCa = value.customCa;
      this._endpoint = value.endpoint;
      this._folder = value.folder;
      this._region = value.region;
      this._secretKey = value.secretKey;
    }
  }

  // access_key - computed: false, optional: true, required: false
  private _accessKey?: string; 
  public get accessKey() {
    return this.getStringAttribute('access_key');
  }
  public set accessKey(value: string) {
    this._accessKey = value;
  }
  public resetAccessKey() {
    this._accessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey;
  }

  // bucket_name - computed: false, optional: false, required: true
  private _bucketName?: string; 
  public get bucketName() {
    return this.getStringAttribute('bucket_name');
  }
  public set bucketName(value: string) {
    this._bucketName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketNameInput() {
    return this._bucketName;
  }

  // custom_ca - computed: false, optional: true, required: false
  private _customCa?: string; 
  public get customCa() {
    return this.getStringAttribute('custom_ca');
  }
  public set customCa(value: string) {
    this._customCa = value;
  }
  public resetCustomCa() {
    this._customCa = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customCaInput() {
    return this._customCa;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // folder - computed: false, optional: true, required: false
  private _folder?: string; 
  public get folder() {
    return this.getStringAttribute('folder');
  }
  public set folder(value: string) {
    this._folder = value;
  }
  public resetFolder() {
    this._folder = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get folderInput() {
    return this._folder;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // secret_key - computed: false, optional: true, required: false
  private _secretKey?: string; 
  public get secretKey() {
    return this.getStringAttribute('secret_key');
  }
  public set secretKey(value: string) {
    this._secretKey = value;
  }
  public resetSecretKey() {
    this._secretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyInput() {
    return this._secretKey;
  }
}
export interface ClusterRkeConfigServicesEtcdBackupConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#interval_hours Cluster#interval_hours}
  */
  readonly intervalHours?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#retention Cluster#retention}
  */
  readonly retention?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#safe_timestamp Cluster#safe_timestamp}
  */
  readonly safeTimestamp?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#timeout Cluster#timeout}
  */
  readonly timeout?: number;
  /**
  * s3_backup_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#s3_backup_config Cluster#s3_backup_config}
  */
  readonly s3BackupConfig?: ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig;
}

export function clusterRkeConfigServicesEtcdBackupConfigToTerraform(struct?: ClusterRkeConfigServicesEtcdBackupConfigOutputReference | ClusterRkeConfigServicesEtcdBackupConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    interval_hours: cdktf.numberToTerraform(struct!.intervalHours),
    retention: cdktf.numberToTerraform(struct!.retention),
    safe_timestamp: cdktf.booleanToTerraform(struct!.safeTimestamp),
    timeout: cdktf.numberToTerraform(struct!.timeout),
    s3_backup_config: clusterRkeConfigServicesEtcdBackupConfigS3BackupConfigToTerraform(struct!.s3BackupConfig),
  }
}


export function clusterRkeConfigServicesEtcdBackupConfigToHclTerraform(struct?: ClusterRkeConfigServicesEtcdBackupConfigOutputReference | ClusterRkeConfigServicesEtcdBackupConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval_hours: {
      value: cdktf.numberToHclTerraform(struct!.intervalHours),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retention: {
      value: cdktf.numberToHclTerraform(struct!.retention),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    safe_timestamp: {
      value: cdktf.booleanToHclTerraform(struct!.safeTimestamp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    s3_backup_config: {
      value: clusterRkeConfigServicesEtcdBackupConfigS3BackupConfigToHclTerraform(struct!.s3BackupConfig),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesEtcdBackupConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesEtcdBackupConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._intervalHours !== undefined) {
      hasAnyValues = true;
      internalValueResult.intervalHours = this._intervalHours;
    }
    if (this._retention !== undefined) {
      hasAnyValues = true;
      internalValueResult.retention = this._retention;
    }
    if (this._safeTimestamp !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeTimestamp = this._safeTimestamp;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._s3BackupConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.s3BackupConfig = this._s3BackupConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesEtcdBackupConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enabled = undefined;
      this._intervalHours = undefined;
      this._retention = undefined;
      this._safeTimestamp = undefined;
      this._timeout = undefined;
      this._s3BackupConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enabled = value.enabled;
      this._intervalHours = value.intervalHours;
      this._retention = value.retention;
      this._safeTimestamp = value.safeTimestamp;
      this._timeout = value.timeout;
      this._s3BackupConfig.internalValue = value.s3BackupConfig;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // interval_hours - computed: false, optional: true, required: false
  private _intervalHours?: number; 
  public get intervalHours() {
    return this.getNumberAttribute('interval_hours');
  }
  public set intervalHours(value: number) {
    this._intervalHours = value;
  }
  public resetIntervalHours() {
    this._intervalHours = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalHoursInput() {
    return this._intervalHours;
  }

  // retention - computed: false, optional: true, required: false
  private _retention?: number; 
  public get retention() {
    return this.getNumberAttribute('retention');
  }
  public set retention(value: number) {
    this._retention = value;
  }
  public resetRetention() {
    this._retention = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retentionInput() {
    return this._retention;
  }

  // safe_timestamp - computed: false, optional: true, required: false
  private _safeTimestamp?: boolean | cdktf.IResolvable; 
  public get safeTimestamp() {
    return this.getBooleanAttribute('safe_timestamp');
  }
  public set safeTimestamp(value: boolean | cdktf.IResolvable) {
    this._safeTimestamp = value;
  }
  public resetSafeTimestamp() {
    this._safeTimestamp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeTimestampInput() {
    return this._safeTimestamp;
  }

  // timeout - computed: true, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // s3_backup_config - computed: false, optional: true, required: false
  private _s3BackupConfig = new ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigOutputReference(this, "s3_backup_config");
  public get s3BackupConfig() {
    return this._s3BackupConfig;
  }
  public putS3BackupConfig(value: ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig) {
    this._s3BackupConfig.internalValue = value;
  }
  public resetS3BackupConfig() {
    this._s3BackupConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get s3BackupConfigInput() {
    return this._s3BackupConfig.internalValue;
  }
}
export interface ClusterRkeConfigServicesEtcd {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ca_cert Cluster#ca_cert}
  */
  readonly caCert?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cert Cluster#cert}
  */
  readonly cert?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#creation Cluster#creation}
  */
  readonly creation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#external_urls Cluster#external_urls}
  */
  readonly externalUrls?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_args Cluster#extra_args}
  */
  readonly extraArgs?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_binds Cluster#extra_binds}
  */
  readonly extraBinds?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_env Cluster#extra_env}
  */
  readonly extraEnv?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#gid Cluster#gid}
  */
  readonly gid?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#path Cluster#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#retention Cluster#retention}
  */
  readonly retention?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#snapshot Cluster#snapshot}
  */
  readonly snapshot?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#uid Cluster#uid}
  */
  readonly uid?: number;
  /**
  * backup_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#backup_config Cluster#backup_config}
  */
  readonly backupConfig?: ClusterRkeConfigServicesEtcdBackupConfig;
}

export function clusterRkeConfigServicesEtcdToTerraform(struct?: ClusterRkeConfigServicesEtcdOutputReference | ClusterRkeConfigServicesEtcd): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_cert: cdktf.stringToTerraform(struct!.caCert),
    cert: cdktf.stringToTerraform(struct!.cert),
    creation: cdktf.stringToTerraform(struct!.creation),
    external_urls: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.externalUrls),
    extra_args: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraArgs),
    extra_binds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraBinds),
    extra_env: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraEnv),
    gid: cdktf.numberToTerraform(struct!.gid),
    image: cdktf.stringToTerraform(struct!.image),
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.stringToTerraform(struct!.path),
    retention: cdktf.stringToTerraform(struct!.retention),
    snapshot: cdktf.booleanToTerraform(struct!.snapshot),
    uid: cdktf.numberToTerraform(struct!.uid),
    backup_config: clusterRkeConfigServicesEtcdBackupConfigToTerraform(struct!.backupConfig),
  }
}


export function clusterRkeConfigServicesEtcdToHclTerraform(struct?: ClusterRkeConfigServicesEtcdOutputReference | ClusterRkeConfigServicesEtcd): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_cert: {
      value: cdktf.stringToHclTerraform(struct!.caCert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert: {
      value: cdktf.stringToHclTerraform(struct!.cert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    creation: {
      value: cdktf.stringToHclTerraform(struct!.creation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_urls: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.externalUrls),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_args: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraArgs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    extra_binds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraBinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_env: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraEnv),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    gid: {
      value: cdktf.numberToHclTerraform(struct!.gid),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    retention: {
      value: cdktf.stringToHclTerraform(struct!.retention),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    snapshot: {
      value: cdktf.booleanToHclTerraform(struct!.snapshot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    uid: {
      value: cdktf.numberToHclTerraform(struct!.uid),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backup_config: {
      value: clusterRkeConfigServicesEtcdBackupConfigToHclTerraform(struct!.backupConfig),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesEtcdBackupConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesEtcdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesEtcd | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCert = this._caCert;
    }
    if (this._cert !== undefined) {
      hasAnyValues = true;
      internalValueResult.cert = this._cert;
    }
    if (this._creation !== undefined) {
      hasAnyValues = true;
      internalValueResult.creation = this._creation;
    }
    if (this._externalUrls !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalUrls = this._externalUrls;
    }
    if (this._extraArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraArgs = this._extraArgs;
    }
    if (this._extraBinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraBinds = this._extraBinds;
    }
    if (this._extraEnv !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraEnv = this._extraEnv;
    }
    if (this._gid !== undefined) {
      hasAnyValues = true;
      internalValueResult.gid = this._gid;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._retention !== undefined) {
      hasAnyValues = true;
      internalValueResult.retention = this._retention;
    }
    if (this._snapshot !== undefined) {
      hasAnyValues = true;
      internalValueResult.snapshot = this._snapshot;
    }
    if (this._uid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid;
    }
    if (this._backupConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backupConfig = this._backupConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesEtcd | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._caCert = undefined;
      this._cert = undefined;
      this._creation = undefined;
      this._externalUrls = undefined;
      this._extraArgs = undefined;
      this._extraBinds = undefined;
      this._extraEnv = undefined;
      this._gid = undefined;
      this._image = undefined;
      this._key = undefined;
      this._path = undefined;
      this._retention = undefined;
      this._snapshot = undefined;
      this._uid = undefined;
      this._backupConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._caCert = value.caCert;
      this._cert = value.cert;
      this._creation = value.creation;
      this._externalUrls = value.externalUrls;
      this._extraArgs = value.extraArgs;
      this._extraBinds = value.extraBinds;
      this._extraEnv = value.extraEnv;
      this._gid = value.gid;
      this._image = value.image;
      this._key = value.key;
      this._path = value.path;
      this._retention = value.retention;
      this._snapshot = value.snapshot;
      this._uid = value.uid;
      this._backupConfig.internalValue = value.backupConfig;
    }
  }

  // ca_cert - computed: true, optional: true, required: false
  private _caCert?: string; 
  public get caCert() {
    return this.getStringAttribute('ca_cert');
  }
  public set caCert(value: string) {
    this._caCert = value;
  }
  public resetCaCert() {
    this._caCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertInput() {
    return this._caCert;
  }

  // cert - computed: true, optional: true, required: false
  private _cert?: string; 
  public get cert() {
    return this.getStringAttribute('cert');
  }
  public set cert(value: string) {
    this._cert = value;
  }
  public resetCert() {
    this._cert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certInput() {
    return this._cert;
  }

  // creation - computed: true, optional: true, required: false
  private _creation?: string; 
  public get creation() {
    return this.getStringAttribute('creation');
  }
  public set creation(value: string) {
    this._creation = value;
  }
  public resetCreation() {
    this._creation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get creationInput() {
    return this._creation;
  }

  // external_urls - computed: false, optional: true, required: false
  private _externalUrls?: string[]; 
  public get externalUrls() {
    return this.getListAttribute('external_urls');
  }
  public set externalUrls(value: string[]) {
    this._externalUrls = value;
  }
  public resetExternalUrls() {
    this._externalUrls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalUrlsInput() {
    return this._externalUrls;
  }

  // extra_args - computed: true, optional: true, required: false
  private _extraArgs?: { [key: string]: string }; 
  public get extraArgs() {
    return this.getStringMapAttribute('extra_args');
  }
  public set extraArgs(value: { [key: string]: string }) {
    this._extraArgs = value;
  }
  public resetExtraArgs() {
    this._extraArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraArgsInput() {
    return this._extraArgs;
  }

  // extra_binds - computed: false, optional: true, required: false
  private _extraBinds?: string[]; 
  public get extraBinds() {
    return this.getListAttribute('extra_binds');
  }
  public set extraBinds(value: string[]) {
    this._extraBinds = value;
  }
  public resetExtraBinds() {
    this._extraBinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraBindsInput() {
    return this._extraBinds;
  }

  // extra_env - computed: false, optional: true, required: false
  private _extraEnv?: string[]; 
  public get extraEnv() {
    return this.getListAttribute('extra_env');
  }
  public set extraEnv(value: string[]) {
    this._extraEnv = value;
  }
  public resetExtraEnv() {
    this._extraEnv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraEnvInput() {
    return this._extraEnv;
  }

  // gid - computed: false, optional: true, required: false
  private _gid?: number; 
  public get gid() {
    return this.getNumberAttribute('gid');
  }
  public set gid(value: number) {
    this._gid = value;
  }
  public resetGid() {
    this._gid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gidInput() {
    return this._gid;
  }

  // image - computed: true, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // retention - computed: true, optional: true, required: false
  private _retention?: string; 
  public get retention() {
    return this.getStringAttribute('retention');
  }
  public set retention(value: string) {
    this._retention = value;
  }
  public resetRetention() {
    this._retention = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retentionInput() {
    return this._retention;
  }

  // snapshot - computed: true, optional: true, required: false
  private _snapshot?: boolean | cdktf.IResolvable; 
  public get snapshot() {
    return this.getBooleanAttribute('snapshot');
  }
  public set snapshot(value: boolean | cdktf.IResolvable) {
    this._snapshot = value;
  }
  public resetSnapshot() {
    this._snapshot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snapshotInput() {
    return this._snapshot;
  }

  // uid - computed: false, optional: true, required: false
  private _uid?: number; 
  public get uid() {
    return this.getNumberAttribute('uid');
  }
  public set uid(value: number) {
    this._uid = value;
  }
  public resetUid() {
    this._uid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid;
  }

  // backup_config - computed: false, optional: true, required: false
  private _backupConfig = new ClusterRkeConfigServicesEtcdBackupConfigOutputReference(this, "backup_config");
  public get backupConfig() {
    return this._backupConfig;
  }
  public putBackupConfig(value: ClusterRkeConfigServicesEtcdBackupConfig) {
    this._backupConfig.internalValue = value;
  }
  public resetBackupConfig() {
    this._backupConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backupConfigInput() {
    return this._backupConfig.internalValue;
  }
}
export interface ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugins {
  /**
  * Plugin configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#configuration Cluster#configuration}
  */
  readonly configuration?: string;
  /**
  * Plugin name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#name Cluster#name}
  */
  readonly name?: string;
  /**
  * Plugin path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#path Cluster#path}
  */
  readonly path?: string;
}

export function clusterRkeConfigServicesKubeApiAdmissionConfigurationPluginsToTerraform(struct?: ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    configuration: cdktf.stringToTerraform(struct!.configuration),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function clusterRkeConfigServicesKubeApiAdmissionConfigurationPluginsToHclTerraform(struct?: ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    configuration: {
      value: cdktf.stringToHclTerraform(struct!.configuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugins | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.configuration = this._configuration;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugins | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configuration = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configuration = value.configuration;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // configuration - computed: true, optional: true, required: false
  private _configuration?: string; 
  public get configuration() {
    return this.getStringAttribute('configuration');
  }
  public set configuration(value: string) {
    this._configuration = value;
  }
  public resetConfiguration() {
    this._configuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configurationInput() {
    return this._configuration;
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginsList extends cdktf.ComplexList {
  public internalValue? : ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugins[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginsOutputReference {
    return new ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterRkeConfigServicesKubeApiAdmissionConfiguration {
  /**
  * Admission configuration ApiVersion
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#api_version Cluster#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Admission configuration Kind
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kind Cluster#kind}
  */
  readonly kind?: string;
  /**
  * plugins block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#plugins Cluster#plugins}
  */
  readonly plugins?: ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugins[] | cdktf.IResolvable;
}

export function clusterRkeConfigServicesKubeApiAdmissionConfigurationToTerraform(struct?: ClusterRkeConfigServicesKubeApiAdmissionConfigurationOutputReference | ClusterRkeConfigServicesKubeApiAdmissionConfiguration): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    kind: cdktf.stringToTerraform(struct!.kind),
    plugins: cdktf.listMapper(clusterRkeConfigServicesKubeApiAdmissionConfigurationPluginsToTerraform, true)(struct!.plugins),
  }
}


export function clusterRkeConfigServicesKubeApiAdmissionConfigurationToHclTerraform(struct?: ClusterRkeConfigServicesKubeApiAdmissionConfigurationOutputReference | ClusterRkeConfigServicesKubeApiAdmissionConfiguration): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plugins: {
      value: cdktf.listMapperHcl(clusterRkeConfigServicesKubeApiAdmissionConfigurationPluginsToHclTerraform, true)(struct!.plugins),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesKubeApiAdmissionConfigurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesKubeApiAdmissionConfiguration | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._plugins?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugins = this._plugins?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesKubeApiAdmissionConfiguration | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._apiVersion = undefined;
      this._kind = undefined;
      this._plugins.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._apiVersion = value.apiVersion;
      this._kind = value.kind;
      this._plugins.internalValue = value.plugins;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // plugins - computed: false, optional: true, required: false
  private _plugins = new ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginsList(this, "plugins", false);
  public get plugins() {
    return this._plugins;
  }
  public putPlugins(value: ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugins[] | cdktf.IResolvable) {
    this._plugins.internalValue = value;
  }
  public resetPlugins() {
    this._plugins.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginsInput() {
    return this._plugins.internalValue;
  }
}
export interface ClusterRkeConfigServicesKubeApiAuditLogConfiguration {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#format Cluster#format}
  */
  readonly format?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_age Cluster#max_age}
  */
  readonly maxAge?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_backup Cluster#max_backup}
  */
  readonly maxBackup?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_size Cluster#max_size}
  */
  readonly maxSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#path Cluster#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#policy Cluster#policy}
  */
  readonly policy?: string;
}

export function clusterRkeConfigServicesKubeApiAuditLogConfigurationToTerraform(struct?: ClusterRkeConfigServicesKubeApiAuditLogConfigurationOutputReference | ClusterRkeConfigServicesKubeApiAuditLogConfiguration): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: cdktf.stringToTerraform(struct!.format),
    max_age: cdktf.numberToTerraform(struct!.maxAge),
    max_backup: cdktf.numberToTerraform(struct!.maxBackup),
    max_size: cdktf.numberToTerraform(struct!.maxSize),
    path: cdktf.stringToTerraform(struct!.path),
    policy: cdktf.stringToTerraform(struct!.policy),
  }
}


export function clusterRkeConfigServicesKubeApiAuditLogConfigurationToHclTerraform(struct?: ClusterRkeConfigServicesKubeApiAuditLogConfigurationOutputReference | ClusterRkeConfigServicesKubeApiAuditLogConfiguration): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_age: {
      value: cdktf.numberToHclTerraform(struct!.maxAge),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backup: {
      value: cdktf.numberToHclTerraform(struct!.maxBackup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_size: {
      value: cdktf.numberToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    policy: {
      value: cdktf.stringToHclTerraform(struct!.policy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesKubeApiAuditLogConfigurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesKubeApiAuditLogConfiguration | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._maxAge !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxAge = this._maxAge;
    }
    if (this._maxBackup !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackup = this._maxBackup;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._policy !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesKubeApiAuditLogConfiguration | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._format = undefined;
      this._maxAge = undefined;
      this._maxBackup = undefined;
      this._maxSize = undefined;
      this._path = undefined;
      this._policy = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._format = value.format;
      this._maxAge = value.maxAge;
      this._maxBackup = value.maxBackup;
      this._maxSize = value.maxSize;
      this._path = value.path;
      this._policy = value.policy;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // max_age - computed: false, optional: true, required: false
  private _maxAge?: number; 
  public get maxAge() {
    return this.getNumberAttribute('max_age');
  }
  public set maxAge(value: number) {
    this._maxAge = value;
  }
  public resetMaxAge() {
    this._maxAge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxAgeInput() {
    return this._maxAge;
  }

  // max_backup - computed: false, optional: true, required: false
  private _maxBackup?: number; 
  public get maxBackup() {
    return this.getNumberAttribute('max_backup');
  }
  public set maxBackup(value: number) {
    this._maxBackup = value;
  }
  public resetMaxBackup() {
    this._maxBackup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackupInput() {
    return this._maxBackup;
  }

  // max_size - computed: false, optional: true, required: false
  private _maxSize?: number; 
  public get maxSize() {
    return this.getNumberAttribute('max_size');
  }
  public set maxSize(value: number) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // policy - computed: true, optional: true, required: false
  private _policy?: string; 
  public get policy() {
    return this.getStringAttribute('policy');
  }
  public set policy(value: string) {
    this._policy = value;
  }
  public resetPolicy() {
    this._policy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy;
  }
}
export interface ClusterRkeConfigServicesKubeApiAuditLog {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * configuration block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#configuration Cluster#configuration}
  */
  readonly configuration?: ClusterRkeConfigServicesKubeApiAuditLogConfiguration;
}

export function clusterRkeConfigServicesKubeApiAuditLogToTerraform(struct?: ClusterRkeConfigServicesKubeApiAuditLogOutputReference | ClusterRkeConfigServicesKubeApiAuditLog): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    configuration: clusterRkeConfigServicesKubeApiAuditLogConfigurationToTerraform(struct!.configuration),
  }
}


export function clusterRkeConfigServicesKubeApiAuditLogToHclTerraform(struct?: ClusterRkeConfigServicesKubeApiAuditLogOutputReference | ClusterRkeConfigServicesKubeApiAuditLog): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    configuration: {
      value: clusterRkeConfigServicesKubeApiAuditLogConfigurationToHclTerraform(struct!.configuration),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesKubeApiAuditLogConfigurationList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesKubeApiAuditLogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesKubeApiAuditLog | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._configuration?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configuration = this._configuration?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesKubeApiAuditLog | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enabled = undefined;
      this._configuration.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enabled = value.enabled;
      this._configuration.internalValue = value.configuration;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // configuration - computed: false, optional: true, required: false
  private _configuration = new ClusterRkeConfigServicesKubeApiAuditLogConfigurationOutputReference(this, "configuration");
  public get configuration() {
    return this._configuration;
  }
  public putConfiguration(value: ClusterRkeConfigServicesKubeApiAuditLogConfiguration) {
    this._configuration.internalValue = value;
  }
  public resetConfiguration() {
    this._configuration.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configurationInput() {
    return this._configuration.internalValue;
  }
}
export interface ClusterRkeConfigServicesKubeApiEventRateLimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#configuration Cluster#configuration}
  */
  readonly configuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function clusterRkeConfigServicesKubeApiEventRateLimitToTerraform(struct?: ClusterRkeConfigServicesKubeApiEventRateLimitOutputReference | ClusterRkeConfigServicesKubeApiEventRateLimit): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    configuration: cdktf.stringToTerraform(struct!.configuration),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function clusterRkeConfigServicesKubeApiEventRateLimitToHclTerraform(struct?: ClusterRkeConfigServicesKubeApiEventRateLimitOutputReference | ClusterRkeConfigServicesKubeApiEventRateLimit): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    configuration: {
      value: cdktf.stringToHclTerraform(struct!.configuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesKubeApiEventRateLimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesKubeApiEventRateLimit | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.configuration = this._configuration;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesKubeApiEventRateLimit | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._configuration = undefined;
      this._enabled = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._configuration = value.configuration;
      this._enabled = value.enabled;
    }
  }

  // configuration - computed: true, optional: true, required: false
  private _configuration?: string; 
  public get configuration() {
    return this.getStringAttribute('configuration');
  }
  public set configuration(value: string) {
    this._configuration = value;
  }
  public resetConfiguration() {
    this._configuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configurationInput() {
    return this._configuration;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#custom_config Cluster#custom_config}
  */
  readonly customConfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function clusterRkeConfigServicesKubeApiSecretsEncryptionConfigToTerraform(struct?: ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigOutputReference | ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_config: cdktf.stringToTerraform(struct!.customConfig),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function clusterRkeConfigServicesKubeApiSecretsEncryptionConfigToHclTerraform(struct?: ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigOutputReference | ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_config: {
      value: cdktf.stringToHclTerraform(struct!.customConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.customConfig = this._customConfig;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._customConfig = undefined;
      this._enabled = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._customConfig = value.customConfig;
      this._enabled = value.enabled;
    }
  }

  // custom_config - computed: false, optional: true, required: false
  private _customConfig?: string; 
  public get customConfig() {
    return this.getStringAttribute('custom_config');
  }
  public set customConfig(value: string) {
    this._customConfig = value;
  }
  public resetCustomConfig() {
    this._customConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customConfigInput() {
    return this._customConfig;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface ClusterRkeConfigServicesKubeApi {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#always_pull_images Cluster#always_pull_images}
  */
  readonly alwaysPullImages?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_args Cluster#extra_args}
  */
  readonly extraArgs?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_binds Cluster#extra_binds}
  */
  readonly extraBinds?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_env Cluster#extra_env}
  */
  readonly extraEnv?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service_cluster_ip_range Cluster#service_cluster_ip_range}
  */
  readonly serviceClusterIpRange?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service_node_port_range Cluster#service_node_port_range}
  */
  readonly serviceNodePortRange?: string;
  /**
  * admission_configuration block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#admission_configuration Cluster#admission_configuration}
  */
  readonly admissionConfiguration?: ClusterRkeConfigServicesKubeApiAdmissionConfiguration;
  /**
  * audit_log block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#audit_log Cluster#audit_log}
  */
  readonly auditLog?: ClusterRkeConfigServicesKubeApiAuditLog;
  /**
  * event_rate_limit block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#event_rate_limit Cluster#event_rate_limit}
  */
  readonly eventRateLimit?: ClusterRkeConfigServicesKubeApiEventRateLimit;
  /**
  * secrets_encryption_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#secrets_encryption_config Cluster#secrets_encryption_config}
  */
  readonly secretsEncryptionConfig?: ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig;
}

export function clusterRkeConfigServicesKubeApiToTerraform(struct?: ClusterRkeConfigServicesKubeApiOutputReference | ClusterRkeConfigServicesKubeApi): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    always_pull_images: cdktf.booleanToTerraform(struct!.alwaysPullImages),
    extra_args: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraArgs),
    extra_binds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraBinds),
    extra_env: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraEnv),
    image: cdktf.stringToTerraform(struct!.image),
    service_cluster_ip_range: cdktf.stringToTerraform(struct!.serviceClusterIpRange),
    service_node_port_range: cdktf.stringToTerraform(struct!.serviceNodePortRange),
    admission_configuration: clusterRkeConfigServicesKubeApiAdmissionConfigurationToTerraform(struct!.admissionConfiguration),
    audit_log: clusterRkeConfigServicesKubeApiAuditLogToTerraform(struct!.auditLog),
    event_rate_limit: clusterRkeConfigServicesKubeApiEventRateLimitToTerraform(struct!.eventRateLimit),
    secrets_encryption_config: clusterRkeConfigServicesKubeApiSecretsEncryptionConfigToTerraform(struct!.secretsEncryptionConfig),
  }
}


export function clusterRkeConfigServicesKubeApiToHclTerraform(struct?: ClusterRkeConfigServicesKubeApiOutputReference | ClusterRkeConfigServicesKubeApi): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    always_pull_images: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPullImages),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_args: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraArgs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    extra_binds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraBinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_env: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraEnv),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_cluster_ip_range: {
      value: cdktf.stringToHclTerraform(struct!.serviceClusterIpRange),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_node_port_range: {
      value: cdktf.stringToHclTerraform(struct!.serviceNodePortRange),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    admission_configuration: {
      value: clusterRkeConfigServicesKubeApiAdmissionConfigurationToHclTerraform(struct!.admissionConfiguration),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesKubeApiAdmissionConfigurationList",
    },
    audit_log: {
      value: clusterRkeConfigServicesKubeApiAuditLogToHclTerraform(struct!.auditLog),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesKubeApiAuditLogList",
    },
    event_rate_limit: {
      value: clusterRkeConfigServicesKubeApiEventRateLimitToHclTerraform(struct!.eventRateLimit),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesKubeApiEventRateLimitList",
    },
    secrets_encryption_config: {
      value: clusterRkeConfigServicesKubeApiSecretsEncryptionConfigToHclTerraform(struct!.secretsEncryptionConfig),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesKubeApiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesKubeApi | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alwaysPullImages !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPullImages = this._alwaysPullImages;
    }
    if (this._extraArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraArgs = this._extraArgs;
    }
    if (this._extraBinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraBinds = this._extraBinds;
    }
    if (this._extraEnv !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraEnv = this._extraEnv;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._serviceClusterIpRange !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceClusterIpRange = this._serviceClusterIpRange;
    }
    if (this._serviceNodePortRange !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceNodePortRange = this._serviceNodePortRange;
    }
    if (this._admissionConfiguration?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.admissionConfiguration = this._admissionConfiguration?.internalValue;
    }
    if (this._auditLog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditLog = this._auditLog?.internalValue;
    }
    if (this._eventRateLimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventRateLimit = this._eventRateLimit?.internalValue;
    }
    if (this._secretsEncryptionConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretsEncryptionConfig = this._secretsEncryptionConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesKubeApi | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._alwaysPullImages = undefined;
      this._extraArgs = undefined;
      this._extraBinds = undefined;
      this._extraEnv = undefined;
      this._image = undefined;
      this._serviceClusterIpRange = undefined;
      this._serviceNodePortRange = undefined;
      this._admissionConfiguration.internalValue = undefined;
      this._auditLog.internalValue = undefined;
      this._eventRateLimit.internalValue = undefined;
      this._secretsEncryptionConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._alwaysPullImages = value.alwaysPullImages;
      this._extraArgs = value.extraArgs;
      this._extraBinds = value.extraBinds;
      this._extraEnv = value.extraEnv;
      this._image = value.image;
      this._serviceClusterIpRange = value.serviceClusterIpRange;
      this._serviceNodePortRange = value.serviceNodePortRange;
      this._admissionConfiguration.internalValue = value.admissionConfiguration;
      this._auditLog.internalValue = value.auditLog;
      this._eventRateLimit.internalValue = value.eventRateLimit;
      this._secretsEncryptionConfig.internalValue = value.secretsEncryptionConfig;
    }
  }

  // always_pull_images - computed: false, optional: true, required: false
  private _alwaysPullImages?: boolean | cdktf.IResolvable; 
  public get alwaysPullImages() {
    return this.getBooleanAttribute('always_pull_images');
  }
  public set alwaysPullImages(value: boolean | cdktf.IResolvable) {
    this._alwaysPullImages = value;
  }
  public resetAlwaysPullImages() {
    this._alwaysPullImages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPullImagesInput() {
    return this._alwaysPullImages;
  }

  // extra_args - computed: true, optional: true, required: false
  private _extraArgs?: { [key: string]: string }; 
  public get extraArgs() {
    return this.getStringMapAttribute('extra_args');
  }
  public set extraArgs(value: { [key: string]: string }) {
    this._extraArgs = value;
  }
  public resetExtraArgs() {
    this._extraArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraArgsInput() {
    return this._extraArgs;
  }

  // extra_binds - computed: false, optional: true, required: false
  private _extraBinds?: string[]; 
  public get extraBinds() {
    return this.getListAttribute('extra_binds');
  }
  public set extraBinds(value: string[]) {
    this._extraBinds = value;
  }
  public resetExtraBinds() {
    this._extraBinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraBindsInput() {
    return this._extraBinds;
  }

  // extra_env - computed: false, optional: true, required: false
  private _extraEnv?: string[]; 
  public get extraEnv() {
    return this.getListAttribute('extra_env');
  }
  public set extraEnv(value: string[]) {
    this._extraEnv = value;
  }
  public resetExtraEnv() {
    this._extraEnv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraEnvInput() {
    return this._extraEnv;
  }

  // image - computed: true, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // service_cluster_ip_range - computed: true, optional: true, required: false
  private _serviceClusterIpRange?: string; 
  public get serviceClusterIpRange() {
    return this.getStringAttribute('service_cluster_ip_range');
  }
  public set serviceClusterIpRange(value: string) {
    this._serviceClusterIpRange = value;
  }
  public resetServiceClusterIpRange() {
    this._serviceClusterIpRange = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceClusterIpRangeInput() {
    return this._serviceClusterIpRange;
  }

  // service_node_port_range - computed: true, optional: true, required: false
  private _serviceNodePortRange?: string; 
  public get serviceNodePortRange() {
    return this.getStringAttribute('service_node_port_range');
  }
  public set serviceNodePortRange(value: string) {
    this._serviceNodePortRange = value;
  }
  public resetServiceNodePortRange() {
    this._serviceNodePortRange = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNodePortRangeInput() {
    return this._serviceNodePortRange;
  }

  // admission_configuration - computed: false, optional: true, required: false
  private _admissionConfiguration = new ClusterRkeConfigServicesKubeApiAdmissionConfigurationOutputReference(this, "admission_configuration");
  public get admissionConfiguration() {
    return this._admissionConfiguration;
  }
  public putAdmissionConfiguration(value: ClusterRkeConfigServicesKubeApiAdmissionConfiguration) {
    this._admissionConfiguration.internalValue = value;
  }
  public resetAdmissionConfiguration() {
    this._admissionConfiguration.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get admissionConfigurationInput() {
    return this._admissionConfiguration.internalValue;
  }

  // audit_log - computed: false, optional: true, required: false
  private _auditLog = new ClusterRkeConfigServicesKubeApiAuditLogOutputReference(this, "audit_log");
  public get auditLog() {
    return this._auditLog;
  }
  public putAuditLog(value: ClusterRkeConfigServicesKubeApiAuditLog) {
    this._auditLog.internalValue = value;
  }
  public resetAuditLog() {
    this._auditLog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditLogInput() {
    return this._auditLog.internalValue;
  }

  // event_rate_limit - computed: false, optional: true, required: false
  private _eventRateLimit = new ClusterRkeConfigServicesKubeApiEventRateLimitOutputReference(this, "event_rate_limit");
  public get eventRateLimit() {
    return this._eventRateLimit;
  }
  public putEventRateLimit(value: ClusterRkeConfigServicesKubeApiEventRateLimit) {
    this._eventRateLimit.internalValue = value;
  }
  public resetEventRateLimit() {
    this._eventRateLimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventRateLimitInput() {
    return this._eventRateLimit.internalValue;
  }

  // secrets_encryption_config - computed: false, optional: true, required: false
  private _secretsEncryptionConfig = new ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigOutputReference(this, "secrets_encryption_config");
  public get secretsEncryptionConfig() {
    return this._secretsEncryptionConfig;
  }
  public putSecretsEncryptionConfig(value: ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig) {
    this._secretsEncryptionConfig.internalValue = value;
  }
  public resetSecretsEncryptionConfig() {
    this._secretsEncryptionConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsEncryptionConfigInput() {
    return this._secretsEncryptionConfig.internalValue;
  }
}
export interface ClusterRkeConfigServicesKubeController {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_cidr Cluster#cluster_cidr}
  */
  readonly clusterCidr?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_args Cluster#extra_args}
  */
  readonly extraArgs?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_binds Cluster#extra_binds}
  */
  readonly extraBinds?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_env Cluster#extra_env}
  */
  readonly extraEnv?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#service_cluster_ip_range Cluster#service_cluster_ip_range}
  */
  readonly serviceClusterIpRange?: string;
}

export function clusterRkeConfigServicesKubeControllerToTerraform(struct?: ClusterRkeConfigServicesKubeControllerOutputReference | ClusterRkeConfigServicesKubeController): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_cidr: cdktf.stringToTerraform(struct!.clusterCidr),
    extra_args: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraArgs),
    extra_binds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraBinds),
    extra_env: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraEnv),
    image: cdktf.stringToTerraform(struct!.image),
    service_cluster_ip_range: cdktf.stringToTerraform(struct!.serviceClusterIpRange),
  }
}


export function clusterRkeConfigServicesKubeControllerToHclTerraform(struct?: ClusterRkeConfigServicesKubeControllerOutputReference | ClusterRkeConfigServicesKubeController): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_cidr: {
      value: cdktf.stringToHclTerraform(struct!.clusterCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_args: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraArgs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    extra_binds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraBinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_env: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraEnv),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_cluster_ip_range: {
      value: cdktf.stringToHclTerraform(struct!.serviceClusterIpRange),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesKubeControllerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesKubeController | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterCidr = this._clusterCidr;
    }
    if (this._extraArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraArgs = this._extraArgs;
    }
    if (this._extraBinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraBinds = this._extraBinds;
    }
    if (this._extraEnv !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraEnv = this._extraEnv;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._serviceClusterIpRange !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceClusterIpRange = this._serviceClusterIpRange;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesKubeController | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clusterCidr = undefined;
      this._extraArgs = undefined;
      this._extraBinds = undefined;
      this._extraEnv = undefined;
      this._image = undefined;
      this._serviceClusterIpRange = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clusterCidr = value.clusterCidr;
      this._extraArgs = value.extraArgs;
      this._extraBinds = value.extraBinds;
      this._extraEnv = value.extraEnv;
      this._image = value.image;
      this._serviceClusterIpRange = value.serviceClusterIpRange;
    }
  }

  // cluster_cidr - computed: true, optional: true, required: false
  private _clusterCidr?: string; 
  public get clusterCidr() {
    return this.getStringAttribute('cluster_cidr');
  }
  public set clusterCidr(value: string) {
    this._clusterCidr = value;
  }
  public resetClusterCidr() {
    this._clusterCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterCidrInput() {
    return this._clusterCidr;
  }

  // extra_args - computed: true, optional: true, required: false
  private _extraArgs?: { [key: string]: string }; 
  public get extraArgs() {
    return this.getStringMapAttribute('extra_args');
  }
  public set extraArgs(value: { [key: string]: string }) {
    this._extraArgs = value;
  }
  public resetExtraArgs() {
    this._extraArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraArgsInput() {
    return this._extraArgs;
  }

  // extra_binds - computed: false, optional: true, required: false
  private _extraBinds?: string[]; 
  public get extraBinds() {
    return this.getListAttribute('extra_binds');
  }
  public set extraBinds(value: string[]) {
    this._extraBinds = value;
  }
  public resetExtraBinds() {
    this._extraBinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraBindsInput() {
    return this._extraBinds;
  }

  // extra_env - computed: false, optional: true, required: false
  private _extraEnv?: string[]; 
  public get extraEnv() {
    return this.getListAttribute('extra_env');
  }
  public set extraEnv(value: string[]) {
    this._extraEnv = value;
  }
  public resetExtraEnv() {
    this._extraEnv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraEnvInput() {
    return this._extraEnv;
  }

  // image - computed: true, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // service_cluster_ip_range - computed: true, optional: true, required: false
  private _serviceClusterIpRange?: string; 
  public get serviceClusterIpRange() {
    return this.getStringAttribute('service_cluster_ip_range');
  }
  public set serviceClusterIpRange(value: string) {
    this._serviceClusterIpRange = value;
  }
  public resetServiceClusterIpRange() {
    this._serviceClusterIpRange = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceClusterIpRangeInput() {
    return this._serviceClusterIpRange;
  }
}
export interface ClusterRkeConfigServicesKubelet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_dns_server Cluster#cluster_dns_server}
  */
  readonly clusterDnsServer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cluster_domain Cluster#cluster_domain}
  */
  readonly clusterDomain?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_args Cluster#extra_args}
  */
  readonly extraArgs?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_binds Cluster#extra_binds}
  */
  readonly extraBinds?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_env Cluster#extra_env}
  */
  readonly extraEnv?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#fail_swap_on Cluster#fail_swap_on}
  */
  readonly failSwapOn?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#generate_serving_certificate Cluster#generate_serving_certificate}
  */
  readonly generateServingCertificate?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#infra_container_image Cluster#infra_container_image}
  */
  readonly infraContainerImage?: string;
}

export function clusterRkeConfigServicesKubeletToTerraform(struct?: ClusterRkeConfigServicesKubeletOutputReference | ClusterRkeConfigServicesKubelet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_dns_server: cdktf.stringToTerraform(struct!.clusterDnsServer),
    cluster_domain: cdktf.stringToTerraform(struct!.clusterDomain),
    extra_args: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraArgs),
    extra_binds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraBinds),
    extra_env: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraEnv),
    fail_swap_on: cdktf.booleanToTerraform(struct!.failSwapOn),
    generate_serving_certificate: cdktf.booleanToTerraform(struct!.generateServingCertificate),
    image: cdktf.stringToTerraform(struct!.image),
    infra_container_image: cdktf.stringToTerraform(struct!.infraContainerImage),
  }
}


export function clusterRkeConfigServicesKubeletToHclTerraform(struct?: ClusterRkeConfigServicesKubeletOutputReference | ClusterRkeConfigServicesKubelet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_dns_server: {
      value: cdktf.stringToHclTerraform(struct!.clusterDnsServer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_domain: {
      value: cdktf.stringToHclTerraform(struct!.clusterDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_args: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraArgs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    extra_binds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraBinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_env: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraEnv),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    fail_swap_on: {
      value: cdktf.booleanToHclTerraform(struct!.failSwapOn),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    generate_serving_certificate: {
      value: cdktf.booleanToHclTerraform(struct!.generateServingCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    infra_container_image: {
      value: cdktf.stringToHclTerraform(struct!.infraContainerImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesKubeletOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesKubelet | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterDnsServer !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterDnsServer = this._clusterDnsServer;
    }
    if (this._clusterDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterDomain = this._clusterDomain;
    }
    if (this._extraArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraArgs = this._extraArgs;
    }
    if (this._extraBinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraBinds = this._extraBinds;
    }
    if (this._extraEnv !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraEnv = this._extraEnv;
    }
    if (this._failSwapOn !== undefined) {
      hasAnyValues = true;
      internalValueResult.failSwapOn = this._failSwapOn;
    }
    if (this._generateServingCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.generateServingCertificate = this._generateServingCertificate;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._infraContainerImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.infraContainerImage = this._infraContainerImage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesKubelet | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clusterDnsServer = undefined;
      this._clusterDomain = undefined;
      this._extraArgs = undefined;
      this._extraBinds = undefined;
      this._extraEnv = undefined;
      this._failSwapOn = undefined;
      this._generateServingCertificate = undefined;
      this._image = undefined;
      this._infraContainerImage = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clusterDnsServer = value.clusterDnsServer;
      this._clusterDomain = value.clusterDomain;
      this._extraArgs = value.extraArgs;
      this._extraBinds = value.extraBinds;
      this._extraEnv = value.extraEnv;
      this._failSwapOn = value.failSwapOn;
      this._generateServingCertificate = value.generateServingCertificate;
      this._image = value.image;
      this._infraContainerImage = value.infraContainerImage;
    }
  }

  // cluster_dns_server - computed: true, optional: true, required: false
  private _clusterDnsServer?: string; 
  public get clusterDnsServer() {
    return this.getStringAttribute('cluster_dns_server');
  }
  public set clusterDnsServer(value: string) {
    this._clusterDnsServer = value;
  }
  public resetClusterDnsServer() {
    this._clusterDnsServer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterDnsServerInput() {
    return this._clusterDnsServer;
  }

  // cluster_domain - computed: true, optional: true, required: false
  private _clusterDomain?: string; 
  public get clusterDomain() {
    return this.getStringAttribute('cluster_domain');
  }
  public set clusterDomain(value: string) {
    this._clusterDomain = value;
  }
  public resetClusterDomain() {
    this._clusterDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterDomainInput() {
    return this._clusterDomain;
  }

  // extra_args - computed: true, optional: true, required: false
  private _extraArgs?: { [key: string]: string }; 
  public get extraArgs() {
    return this.getStringMapAttribute('extra_args');
  }
  public set extraArgs(value: { [key: string]: string }) {
    this._extraArgs = value;
  }
  public resetExtraArgs() {
    this._extraArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraArgsInput() {
    return this._extraArgs;
  }

  // extra_binds - computed: false, optional: true, required: false
  private _extraBinds?: string[]; 
  public get extraBinds() {
    return this.getListAttribute('extra_binds');
  }
  public set extraBinds(value: string[]) {
    this._extraBinds = value;
  }
  public resetExtraBinds() {
    this._extraBinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraBindsInput() {
    return this._extraBinds;
  }

  // extra_env - computed: false, optional: true, required: false
  private _extraEnv?: string[]; 
  public get extraEnv() {
    return this.getListAttribute('extra_env');
  }
  public set extraEnv(value: string[]) {
    this._extraEnv = value;
  }
  public resetExtraEnv() {
    this._extraEnv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraEnvInput() {
    return this._extraEnv;
  }

  // fail_swap_on - computed: true, optional: true, required: false
  private _failSwapOn?: boolean | cdktf.IResolvable; 
  public get failSwapOn() {
    return this.getBooleanAttribute('fail_swap_on');
  }
  public set failSwapOn(value: boolean | cdktf.IResolvable) {
    this._failSwapOn = value;
  }
  public resetFailSwapOn() {
    this._failSwapOn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failSwapOnInput() {
    return this._failSwapOn;
  }

  // generate_serving_certificate - computed: false, optional: true, required: false
  private _generateServingCertificate?: boolean | cdktf.IResolvable; 
  public get generateServingCertificate() {
    return this.getBooleanAttribute('generate_serving_certificate');
  }
  public set generateServingCertificate(value: boolean | cdktf.IResolvable) {
    this._generateServingCertificate = value;
  }
  public resetGenerateServingCertificate() {
    this._generateServingCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get generateServingCertificateInput() {
    return this._generateServingCertificate;
  }

  // image - computed: true, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // infra_container_image - computed: true, optional: true, required: false
  private _infraContainerImage?: string; 
  public get infraContainerImage() {
    return this.getStringAttribute('infra_container_image');
  }
  public set infraContainerImage(value: string) {
    this._infraContainerImage = value;
  }
  public resetInfraContainerImage() {
    this._infraContainerImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get infraContainerImageInput() {
    return this._infraContainerImage;
  }
}
export interface ClusterRkeConfigServicesKubeproxy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_args Cluster#extra_args}
  */
  readonly extraArgs?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_binds Cluster#extra_binds}
  */
  readonly extraBinds?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_env Cluster#extra_env}
  */
  readonly extraEnv?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
}

export function clusterRkeConfigServicesKubeproxyToTerraform(struct?: ClusterRkeConfigServicesKubeproxyOutputReference | ClusterRkeConfigServicesKubeproxy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    extra_args: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraArgs),
    extra_binds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraBinds),
    extra_env: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraEnv),
    image: cdktf.stringToTerraform(struct!.image),
  }
}


export function clusterRkeConfigServicesKubeproxyToHclTerraform(struct?: ClusterRkeConfigServicesKubeproxyOutputReference | ClusterRkeConfigServicesKubeproxy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    extra_args: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraArgs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    extra_binds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraBinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_env: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraEnv),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesKubeproxyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesKubeproxy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._extraArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraArgs = this._extraArgs;
    }
    if (this._extraBinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraBinds = this._extraBinds;
    }
    if (this._extraEnv !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraEnv = this._extraEnv;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesKubeproxy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._extraArgs = undefined;
      this._extraBinds = undefined;
      this._extraEnv = undefined;
      this._image = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._extraArgs = value.extraArgs;
      this._extraBinds = value.extraBinds;
      this._extraEnv = value.extraEnv;
      this._image = value.image;
    }
  }

  // extra_args - computed: true, optional: true, required: false
  private _extraArgs?: { [key: string]: string }; 
  public get extraArgs() {
    return this.getStringMapAttribute('extra_args');
  }
  public set extraArgs(value: { [key: string]: string }) {
    this._extraArgs = value;
  }
  public resetExtraArgs() {
    this._extraArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraArgsInput() {
    return this._extraArgs;
  }

  // extra_binds - computed: false, optional: true, required: false
  private _extraBinds?: string[]; 
  public get extraBinds() {
    return this.getListAttribute('extra_binds');
  }
  public set extraBinds(value: string[]) {
    this._extraBinds = value;
  }
  public resetExtraBinds() {
    this._extraBinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraBindsInput() {
    return this._extraBinds;
  }

  // extra_env - computed: false, optional: true, required: false
  private _extraEnv?: string[]; 
  public get extraEnv() {
    return this.getListAttribute('extra_env');
  }
  public set extraEnv(value: string[]) {
    this._extraEnv = value;
  }
  public resetExtraEnv() {
    this._extraEnv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraEnvInput() {
    return this._extraEnv;
  }

  // image - computed: true, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }
}
export interface ClusterRkeConfigServicesScheduler {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_args Cluster#extra_args}
  */
  readonly extraArgs?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_binds Cluster#extra_binds}
  */
  readonly extraBinds?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#extra_env Cluster#extra_env}
  */
  readonly extraEnv?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
}

export function clusterRkeConfigServicesSchedulerToTerraform(struct?: ClusterRkeConfigServicesSchedulerOutputReference | ClusterRkeConfigServicesScheduler): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    extra_args: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraArgs),
    extra_binds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraBinds),
    extra_env: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraEnv),
    image: cdktf.stringToTerraform(struct!.image),
  }
}


export function clusterRkeConfigServicesSchedulerToHclTerraform(struct?: ClusterRkeConfigServicesSchedulerOutputReference | ClusterRkeConfigServicesScheduler): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    extra_args: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraArgs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    extra_binds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraBinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_env: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraEnv),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesSchedulerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServicesScheduler | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._extraArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraArgs = this._extraArgs;
    }
    if (this._extraBinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraBinds = this._extraBinds;
    }
    if (this._extraEnv !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraEnv = this._extraEnv;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServicesScheduler | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._extraArgs = undefined;
      this._extraBinds = undefined;
      this._extraEnv = undefined;
      this._image = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._extraArgs = value.extraArgs;
      this._extraBinds = value.extraBinds;
      this._extraEnv = value.extraEnv;
      this._image = value.image;
    }
  }

  // extra_args - computed: true, optional: true, required: false
  private _extraArgs?: { [key: string]: string }; 
  public get extraArgs() {
    return this.getStringMapAttribute('extra_args');
  }
  public set extraArgs(value: { [key: string]: string }) {
    this._extraArgs = value;
  }
  public resetExtraArgs() {
    this._extraArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraArgsInput() {
    return this._extraArgs;
  }

  // extra_binds - computed: false, optional: true, required: false
  private _extraBinds?: string[]; 
  public get extraBinds() {
    return this.getListAttribute('extra_binds');
  }
  public set extraBinds(value: string[]) {
    this._extraBinds = value;
  }
  public resetExtraBinds() {
    this._extraBinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraBindsInput() {
    return this._extraBinds;
  }

  // extra_env - computed: false, optional: true, required: false
  private _extraEnv?: string[]; 
  public get extraEnv() {
    return this.getListAttribute('extra_env');
  }
  public set extraEnv(value: string[]) {
    this._extraEnv = value;
  }
  public resetExtraEnv() {
    this._extraEnv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraEnvInput() {
    return this._extraEnv;
  }

  // image - computed: true, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }
}
export interface ClusterRkeConfigServices {
  /**
  * etcd block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#etcd Cluster#etcd}
  */
  readonly etcd?: ClusterRkeConfigServicesEtcd;
  /**
  * kube_api block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kube_api Cluster#kube_api}
  */
  readonly kubeApi?: ClusterRkeConfigServicesKubeApi;
  /**
  * kube_controller block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kube_controller Cluster#kube_controller}
  */
  readonly kubeController?: ClusterRkeConfigServicesKubeController;
  /**
  * kubelet block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kubelet Cluster#kubelet}
  */
  readonly kubelet?: ClusterRkeConfigServicesKubelet;
  /**
  * kubeproxy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kubeproxy Cluster#kubeproxy}
  */
  readonly kubeproxy?: ClusterRkeConfigServicesKubeproxy;
  /**
  * scheduler block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#scheduler Cluster#scheduler}
  */
  readonly scheduler?: ClusterRkeConfigServicesScheduler;
}

export function clusterRkeConfigServicesToTerraform(struct?: ClusterRkeConfigServicesOutputReference | ClusterRkeConfigServices): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    etcd: clusterRkeConfigServicesEtcdToTerraform(struct!.etcd),
    kube_api: clusterRkeConfigServicesKubeApiToTerraform(struct!.kubeApi),
    kube_controller: clusterRkeConfigServicesKubeControllerToTerraform(struct!.kubeController),
    kubelet: clusterRkeConfigServicesKubeletToTerraform(struct!.kubelet),
    kubeproxy: clusterRkeConfigServicesKubeproxyToTerraform(struct!.kubeproxy),
    scheduler: clusterRkeConfigServicesSchedulerToTerraform(struct!.scheduler),
  }
}


export function clusterRkeConfigServicesToHclTerraform(struct?: ClusterRkeConfigServicesOutputReference | ClusterRkeConfigServices): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    etcd: {
      value: clusterRkeConfigServicesEtcdToHclTerraform(struct!.etcd),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesEtcdList",
    },
    kube_api: {
      value: clusterRkeConfigServicesKubeApiToHclTerraform(struct!.kubeApi),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesKubeApiList",
    },
    kube_controller: {
      value: clusterRkeConfigServicesKubeControllerToHclTerraform(struct!.kubeController),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesKubeControllerList",
    },
    kubelet: {
      value: clusterRkeConfigServicesKubeletToHclTerraform(struct!.kubelet),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesKubeletList",
    },
    kubeproxy: {
      value: clusterRkeConfigServicesKubeproxyToHclTerraform(struct!.kubeproxy),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesKubeproxyList",
    },
    scheduler: {
      value: clusterRkeConfigServicesSchedulerToHclTerraform(struct!.scheduler),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesSchedulerList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigServices | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._etcd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.etcd = this._etcd?.internalValue;
    }
    if (this._kubeApi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeApi = this._kubeApi?.internalValue;
    }
    if (this._kubeController?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeController = this._kubeController?.internalValue;
    }
    if (this._kubelet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubelet = this._kubelet?.internalValue;
    }
    if (this._kubeproxy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeproxy = this._kubeproxy?.internalValue;
    }
    if (this._scheduler?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.scheduler = this._scheduler?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigServices | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._etcd.internalValue = undefined;
      this._kubeApi.internalValue = undefined;
      this._kubeController.internalValue = undefined;
      this._kubelet.internalValue = undefined;
      this._kubeproxy.internalValue = undefined;
      this._scheduler.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._etcd.internalValue = value.etcd;
      this._kubeApi.internalValue = value.kubeApi;
      this._kubeController.internalValue = value.kubeController;
      this._kubelet.internalValue = value.kubelet;
      this._kubeproxy.internalValue = value.kubeproxy;
      this._scheduler.internalValue = value.scheduler;
    }
  }

  // etcd - computed: false, optional: true, required: false
  private _etcd = new ClusterRkeConfigServicesEtcdOutputReference(this, "etcd");
  public get etcd() {
    return this._etcd;
  }
  public putEtcd(value: ClusterRkeConfigServicesEtcd) {
    this._etcd.internalValue = value;
  }
  public resetEtcd() {
    this._etcd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get etcdInput() {
    return this._etcd.internalValue;
  }

  // kube_api - computed: false, optional: true, required: false
  private _kubeApi = new ClusterRkeConfigServicesKubeApiOutputReference(this, "kube_api");
  public get kubeApi() {
    return this._kubeApi;
  }
  public putKubeApi(value: ClusterRkeConfigServicesKubeApi) {
    this._kubeApi.internalValue = value;
  }
  public resetKubeApi() {
    this._kubeApi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeApiInput() {
    return this._kubeApi.internalValue;
  }

  // kube_controller - computed: false, optional: true, required: false
  private _kubeController = new ClusterRkeConfigServicesKubeControllerOutputReference(this, "kube_controller");
  public get kubeController() {
    return this._kubeController;
  }
  public putKubeController(value: ClusterRkeConfigServicesKubeController) {
    this._kubeController.internalValue = value;
  }
  public resetKubeController() {
    this._kubeController.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeControllerInput() {
    return this._kubeController.internalValue;
  }

  // kubelet - computed: false, optional: true, required: false
  private _kubelet = new ClusterRkeConfigServicesKubeletOutputReference(this, "kubelet");
  public get kubelet() {
    return this._kubelet;
  }
  public putKubelet(value: ClusterRkeConfigServicesKubelet) {
    this._kubelet.internalValue = value;
  }
  public resetKubelet() {
    this._kubelet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeletInput() {
    return this._kubelet.internalValue;
  }

  // kubeproxy - computed: false, optional: true, required: false
  private _kubeproxy = new ClusterRkeConfigServicesKubeproxyOutputReference(this, "kubeproxy");
  public get kubeproxy() {
    return this._kubeproxy;
  }
  public putKubeproxy(value: ClusterRkeConfigServicesKubeproxy) {
    this._kubeproxy.internalValue = value;
  }
  public resetKubeproxy() {
    this._kubeproxy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeproxyInput() {
    return this._kubeproxy.internalValue;
  }

  // scheduler - computed: false, optional: true, required: false
  private _scheduler = new ClusterRkeConfigServicesSchedulerOutputReference(this, "scheduler");
  public get scheduler() {
    return this._scheduler;
  }
  public putScheduler(value: ClusterRkeConfigServicesScheduler) {
    this._scheduler.internalValue = value;
  }
  public resetScheduler() {
    this._scheduler.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schedulerInput() {
    return this._scheduler.internalValue;
  }
}
export interface ClusterRkeConfigUpgradeStrategyDrainInput {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#delete_local_data Cluster#delete_local_data}
  */
  readonly deleteLocalData?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#force Cluster#force}
  */
  readonly force?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#grace_period Cluster#grace_period}
  */
  readonly gracePeriod?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ignore_daemon_sets Cluster#ignore_daemon_sets}
  */
  readonly ignoreDaemonSets?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#timeout Cluster#timeout}
  */
  readonly timeout?: number;
}

export function clusterRkeConfigUpgradeStrategyDrainInputToTerraform(struct?: ClusterRkeConfigUpgradeStrategyDrainInputOutputReference | ClusterRkeConfigUpgradeStrategyDrainInput): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delete_local_data: cdktf.booleanToTerraform(struct!.deleteLocalData),
    force: cdktf.booleanToTerraform(struct!.force),
    grace_period: cdktf.numberToTerraform(struct!.gracePeriod),
    ignore_daemon_sets: cdktf.booleanToTerraform(struct!.ignoreDaemonSets),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function clusterRkeConfigUpgradeStrategyDrainInputToHclTerraform(struct?: ClusterRkeConfigUpgradeStrategyDrainInputOutputReference | ClusterRkeConfigUpgradeStrategyDrainInput): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delete_local_data: {
      value: cdktf.booleanToHclTerraform(struct!.deleteLocalData),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    force: {
      value: cdktf.booleanToHclTerraform(struct!.force),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    grace_period: {
      value: cdktf.numberToHclTerraform(struct!.gracePeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ignore_daemon_sets: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreDaemonSets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigUpgradeStrategyDrainInputOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigUpgradeStrategyDrainInput | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deleteLocalData !== undefined) {
      hasAnyValues = true;
      internalValueResult.deleteLocalData = this._deleteLocalData;
    }
    if (this._force !== undefined) {
      hasAnyValues = true;
      internalValueResult.force = this._force;
    }
    if (this._gracePeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.gracePeriod = this._gracePeriod;
    }
    if (this._ignoreDaemonSets !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreDaemonSets = this._ignoreDaemonSets;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigUpgradeStrategyDrainInput | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._deleteLocalData = undefined;
      this._force = undefined;
      this._gracePeriod = undefined;
      this._ignoreDaemonSets = undefined;
      this._timeout = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._deleteLocalData = value.deleteLocalData;
      this._force = value.force;
      this._gracePeriod = value.gracePeriod;
      this._ignoreDaemonSets = value.ignoreDaemonSets;
      this._timeout = value.timeout;
    }
  }

  // delete_local_data - computed: false, optional: true, required: false
  private _deleteLocalData?: boolean | cdktf.IResolvable; 
  public get deleteLocalData() {
    return this.getBooleanAttribute('delete_local_data');
  }
  public set deleteLocalData(value: boolean | cdktf.IResolvable) {
    this._deleteLocalData = value;
  }
  public resetDeleteLocalData() {
    this._deleteLocalData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteLocalDataInput() {
    return this._deleteLocalData;
  }

  // force - computed: false, optional: true, required: false
  private _force?: boolean | cdktf.IResolvable; 
  public get force() {
    return this.getBooleanAttribute('force');
  }
  public set force(value: boolean | cdktf.IResolvable) {
    this._force = value;
  }
  public resetForce() {
    this._force = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceInput() {
    return this._force;
  }

  // grace_period - computed: false, optional: true, required: false
  private _gracePeriod?: number; 
  public get gracePeriod() {
    return this.getNumberAttribute('grace_period');
  }
  public set gracePeriod(value: number) {
    this._gracePeriod = value;
  }
  public resetGracePeriod() {
    this._gracePeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gracePeriodInput() {
    return this._gracePeriod;
  }

  // ignore_daemon_sets - computed: false, optional: true, required: false
  private _ignoreDaemonSets?: boolean | cdktf.IResolvable; 
  public get ignoreDaemonSets() {
    return this.getBooleanAttribute('ignore_daemon_sets');
  }
  public set ignoreDaemonSets(value: boolean | cdktf.IResolvable) {
    this._ignoreDaemonSets = value;
  }
  public resetIgnoreDaemonSets() {
    this._ignoreDaemonSets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreDaemonSetsInput() {
    return this._ignoreDaemonSets;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface ClusterRkeConfigUpgradeStrategy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#drain Cluster#drain}
  */
  readonly drain?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_unavailable_controlplane Cluster#max_unavailable_controlplane}
  */
  readonly maxUnavailableControlplane?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#max_unavailable_worker Cluster#max_unavailable_worker}
  */
  readonly maxUnavailableWorker?: string;
  /**
  * drain_input block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#drain_input Cluster#drain_input}
  */
  readonly drainInput?: ClusterRkeConfigUpgradeStrategyDrainInput;
}

export function clusterRkeConfigUpgradeStrategyToTerraform(struct?: ClusterRkeConfigUpgradeStrategyOutputReference | ClusterRkeConfigUpgradeStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    drain: cdktf.booleanToTerraform(struct!.drain),
    max_unavailable_controlplane: cdktf.stringToTerraform(struct!.maxUnavailableControlplane),
    max_unavailable_worker: cdktf.stringToTerraform(struct!.maxUnavailableWorker),
    drain_input: clusterRkeConfigUpgradeStrategyDrainInputToTerraform(struct!.drainInput),
  }
}


export function clusterRkeConfigUpgradeStrategyToHclTerraform(struct?: ClusterRkeConfigUpgradeStrategyOutputReference | ClusterRkeConfigUpgradeStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    drain: {
      value: cdktf.booleanToHclTerraform(struct!.drain),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_unavailable_controlplane: {
      value: cdktf.stringToHclTerraform(struct!.maxUnavailableControlplane),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_unavailable_worker: {
      value: cdktf.stringToHclTerraform(struct!.maxUnavailableWorker),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    drain_input: {
      value: clusterRkeConfigUpgradeStrategyDrainInputToHclTerraform(struct!.drainInput),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigUpgradeStrategyDrainInputList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigUpgradeStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfigUpgradeStrategy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._drain !== undefined) {
      hasAnyValues = true;
      internalValueResult.drain = this._drain;
    }
    if (this._maxUnavailableControlplane !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxUnavailableControlplane = this._maxUnavailableControlplane;
    }
    if (this._maxUnavailableWorker !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxUnavailableWorker = this._maxUnavailableWorker;
    }
    if (this._drainInput?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.drainInput = this._drainInput?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfigUpgradeStrategy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._drain = undefined;
      this._maxUnavailableControlplane = undefined;
      this._maxUnavailableWorker = undefined;
      this._drainInput.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._drain = value.drain;
      this._maxUnavailableControlplane = value.maxUnavailableControlplane;
      this._maxUnavailableWorker = value.maxUnavailableWorker;
      this._drainInput.internalValue = value.drainInput;
    }
  }

  // drain - computed: false, optional: true, required: false
  private _drain?: boolean | cdktf.IResolvable; 
  public get drain() {
    return this.getBooleanAttribute('drain');
  }
  public set drain(value: boolean | cdktf.IResolvable) {
    this._drain = value;
  }
  public resetDrain() {
    this._drain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drainTfInput() {
    return this._drain;
  }

  // max_unavailable_controlplane - computed: false, optional: true, required: false
  private _maxUnavailableControlplane?: string; 
  public get maxUnavailableControlplane() {
    return this.getStringAttribute('max_unavailable_controlplane');
  }
  public set maxUnavailableControlplane(value: string) {
    this._maxUnavailableControlplane = value;
  }
  public resetMaxUnavailableControlplane() {
    this._maxUnavailableControlplane = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxUnavailableControlplaneInput() {
    return this._maxUnavailableControlplane;
  }

  // max_unavailable_worker - computed: false, optional: true, required: false
  private _maxUnavailableWorker?: string; 
  public get maxUnavailableWorker() {
    return this.getStringAttribute('max_unavailable_worker');
  }
  public set maxUnavailableWorker(value: string) {
    this._maxUnavailableWorker = value;
  }
  public resetMaxUnavailableWorker() {
    this._maxUnavailableWorker = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxUnavailableWorkerInput() {
    return this._maxUnavailableWorker;
  }

  // drain_input - computed: false, optional: true, required: false
  private _drainInput = new ClusterRkeConfigUpgradeStrategyDrainInputOutputReference(this, "drain_input");
  public get drainInput() {
    return this._drainInput;
  }
  public putDrainInput(value: ClusterRkeConfigUpgradeStrategyDrainInput) {
    this._drainInput.internalValue = value;
  }
  public resetDrainInput() {
    this._drainInput.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drainInputInput() {
    return this._drainInput.internalValue;
  }
}
export interface ClusterRkeConfig {
  /**
  * Optional duration in seconds of addon job.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#addon_job_timeout Cluster#addon_job_timeout}
  */
  readonly addonJobTimeout?: number;
  /**
  * Optional addons descripton to deploy on rke cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#addons Cluster#addons}
  */
  readonly addons?: string;
  /**
  * Optional addons yaml manisfest to deploy on rke cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#addons_include Cluster#addons_include}
  */
  readonly addonsInclude?: string[];
  /**
  * Enable/disable using cri-dockerd
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#enable_cri_dockerd Cluster#enable_cri_dockerd}
  */
  readonly enableCriDockerd?: boolean | cdktf.IResolvable;
  /**
  * Optional ignore docker version on nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ignore_docker_version Cluster#ignore_docker_version}
  */
  readonly ignoreDockerVersion?: boolean | cdktf.IResolvable;
  /**
  * Optional kubernetes version to deploy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#kubernetes_version Cluster#kubernetes_version}
  */
  readonly kubernetesVersion?: string;
  /**
  * Optional prefix to customize kubernetes path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#prefix_path Cluster#prefix_path}
  */
  readonly prefixPath?: string;
  /**
  * Optional use ssh agent auth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ssh_agent_auth Cluster#ssh_agent_auth}
  */
  readonly sshAgentAuth?: boolean | cdktf.IResolvable;
  /**
  * Optional cluster level SSH certificate path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ssh_cert_path Cluster#ssh_cert_path}
  */
  readonly sshCertPath?: string;
  /**
  * Optional cluster level SSH private key path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ssh_key_path Cluster#ssh_key_path}
  */
  readonly sshKeyPath?: string;
  /**
  * Optional prefix to customize kubernetes path for windows
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#win_prefix_path Cluster#win_prefix_path}
  */
  readonly winPrefixPath?: string;
  /**
  * authentication block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#authentication Cluster#authentication}
  */
  readonly authentication?: ClusterRkeConfigAuthentication;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#authorization Cluster#authorization}
  */
  readonly authorization?: ClusterRkeConfigAuthorization;
  /**
  * bastion_host block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#bastion_host Cluster#bastion_host}
  */
  readonly bastionHost?: ClusterRkeConfigBastionHost;
  /**
  * cloud_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#cloud_provider Cluster#cloud_provider}
  */
  readonly cloudProvider?: ClusterRkeConfigCloudProvider;
  /**
  * dns block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#dns Cluster#dns}
  */
  readonly dns?: ClusterRkeConfigDns;
  /**
  * ingress block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#ingress Cluster#ingress}
  */
  readonly ingress?: ClusterRkeConfigIngress;
  /**
  * monitoring block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#monitoring Cluster#monitoring}
  */
  readonly monitoring?: ClusterRkeConfigMonitoring;
  /**
  * network block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#network Cluster#network}
  */
  readonly network?: ClusterRkeConfigNetwork;
  /**
  * nodes block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#nodes Cluster#nodes}
  */
  readonly nodes?: ClusterRkeConfigNodes[] | cdktf.IResolvable;
  /**
  * private_registries block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#private_registries Cluster#private_registries}
  */
  readonly privateRegistries?: ClusterRkeConfigPrivateRegistries[] | cdktf.IResolvable;
  /**
  * services block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#services Cluster#services}
  */
  readonly services?: ClusterRkeConfigServices;
  /**
  * upgrade_strategy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#upgrade_strategy Cluster#upgrade_strategy}
  */
  readonly upgradeStrategy?: ClusterRkeConfigUpgradeStrategy;
}

export function clusterRkeConfigToTerraform(struct?: ClusterRkeConfigOutputReference | ClusterRkeConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    addon_job_timeout: cdktf.numberToTerraform(struct!.addonJobTimeout),
    addons: cdktf.stringToTerraform(struct!.addons),
    addons_include: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.addonsInclude),
    enable_cri_dockerd: cdktf.booleanToTerraform(struct!.enableCriDockerd),
    ignore_docker_version: cdktf.booleanToTerraform(struct!.ignoreDockerVersion),
    kubernetes_version: cdktf.stringToTerraform(struct!.kubernetesVersion),
    prefix_path: cdktf.stringToTerraform(struct!.prefixPath),
    ssh_agent_auth: cdktf.booleanToTerraform(struct!.sshAgentAuth),
    ssh_cert_path: cdktf.stringToTerraform(struct!.sshCertPath),
    ssh_key_path: cdktf.stringToTerraform(struct!.sshKeyPath),
    win_prefix_path: cdktf.stringToTerraform(struct!.winPrefixPath),
    authentication: clusterRkeConfigAuthenticationToTerraform(struct!.authentication),
    authorization: clusterRkeConfigAuthorizationToTerraform(struct!.authorization),
    bastion_host: clusterRkeConfigBastionHostToTerraform(struct!.bastionHost),
    cloud_provider: clusterRkeConfigCloudProviderToTerraform(struct!.cloudProvider),
    dns: clusterRkeConfigDnsToTerraform(struct!.dns),
    ingress: clusterRkeConfigIngressToTerraform(struct!.ingress),
    monitoring: clusterRkeConfigMonitoringToTerraform(struct!.monitoring),
    network: clusterRkeConfigNetworkToTerraform(struct!.network),
    nodes: cdktf.listMapper(clusterRkeConfigNodesToTerraform, true)(struct!.nodes),
    private_registries: cdktf.listMapper(clusterRkeConfigPrivateRegistriesToTerraform, true)(struct!.privateRegistries),
    services: clusterRkeConfigServicesToTerraform(struct!.services),
    upgrade_strategy: clusterRkeConfigUpgradeStrategyToTerraform(struct!.upgradeStrategy),
  }
}


export function clusterRkeConfigToHclTerraform(struct?: ClusterRkeConfigOutputReference | ClusterRkeConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    addon_job_timeout: {
      value: cdktf.numberToHclTerraform(struct!.addonJobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    addons: {
      value: cdktf.stringToHclTerraform(struct!.addons),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    addons_include: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.addonsInclude),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    enable_cri_dockerd: {
      value: cdktf.booleanToHclTerraform(struct!.enableCriDockerd),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignore_docker_version: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreDockerVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kubernetes_version: {
      value: cdktf.stringToHclTerraform(struct!.kubernetesVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_path: {
      value: cdktf.stringToHclTerraform(struct!.prefixPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssh_agent_auth: {
      value: cdktf.booleanToHclTerraform(struct!.sshAgentAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ssh_cert_path: {
      value: cdktf.stringToHclTerraform(struct!.sshCertPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssh_key_path: {
      value: cdktf.stringToHclTerraform(struct!.sshKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    win_prefix_path: {
      value: cdktf.stringToHclTerraform(struct!.winPrefixPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication: {
      value: clusterRkeConfigAuthenticationToHclTerraform(struct!.authentication),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigAuthenticationList",
    },
    authorization: {
      value: clusterRkeConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigAuthorizationList",
    },
    bastion_host: {
      value: clusterRkeConfigBastionHostToHclTerraform(struct!.bastionHost),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigBastionHostList",
    },
    cloud_provider: {
      value: clusterRkeConfigCloudProviderToHclTerraform(struct!.cloudProvider),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigCloudProviderList",
    },
    dns: {
      value: clusterRkeConfigDnsToHclTerraform(struct!.dns),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigDnsList",
    },
    ingress: {
      value: clusterRkeConfigIngressToHclTerraform(struct!.ingress),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigIngressList",
    },
    monitoring: {
      value: clusterRkeConfigMonitoringToHclTerraform(struct!.monitoring),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigMonitoringList",
    },
    network: {
      value: clusterRkeConfigNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigNetworkList",
    },
    nodes: {
      value: cdktf.listMapperHcl(clusterRkeConfigNodesToHclTerraform, true)(struct!.nodes),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigNodesList",
    },
    private_registries: {
      value: cdktf.listMapperHcl(clusterRkeConfigPrivateRegistriesToHclTerraform, true)(struct!.privateRegistries),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigPrivateRegistriesList",
    },
    services: {
      value: clusterRkeConfigServicesToHclTerraform(struct!.services),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigServicesList",
    },
    upgrade_strategy: {
      value: clusterRkeConfigUpgradeStrategyToHclTerraform(struct!.upgradeStrategy),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterRkeConfigUpgradeStrategyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterRkeConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterRkeConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addonJobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.addonJobTimeout = this._addonJobTimeout;
    }
    if (this._addons !== undefined) {
      hasAnyValues = true;
      internalValueResult.addons = this._addons;
    }
    if (this._addonsInclude !== undefined) {
      hasAnyValues = true;
      internalValueResult.addonsInclude = this._addonsInclude;
    }
    if (this._enableCriDockerd !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableCriDockerd = this._enableCriDockerd;
    }
    if (this._ignoreDockerVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreDockerVersion = this._ignoreDockerVersion;
    }
    if (this._kubernetesVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesVersion = this._kubernetesVersion;
    }
    if (this._prefixPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixPath = this._prefixPath;
    }
    if (this._sshAgentAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.sshAgentAuth = this._sshAgentAuth;
    }
    if (this._sshCertPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.sshCertPath = this._sshCertPath;
    }
    if (this._sshKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.sshKeyPath = this._sshKeyPath;
    }
    if (this._winPrefixPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.winPrefixPath = this._winPrefixPath;
    }
    if (this._authentication?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authentication = this._authentication?.internalValue;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._bastionHost?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bastionHost = this._bastionHost?.internalValue;
    }
    if (this._cloudProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProvider = this._cloudProvider?.internalValue;
    }
    if (this._dns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dns = this._dns?.internalValue;
    }
    if (this._ingress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingress = this._ingress?.internalValue;
    }
    if (this._monitoring?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoring = this._monitoring?.internalValue;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._nodes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodes = this._nodes?.internalValue;
    }
    if (this._privateRegistries?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateRegistries = this._privateRegistries?.internalValue;
    }
    if (this._services?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.services = this._services?.internalValue;
    }
    if (this._upgradeStrategy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upgradeStrategy = this._upgradeStrategy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterRkeConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._addonJobTimeout = undefined;
      this._addons = undefined;
      this._addonsInclude = undefined;
      this._enableCriDockerd = undefined;
      this._ignoreDockerVersion = undefined;
      this._kubernetesVersion = undefined;
      this._prefixPath = undefined;
      this._sshAgentAuth = undefined;
      this._sshCertPath = undefined;
      this._sshKeyPath = undefined;
      this._winPrefixPath = undefined;
      this._authentication.internalValue = undefined;
      this._authorization.internalValue = undefined;
      this._bastionHost.internalValue = undefined;
      this._cloudProvider.internalValue = undefined;
      this._dns.internalValue = undefined;
      this._ingress.internalValue = undefined;
      this._monitoring.internalValue = undefined;
      this._network.internalValue = undefined;
      this._nodes.internalValue = undefined;
      this._privateRegistries.internalValue = undefined;
      this._services.internalValue = undefined;
      this._upgradeStrategy.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._addonJobTimeout = value.addonJobTimeout;
      this._addons = value.addons;
      this._addonsInclude = value.addonsInclude;
      this._enableCriDockerd = value.enableCriDockerd;
      this._ignoreDockerVersion = value.ignoreDockerVersion;
      this._kubernetesVersion = value.kubernetesVersion;
      this._prefixPath = value.prefixPath;
      this._sshAgentAuth = value.sshAgentAuth;
      this._sshCertPath = value.sshCertPath;
      this._sshKeyPath = value.sshKeyPath;
      this._winPrefixPath = value.winPrefixPath;
      this._authentication.internalValue = value.authentication;
      this._authorization.internalValue = value.authorization;
      this._bastionHost.internalValue = value.bastionHost;
      this._cloudProvider.internalValue = value.cloudProvider;
      this._dns.internalValue = value.dns;
      this._ingress.internalValue = value.ingress;
      this._monitoring.internalValue = value.monitoring;
      this._network.internalValue = value.network;
      this._nodes.internalValue = value.nodes;
      this._privateRegistries.internalValue = value.privateRegistries;
      this._services.internalValue = value.services;
      this._upgradeStrategy.internalValue = value.upgradeStrategy;
    }
  }

  // addon_job_timeout - computed: true, optional: true, required: false
  private _addonJobTimeout?: number; 
  public get addonJobTimeout() {
    return this.getNumberAttribute('addon_job_timeout');
  }
  public set addonJobTimeout(value: number) {
    this._addonJobTimeout = value;
  }
  public resetAddonJobTimeout() {
    this._addonJobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addonJobTimeoutInput() {
    return this._addonJobTimeout;
  }

  // addons - computed: false, optional: true, required: false
  private _addons?: string; 
  public get addons() {
    return this.getStringAttribute('addons');
  }
  public set addons(value: string) {
    this._addons = value;
  }
  public resetAddons() {
    this._addons = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addonsInput() {
    return this._addons;
  }

  // addons_include - computed: false, optional: true, required: false
  private _addonsInclude?: string[]; 
  public get addonsInclude() {
    return this.getListAttribute('addons_include');
  }
  public set addonsInclude(value: string[]) {
    this._addonsInclude = value;
  }
  public resetAddonsInclude() {
    this._addonsInclude = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addonsIncludeInput() {
    return this._addonsInclude;
  }

  // enable_cri_dockerd - computed: false, optional: true, required: false
  private _enableCriDockerd?: boolean | cdktf.IResolvable; 
  public get enableCriDockerd() {
    return this.getBooleanAttribute('enable_cri_dockerd');
  }
  public set enableCriDockerd(value: boolean | cdktf.IResolvable) {
    this._enableCriDockerd = value;
  }
  public resetEnableCriDockerd() {
    this._enableCriDockerd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableCriDockerdInput() {
    return this._enableCriDockerd;
  }

  // ignore_docker_version - computed: false, optional: true, required: false
  private _ignoreDockerVersion?: boolean | cdktf.IResolvable; 
  public get ignoreDockerVersion() {
    return this.getBooleanAttribute('ignore_docker_version');
  }
  public set ignoreDockerVersion(value: boolean | cdktf.IResolvable) {
    this._ignoreDockerVersion = value;
  }
  public resetIgnoreDockerVersion() {
    this._ignoreDockerVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreDockerVersionInput() {
    return this._ignoreDockerVersion;
  }

  // kubernetes_version - computed: true, optional: true, required: false
  private _kubernetesVersion?: string; 
  public get kubernetesVersion() {
    return this.getStringAttribute('kubernetes_version');
  }
  public set kubernetesVersion(value: string) {
    this._kubernetesVersion = value;
  }
  public resetKubernetesVersion() {
    this._kubernetesVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesVersionInput() {
    return this._kubernetesVersion;
  }

  // prefix_path - computed: true, optional: true, required: false
  private _prefixPath?: string; 
  public get prefixPath() {
    return this.getStringAttribute('prefix_path');
  }
  public set prefixPath(value: string) {
    this._prefixPath = value;
  }
  public resetPrefixPath() {
    this._prefixPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixPathInput() {
    return this._prefixPath;
  }

  // ssh_agent_auth - computed: false, optional: true, required: false
  private _sshAgentAuth?: boolean | cdktf.IResolvable; 
  public get sshAgentAuth() {
    return this.getBooleanAttribute('ssh_agent_auth');
  }
  public set sshAgentAuth(value: boolean | cdktf.IResolvable) {
    this._sshAgentAuth = value;
  }
  public resetSshAgentAuth() {
    this._sshAgentAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshAgentAuthInput() {
    return this._sshAgentAuth;
  }

  // ssh_cert_path - computed: true, optional: true, required: false
  private _sshCertPath?: string; 
  public get sshCertPath() {
    return this.getStringAttribute('ssh_cert_path');
  }
  public set sshCertPath(value: string) {
    this._sshCertPath = value;
  }
  public resetSshCertPath() {
    this._sshCertPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshCertPathInput() {
    return this._sshCertPath;
  }

  // ssh_key_path - computed: true, optional: true, required: false
  private _sshKeyPath?: string; 
  public get sshKeyPath() {
    return this.getStringAttribute('ssh_key_path');
  }
  public set sshKeyPath(value: string) {
    this._sshKeyPath = value;
  }
  public resetSshKeyPath() {
    this._sshKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshKeyPathInput() {
    return this._sshKeyPath;
  }

  // win_prefix_path - computed: true, optional: true, required: false
  private _winPrefixPath?: string; 
  public get winPrefixPath() {
    return this.getStringAttribute('win_prefix_path');
  }
  public set winPrefixPath(value: string) {
    this._winPrefixPath = value;
  }
  public resetWinPrefixPath() {
    this._winPrefixPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get winPrefixPathInput() {
    return this._winPrefixPath;
  }

  // authentication - computed: false, optional: true, required: false
  private _authentication = new ClusterRkeConfigAuthenticationOutputReference(this, "authentication");
  public get authentication() {
    return this._authentication;
  }
  public putAuthentication(value: ClusterRkeConfigAuthentication) {
    this._authentication.internalValue = value;
  }
  public resetAuthentication() {
    this._authentication.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationInput() {
    return this._authentication.internalValue;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new ClusterRkeConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: ClusterRkeConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // bastion_host - computed: false, optional: true, required: false
  private _bastionHost = new ClusterRkeConfigBastionHostOutputReference(this, "bastion_host");
  public get bastionHost() {
    return this._bastionHost;
  }
  public putBastionHost(value: ClusterRkeConfigBastionHost) {
    this._bastionHost.internalValue = value;
  }
  public resetBastionHost() {
    this._bastionHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bastionHostInput() {
    return this._bastionHost.internalValue;
  }

  // cloud_provider - computed: false, optional: true, required: false
  private _cloudProvider = new ClusterRkeConfigCloudProviderOutputReference(this, "cloud_provider");
  public get cloudProvider() {
    return this._cloudProvider;
  }
  public putCloudProvider(value: ClusterRkeConfigCloudProvider) {
    this._cloudProvider.internalValue = value;
  }
  public resetCloudProvider() {
    this._cloudProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderInput() {
    return this._cloudProvider.internalValue;
  }

  // dns - computed: false, optional: true, required: false
  private _dns = new ClusterRkeConfigDnsOutputReference(this, "dns");
  public get dns() {
    return this._dns;
  }
  public putDns(value: ClusterRkeConfigDns) {
    this._dns.internalValue = value;
  }
  public resetDns() {
    this._dns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsInput() {
    return this._dns.internalValue;
  }

  // ingress - computed: false, optional: true, required: false
  private _ingress = new ClusterRkeConfigIngressOutputReference(this, "ingress");
  public get ingress() {
    return this._ingress;
  }
  public putIngress(value: ClusterRkeConfigIngress) {
    this._ingress.internalValue = value;
  }
  public resetIngress() {
    this._ingress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressInput() {
    return this._ingress.internalValue;
  }

  // monitoring - computed: false, optional: true, required: false
  private _monitoring = new ClusterRkeConfigMonitoringOutputReference(this, "monitoring");
  public get monitoring() {
    return this._monitoring;
  }
  public putMonitoring(value: ClusterRkeConfigMonitoring) {
    this._monitoring.internalValue = value;
  }
  public resetMonitoring() {
    this._monitoring.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringInput() {
    return this._monitoring.internalValue;
  }

  // network - computed: false, optional: true, required: false
  private _network = new ClusterRkeConfigNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: ClusterRkeConfigNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // nodes - computed: false, optional: true, required: false
  private _nodes = new ClusterRkeConfigNodesList(this, "nodes", false);
  public get nodes() {
    return this._nodes;
  }
  public putNodes(value: ClusterRkeConfigNodes[] | cdktf.IResolvable) {
    this._nodes.internalValue = value;
  }
  public resetNodes() {
    this._nodes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodesInput() {
    return this._nodes.internalValue;
  }

  // private_registries - computed: false, optional: true, required: false
  private _privateRegistries = new ClusterRkeConfigPrivateRegistriesList(this, "private_registries", false);
  public get privateRegistries() {
    return this._privateRegistries;
  }
  public putPrivateRegistries(value: ClusterRkeConfigPrivateRegistries[] | cdktf.IResolvable) {
    this._privateRegistries.internalValue = value;
  }
  public resetPrivateRegistries() {
    this._privateRegistries.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateRegistriesInput() {
    return this._privateRegistries.internalValue;
  }

  // services - computed: false, optional: true, required: false
  private _services = new ClusterRkeConfigServicesOutputReference(this, "services");
  public get services() {
    return this._services;
  }
  public putServices(value: ClusterRkeConfigServices) {
    this._services.internalValue = value;
  }
  public resetServices() {
    this._services.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesInput() {
    return this._services.internalValue;
  }

  // upgrade_strategy - computed: false, optional: true, required: false
  private _upgradeStrategy = new ClusterRkeConfigUpgradeStrategyOutputReference(this, "upgrade_strategy");
  public get upgradeStrategy() {
    return this._upgradeStrategy;
  }
  public putUpgradeStrategy(value: ClusterRkeConfigUpgradeStrategy) {
    this._upgradeStrategy.internalValue = value;
  }
  public resetUpgradeStrategy() {
    this._upgradeStrategy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upgradeStrategyInput() {
    return this._upgradeStrategy.internalValue;
  }
}
export interface ClusterTimeouts {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#create Cluster#create}
  */
  readonly create?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#delete Cluster#delete}
  */
  readonly delete?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#update Cluster#update}
  */
  readonly update?: string;
}

export function clusterTimeoutsToTerraform(struct?: ClusterTimeouts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    create: cdktf.stringToTerraform(struct!.create),
    delete: cdktf.stringToTerraform(struct!.delete),
    update: cdktf.stringToTerraform(struct!.update),
  }
}


export function clusterTimeoutsToHclTerraform(struct?: ClusterTimeouts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    create: {
      value: cdktf.stringToHclTerraform(struct!.create),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delete: {
      value: cdktf.stringToHclTerraform(struct!.delete),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    update: {
      value: cdktf.stringToHclTerraform(struct!.update),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterTimeoutsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): ClusterTimeouts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._create !== undefined) {
      hasAnyValues = true;
      internalValueResult.create = this._create;
    }
    if (this._delete !== undefined) {
      hasAnyValues = true;
      internalValueResult.delete = this._delete;
    }
    if (this._update !== undefined) {
      hasAnyValues = true;
      internalValueResult.update = this._update;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterTimeouts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._create = undefined;
      this._delete = undefined;
      this._update = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._create = value.create;
      this._delete = value.delete;
      this._update = value.update;
    }
  }

  // create - computed: false, optional: true, required: false
  private _create?: string; 
  public get create() {
    return this.getStringAttribute('create');
  }
  public set create(value: string) {
    this._create = value;
  }
  public resetCreate() {
    this._create = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createInput() {
    return this._create;
  }

  // delete - computed: false, optional: true, required: false
  private _delete?: string; 
  public get delete() {
    return this.getStringAttribute('delete');
  }
  public set delete(value: string) {
    this._delete = value;
  }
  public resetDelete() {
    this._delete = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteInput() {
    return this._delete;
  }

  // update - computed: false, optional: true, required: false
  private _update?: string; 
  public get update() {
    return this.getStringAttribute('update');
  }
  public set update(value: string) {
    this._update = value;
  }
  public resetUpdate() {
    this._update = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateInput() {
    return this._update;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster rancher2_cluster}
*/
export class Cluster extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "rancher2_cluster";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a Cluster resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the Cluster to import
  * @param importFromId The id of the existing Cluster that should be imported. Refer to the {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the Cluster to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "rancher2_cluster", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/rancher/rancher2/8.3.1/docs/resources/cluster rancher2_cluster} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ClusterConfig
  */
  public constructor(scope: Construct, id: string, config: ClusterConfig) {
    super(scope, id, {
      terraformResourceType: 'rancher2_cluster',
      terraformGeneratorMetadata: {
        providerName: 'rancher2',
        providerVersion: '8.3.1'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._annotations = config.annotations;
    this._clusterTemplateId = config.clusterTemplateId;
    this._clusterTemplateRevisionId = config.clusterTemplateRevisionId;
    this._defaultPodSecurityAdmissionConfigurationTemplateName = config.defaultPodSecurityAdmissionConfigurationTemplateName;
    this._description = config.description;
    this._desiredAgentImage = config.desiredAgentImage;
    this._desiredAuthImage = config.desiredAuthImage;
    this._dockerRootDir = config.dockerRootDir;
    this._driver = config.driver;
    this._enableNetworkPolicy = config.enableNetworkPolicy;
    this._fleetWorkspaceName = config.fleetWorkspaceName;
    this._id = config.id;
    this._labels = config.labels;
    this._name = config.name;
    this._windowsPreferedCluster = config.windowsPreferedCluster;
    this._agentEnvVars.internalValue = config.agentEnvVars;
    this._aksConfigV2.internalValue = config.aksConfigV2;
    this._clusterAgentDeploymentCustomization.internalValue = config.clusterAgentDeploymentCustomization;
    this._clusterAuthEndpoint.internalValue = config.clusterAuthEndpoint;
    this._clusterTemplateAnswers.internalValue = config.clusterTemplateAnswers;
    this._clusterTemplateQuestions.internalValue = config.clusterTemplateQuestions;
    this._eksConfigV2.internalValue = config.eksConfigV2;
    this._fleetAgentDeploymentCustomization.internalValue = config.fleetAgentDeploymentCustomization;
    this._gkeConfigV2.internalValue = config.gkeConfigV2;
    this._importedConfig.internalValue = config.importedConfig;
    this._k3SConfig.internalValue = config.k3SConfig;
    this._okeConfig.internalValue = config.okeConfig;
    this._rke2Config.internalValue = config.rke2Config;
    this._rkeConfig.internalValue = config.rkeConfig;
    this._timeouts.internalValue = config.timeouts;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // annotations - computed: true, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // ca_cert - computed: true, optional: false, required: false
  public get caCert() {
    return this.getStringAttribute('ca_cert');
  }

  // cluster_registration_token - computed: true, optional: false, required: false
  private _clusterRegistrationToken = new ClusterClusterRegistrationTokenList(this, "cluster_registration_token", false);
  public get clusterRegistrationToken() {
    return this._clusterRegistrationToken;
  }

  // cluster_template_id - computed: false, optional: true, required: false
  private _clusterTemplateId?: string; 
  public get clusterTemplateId() {
    return this.getStringAttribute('cluster_template_id');
  }
  public set clusterTemplateId(value: string) {
    this._clusterTemplateId = value;
  }
  public resetClusterTemplateId() {
    this._clusterTemplateId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterTemplateIdInput() {
    return this._clusterTemplateId;
  }

  // cluster_template_revision_id - computed: false, optional: true, required: false
  private _clusterTemplateRevisionId?: string; 
  public get clusterTemplateRevisionId() {
    return this.getStringAttribute('cluster_template_revision_id');
  }
  public set clusterTemplateRevisionId(value: string) {
    this._clusterTemplateRevisionId = value;
  }
  public resetClusterTemplateRevisionId() {
    this._clusterTemplateRevisionId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterTemplateRevisionIdInput() {
    return this._clusterTemplateRevisionId;
  }

  // default_pod_security_admission_configuration_template_name - computed: true, optional: true, required: false
  private _defaultPodSecurityAdmissionConfigurationTemplateName?: string; 
  public get defaultPodSecurityAdmissionConfigurationTemplateName() {
    return this.getStringAttribute('default_pod_security_admission_configuration_template_name');
  }
  public set defaultPodSecurityAdmissionConfigurationTemplateName(value: string) {
    this._defaultPodSecurityAdmissionConfigurationTemplateName = value;
  }
  public resetDefaultPodSecurityAdmissionConfigurationTemplateName() {
    this._defaultPodSecurityAdmissionConfigurationTemplateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultPodSecurityAdmissionConfigurationTemplateNameInput() {
    return this._defaultPodSecurityAdmissionConfigurationTemplateName;
  }

  // default_project_id - computed: true, optional: false, required: false
  public get defaultProjectId() {
    return this.getStringAttribute('default_project_id');
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // desired_agent_image - computed: true, optional: true, required: false
  private _desiredAgentImage?: string; 
  public get desiredAgentImage() {
    return this.getStringAttribute('desired_agent_image');
  }
  public set desiredAgentImage(value: string) {
    this._desiredAgentImage = value;
  }
  public resetDesiredAgentImage() {
    this._desiredAgentImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get desiredAgentImageInput() {
    return this._desiredAgentImage;
  }

  // desired_auth_image - computed: true, optional: true, required: false
  private _desiredAuthImage?: string; 
  public get desiredAuthImage() {
    return this.getStringAttribute('desired_auth_image');
  }
  public set desiredAuthImage(value: string) {
    this._desiredAuthImage = value;
  }
  public resetDesiredAuthImage() {
    this._desiredAuthImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get desiredAuthImageInput() {
    return this._desiredAuthImage;
  }

  // docker_root_dir - computed: true, optional: true, required: false
  private _dockerRootDir?: string; 
  public get dockerRootDir() {
    return this.getStringAttribute('docker_root_dir');
  }
  public set dockerRootDir(value: string) {
    this._dockerRootDir = value;
  }
  public resetDockerRootDir() {
    this._dockerRootDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerRootDirInput() {
    return this._dockerRootDir;
  }

  // driver - computed: true, optional: true, required: false
  private _driver?: string; 
  public get driver() {
    return this.getStringAttribute('driver');
  }
  public set driver(value: string) {
    this._driver = value;
  }
  public resetDriver() {
    this._driver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverInput() {
    return this._driver;
  }

  // enable_cluster_istio - computed: true, optional: false, required: false
  public get enableClusterIstio() {
    return this.getBooleanAttribute('enable_cluster_istio');
  }

  // enable_network_policy - computed: true, optional: true, required: false
  private _enableNetworkPolicy?: boolean | cdktf.IResolvable; 
  public get enableNetworkPolicy() {
    return this.getBooleanAttribute('enable_network_policy');
  }
  public set enableNetworkPolicy(value: boolean | cdktf.IResolvable) {
    this._enableNetworkPolicy = value;
  }
  public resetEnableNetworkPolicy() {
    this._enableNetworkPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableNetworkPolicyInput() {
    return this._enableNetworkPolicy;
  }

  // fleet_workspace_name - computed: true, optional: true, required: false
  private _fleetWorkspaceName?: string; 
  public get fleetWorkspaceName() {
    return this.getStringAttribute('fleet_workspace_name');
  }
  public set fleetWorkspaceName(value: string) {
    this._fleetWorkspaceName = value;
  }
  public resetFleetWorkspaceName() {
    this._fleetWorkspaceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fleetWorkspaceNameInput() {
    return this._fleetWorkspaceName;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // istio_enabled - computed: true, optional: false, required: false
  public get istioEnabled() {
    return this.getBooleanAttribute('istio_enabled');
  }

  // kube_config - computed: true, optional: false, required: false
  public get kubeConfig() {
    return this.getStringAttribute('kube_config');
  }

  // labels - computed: true, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // system_project_id - computed: true, optional: false, required: false
  public get systemProjectId() {
    return this.getStringAttribute('system_project_id');
  }

  // windows_prefered_cluster - computed: false, optional: true, required: false
  private _windowsPreferedCluster?: boolean | cdktf.IResolvable; 
  public get windowsPreferedCluster() {
    return this.getBooleanAttribute('windows_prefered_cluster');
  }
  public set windowsPreferedCluster(value: boolean | cdktf.IResolvable) {
    this._windowsPreferedCluster = value;
  }
  public resetWindowsPreferedCluster() {
    this._windowsPreferedCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get windowsPreferedClusterInput() {
    return this._windowsPreferedCluster;
  }

  // agent_env_vars - computed: false, optional: true, required: false
  private _agentEnvVars = new ClusterAgentEnvVarsList(this, "agent_env_vars", false);
  public get agentEnvVars() {
    return this._agentEnvVars;
  }
  public putAgentEnvVars(value: ClusterAgentEnvVars[] | cdktf.IResolvable) {
    this._agentEnvVars.internalValue = value;
  }
  public resetAgentEnvVars() {
    this._agentEnvVars.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get agentEnvVarsInput() {
    return this._agentEnvVars.internalValue;
  }

  // aks_config_v2 - computed: false, optional: true, required: false
  private _aksConfigV2 = new ClusterAksConfigV2OutputReference(this, "aks_config_v2");
  public get aksConfigV2() {
    return this._aksConfigV2;
  }
  public putAksConfigV2(value: ClusterAksConfigV2) {
    this._aksConfigV2.internalValue = value;
  }
  public resetAksConfigV2() {
    this._aksConfigV2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aksConfigV2Input() {
    return this._aksConfigV2.internalValue;
  }

  // cluster_agent_deployment_customization - computed: false, optional: true, required: false
  private _clusterAgentDeploymentCustomization = new ClusterClusterAgentDeploymentCustomizationList(this, "cluster_agent_deployment_customization", false);
  public get clusterAgentDeploymentCustomization() {
    return this._clusterAgentDeploymentCustomization;
  }
  public putClusterAgentDeploymentCustomization(value: ClusterClusterAgentDeploymentCustomization[] | cdktf.IResolvable) {
    this._clusterAgentDeploymentCustomization.internalValue = value;
  }
  public resetClusterAgentDeploymentCustomization() {
    this._clusterAgentDeploymentCustomization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterAgentDeploymentCustomizationInput() {
    return this._clusterAgentDeploymentCustomization.internalValue;
  }

  // cluster_auth_endpoint - computed: false, optional: true, required: false
  private _clusterAuthEndpoint = new ClusterClusterAuthEndpointOutputReference(this, "cluster_auth_endpoint");
  public get clusterAuthEndpoint() {
    return this._clusterAuthEndpoint;
  }
  public putClusterAuthEndpoint(value: ClusterClusterAuthEndpoint) {
    this._clusterAuthEndpoint.internalValue = value;
  }
  public resetClusterAuthEndpoint() {
    this._clusterAuthEndpoint.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterAuthEndpointInput() {
    return this._clusterAuthEndpoint.internalValue;
  }

  // cluster_template_answers - computed: false, optional: true, required: false
  private _clusterTemplateAnswers = new ClusterClusterTemplateAnswersOutputReference(this, "cluster_template_answers");
  public get clusterTemplateAnswers() {
    return this._clusterTemplateAnswers;
  }
  public putClusterTemplateAnswers(value: ClusterClusterTemplateAnswers) {
    this._clusterTemplateAnswers.internalValue = value;
  }
  public resetClusterTemplateAnswers() {
    this._clusterTemplateAnswers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterTemplateAnswersInput() {
    return this._clusterTemplateAnswers.internalValue;
  }

  // cluster_template_questions - computed: false, optional: true, required: false
  private _clusterTemplateQuestions = new ClusterClusterTemplateQuestionsList(this, "cluster_template_questions", false);
  public get clusterTemplateQuestions() {
    return this._clusterTemplateQuestions;
  }
  public putClusterTemplateQuestions(value: ClusterClusterTemplateQuestions[] | cdktf.IResolvable) {
    this._clusterTemplateQuestions.internalValue = value;
  }
  public resetClusterTemplateQuestions() {
    this._clusterTemplateQuestions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterTemplateQuestionsInput() {
    return this._clusterTemplateQuestions.internalValue;
  }

  // eks_config_v2 - computed: false, optional: true, required: false
  private _eksConfigV2 = new ClusterEksConfigV2OutputReference(this, "eks_config_v2");
  public get eksConfigV2() {
    return this._eksConfigV2;
  }
  public putEksConfigV2(value: ClusterEksConfigV2) {
    this._eksConfigV2.internalValue = value;
  }
  public resetEksConfigV2() {
    this._eksConfigV2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eksConfigV2Input() {
    return this._eksConfigV2.internalValue;
  }

  // fleet_agent_deployment_customization - computed: false, optional: true, required: false
  private _fleetAgentDeploymentCustomization = new ClusterFleetAgentDeploymentCustomizationList(this, "fleet_agent_deployment_customization", false);
  public get fleetAgentDeploymentCustomization() {
    return this._fleetAgentDeploymentCustomization;
  }
  public putFleetAgentDeploymentCustomization(value: ClusterFleetAgentDeploymentCustomization[] | cdktf.IResolvable) {
    this._fleetAgentDeploymentCustomization.internalValue = value;
  }
  public resetFleetAgentDeploymentCustomization() {
    this._fleetAgentDeploymentCustomization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fleetAgentDeploymentCustomizationInput() {
    return this._fleetAgentDeploymentCustomization.internalValue;
  }

  // gke_config_v2 - computed: false, optional: true, required: false
  private _gkeConfigV2 = new ClusterGkeConfigV2OutputReference(this, "gke_config_v2");
  public get gkeConfigV2() {
    return this._gkeConfigV2;
  }
  public putGkeConfigV2(value: ClusterGkeConfigV2) {
    this._gkeConfigV2.internalValue = value;
  }
  public resetGkeConfigV2() {
    this._gkeConfigV2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gkeConfigV2Input() {
    return this._gkeConfigV2.internalValue;
  }

  // imported_config - computed: false, optional: true, required: false
  private _importedConfig = new ClusterImportedConfigOutputReference(this, "imported_config");
  public get importedConfig() {
    return this._importedConfig;
  }
  public putImportedConfig(value: ClusterImportedConfig) {
    this._importedConfig.internalValue = value;
  }
  public resetImportedConfig() {
    this._importedConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importedConfigInput() {
    return this._importedConfig.internalValue;
  }

  // k3s_config - computed: false, optional: true, required: false
  private _k3SConfig = new ClusterK3SConfigOutputReference(this, "k3s_config");
  public get k3SConfig() {
    return this._k3SConfig;
  }
  public putK3SConfig(value: ClusterK3SConfig) {
    this._k3SConfig.internalValue = value;
  }
  public resetK3SConfig() {
    this._k3SConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get k3SConfigInput() {
    return this._k3SConfig.internalValue;
  }

  // oke_config - computed: false, optional: true, required: false
  private _okeConfig = new ClusterOkeConfigOutputReference(this, "oke_config");
  public get okeConfig() {
    return this._okeConfig;
  }
  public putOkeConfig(value: ClusterOkeConfig) {
    this._okeConfig.internalValue = value;
  }
  public resetOkeConfig() {
    this._okeConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get okeConfigInput() {
    return this._okeConfig.internalValue;
  }

  // rke2_config - computed: false, optional: true, required: false
  private _rke2Config = new ClusterRke2ConfigOutputReference(this, "rke2_config");
  public get rke2Config() {
    return this._rke2Config;
  }
  public putRke2Config(value: ClusterRke2Config) {
    this._rke2Config.internalValue = value;
  }
  public resetRke2Config() {
    this._rke2Config.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rke2ConfigInput() {
    return this._rke2Config.internalValue;
  }

  // rke_config - computed: false, optional: true, required: false
  private _rkeConfig = new ClusterRkeConfigOutputReference(this, "rke_config");
  public get rkeConfig() {
    return this._rkeConfig;
  }
  public putRkeConfig(value: ClusterRkeConfig) {
    this._rkeConfig.internalValue = value;
  }
  public resetRkeConfig() {
    this._rkeConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rkeConfigInput() {
    return this._rkeConfig.internalValue;
  }

  // timeouts - computed: false, optional: true, required: false
  private _timeouts = new ClusterTimeoutsOutputReference(this, "timeouts");
  public get timeouts() {
    return this._timeouts;
  }
  public putTimeouts(value: ClusterTimeouts) {
    this._timeouts.internalValue = value;
  }
  public resetTimeouts() {
    this._timeouts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutsInput() {
    return this._timeouts.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      annotations: cdktf.hashMapper(cdktf.stringToTerraform)(this._annotations),
      cluster_template_id: cdktf.stringToTerraform(this._clusterTemplateId),
      cluster_template_revision_id: cdktf.stringToTerraform(this._clusterTemplateRevisionId),
      default_pod_security_admission_configuration_template_name: cdktf.stringToTerraform(this._defaultPodSecurityAdmissionConfigurationTemplateName),
      description: cdktf.stringToTerraform(this._description),
      desired_agent_image: cdktf.stringToTerraform(this._desiredAgentImage),
      desired_auth_image: cdktf.stringToTerraform(this._desiredAuthImage),
      docker_root_dir: cdktf.stringToTerraform(this._dockerRootDir),
      driver: cdktf.stringToTerraform(this._driver),
      enable_network_policy: cdktf.booleanToTerraform(this._enableNetworkPolicy),
      fleet_workspace_name: cdktf.stringToTerraform(this._fleetWorkspaceName),
      id: cdktf.stringToTerraform(this._id),
      labels: cdktf.hashMapper(cdktf.stringToTerraform)(this._labels),
      name: cdktf.stringToTerraform(this._name),
      windows_prefered_cluster: cdktf.booleanToTerraform(this._windowsPreferedCluster),
      agent_env_vars: cdktf.listMapper(clusterAgentEnvVarsToTerraform, true)(this._agentEnvVars.internalValue),
      aks_config_v2: clusterAksConfigV2ToTerraform(this._aksConfigV2.internalValue),
      cluster_agent_deployment_customization: cdktf.listMapper(clusterClusterAgentDeploymentCustomizationToTerraform, true)(this._clusterAgentDeploymentCustomization.internalValue),
      cluster_auth_endpoint: clusterClusterAuthEndpointToTerraform(this._clusterAuthEndpoint.internalValue),
      cluster_template_answers: clusterClusterTemplateAnswersToTerraform(this._clusterTemplateAnswers.internalValue),
      cluster_template_questions: cdktf.listMapper(clusterClusterTemplateQuestionsToTerraform, true)(this._clusterTemplateQuestions.internalValue),
      eks_config_v2: clusterEksConfigV2ToTerraform(this._eksConfigV2.internalValue),
      fleet_agent_deployment_customization: cdktf.listMapper(clusterFleetAgentDeploymentCustomizationToTerraform, true)(this._fleetAgentDeploymentCustomization.internalValue),
      gke_config_v2: clusterGkeConfigV2ToTerraform(this._gkeConfigV2.internalValue),
      imported_config: clusterImportedConfigToTerraform(this._importedConfig.internalValue),
      k3s_config: clusterK3SConfigToTerraform(this._k3SConfig.internalValue),
      oke_config: clusterOkeConfigToTerraform(this._okeConfig.internalValue),
      rke2_config: clusterRke2ConfigToTerraform(this._rke2Config.internalValue),
      rke_config: clusterRkeConfigToTerraform(this._rkeConfig.internalValue),
      timeouts: clusterTimeoutsToTerraform(this._timeouts.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      annotations: {
        value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(this._annotations),
        isBlock: false,
        type: "map",
        storageClassType: "stringMap",
      },
      cluster_template_id: {
        value: cdktf.stringToHclTerraform(this._clusterTemplateId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      cluster_template_revision_id: {
        value: cdktf.stringToHclTerraform(this._clusterTemplateRevisionId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      default_pod_security_admission_configuration_template_name: {
        value: cdktf.stringToHclTerraform(this._defaultPodSecurityAdmissionConfigurationTemplateName),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      description: {
        value: cdktf.stringToHclTerraform(this._description),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      desired_agent_image: {
        value: cdktf.stringToHclTerraform(this._desiredAgentImage),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      desired_auth_image: {
        value: cdktf.stringToHclTerraform(this._desiredAuthImage),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      docker_root_dir: {
        value: cdktf.stringToHclTerraform(this._dockerRootDir),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      driver: {
        value: cdktf.stringToHclTerraform(this._driver),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      enable_network_policy: {
        value: cdktf.booleanToHclTerraform(this._enableNetworkPolicy),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      fleet_workspace_name: {
        value: cdktf.stringToHclTerraform(this._fleetWorkspaceName),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      id: {
        value: cdktf.stringToHclTerraform(this._id),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      labels: {
        value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(this._labels),
        isBlock: false,
        type: "map",
        storageClassType: "stringMap",
      },
      name: {
        value: cdktf.stringToHclTerraform(this._name),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      windows_prefered_cluster: {
        value: cdktf.booleanToHclTerraform(this._windowsPreferedCluster),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      agent_env_vars: {
        value: cdktf.listMapperHcl(clusterAgentEnvVarsToHclTerraform, true)(this._agentEnvVars.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterAgentEnvVarsList",
      },
      aks_config_v2: {
        value: clusterAksConfigV2ToHclTerraform(this._aksConfigV2.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterAksConfigV2List",
      },
      cluster_agent_deployment_customization: {
        value: cdktf.listMapperHcl(clusterClusterAgentDeploymentCustomizationToHclTerraform, true)(this._clusterAgentDeploymentCustomization.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterClusterAgentDeploymentCustomizationList",
      },
      cluster_auth_endpoint: {
        value: clusterClusterAuthEndpointToHclTerraform(this._clusterAuthEndpoint.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterClusterAuthEndpointList",
      },
      cluster_template_answers: {
        value: clusterClusterTemplateAnswersToHclTerraform(this._clusterTemplateAnswers.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterClusterTemplateAnswersList",
      },
      cluster_template_questions: {
        value: cdktf.listMapperHcl(clusterClusterTemplateQuestionsToHclTerraform, true)(this._clusterTemplateQuestions.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterClusterTemplateQuestionsList",
      },
      eks_config_v2: {
        value: clusterEksConfigV2ToHclTerraform(this._eksConfigV2.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterEksConfigV2List",
      },
      fleet_agent_deployment_customization: {
        value: cdktf.listMapperHcl(clusterFleetAgentDeploymentCustomizationToHclTerraform, true)(this._fleetAgentDeploymentCustomization.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterFleetAgentDeploymentCustomizationList",
      },
      gke_config_v2: {
        value: clusterGkeConfigV2ToHclTerraform(this._gkeConfigV2.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterGkeConfigV2List",
      },
      imported_config: {
        value: clusterImportedConfigToHclTerraform(this._importedConfig.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterImportedConfigList",
      },
      k3s_config: {
        value: clusterK3SConfigToHclTerraform(this._k3SConfig.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterK3SConfigList",
      },
      oke_config: {
        value: clusterOkeConfigToHclTerraform(this._okeConfig.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterOkeConfigList",
      },
      rke2_config: {
        value: clusterRke2ConfigToHclTerraform(this._rke2Config.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterRke2ConfigList",
      },
      rke_config: {
        value: clusterRkeConfigToHclTerraform(this._rkeConfig.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ClusterRkeConfigList",
      },
      timeouts: {
        value: clusterTimeoutsToHclTerraform(this._timeouts.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "ClusterTimeouts",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
