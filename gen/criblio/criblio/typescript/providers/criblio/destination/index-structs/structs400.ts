import * as cdktf from 'cdktf';
import { DestinationOutputInfluxdbExtraHttpHeaders,
destinationOutputInfluxdbExtraHttpHeadersToTerraform,
destinationOutputInfluxdbExtraHttpHeadersToHclTerraform,
DestinationOutputInfluxdbExtraHttpHeadersList,
DestinationOutputInfluxdbOauthHeaders,
destinationOutputInfluxdbOauthHeadersToTerraform,
destinationOutputInfluxdbOauthHeadersToHclTerraform,
DestinationOutputInfluxdbOauthHeadersList } from './structs0'
export interface DestinationOutputInfluxdbOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputInfluxdbOauthParamsToTerraform(struct?: DestinationOutputInfluxdbOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputInfluxdbOauthParamsToHclTerraform(struct?: DestinationOutputInfluxdbOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputInfluxdbOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputInfluxdbOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputInfluxdbOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputInfluxdbOauthParamsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputInfluxdbOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputInfluxdbOauthParamsOutputReference {
    return new DestinationOutputInfluxdbOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputInfluxdbPqControls {
}

export function destinationOutputInfluxdbPqControlsToTerraform(struct?: DestinationOutputInfluxdbPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputInfluxdbPqControlsToHclTerraform(struct?: DestinationOutputInfluxdbPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputInfluxdbPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputInfluxdbPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputInfluxdbPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputInfluxdbResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputInfluxdbResponseRetrySettingsToTerraform(struct?: DestinationOutputInfluxdbResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputInfluxdbResponseRetrySettingsToHclTerraform(struct?: DestinationOutputInfluxdbResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputInfluxdbResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputInfluxdbResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputInfluxdbResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputInfluxdbResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputInfluxdbResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputInfluxdbResponseRetrySettingsOutputReference {
    return new DestinationOutputInfluxdbResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputInfluxdbTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputInfluxdbTimeoutRetrySettingsToTerraform(struct?: DestinationOutputInfluxdbTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputInfluxdbTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputInfluxdbTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputInfluxdbTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputInfluxdbTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputInfluxdbTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputInfluxdb {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_header_expr Destination#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * InfluxDB authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Bucket to write to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#bucket Destination#bucket}
  */
  readonly bucket?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Database to write to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#database Destination#database}
  */
  readonly database?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dynamic_value_field_name Destination#dynamic_value_field_name}
  */
  readonly dynamicValueFieldName?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputInfluxdbExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#login_url Destination#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#oauth_headers Destination#oauth_headers}
  */
  readonly oauthHeaders?: DestinationOutputInfluxdbOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#oauth_params Destination#oauth_params}
  */
  readonly oauthParams?: DestinationOutputInfluxdbOauthParams[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Organization ID for this bucket.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#org Destination#org}
  */
  readonly org?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#password Destination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputInfluxdbPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputInfluxdbResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#secret Destination#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#secret_param_name Destination#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputInfluxdbTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Sets the precision for the supplied Unix time values. Defaults to milliseconds. Default: "ms"; must be one of ["ns", "u", "ms", "s", "m", "h"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timestamp_precision Destination#timestamp_precision}
  */
  readonly timestampPrecision?: string;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token_attribute_name Destination#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token_timeout_secs Destination#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "influxdb"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * The v2 API can be enabled with InfluxDB versions 1.8 and later. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_v2_api Destination#use_v2_api}
  */
  readonly useV2Api?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#username Destination#username}
  */
  readonly username?: string;
  /**
  * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback. Default: "value"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value_field_name Destination#value_field_name}
  */
  readonly valueFieldName?: string;
}

export function destinationOutputInfluxdbToTerraform(struct?: DestinationOutputInfluxdb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    database: cdktf.stringToTerraform(struct!.database),
    description: cdktf.stringToTerraform(struct!.description),
    dynamic_value_field_name: cdktf.booleanToTerraform(struct!.dynamicValueFieldName),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputInfluxdbExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    oauth_headers: cdktf.listMapper(destinationOutputInfluxdbOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(destinationOutputInfluxdbOauthParamsToTerraform, false)(struct!.oauthParams),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    org: cdktf.stringToTerraform(struct!.org),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputInfluxdbPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputInfluxdbResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputInfluxdbTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    timestamp_precision: cdktf.stringToTerraform(struct!.timestampPrecision),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    use_v2_api: cdktf.booleanToTerraform(struct!.useV2Api),
    username: cdktf.stringToTerraform(struct!.username),
    value_field_name: cdktf.stringToTerraform(struct!.valueFieldName),
  }
}


export function destinationOutputInfluxdbToHclTerraform(struct?: DestinationOutputInfluxdb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dynamic_value_field_name: {
      value: cdktf.booleanToHclTerraform(struct!.dynamicValueFieldName),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputInfluxdbExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputInfluxdbExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(destinationOutputInfluxdbOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputInfluxdbOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(destinationOutputInfluxdbOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputInfluxdbOauthParamsList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    org: {
      value: cdktf.stringToHclTerraform(struct!.org),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputInfluxdbPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputInfluxdbPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputInfluxdbResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputInfluxdbResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputInfluxdbTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputInfluxdbTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timestamp_precision: {
      value: cdktf.stringToHclTerraform(struct!.timestampPrecision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    use_v2_api: {
      value: cdktf.booleanToHclTerraform(struct!.useV2Api),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_field_name: {
      value: cdktf.stringToHclTerraform(struct!.valueFieldName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputInfluxdbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputInfluxdb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dynamicValueFieldName !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicValueFieldName = this._dynamicValueFieldName;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._org !== undefined) {
      hasAnyValues = true;
      internalValueResult.org = this._org;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._timestampPrecision !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampPrecision = this._timestampPrecision;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._useV2Api !== undefined) {
      hasAnyValues = true;
      internalValueResult.useV2Api = this._useV2Api;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._valueFieldName !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFieldName = this._valueFieldName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputInfluxdb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._bucket = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._credentialsSecret = undefined;
      this._database = undefined;
      this._description = undefined;
      this._dynamicValueFieldName = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._loginUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._onBackpressure = undefined;
      this._org = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._timestampPrecision = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
      this._useV2Api = undefined;
      this._username = undefined;
      this._valueFieldName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._bucket = value.bucket;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._credentialsSecret = value.credentialsSecret;
      this._database = value.database;
      this._description = value.description;
      this._dynamicValueFieldName = value.dynamicValueFieldName;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._loginUrl = value.loginUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._onBackpressure = value.onBackpressure;
      this._org = value.org;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._timestampPrecision = value.timestampPrecision;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._useV2Api = value.useV2Api;
      this._username = value.username;
      this._valueFieldName = value.valueFieldName;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // bucket - computed: false, optional: true, required: false
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  public resetBucket() {
    this._bucket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dynamic_value_field_name - computed: true, optional: true, required: false
  private _dynamicValueFieldName?: boolean | cdktf.IResolvable; 
  public get dynamicValueFieldName() {
    return this.getBooleanAttribute('dynamic_value_field_name');
  }
  public set dynamicValueFieldName(value: boolean | cdktf.IResolvable) {
    this._dynamicValueFieldName = value;
  }
  public resetDynamicValueFieldName() {
    this._dynamicValueFieldName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicValueFieldNameInput() {
    return this._dynamicValueFieldName;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputInfluxdbExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputInfluxdbExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new DestinationOutputInfluxdbOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: DestinationOutputInfluxdbOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new DestinationOutputInfluxdbOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: DestinationOutputInfluxdbOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // org - computed: false, optional: true, required: false
  private _org?: string; 
  public get org() {
    return this.getStringAttribute('org');
  }
  public set org(value: string) {
    this._org = value;
  }
  public resetOrg() {
    this._org = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orgInput() {
    return this._org;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputInfluxdbPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputInfluxdbPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputInfluxdbResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputInfluxdbResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputInfluxdbTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputInfluxdbTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // timestamp_precision - computed: true, optional: true, required: false
  private _timestampPrecision?: string; 
  public get timestampPrecision() {
    return this.getStringAttribute('timestamp_precision');
  }
  public set timestampPrecision(value: string) {
    this._timestampPrecision = value;
  }
  public resetTimestampPrecision() {
    this._timestampPrecision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampPrecisionInput() {
    return this._timestampPrecision;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // use_v2_api - computed: true, optional: true, required: false
  private _useV2Api?: boolean | cdktf.IResolvable; 
  public get useV2Api() {
    return this.getBooleanAttribute('use_v2_api');
  }
  public set useV2Api(value: boolean | cdktf.IResolvable) {
    this._useV2Api = value;
  }
  public resetUseV2Api() {
    this._useV2Api = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useV2ApiInput() {
    return this._useV2Api;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // value_field_name - computed: true, optional: true, required: false
  private _valueFieldName?: string; 
  public get valueFieldName() {
    return this.getStringAttribute('value_field_name');
  }
  public set valueFieldName(value: string) {
    this._valueFieldName = value;
  }
  public resetValueFieldName() {
    this._valueFieldName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFieldNameInput() {
    return this._valueFieldName;
  }
}
export interface DestinationOutputKafkaKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function destinationOutputKafkaKafkaSchemaRegistryAuthToTerraform(struct?: DestinationOutputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function destinationOutputKafkaKafkaSchemaRegistryAuthToHclTerraform(struct?: DestinationOutputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputKafkaKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface DestinationOutputKafkaKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputKafkaKafkaSchemaRegistryTlsToTerraform(struct?: DestinationOutputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputKafkaKafkaSchemaRegistryTlsToHclTerraform(struct?: DestinationOutputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputKafkaKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputKafkaKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth Destination#auth}
  */
  readonly auth?: DestinationOutputKafkaKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#default_key_schema_id Destination#default_key_schema_id}
  */
  readonly defaultKeySchemaId?: number;
  /**
  * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#default_value_schema_id Destination#default_value_schema_id}
  */
  readonly defaultValueSchemaId?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_retries Destination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#request_timeout Destination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#schema_registry_url Destination#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputKafkaKafkaSchemaRegistryTls;
}

export function destinationOutputKafkaKafkaSchemaRegistryToTerraform(struct?: DestinationOutputKafkaKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: destinationOutputKafkaKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    default_key_schema_id: cdktf.numberToTerraform(struct!.defaultKeySchemaId),
    default_value_schema_id: cdktf.numberToTerraform(struct!.defaultValueSchemaId),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: destinationOutputKafkaKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function destinationOutputKafkaKafkaSchemaRegistryToHclTerraform(struct?: DestinationOutputKafkaKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: destinationOutputKafkaKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputKafkaKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_key_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultKeySchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_value_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultValueSchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: destinationOutputKafkaKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputKafkaKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputKafkaKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputKafkaKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._defaultKeySchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultKeySchemaId = this._defaultKeySchemaId;
    }
    if (this._defaultValueSchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValueSchemaId = this._defaultValueSchemaId;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputKafkaKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._defaultKeySchemaId = undefined;
      this._defaultValueSchemaId = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._defaultKeySchemaId = value.defaultKeySchemaId;
      this._defaultValueSchemaId = value.defaultValueSchemaId;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DestinationOutputKafkaKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DestinationOutputKafkaKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // default_key_schema_id - computed: false, optional: true, required: false
  private _defaultKeySchemaId?: number; 
  public get defaultKeySchemaId() {
    return this.getNumberAttribute('default_key_schema_id');
  }
  public set defaultKeySchemaId(value: number) {
    this._defaultKeySchemaId = value;
  }
  public resetDefaultKeySchemaId() {
    this._defaultKeySchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultKeySchemaIdInput() {
    return this._defaultKeySchemaId;
  }

  // default_value_schema_id - computed: false, optional: true, required: false
  private _defaultValueSchemaId?: number; 
  public get defaultValueSchemaId() {
    return this.getNumberAttribute('default_value_schema_id');
  }
  public set defaultValueSchemaId(value: number) {
    this._defaultValueSchemaId = value;
  }
  public resetDefaultValueSchemaId() {
    this._defaultValueSchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueSchemaIdInput() {
    return this._defaultValueSchemaId;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputKafkaKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputKafkaKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DestinationOutputKafkaPqControls {
}

export function destinationOutputKafkaPqControlsToTerraform(struct?: DestinationOutputKafkaPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputKafkaPqControlsToHclTerraform(struct?: DestinationOutputKafkaPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputKafkaPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputKafkaPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputKafkaPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputKafkaSasl {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#mechanism Destination#mechanism}
  */
  readonly mechanism?: string;
}

export function destinationOutputKafkaSaslToTerraform(struct?: DestinationOutputKafkaSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
  }
}


export function destinationOutputKafkaSaslToHclTerraform(struct?: DestinationOutputKafkaSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputKafkaSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputKafkaSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputKafkaSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._mechanism = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._mechanism = value.mechanism;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // mechanism - computed: true, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }
}
export interface DestinationOutputKafkaTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputKafkaTlsToTerraform(struct?: DestinationOutputKafkaTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputKafkaTlsToHclTerraform(struct?: DestinationOutputKafkaTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputKafkaTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputKafkaTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputKafkaTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputKafka {
  /**
  * Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ack Destination#ack}
  */
  readonly ack?: number;
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#authentication_timeout Destination#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#brokers Destination#brokers}
  */
  readonly brokers: string[];
  /**
  * Codec to use to compress the data before sending to Kafka. Default: "gzip"; must be one of ["none", "gzip", "snappy", "lz4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compression Destination#compression}
  */
  readonly compression?: string;
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * The maximum number of events you want the Destination to allow in a batch before forcing a flush. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_event_count Destination#flush_event_count}
  */
  readonly flushEventCount?: number;
  /**
  * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Format to use to serialize events before writing to Kafka. Default: "json"; must be one of ["json", "raw", "protobuf"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#kafka_schema_registry Destination#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: DestinationOutputKafkaKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_back_off Destination#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting. Default: 768
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_record_size_kb Destination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_retries Destination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputKafkaPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a set of Protobuf definitions for the events you want to send
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#protobuf_library_id Destination#protobuf_library_id}
  */
  readonly protobufLibraryId?: string;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reauthentication_threshold Destination#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#request_timeout Destination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#sasl Destination#sasl}
  */
  readonly sasl?: DestinationOutputKafkaSasl;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputKafkaTls;
  /**
  * The topic to publish events to. Can be overridden using the __topicOut field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#topic Destination#topic}
  */
  readonly topic: string;
  /**
  * must be "kafka"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
}

export function destinationOutputKafkaToTerraform(struct?: DestinationOutputKafka | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ack: cdktf.numberToTerraform(struct!.ack),
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    compression: cdktf.stringToTerraform(struct!.compression),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_event_count: cdktf.numberToTerraform(struct!.flushEventCount),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: destinationOutputKafkaKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputKafkaPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protobuf_library_id: cdktf.stringToTerraform(struct!.protobufLibraryId),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    sasl: destinationOutputKafkaSaslToTerraform(struct!.sasl),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tls: destinationOutputKafkaTlsToTerraform(struct!.tls),
    topic: cdktf.stringToTerraform(struct!.topic),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputKafkaToHclTerraform(struct?: DestinationOutputKafka | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ack: {
      value: cdktf.numberToHclTerraform(struct!.ack),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_event_count: {
      value: cdktf.numberToHclTerraform(struct!.flushEventCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: destinationOutputKafkaKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputKafkaKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputKafkaPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputKafkaPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protobuf_library_id: {
      value: cdktf.stringToHclTerraform(struct!.protobufLibraryId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sasl: {
      value: destinationOutputKafkaSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputKafkaSasl",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: destinationOutputKafkaTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputKafkaTls",
    },
    topic: {
      value: cdktf.stringToHclTerraform(struct!.topic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputKafkaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputKafka | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ack !== undefined) {
      hasAnyValues = true;
      internalValueResult.ack = this._ack;
    }
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushEventCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushEventCount = this._flushEventCount;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protobufLibraryId !== undefined) {
      hasAnyValues = true;
      internalValueResult.protobufLibraryId = this._protobufLibraryId;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topic !== undefined) {
      hasAnyValues = true;
      internalValueResult.topic = this._topic;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputKafka | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ack = undefined;
      this._authenticationTimeout = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._compression = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._flushEventCount = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxRecordSizeKb = undefined;
      this._maxRetries = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protobufLibraryId = undefined;
      this._reauthenticationThreshold = undefined;
      this._requestTimeout = undefined;
      this._sasl.internalValue = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tls.internalValue = undefined;
      this._topic = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ack = value.ack;
      this._authenticationTimeout = value.authenticationTimeout;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._compression = value.compression;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._environment = value.environment;
      this._flushEventCount = value.flushEventCount;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._maxRetries = value.maxRetries;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protobufLibraryId = value.protobufLibraryId;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._requestTimeout = value.requestTimeout;
      this._sasl.internalValue = value.sasl;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tls.internalValue = value.tls;
      this._topic = value.topic;
      this._type = value.type;
    }
  }

  // ack - computed: true, optional: true, required: false
  private _ack?: number; 
  public get ack() {
    return this.getNumberAttribute('ack');
  }
  public set ack(value: number) {
    this._ack = value;
  }
  public resetAck() {
    this._ack = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ackInput() {
    return this._ack;
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_event_count - computed: true, optional: true, required: false
  private _flushEventCount?: number; 
  public get flushEventCount() {
    return this.getNumberAttribute('flush_event_count');
  }
  public set flushEventCount(value: number) {
    this._flushEventCount = value;
  }
  public resetFlushEventCount() {
    this._flushEventCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushEventCountInput() {
    return this._flushEventCount;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new DestinationOutputKafkaKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: DestinationOutputKafkaKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputKafkaPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputKafkaPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protobuf_library_id - computed: false, optional: true, required: false
  private _protobufLibraryId?: string; 
  public get protobufLibraryId() {
    return this.getStringAttribute('protobuf_library_id');
  }
  public set protobufLibraryId(value: string) {
    this._protobufLibraryId = value;
  }
  public resetProtobufLibraryId() {
    this._protobufLibraryId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protobufLibraryIdInput() {
    return this._protobufLibraryId;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new DestinationOutputKafkaSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: DestinationOutputKafkaSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputKafkaTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputKafkaTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topic - computed: false, optional: false, required: true
  private _topic?: string; 
  public get topic() {
    return this.getStringAttribute('topic');
  }
  public set topic(value: string) {
    this._topic = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicInput() {
    return this._topic;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputKinesisPqControls {
}

export function destinationOutputKinesisPqControlsToTerraform(struct?: DestinationOutputKinesisPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputKinesisPqControlsToHclTerraform(struct?: DestinationOutputKinesisPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputKinesisPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputKinesisPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputKinesisPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputKinesis {
  /**
  * Batch events into a single record as NDJSON. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#as_ndjson Destination#as_ndjson}
  */
  readonly asNdjson?: boolean | cdktf.IResolvable;
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_arn Destination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_external_id Destination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_authentication_method Destination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret Destination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Compression type to use for records. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compression Destination#compression}
  */
  readonly compression?: string;
  /**
  * Maximum number of ongoing put requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#duration_seconds Destination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Kinesis stream. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_assume_role Destination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum size (KB) of each individual record before compression. For uncompressed or non-compressible data 1MB is the max recommended size. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_record_size_kb Destination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputKinesisPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Region where the Kinesis stream is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#region Destination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing Kinesis stream requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#signature_version Destination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Kinesis stream name to send events to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#stream_name Destination#stream_name}
  */
  readonly streamName: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "kinesis"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Provides higher stream rate limits, improving delivery speed and reliability by minimizing throttling. See the [ListShards API](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_ListShards.html) documentation for details. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_list_shards Destination#use_list_shards}
  */
  readonly useListShards?: boolean | cdktf.IResolvable;
}

export function destinationOutputKinesisToTerraform(struct?: DestinationOutputKinesis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_ndjson: cdktf.booleanToTerraform(struct!.asNdjson),
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    compression: cdktf.stringToTerraform(struct!.compression),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputKinesisPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    use_list_shards: cdktf.booleanToTerraform(struct!.useListShards),
  }
}


export function destinationOutputKinesisToHclTerraform(struct?: DestinationOutputKinesis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_ndjson: {
      value: cdktf.booleanToHclTerraform(struct!.asNdjson),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputKinesisPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputKinesisPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_list_shards: {
      value: cdktf.booleanToHclTerraform(struct!.useListShards),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputKinesisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputKinesis | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asNdjson !== undefined) {
      hasAnyValues = true;
      internalValueResult.asNdjson = this._asNdjson;
    }
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useListShards !== undefined) {
      hasAnyValues = true;
      internalValueResult.useListShards = this._useListShards;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputKinesis | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asNdjson = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._compression = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxRecordSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._signatureVersion = undefined;
      this._streamName = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._useListShards = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asNdjson = value.asNdjson;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._compression = value.compression;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._signatureVersion = value.signatureVersion;
      this._streamName = value.streamName;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._useListShards = value.useListShards;
    }
  }

  // as_ndjson - computed: true, optional: true, required: false
  private _asNdjson?: boolean | cdktf.IResolvable; 
  public get asNdjson() {
    return this.getBooleanAttribute('as_ndjson');
  }
  public set asNdjson(value: boolean | cdktf.IResolvable) {
    this._asNdjson = value;
  }
  public resetAsNdjson() {
    this._asNdjson = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asNdjsonInput() {
    return this._asNdjson;
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputKinesisPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputKinesisPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stream_name - computed: false, optional: false, required: true
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_list_shards - computed: true, optional: true, required: false
  private _useListShards?: boolean | cdktf.IResolvable; 
  public get useListShards() {
    return this.getBooleanAttribute('use_list_shards');
  }
  public set useListShards(value: boolean | cdktf.IResolvable) {
    this._useListShards = value;
  }
  public resetUseListShards() {
    this._useListShards = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useListShardsInput() {
    return this._useListShards;
  }
}
export interface DestinationOutputLokiExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputLokiExtraHttpHeadersToTerraform(struct?: DestinationOutputLokiExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputLokiExtraHttpHeadersToHclTerraform(struct?: DestinationOutputLokiExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputLokiExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputLokiExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputLokiExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputLokiExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputLokiExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputLokiExtraHttpHeadersOutputReference {
    return new DestinationOutputLokiExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputLokiLabels {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputLokiLabelsToTerraform(struct?: DestinationOutputLokiLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputLokiLabelsToHclTerraform(struct?: DestinationOutputLokiLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputLokiLabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputLokiLabels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputLokiLabels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputLokiLabelsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputLokiLabels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputLokiLabelsOutputReference {
    return new DestinationOutputLokiLabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputLokiPqControls {
}

export function destinationOutputLokiPqControlsToTerraform(struct?: DestinationOutputLokiPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputLokiPqControlsToHclTerraform(struct?: DestinationOutputLokiPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputLokiPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputLokiPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputLokiPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputLokiResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputLokiResponseRetrySettingsToTerraform(struct?: DestinationOutputLokiResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputLokiResponseRetrySettingsToHclTerraform(struct?: DestinationOutputLokiResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputLokiResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputLokiResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputLokiResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputLokiResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputLokiResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputLokiResponseRetrySettingsOutputReference {
    return new DestinationOutputLokiResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputLokiTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputLokiTimeoutRetrySettingsToTerraform(struct?: DestinationOutputLokiTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputLokiTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputLokiTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputLokiTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputLokiTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputLokiTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputLoki {
  /**
  * Default: "none"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki to complain about entries being delivered out of order. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputLokiExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the events __labels field. Example: "__labels: {host: "cribl.io", level: "error"}"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#labels Destination#labels}
  */
  readonly labels?: DestinationOutputLokiLabels[] | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Defaults to 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#message Destination#message}
  */
  readonly message?: string;
  /**
  * Format to use when sending logs to Loki (Protobuf or JSON). Default: "protobuf"; must be one of ["protobuf", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#message_format Destination#message_format}
  */
  readonly messageFormat?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Password (API key in Grafana Cloud domain) for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#password Destination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputLokiPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputLokiResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as labels to generated logs. Default: ["cribl_host","cribl_wp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputLokiTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "loki"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * The endpoint to send logs to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Username for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#username Destination#username}
  */
  readonly username?: string;
}

export function destinationOutputLokiToTerraform(struct?: DestinationOutputLoki | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputLokiExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    labels: cdktf.listMapper(destinationOutputLokiLabelsToTerraform, false)(struct!.labels),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message: cdktf.stringToTerraform(struct!.message),
    message_format: cdktf.stringToTerraform(struct!.messageFormat),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputLokiPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputLokiResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputLokiTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function destinationOutputLokiToHclTerraform(struct?: DestinationOutputLoki | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputLokiExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputLokiExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.listMapperHcl(destinationOutputLokiLabelsToHclTerraform, false)(struct!.labels),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputLokiLabelsList",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_format: {
      value: cdktf.stringToHclTerraform(struct!.messageFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputLokiPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputLokiPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputLokiResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputLokiResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputLokiTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputLokiTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputLokiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputLoki | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._labels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels?.internalValue;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._messageFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageFormat = this._messageFormat;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputLoki | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._labels.internalValue = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._message = undefined;
      this._messageFormat = undefined;
      this._onBackpressure = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._labels.internalValue = value.labels;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._message = value.message;
      this._messageFormat = value.messageFormat;
      this._onBackpressure = value.onBackpressure;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputLokiExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputLokiExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // labels - computed: false, optional: true, required: false
  private _labels = new DestinationOutputLokiLabelsList(this, "labels", false);
  public get labels() {
    return this._labels;
  }
  public putLabels(value: DestinationOutputLokiLabels[] | cdktf.IResolvable) {
    this._labels.internalValue = value;
  }
  public resetLabels() {
    this._labels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels.internalValue;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // message_format - computed: true, optional: true, required: false
  private _messageFormat?: string; 
  public get messageFormat() {
    return this.getStringAttribute('message_format');
  }
  public set messageFormat(value: string) {
    this._messageFormat = value;
  }
  public resetMessageFormat() {
    this._messageFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFormatInput() {
    return this._messageFormat;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputLokiPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputLokiPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputLokiResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputLokiResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputLokiTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputLokiTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DestinationOutputMinioKeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#key Destination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputMinioKeyValueMetadataToTerraform(struct?: DestinationOutputMinioKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputMinioKeyValueMetadataToHclTerraform(struct?: DestinationOutputMinioKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputMinioKeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputMinioKeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputMinioKeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputMinioKeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputMinioKeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputMinioKeyValueMetadataOutputReference {
    return new DestinationOutputMinioKeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputMinio {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#add_id_to_stage_path Destination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#automatic_schema Destination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_authentication_method Destination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret Destination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#base_file_name Destination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#bucket Destination#bucket}
  */
  readonly bucket: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compression_level Destination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#deadletter_enabled Destination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#deadletter_path Destination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dest_path Destination#dest_path}
  */
  readonly destPath?: string;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#empty_dir_cleanup_sec Destination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_page_checksum Destination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_statistics Destination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_write_page_index Destination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * MinIO service url (e.g. http://minioHost:9000)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#file_name_suffix Destination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#header_line Destination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#key_value_metadata Destination#key_value_metadata}
  */
  readonly keyValueMetadata?: DestinationOutputMinioKeyValueMetadata[] | cdktf.IResolvable;
  /**
  * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_concurrent_file_parts Destination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_file_idle_time_sec Destination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_file_open_time_sec Destination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_file_size_mb Destination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_open_files Destination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_retry_num Destination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#object_acl Destination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_disk_full_backpressure Destination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_data_page_version Destination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_page_size Destination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_row_group_length Destination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_version Destination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value  if present  otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#partition_expr Destination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the MinIO service/cluster is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#region Destination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates). Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#remove_empty_dirs Destination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Server-side encryption for uploaded objects. must be "AES256"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#server_side_encryption Destination#server_side_encryption}
  */
  readonly serverSideEncryption?: string;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#should_log_invalid_rows Destination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing MinIO requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#signature_version Destination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#stage_path Destination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#storage_class Destination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "minio"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Disable if you can access files within the bucket but not the bucket itself. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#verify_permissions Destination#verify_permissions}
  */
  readonly verifyPermissions?: boolean | cdktf.IResolvable;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#write_high_water_mark Destination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function destinationOutputMinioToTerraform(struct?: DestinationOutputMinio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(destinationOutputMinioKeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    server_side_encryption: cdktf.stringToTerraform(struct!.serverSideEncryption),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    verify_permissions: cdktf.booleanToTerraform(struct!.verifyPermissions),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function destinationOutputMinioToHclTerraform(struct?: DestinationOutputMinio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(destinationOutputMinioKeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputMinioKeyValueMetadataList",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_side_encryption: {
      value: cdktf.stringToHclTerraform(struct!.serverSideEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.verifyPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputMinioOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputMinio | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._serverSideEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSideEncryption = this._serverSideEncryption;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyPermissions = this._verifyPermissions;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputMinio | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._automaticSchema = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._baseFileName = undefined;
      this._bucket = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._serverSideEncryption = undefined;
      this._shouldLogInvalidRows = undefined;
      this._signatureVersion = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._verifyPermissions = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._automaticSchema = value.automaticSchema;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._baseFileName = value.baseFileName;
      this._bucket = value.bucket;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._serverSideEncryption = value.serverSideEncryption;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._signatureVersion = value.signatureVersion;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._verifyPermissions = value.verifyPermissions;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: false, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new DestinationOutputMinioKeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: DestinationOutputMinioKeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partition_expr - computed: true, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // server_side_encryption - computed: false, optional: true, required: false
  private _serverSideEncryption?: string; 
  public get serverSideEncryption() {
    return this.getStringAttribute('server_side_encryption');
  }
  public set serverSideEncryption(value: string) {
    this._serverSideEncryption = value;
  }
  public resetServerSideEncryption() {
    this._serverSideEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSideEncryptionInput() {
    return this._serverSideEncryption;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_permissions - computed: true, optional: true, required: false
  private _verifyPermissions?: boolean | cdktf.IResolvable; 
  public get verifyPermissions() {
    return this.getBooleanAttribute('verify_permissions');
  }
  public set verifyPermissions(value: boolean | cdktf.IResolvable) {
    this._verifyPermissions = value;
  }
  public resetVerifyPermissions() {
    this._verifyPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyPermissionsInput() {
    return this._verifyPermissions;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface DestinationOutputMskKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function destinationOutputMskKafkaSchemaRegistryAuthToTerraform(struct?: DestinationOutputMskKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function destinationOutputMskKafkaSchemaRegistryAuthToHclTerraform(struct?: DestinationOutputMskKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputMskKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputMskKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputMskKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface DestinationOutputMskKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputMskKafkaSchemaRegistryTlsToTerraform(struct?: DestinationOutputMskKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputMskKafkaSchemaRegistryTlsToHclTerraform(struct?: DestinationOutputMskKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputMskKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputMskKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputMskKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputMskKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth Destination#auth}
  */
  readonly auth?: DestinationOutputMskKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#default_key_schema_id Destination#default_key_schema_id}
  */
  readonly defaultKeySchemaId?: number;
  /**
  * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#default_value_schema_id Destination#default_value_schema_id}
  */
  readonly defaultValueSchemaId?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_retries Destination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#request_timeout Destination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#schema_registry_url Destination#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputMskKafkaSchemaRegistryTls;
}

export function destinationOutputMskKafkaSchemaRegistryToTerraform(struct?: DestinationOutputMskKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: destinationOutputMskKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    default_key_schema_id: cdktf.numberToTerraform(struct!.defaultKeySchemaId),
    default_value_schema_id: cdktf.numberToTerraform(struct!.defaultValueSchemaId),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: destinationOutputMskKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function destinationOutputMskKafkaSchemaRegistryToHclTerraform(struct?: DestinationOutputMskKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: destinationOutputMskKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputMskKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_key_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultKeySchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_value_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultValueSchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: destinationOutputMskKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputMskKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputMskKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputMskKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._defaultKeySchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultKeySchemaId = this._defaultKeySchemaId;
    }
    if (this._defaultValueSchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValueSchemaId = this._defaultValueSchemaId;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputMskKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._defaultKeySchemaId = undefined;
      this._defaultValueSchemaId = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._defaultKeySchemaId = value.defaultKeySchemaId;
      this._defaultValueSchemaId = value.defaultValueSchemaId;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DestinationOutputMskKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DestinationOutputMskKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // default_key_schema_id - computed: false, optional: true, required: false
  private _defaultKeySchemaId?: number; 
  public get defaultKeySchemaId() {
    return this.getNumberAttribute('default_key_schema_id');
  }
  public set defaultKeySchemaId(value: number) {
    this._defaultKeySchemaId = value;
  }
  public resetDefaultKeySchemaId() {
    this._defaultKeySchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultKeySchemaIdInput() {
    return this._defaultKeySchemaId;
  }

  // default_value_schema_id - computed: false, optional: true, required: false
  private _defaultValueSchemaId?: number; 
  public get defaultValueSchemaId() {
    return this.getNumberAttribute('default_value_schema_id');
  }
  public set defaultValueSchemaId(value: number) {
    this._defaultValueSchemaId = value;
  }
  public resetDefaultValueSchemaId() {
    this._defaultValueSchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueSchemaIdInput() {
    return this._defaultValueSchemaId;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputMskKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputMskKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DestinationOutputMskPqControls {
}

export function destinationOutputMskPqControlsToTerraform(struct?: DestinationOutputMskPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputMskPqControlsToHclTerraform(struct?: DestinationOutputMskPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputMskPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputMskPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputMskPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputMskTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputMskTlsToTerraform(struct?: DestinationOutputMskTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputMskTlsToHclTerraform(struct?: DestinationOutputMskTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputMskTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputMskTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputMskTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputMsk {
  /**
  * Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ack Destination#ack}
  */
  readonly ack?: number;
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_arn Destination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_external_id Destination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#authentication_timeout Destination#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_authentication_method Destination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret Destination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#brokers Destination#brokers}
  */
  readonly brokers: string[];
  /**
  * Codec to use to compress the data before sending to Kafka. Default: "gzip"; must be one of ["none", "gzip", "snappy", "lz4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compression Destination#compression}
  */
  readonly compression?: string;
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#duration_seconds Destination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access MSK. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_assume_role Destination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * The maximum number of events you want the Destination to allow in a batch before forcing a flush. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_event_count Destination#flush_event_count}
  */
  readonly flushEventCount?: number;
  /**
  * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Format to use to serialize events before writing to Kafka. Default: "json"; must be one of ["json", "raw", "protobuf"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#kafka_schema_registry Destination#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: DestinationOutputMskKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_back_off Destination#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting. Default: 768
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_record_size_kb Destination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_retries Destination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputMskPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a set of Protobuf definitions for the events you want to send
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#protobuf_library_id Destination#protobuf_library_id}
  */
  readonly protobufLibraryId?: string;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reauthentication_threshold Destination#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Region where the MSK cluster is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#region Destination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#request_timeout Destination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing MSK cluster requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#signature_version Destination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputMskTls;
  /**
  * The topic to publish events to. Can be overridden using the __topicOut field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#topic Destination#topic}
  */
  readonly topic: string;
  /**
  * must be "msk"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
}

export function destinationOutputMskToTerraform(struct?: DestinationOutputMsk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ack: cdktf.numberToTerraform(struct!.ack),
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    compression: cdktf.stringToTerraform(struct!.compression),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_event_count: cdktf.numberToTerraform(struct!.flushEventCount),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: destinationOutputMskKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputMskPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protobuf_library_id: cdktf.stringToTerraform(struct!.protobufLibraryId),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tls: destinationOutputMskTlsToTerraform(struct!.tls),
    topic: cdktf.stringToTerraform(struct!.topic),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputMskToHclTerraform(struct?: DestinationOutputMsk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ack: {
      value: cdktf.numberToHclTerraform(struct!.ack),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_event_count: {
      value: cdktf.numberToHclTerraform(struct!.flushEventCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: destinationOutputMskKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputMskKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputMskPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputMskPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protobuf_library_id: {
      value: cdktf.stringToHclTerraform(struct!.protobufLibraryId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: destinationOutputMskTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputMskTls",
    },
    topic: {
      value: cdktf.stringToHclTerraform(struct!.topic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputMskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputMsk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ack !== undefined) {
      hasAnyValues = true;
      internalValueResult.ack = this._ack;
    }
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushEventCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushEventCount = this._flushEventCount;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protobufLibraryId !== undefined) {
      hasAnyValues = true;
      internalValueResult.protobufLibraryId = this._protobufLibraryId;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topic !== undefined) {
      hasAnyValues = true;
      internalValueResult.topic = this._topic;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputMsk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ack = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._authenticationTimeout = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._compression = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._flushEventCount = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxRecordSizeKb = undefined;
      this._maxRetries = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protobufLibraryId = undefined;
      this._reauthenticationThreshold = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._requestTimeout = undefined;
      this._reuseConnections = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tls.internalValue = undefined;
      this._topic = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ack = value.ack;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._authenticationTimeout = value.authenticationTimeout;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._compression = value.compression;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._flushEventCount = value.flushEventCount;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._maxRetries = value.maxRetries;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protobufLibraryId = value.protobufLibraryId;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestTimeout = value.requestTimeout;
      this._reuseConnections = value.reuseConnections;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tls.internalValue = value.tls;
      this._topic = value.topic;
      this._type = value.type;
    }
  }

  // ack - computed: true, optional: true, required: false
  private _ack?: number; 
  public get ack() {
    return this.getNumberAttribute('ack');
  }
  public set ack(value: number) {
    this._ack = value;
  }
  public resetAck() {
    this._ack = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ackInput() {
    return this._ack;
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_event_count - computed: true, optional: true, required: false
  private _flushEventCount?: number; 
  public get flushEventCount() {
    return this.getNumberAttribute('flush_event_count');
  }
  public set flushEventCount(value: number) {
    this._flushEventCount = value;
  }
  public resetFlushEventCount() {
    this._flushEventCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushEventCountInput() {
    return this._flushEventCount;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new DestinationOutputMskKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: DestinationOutputMskKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputMskPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputMskPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protobuf_library_id - computed: false, optional: true, required: false
  private _protobufLibraryId?: string; 
  public get protobufLibraryId() {
    return this.getStringAttribute('protobuf_library_id');
  }
  public set protobufLibraryId(value: string) {
    this._protobufLibraryId = value;
  }
  public resetProtobufLibraryId() {
    this._protobufLibraryId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protobufLibraryIdInput() {
    return this._protobufLibraryId;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputMskTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputMskTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topic - computed: false, optional: false, required: true
  private _topic?: string; 
  public get topic() {
    return this.getStringAttribute('topic');
  }
  public set topic(value: string) {
    this._topic = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicInput() {
    return this._topic;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputNetflowHosts {
  /**
  * Destination host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#host Destination#host}
  */
  readonly host: string;
  /**
  * Destination port, default is 2055. Default: 2055
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
}

export function destinationOutputNetflowHostsToTerraform(struct?: DestinationOutputNetflowHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function destinationOutputNetflowHostsToHclTerraform(struct?: DestinationOutputNetflowHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNetflowHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputNetflowHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNetflowHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}

export class DestinationOutputNetflowHostsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputNetflowHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputNetflowHostsOutputReference {
    return new DestinationOutputNetflowHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputNetflow {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every datagram sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * One or more NetFlow destinations to forward events to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#hosts Destination#hosts}
  */
  readonly hosts: DestinationOutputNetflowHosts[] | cdktf.IResolvable;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "netflow"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
}

export function destinationOutputNetflowToTerraform(struct?: DestinationOutputNetflow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    hosts: cdktf.listMapper(destinationOutputNetflowHostsToTerraform, false)(struct!.hosts),
    id: cdktf.stringToTerraform(struct!.id),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputNetflowToHclTerraform(struct?: DestinationOutputNetflow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hosts: {
      value: cdktf.listMapperHcl(destinationOutputNetflowHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputNetflowHostsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNetflowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputNetflow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNetflow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._hosts.internalValue = undefined;
      this._id = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._hosts.internalValue = value.hosts;
      this._id = value.id;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts = new DestinationOutputNetflowHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: DestinationOutputNetflowHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputNewrelicExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputNewrelicExtraHttpHeadersToTerraform(struct?: DestinationOutputNewrelicExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputNewrelicExtraHttpHeadersToHclTerraform(struct?: DestinationOutputNewrelicExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNewrelicExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputNewrelicExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelicExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputNewrelicExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputNewrelicExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputNewrelicExtraHttpHeadersOutputReference {
    return new DestinationOutputNewrelicExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputNewrelicMetadata {
  /**
  * must be one of ["service", "hostname", "timestamp", "auditId"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputNewrelicMetadataToTerraform(struct?: DestinationOutputNewrelicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputNewrelicMetadataToHclTerraform(struct?: DestinationOutputNewrelicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNewrelicMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputNewrelicMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelicMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputNewrelicMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputNewrelicMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputNewrelicMetadataOutputReference {
    return new DestinationOutputNewrelicMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputNewrelicPqControls {
}

export function destinationOutputNewrelicPqControlsToTerraform(struct?: DestinationOutputNewrelicPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputNewrelicPqControlsToHclTerraform(struct?: DestinationOutputNewrelicPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputNewrelicPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputNewrelicPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelicPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputNewrelicResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputNewrelicResponseRetrySettingsToTerraform(struct?: DestinationOutputNewrelicResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputNewrelicResponseRetrySettingsToHclTerraform(struct?: DestinationOutputNewrelicResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNewrelicResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputNewrelicResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelicResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputNewrelicResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputNewrelicResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputNewrelicResponseRetrySettingsOutputReference {
    return new DestinationOutputNewrelicResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputNewrelicTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputNewrelicTimeoutRetrySettingsToTerraform(struct?: DestinationOutputNewrelicTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputNewrelicTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputNewrelicTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNewrelicTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputNewrelicTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelicTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputNewrelic {
  /**
  * New Relic API key. Can be overridden using __newRelic_apiKey field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#api_key Destination#api_key}
  */
  readonly apiKey?: string;
  /**
  * Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_url Destination#custom_url}
  */
  readonly customUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputNewrelicExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Name of the logtype to send with events, e.g.: observability, access_log. The event's 'sourcetype' field (if set) will override this value. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#log_type Destination#log_type}
  */
  readonly logType?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of field to send as log message value. If not present, event will be serialized and sent as JSON. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#message_field Destination#message_field}
  */
  readonly messageField?: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#metadata Destination#metadata}
  */
  readonly metadata?: DestinationOutputNewrelicMetadata[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputNewrelicPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Which New Relic region endpoint to use. Default: "US"; must be one of ["US", "EU", "Custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#region Destination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputNewrelicResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputNewrelicTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "newrelic"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputNewrelicToTerraform(struct?: DestinationOutputNewrelic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_url: cdktf.stringToTerraform(struct!.customUrl),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputNewrelicExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    log_type: cdktf.stringToTerraform(struct!.logType),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message_field: cdktf.stringToTerraform(struct!.messageField),
    metadata: cdktf.listMapper(destinationOutputNewrelicMetadataToTerraform, false)(struct!.metadata),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputNewrelicPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputNewrelicResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputNewrelicTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputNewrelicToHclTerraform(struct?: DestinationOutputNewrelic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_url: {
      value: cdktf.stringToHclTerraform(struct!.customUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputNewrelicExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputNewrelicExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_type: {
      value: cdktf.stringToHclTerraform(struct!.logType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message_field: {
      value: cdktf.stringToHclTerraform(struct!.messageField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(destinationOutputNewrelicMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputNewrelicMetadataList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputNewrelicPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputNewrelicPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputNewrelicResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputNewrelicResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputNewrelicTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputNewrelicTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNewrelicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputNewrelic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.customUrl = this._customUrl;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._logType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logType = this._logType;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._messageField !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageField = this._messageField;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKey = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customUrl = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._logType = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._messageField = undefined;
      this._metadata.internalValue = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKey = value.apiKey;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customUrl = value.customUrl;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._logType = value.logType;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._messageField = value.messageField;
      this._metadata.internalValue = value.metadata;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_url - computed: false, optional: true, required: false
  private _customUrl?: string; 
  public get customUrl() {
    return this.getStringAttribute('custom_url');
  }
  public set customUrl(value: string) {
    this._customUrl = value;
  }
  public resetCustomUrl() {
    this._customUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customUrlInput() {
    return this._customUrl;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputNewrelicExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputNewrelicExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // log_type - computed: true, optional: true, required: false
  private _logType?: string; 
  public get logType() {
    return this.getStringAttribute('log_type');
  }
  public set logType(value: string) {
    this._logType = value;
  }
  public resetLogType() {
    this._logType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logTypeInput() {
    return this._logType;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message_field - computed: true, optional: true, required: false
  private _messageField?: string; 
  public get messageField() {
    return this.getStringAttribute('message_field');
  }
  public set messageField(value: string) {
    this._messageField = value;
  }
  public resetMessageField() {
    this._messageField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFieldInput() {
    return this._messageField;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DestinationOutputNewrelicMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DestinationOutputNewrelicMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputNewrelicPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputNewrelicPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: true, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputNewrelicResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputNewrelicResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputNewrelicTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputNewrelicTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputNewrelicEventsExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputNewrelicEventsExtraHttpHeadersToTerraform(struct?: DestinationOutputNewrelicEventsExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputNewrelicEventsExtraHttpHeadersToHclTerraform(struct?: DestinationOutputNewrelicEventsExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNewrelicEventsExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputNewrelicEventsExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelicEventsExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputNewrelicEventsExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputNewrelicEventsExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputNewrelicEventsExtraHttpHeadersOutputReference {
    return new DestinationOutputNewrelicEventsExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputNewrelicEventsPqControls {
}

export function destinationOutputNewrelicEventsPqControlsToTerraform(struct?: DestinationOutputNewrelicEventsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputNewrelicEventsPqControlsToHclTerraform(struct?: DestinationOutputNewrelicEventsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputNewrelicEventsPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputNewrelicEventsPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelicEventsPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputNewrelicEventsResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputNewrelicEventsResponseRetrySettingsToTerraform(struct?: DestinationOutputNewrelicEventsResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputNewrelicEventsResponseRetrySettingsToHclTerraform(struct?: DestinationOutputNewrelicEventsResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNewrelicEventsResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputNewrelicEventsResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelicEventsResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputNewrelicEventsResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputNewrelicEventsResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputNewrelicEventsResponseRetrySettingsOutputReference {
    return new DestinationOutputNewrelicEventsResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputNewrelicEventsTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputNewrelicEventsTimeoutRetrySettingsToTerraform(struct?: DestinationOutputNewrelicEventsTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputNewrelicEventsTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputNewrelicEventsTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNewrelicEventsTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputNewrelicEventsTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelicEventsTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputNewrelicEvents {
  /**
  * New Relic account ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#account_id Destination#account_id}
  */
  readonly accountId: string;
  /**
  * New Relic API key. Can be overridden using __newRelic_apiKey field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#api_key Destination#api_key}
  */
  readonly apiKey?: string;
  /**
  * Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_url Destination#custom_url}
  */
  readonly customUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Default eventType to use when not present in an event. For more information, see [here](https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/#reserved-words).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#event_type Destination#event_type}
  */
  readonly eventType: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputNewrelicEventsExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputNewrelicEventsPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Which New Relic region endpoint to use. Default: "US"; must be one of ["US", "EU", "Custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#region Destination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputNewrelicEventsResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputNewrelicEventsTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "newrelic_events"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputNewrelicEventsToTerraform(struct?: DestinationOutputNewrelicEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account_id: cdktf.stringToTerraform(struct!.accountId),
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_url: cdktf.stringToTerraform(struct!.customUrl),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    event_type: cdktf.stringToTerraform(struct!.eventType),
    extra_http_headers: cdktf.listMapper(destinationOutputNewrelicEventsExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputNewrelicEventsPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputNewrelicEventsResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputNewrelicEventsTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputNewrelicEventsToHclTerraform(struct?: DestinationOutputNewrelicEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account_id: {
      value: cdktf.stringToHclTerraform(struct!.accountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_url: {
      value: cdktf.stringToHclTerraform(struct!.customUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_type: {
      value: cdktf.stringToHclTerraform(struct!.eventType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputNewrelicEventsExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputNewrelicEventsExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputNewrelicEventsPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputNewrelicEventsPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputNewrelicEventsResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputNewrelicEventsResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputNewrelicEventsTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputNewrelicEventsTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputNewrelicEventsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputNewrelicEvents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.accountId = this._accountId;
    }
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.customUrl = this._customUrl;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._eventType !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventType = this._eventType;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputNewrelicEvents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accountId = undefined;
      this._apiKey = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customUrl = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._eventType = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accountId = value.accountId;
      this._apiKey = value.apiKey;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customUrl = value.customUrl;
      this._description = value.description;
      this._environment = value.environment;
      this._eventType = value.eventType;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // account_id - computed: false, optional: false, required: true
  private _accountId?: string; 
  public get accountId() {
    return this.getStringAttribute('account_id');
  }
  public set accountId(value: string) {
    this._accountId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accountIdInput() {
    return this._accountId;
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_url - computed: false, optional: true, required: false
  private _customUrl?: string; 
  public get customUrl() {
    return this.getStringAttribute('custom_url');
  }
  public set customUrl(value: string) {
    this._customUrl = value;
  }
  public resetCustomUrl() {
    this._customUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customUrlInput() {
    return this._customUrl;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // event_type - computed: false, optional: false, required: true
  private _eventType?: string; 
  public get eventType() {
    return this.getStringAttribute('event_type');
  }
  public set eventType(value: string) {
    this._eventType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get eventTypeInput() {
    return this._eventType;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputNewrelicEventsExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputNewrelicEventsExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputNewrelicEventsPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputNewrelicEventsPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: true, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputNewrelicEventsResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputNewrelicEventsResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputNewrelicEventsTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputNewrelicEventsTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputOpenTelemetryExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputOpenTelemetryExtraHttpHeadersToTerraform(struct?: DestinationOutputOpenTelemetryExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputOpenTelemetryExtraHttpHeadersToHclTerraform(struct?: DestinationOutputOpenTelemetryExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputOpenTelemetryExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputOpenTelemetryExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputOpenTelemetryExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputOpenTelemetryExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputOpenTelemetryExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputOpenTelemetryExtraHttpHeadersOutputReference {
    return new DestinationOutputOpenTelemetryExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputOpenTelemetryMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#key Destination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputOpenTelemetryMetadataToTerraform(struct?: DestinationOutputOpenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputOpenTelemetryMetadataToHclTerraform(struct?: DestinationOutputOpenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputOpenTelemetryMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputOpenTelemetryMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputOpenTelemetryMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputOpenTelemetryMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputOpenTelemetryMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputOpenTelemetryMetadataOutputReference {
    return new DestinationOutputOpenTelemetryMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputOpenTelemetryOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputOpenTelemetryOauthHeadersToTerraform(struct?: DestinationOutputOpenTelemetryOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputOpenTelemetryOauthHeadersToHclTerraform(struct?: DestinationOutputOpenTelemetryOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputOpenTelemetryOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputOpenTelemetryOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputOpenTelemetryOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputOpenTelemetryOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputOpenTelemetryOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputOpenTelemetryOauthHeadersOutputReference {
    return new DestinationOutputOpenTelemetryOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputOpenTelemetryOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputOpenTelemetryOauthParamsToTerraform(struct?: DestinationOutputOpenTelemetryOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputOpenTelemetryOauthParamsToHclTerraform(struct?: DestinationOutputOpenTelemetryOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputOpenTelemetryOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputOpenTelemetryOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputOpenTelemetryOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputOpenTelemetryOauthParamsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputOpenTelemetryOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputOpenTelemetryOauthParamsOutputReference {
    return new DestinationOutputOpenTelemetryOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputOpenTelemetryPqControls {
}

export function destinationOutputOpenTelemetryPqControlsToTerraform(struct?: DestinationOutputOpenTelemetryPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputOpenTelemetryPqControlsToHclTerraform(struct?: DestinationOutputOpenTelemetryPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputOpenTelemetryPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputOpenTelemetryPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputOpenTelemetryPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputOpenTelemetryResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputOpenTelemetryResponseRetrySettingsToTerraform(struct?: DestinationOutputOpenTelemetryResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputOpenTelemetryResponseRetrySettingsToHclTerraform(struct?: DestinationOutputOpenTelemetryResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputOpenTelemetryResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputOpenTelemetryResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputOpenTelemetryResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputOpenTelemetryResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputOpenTelemetryResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputOpenTelemetryResponseRetrySettingsOutputReference {
    return new DestinationOutputOpenTelemetryResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputOpenTelemetryTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputOpenTelemetryTimeoutRetrySettingsToTerraform(struct?: DestinationOutputOpenTelemetryTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputOpenTelemetryTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputOpenTelemetryTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputOpenTelemetryTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputOpenTelemetryTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputOpenTelemetryTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputOpenTelemetryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
}

export function destinationOutputOpenTelemetryTlsToTerraform(struct?: DestinationOutputOpenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
  }
}


export function destinationOutputOpenTelemetryTlsToHclTerraform(struct?: DestinationOutputOpenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputOpenTelemetryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputOpenTelemetryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputOpenTelemetryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }
}
export interface DestinationOutputOpenTelemetry {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_header_expr Destination#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * OpenTelemetry authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "deflate", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The endpoint where OTel events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Unspecified ports will default to 4317, unless the endpoint is an HTTPS-based URL or TLS is enabled, in which case 443 will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputOpenTelemetryExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_compress Destination#http_compress}
  */
  readonly httpCompress?: string;
  /**
  * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_logs_endpoint_override Destination#http_logs_endpoint_override}
  */
  readonly httpLogsEndpointOverride?: string;
  /**
  * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_metrics_endpoint_override Destination#http_metrics_endpoint_override}
  */
  readonly httpMetricsEndpointOverride?: string;
  /**
  * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_traces_endpoint_override Destination#http_traces_endpoint_override}
  */
  readonly httpTracesEndpointOverride?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#keep_alive Destination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * How often the sender should ping the peer to keep the connection open. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#keep_alive_time Destination#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#login_url Destination#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#metadata Destination#metadata}
  */
  readonly metadata?: DestinationOutputOpenTelemetryMetadata[] | cdktf.IResolvable;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#oauth_headers Destination#oauth_headers}
  */
  readonly oauthHeaders?: DestinationOutputOpenTelemetryOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#oauth_params Destination#oauth_params}
  */
  readonly oauthParams?: DestinationOutputOpenTelemetryOauthParams[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * The version of OTLP Protobuf definitions to use when structuring data to send. Default: "0.10.0"; must be one of ["0.10.0", "1.3.1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#otlp_version Destination#otlp_version}
  */
  readonly otlpVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#password Destination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputOpenTelemetryPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a transport option for OpenTelemetry. Default: "grpc"; must be one of ["grpc", "http"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#protocol Destination#protocol}
  */
  readonly protocol?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
  * 
  * 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputOpenTelemetryResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#secret Destination#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#secret_param_name Destination#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputOpenTelemetryTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputOpenTelemetryTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token_attribute_name Destination#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token_timeout_secs Destination#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "open_telemetry"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#username Destination#username}
  */
  readonly username?: string;
}

export function destinationOutputOpenTelemetryToTerraform(struct?: DestinationOutputOpenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.stringToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputOpenTelemetryExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    http_compress: cdktf.stringToTerraform(struct!.httpCompress),
    http_logs_endpoint_override: cdktf.stringToTerraform(struct!.httpLogsEndpointOverride),
    http_metrics_endpoint_override: cdktf.stringToTerraform(struct!.httpMetricsEndpointOverride),
    http_traces_endpoint_override: cdktf.stringToTerraform(struct!.httpTracesEndpointOverride),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    metadata: cdktf.listMapper(destinationOutputOpenTelemetryMetadataToTerraform, false)(struct!.metadata),
    oauth_headers: cdktf.listMapper(destinationOutputOpenTelemetryOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(destinationOutputOpenTelemetryOauthParamsToTerraform, false)(struct!.oauthParams),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    otlp_version: cdktf.stringToTerraform(struct!.otlpVersion),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputOpenTelemetryPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputOpenTelemetryResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputOpenTelemetryTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    tls: destinationOutputOpenTelemetryTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function destinationOutputOpenTelemetryToHclTerraform(struct?: DestinationOutputOpenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputOpenTelemetryExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputOpenTelemetryExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_compress: {
      value: cdktf.stringToHclTerraform(struct!.httpCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_logs_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpLogsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_metrics_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpMetricsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_traces_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpTracesEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(destinationOutputOpenTelemetryMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputOpenTelemetryMetadataList",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(destinationOutputOpenTelemetryOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputOpenTelemetryOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(destinationOutputOpenTelemetryOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputOpenTelemetryOauthParamsList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    otlp_version: {
      value: cdktf.stringToHclTerraform(struct!.otlpVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputOpenTelemetryPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputOpenTelemetryPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputOpenTelemetryResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputOpenTelemetryResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputOpenTelemetryTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputOpenTelemetryTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: destinationOutputOpenTelemetryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputOpenTelemetryTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputOpenTelemetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputOpenTelemetry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._httpCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpCompress = this._httpCompress;
    }
    if (this._httpLogsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpLogsEndpointOverride = this._httpLogsEndpointOverride;
    }
    if (this._httpMetricsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpMetricsEndpointOverride = this._httpMetricsEndpointOverride;
    }
    if (this._httpTracesEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpTracesEndpointOverride = this._httpTracesEndpointOverride;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._otlpVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.otlpVersion = this._otlpVersion;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputOpenTelemetry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._connectionTimeout = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._httpCompress = undefined;
      this._httpLogsEndpointOverride = undefined;
      this._httpMetricsEndpointOverride = undefined;
      this._httpTracesEndpointOverride = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._keepAliveTime = undefined;
      this._loginUrl = undefined;
      this._maxPayloadSizeKb = undefined;
      this._metadata.internalValue = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._onBackpressure = undefined;
      this._otlpVersion = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._connectionTimeout = value.connectionTimeout;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._httpCompress = value.httpCompress;
      this._httpLogsEndpointOverride = value.httpLogsEndpointOverride;
      this._httpMetricsEndpointOverride = value.httpMetricsEndpointOverride;
      this._httpTracesEndpointOverride = value.httpTracesEndpointOverride;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._keepAliveTime = value.keepAliveTime;
      this._loginUrl = value.loginUrl;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._metadata.internalValue = value.metadata;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._onBackpressure = value.onBackpressure;
      this._otlpVersion = value.otlpVersion;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputOpenTelemetryExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputOpenTelemetryExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // http_compress - computed: true, optional: true, required: false
  private _httpCompress?: string; 
  public get httpCompress() {
    return this.getStringAttribute('http_compress');
  }
  public set httpCompress(value: string) {
    this._httpCompress = value;
  }
  public resetHttpCompress() {
    this._httpCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpCompressInput() {
    return this._httpCompress;
  }

  // http_logs_endpoint_override - computed: false, optional: true, required: false
  private _httpLogsEndpointOverride?: string; 
  public get httpLogsEndpointOverride() {
    return this.getStringAttribute('http_logs_endpoint_override');
  }
  public set httpLogsEndpointOverride(value: string) {
    this._httpLogsEndpointOverride = value;
  }
  public resetHttpLogsEndpointOverride() {
    this._httpLogsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpLogsEndpointOverrideInput() {
    return this._httpLogsEndpointOverride;
  }

  // http_metrics_endpoint_override - computed: false, optional: true, required: false
  private _httpMetricsEndpointOverride?: string; 
  public get httpMetricsEndpointOverride() {
    return this.getStringAttribute('http_metrics_endpoint_override');
  }
  public set httpMetricsEndpointOverride(value: string) {
    this._httpMetricsEndpointOverride = value;
  }
  public resetHttpMetricsEndpointOverride() {
    this._httpMetricsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpMetricsEndpointOverrideInput() {
    return this._httpMetricsEndpointOverride;
  }

  // http_traces_endpoint_override - computed: false, optional: true, required: false
  private _httpTracesEndpointOverride?: string; 
  public get httpTracesEndpointOverride() {
    return this.getStringAttribute('http_traces_endpoint_override');
  }
  public set httpTracesEndpointOverride(value: string) {
    this._httpTracesEndpointOverride = value;
  }
  public resetHttpTracesEndpointOverride() {
    this._httpTracesEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpTracesEndpointOverrideInput() {
    return this._httpTracesEndpointOverride;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DestinationOutputOpenTelemetryMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DestinationOutputOpenTelemetryMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new DestinationOutputOpenTelemetryOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: DestinationOutputOpenTelemetryOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new DestinationOutputOpenTelemetryOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: DestinationOutputOpenTelemetryOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // otlp_version - computed: true, optional: true, required: false
  private _otlpVersion?: string; 
  public get otlpVersion() {
    return this.getStringAttribute('otlp_version');
  }
  public set otlpVersion(value: string) {
    this._otlpVersion = value;
  }
  public resetOtlpVersion() {
    this._otlpVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get otlpVersionInput() {
    return this._otlpVersion;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputOpenTelemetryPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputOpenTelemetryPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputOpenTelemetryResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputOpenTelemetryResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputOpenTelemetryTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputOpenTelemetryTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputOpenTelemetryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputOpenTelemetryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DestinationOutputPrometheusExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputPrometheusExtraHttpHeadersToTerraform(struct?: DestinationOutputPrometheusExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputPrometheusExtraHttpHeadersToHclTerraform(struct?: DestinationOutputPrometheusExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputPrometheusExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputPrometheusExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputPrometheusExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputPrometheusExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputPrometheusExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputPrometheusExtraHttpHeadersOutputReference {
    return new DestinationOutputPrometheusExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputPrometheusOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputPrometheusOauthHeadersToTerraform(struct?: DestinationOutputPrometheusOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputPrometheusOauthHeadersToHclTerraform(struct?: DestinationOutputPrometheusOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputPrometheusOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputPrometheusOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputPrometheusOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputPrometheusOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputPrometheusOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputPrometheusOauthHeadersOutputReference {
    return new DestinationOutputPrometheusOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputPrometheusOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputPrometheusOauthParamsToTerraform(struct?: DestinationOutputPrometheusOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputPrometheusOauthParamsToHclTerraform(struct?: DestinationOutputPrometheusOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputPrometheusOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputPrometheusOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputPrometheusOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputPrometheusOauthParamsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputPrometheusOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputPrometheusOauthParamsOutputReference {
    return new DestinationOutputPrometheusOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputPrometheusPqControls {
}

export function destinationOutputPrometheusPqControlsToTerraform(struct?: DestinationOutputPrometheusPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputPrometheusPqControlsToHclTerraform(struct?: DestinationOutputPrometheusPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputPrometheusPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputPrometheusPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputPrometheusPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputPrometheusResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputPrometheusResponseRetrySettingsToTerraform(struct?: DestinationOutputPrometheusResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputPrometheusResponseRetrySettingsToHclTerraform(struct?: DestinationOutputPrometheusResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputPrometheusResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputPrometheusResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputPrometheusResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputPrometheusResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputPrometheusResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputPrometheusResponseRetrySettingsOutputReference {
    return new DestinationOutputPrometheusResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputPrometheusTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputPrometheusTimeoutRetrySettingsToTerraform(struct?: DestinationOutputPrometheusTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputPrometheusTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputPrometheusTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputPrometheusTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputPrometheusTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputPrometheusTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputPrometheus {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_header_expr Destination#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Remote Write authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputPrometheusExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#login_url Destination#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * JavaScript expression that can be used to rename metrics. For example, name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name. You can access event fields' values via __e.<fieldName>. Default: "name.replace(/[^a-zA-Z0-9_]/g, '_')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#metric_rename_expr Destination#metric_rename_expr}
  */
  readonly metricRenameExpr?: string;
  /**
  * How frequently metrics metadata is sent out. Value cannot be smaller than the base Flush period set above. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#metrics_flush_period_sec Destination#metrics_flush_period_sec}
  */
  readonly metricsFlushPeriodSec?: number;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#oauth_headers Destination#oauth_headers}
  */
  readonly oauthHeaders?: DestinationOutputPrometheusOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#oauth_params Destination#oauth_params}
  */
  readonly oauthParams?: DestinationOutputPrometheusOauthParams[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#password Destination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputPrometheusPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputPrometheusResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#secret Destination#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#secret_param_name Destination#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Generate and send metadata (`type` and `metricFamilyName`) requests. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#send_metadata Destination#send_metadata}
  */
  readonly sendMetadata?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions to generated metrics. Default: ["cribl_host","cribl_wp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputPrometheusTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token_attribute_name Destination#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token_timeout_secs Destination#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "prometheus"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * The endpoint to send metrics to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#username Destination#username}
  */
  readonly username?: string;
}

export function destinationOutputPrometheusToTerraform(struct?: DestinationOutputPrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputPrometheusExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    metric_rename_expr: cdktf.stringToTerraform(struct!.metricRenameExpr),
    metrics_flush_period_sec: cdktf.numberToTerraform(struct!.metricsFlushPeriodSec),
    oauth_headers: cdktf.listMapper(destinationOutputPrometheusOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(destinationOutputPrometheusOauthParamsToTerraform, false)(struct!.oauthParams),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputPrometheusPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputPrometheusResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    send_metadata: cdktf.booleanToTerraform(struct!.sendMetadata),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputPrometheusTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function destinationOutputPrometheusToHclTerraform(struct?: DestinationOutputPrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputPrometheusExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputPrometheusExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric_rename_expr: {
      value: cdktf.stringToHclTerraform(struct!.metricRenameExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.metricsFlushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(destinationOutputPrometheusOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputPrometheusOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(destinationOutputPrometheusOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputPrometheusOauthParamsList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputPrometheusPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputPrometheusPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputPrometheusResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputPrometheusResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.sendMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputPrometheusTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputPrometheusTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputPrometheusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputPrometheus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._metricRenameExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricRenameExpr = this._metricRenameExpr;
    }
    if (this._metricsFlushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsFlushPeriodSec = this._metricsFlushPeriodSec;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sendMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendMetadata = this._sendMetadata;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputPrometheus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._concurrency = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._loginUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._metricRenameExpr = undefined;
      this._metricsFlushPeriodSec = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._onBackpressure = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sendMetadata = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._concurrency = value.concurrency;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._loginUrl = value.loginUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._metricRenameExpr = value.metricRenameExpr;
      this._metricsFlushPeriodSec = value.metricsFlushPeriodSec;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._onBackpressure = value.onBackpressure;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sendMetadata = value.sendMetadata;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputPrometheusExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputPrometheusExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // metric_rename_expr - computed: true, optional: true, required: false
  private _metricRenameExpr?: string; 
  public get metricRenameExpr() {
    return this.getStringAttribute('metric_rename_expr');
  }
  public set metricRenameExpr(value: string) {
    this._metricRenameExpr = value;
  }
  public resetMetricRenameExpr() {
    this._metricRenameExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricRenameExprInput() {
    return this._metricRenameExpr;
  }

  // metrics_flush_period_sec - computed: true, optional: true, required: false
  private _metricsFlushPeriodSec?: number; 
  public get metricsFlushPeriodSec() {
    return this.getNumberAttribute('metrics_flush_period_sec');
  }
  public set metricsFlushPeriodSec(value: number) {
    this._metricsFlushPeriodSec = value;
  }
  public resetMetricsFlushPeriodSec() {
    this._metricsFlushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsFlushPeriodSecInput() {
    return this._metricsFlushPeriodSec;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new DestinationOutputPrometheusOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: DestinationOutputPrometheusOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new DestinationOutputPrometheusOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: DestinationOutputPrometheusOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputPrometheusPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputPrometheusPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputPrometheusResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputPrometheusResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // send_metadata - computed: true, optional: true, required: false
  private _sendMetadata?: boolean | cdktf.IResolvable; 
  public get sendMetadata() {
    return this.getBooleanAttribute('send_metadata');
  }
  public set sendMetadata(value: boolean | cdktf.IResolvable) {
    this._sendMetadata = value;
  }
  public resetSendMetadata() {
    this._sendMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendMetadataInput() {
    return this._sendMetadata;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputPrometheusTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputPrometheusTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DestinationOutputRing {
  /**
  * Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dest_path Destination#dest_path}
  */
  readonly destPath?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_data_size Destination#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_data_time Destination#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * JS expression to define how files are partitioned and organized. If left blank, Cribl Stream will fallback on event.__partition.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#partition_expr Destination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "ring"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
}

export function destinationOutputRingToTerraform(struct?: DestinationOutputRing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    environment: cdktf.stringToTerraform(struct!.environment),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputRingToHclTerraform(struct?: DestinationOutputRing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputRingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputRing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputRing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._environment = undefined;
      this._format = undefined;
      this._id = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._onBackpressure = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._description = value.description;
      this._destPath = value.destPath;
      this._environment = value.environment;
      this._format = value.format;
      this._id = value.id;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._onBackpressure = value.onBackpressure;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: false, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // partition_expr - computed: false, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputRouterRules {
  /**
  * Description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression to select events to send to output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#filter Destination#filter}
  */
  readonly filter: string;
  /**
  * Flag to control whether to stop the event from being checked against other rules. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#final Destination#final}
  */
  readonly final?: boolean | cdktf.IResolvable;
  /**
  * Output to send matching events to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#output Destination#output}
  */
  readonly output: string;
}

export function destinationOutputRouterRulesToTerraform(struct?: DestinationOutputRouterRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
    final: cdktf.booleanToTerraform(struct!.final),
    output: cdktf.stringToTerraform(struct!.output),
  }
}


export function destinationOutputRouterRulesToHclTerraform(struct?: DestinationOutputRouterRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    final: {
      value: cdktf.booleanToHclTerraform(struct!.final),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputRouterRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputRouterRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._final !== undefined) {
      hasAnyValues = true;
      internalValueResult.final = this._final;
    }
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputRouterRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
      this._final = undefined;
      this._output = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
      this._final = value.final;
      this._output = value.output;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // final - computed: true, optional: true, required: false
  private _final?: boolean | cdktf.IResolvable; 
  public get final() {
    return this.getBooleanAttribute('final');
  }
  public set final(value: boolean | cdktf.IResolvable) {
    this._final = value;
  }
  public resetFinal() {
    this._final = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get finalInput() {
    return this._final;
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }
}

export class DestinationOutputRouterRulesList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputRouterRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputRouterRulesOutputReference {
    return new DestinationOutputRouterRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputRouter {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Event routing rules
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#rules Destination#rules}
  */
  readonly rules: DestinationOutputRouterRules[] | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "router"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
}

export function destinationOutputRouterToTerraform(struct?: DestinationOutputRouter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    rules: cdktf.listMapper(destinationOutputRouterRulesToTerraform, false)(struct!.rules),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputRouterToHclTerraform(struct?: DestinationOutputRouter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rules: {
      value: cdktf.listMapperHcl(destinationOutputRouterRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputRouterRulesList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputRouterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputRouter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputRouter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._pipeline = undefined;
      this._rules.internalValue = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._environment = value.environment;
      this._id = value.id;
      this._pipeline = value.pipeline;
      this._rules.internalValue = value.rules;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // rules - computed: false, optional: false, required: true
  private _rules = new DestinationOutputRouterRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: DestinationOutputRouterRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputS3KeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#key Destination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputS3KeyValueMetadataToTerraform(struct?: DestinationOutputS3KeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputS3KeyValueMetadataToHclTerraform(struct?: DestinationOutputS3KeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputS3KeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputS3KeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputS3KeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputS3KeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputS3KeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputS3KeyValueMetadataOutputReference {
    return new DestinationOutputS3KeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputS3 {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#add_id_to_stage_path Destination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_arn Destination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_external_id Destination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#automatic_schema Destination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_authentication_method Destination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret Destination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Secret key. This value can be a constant or a JavaScript expression. Example: `${C.env.SOME_SECRET}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#base_file_name Destination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#bucket Destination#bucket}
  */
  readonly bucket: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compression_level Destination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#deadletter_enabled Destination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#deadletter_path Destination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dest_path Destination#dest_path}
  */
  readonly destPath?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#duration_seconds Destination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#empty_dir_cleanup_sec Destination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Use Assume Role credentials to access S3. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_assume_role Destination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_page_checksum Destination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_statistics Destination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_write_page_index Destination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#file_name_suffix Destination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#header_line Destination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#key_value_metadata Destination#key_value_metadata}
  */
  readonly keyValueMetadata?: DestinationOutputS3KeyValueMetadata[] | cdktf.IResolvable;
  /**
  * ID or ARN of the KMS customer-managed key to use for encryption
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#kms_key_id Destination#kms_key_id}
  */
  readonly kmsKeyId?: string;
  /**
  * Maximum number of files that can be waiting for upload before backpressure is applied. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_closing_files_to_backpressure Destination#max_closing_files_to_backpressure}
  */
  readonly maxClosingFilesToBackpressure?: number;
  /**
  * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_concurrent_file_parts Destination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_file_idle_time_sec Destination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_file_open_time_sec Destination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_file_size_mb Destination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_open_files Destination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_retry_num Destination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#object_acl Destination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_disk_full_backpressure Destination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_data_page_version Destination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_page_size Destination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_row_group_length Destination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_version Destination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value  if present  otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#partition_expr Destination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the S3 bucket is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#region Destination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#remove_empty_dirs Destination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["AES256", "aws:kms"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#server_side_encryption Destination#server_side_encryption}
  */
  readonly serverSideEncryption?: string;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#should_log_invalid_rows Destination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#signature_version Destination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#stage_path Destination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY", "STANDARD_IA", "ONEZONE_IA", "INTELLIGENT_TIERING", "GLACIER", "GLACIER_IR", "DEEP_ARCHIVE"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#storage_class Destination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "s3"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Disable if you can access files within the bucket but not the bucket itself. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#verify_permissions Destination#verify_permissions}
  */
  readonly verifyPermissions?: boolean | cdktf.IResolvable;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#write_high_water_mark Destination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function destinationOutputS3ToTerraform(struct?: DestinationOutputS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(destinationOutputS3KeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    kms_key_id: cdktf.stringToTerraform(struct!.kmsKeyId),
    max_closing_files_to_backpressure: cdktf.numberToTerraform(struct!.maxClosingFilesToBackpressure),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    server_side_encryption: cdktf.stringToTerraform(struct!.serverSideEncryption),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    verify_permissions: cdktf.booleanToTerraform(struct!.verifyPermissions),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function destinationOutputS3ToHclTerraform(struct?: DestinationOutputS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(destinationOutputS3KeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputS3KeyValueMetadataList",
    },
    kms_key_id: {
      value: cdktf.stringToHclTerraform(struct!.kmsKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_closing_files_to_backpressure: {
      value: cdktf.numberToHclTerraform(struct!.maxClosingFilesToBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_side_encryption: {
      value: cdktf.stringToHclTerraform(struct!.serverSideEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.verifyPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputS3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputS3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._kmsKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.kmsKeyId = this._kmsKeyId;
    }
    if (this._maxClosingFilesToBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxClosingFilesToBackpressure = this._maxClosingFilesToBackpressure;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._serverSideEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSideEncryption = this._serverSideEncryption;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyPermissions = this._verifyPermissions;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputS3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._automaticSchema = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._baseFileName = undefined;
      this._bucket = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._durationSeconds = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enableAssumeRole = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._kmsKeyId = undefined;
      this._maxClosingFilesToBackpressure = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._serverSideEncryption = undefined;
      this._shouldLogInvalidRows = undefined;
      this._signatureVersion = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._verifyPermissions = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._automaticSchema = value.automaticSchema;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._baseFileName = value.baseFileName;
      this._bucket = value.bucket;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._durationSeconds = value.durationSeconds;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._kmsKeyId = value.kmsKeyId;
      this._maxClosingFilesToBackpressure = value.maxClosingFilesToBackpressure;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._serverSideEncryption = value.serverSideEncryption;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._signatureVersion = value.signatureVersion;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._verifyPermissions = value.verifyPermissions;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new DestinationOutputS3KeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: DestinationOutputS3KeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // kms_key_id - computed: false, optional: true, required: false
  private _kmsKeyId?: string; 
  public get kmsKeyId() {
    return this.getStringAttribute('kms_key_id');
  }
  public set kmsKeyId(value: string) {
    this._kmsKeyId = value;
  }
  public resetKmsKeyId() {
    this._kmsKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kmsKeyIdInput() {
    return this._kmsKeyId;
  }

  // max_closing_files_to_backpressure - computed: true, optional: true, required: false
  private _maxClosingFilesToBackpressure?: number; 
  public get maxClosingFilesToBackpressure() {
    return this.getNumberAttribute('max_closing_files_to_backpressure');
  }
  public set maxClosingFilesToBackpressure(value: number) {
    this._maxClosingFilesToBackpressure = value;
  }
  public resetMaxClosingFilesToBackpressure() {
    this._maxClosingFilesToBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxClosingFilesToBackpressureInput() {
    return this._maxClosingFilesToBackpressure;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partition_expr - computed: true, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // server_side_encryption - computed: false, optional: true, required: false
  private _serverSideEncryption?: string; 
  public get serverSideEncryption() {
    return this.getStringAttribute('server_side_encryption');
  }
  public set serverSideEncryption(value: string) {
    this._serverSideEncryption = value;
  }
  public resetServerSideEncryption() {
    this._serverSideEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSideEncryptionInput() {
    return this._serverSideEncryption;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_permissions - computed: true, optional: true, required: false
  private _verifyPermissions?: boolean | cdktf.IResolvable; 
  public get verifyPermissions() {
    return this.getBooleanAttribute('verify_permissions');
  }
  public set verifyPermissions(value: boolean | cdktf.IResolvable) {
    this._verifyPermissions = value;
  }
  public resetVerifyPermissions() {
    this._verifyPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyPermissionsInput() {
    return this._verifyPermissions;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface DestinationOutputSecurityLakeKeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#key Destination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputSecurityLakeKeyValueMetadataToTerraform(struct?: DestinationOutputSecurityLakeKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputSecurityLakeKeyValueMetadataToHclTerraform(struct?: DestinationOutputSecurityLakeKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSecurityLakeKeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSecurityLakeKeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSecurityLakeKeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputSecurityLakeKeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSecurityLakeKeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSecurityLakeKeyValueMetadataOutputReference {
    return new DestinationOutputSecurityLakeKeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSecurityLake {
  /**
  * ID of the AWS account whose data the Destination will write to Security Lake. This should have been configured when creating the Amazon Security Lake custom source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#account_id Destination#account_id}
  */
  readonly accountId: string;
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#add_id_to_stage_path Destination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_arn Destination#assume_role_arn}
  */
  readonly assumeRoleArn: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_external_id Destination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#automatic_schema Destination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_authentication_method Destination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret Destination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#base_file_name Destination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#bucket Destination#bucket}
  */
  readonly bucket: string;
  /**
  * Name of the custom source configured in Amazon Security Lake
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_source Destination#custom_source}
  */
  readonly customSource: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#deadletter_enabled Destination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#deadletter_path Destination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#duration_seconds Destination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#empty_dir_cleanup_sec Destination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Use Assume Role credentials to access S3. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_assume_role Destination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_page_checksum Destination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_statistics Destination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_write_page_index Destination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * Amazon Security Lake service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Amazon Security Lake-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#header_line Destination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#key_value_metadata Destination#key_value_metadata}
  */
  readonly keyValueMetadata?: DestinationOutputSecurityLakeKeyValueMetadata[] | cdktf.IResolvable;
  /**
  * ID or ARN of the KMS customer-managed key to use for encryption
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#kms_key_id Destination#kms_key_id}
  */
  readonly kmsKeyId?: string;
  /**
  * Maximum number of files that can be waiting for upload before backpressure is applied. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_closing_files_to_backpressure Destination#max_closing_files_to_backpressure}
  */
  readonly maxClosingFilesToBackpressure?: number;
  /**
  * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_concurrent_file_parts Destination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_file_idle_time_sec Destination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_file_open_time_sec Destination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_file_size_mb Destination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_open_files Destination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_retry_num Destination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#object_acl Destination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_disk_full_backpressure Destination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_data_page_version Destination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_page_size Destination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_row_group_length Destination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * To add a new schema, navigate to Processing > Knowledge > Parquet Schemas
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_schema Destination#parquet_schema}
  */
  readonly parquetSchema?: string;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#parquet_version Destination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the Amazon Security Lake is located.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#region Destination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#remove_empty_dirs Destination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["AES256", "aws:kms"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#server_side_encryption Destination#server_side_encryption}
  */
  readonly serverSideEncryption?: string;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#should_log_invalid_rows Destination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing Amazon Security Lake requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#signature_version Destination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#stage_path Destination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY", "STANDARD_IA", "ONEZONE_IA", "INTELLIGENT_TIERING", "GLACIER", "GLACIER_IR", "DEEP_ARCHIVE"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#storage_class Destination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "security_lake"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Disable if you can access files within the bucket but not the bucket itself. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#verify_permissions Destination#verify_permissions}
  */
  readonly verifyPermissions?: boolean | cdktf.IResolvable;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#write_high_water_mark Destination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function destinationOutputSecurityLakeToTerraform(struct?: DestinationOutputSecurityLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account_id: cdktf.stringToTerraform(struct!.accountId),
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    custom_source: cdktf.stringToTerraform(struct!.customSource),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(destinationOutputSecurityLakeKeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    kms_key_id: cdktf.stringToTerraform(struct!.kmsKeyId),
    max_closing_files_to_backpressure: cdktf.numberToTerraform(struct!.maxClosingFilesToBackpressure),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_schema: cdktf.stringToTerraform(struct!.parquetSchema),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    server_side_encryption: cdktf.stringToTerraform(struct!.serverSideEncryption),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    verify_permissions: cdktf.booleanToTerraform(struct!.verifyPermissions),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function destinationOutputSecurityLakeToHclTerraform(struct?: DestinationOutputSecurityLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account_id: {
      value: cdktf.stringToHclTerraform(struct!.accountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_source: {
      value: cdktf.stringToHclTerraform(struct!.customSource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(destinationOutputSecurityLakeKeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSecurityLakeKeyValueMetadataList",
    },
    kms_key_id: {
      value: cdktf.stringToHclTerraform(struct!.kmsKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_closing_files_to_backpressure: {
      value: cdktf.numberToHclTerraform(struct!.maxClosingFilesToBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_schema: {
      value: cdktf.stringToHclTerraform(struct!.parquetSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_side_encryption: {
      value: cdktf.stringToHclTerraform(struct!.serverSideEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.verifyPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSecurityLakeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSecurityLake | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.accountId = this._accountId;
    }
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._customSource !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSource = this._customSource;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._kmsKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.kmsKeyId = this._kmsKeyId;
    }
    if (this._maxClosingFilesToBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxClosingFilesToBackpressure = this._maxClosingFilesToBackpressure;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetSchema = this._parquetSchema;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._serverSideEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSideEncryption = this._serverSideEncryption;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyPermissions = this._verifyPermissions;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSecurityLake | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accountId = undefined;
      this._addIdToStagePath = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._automaticSchema = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._baseFileName = undefined;
      this._bucket = undefined;
      this._customSource = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enableAssumeRole = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._kmsKeyId = undefined;
      this._maxClosingFilesToBackpressure = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetSchema = undefined;
      this._parquetVersion = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._serverSideEncryption = undefined;
      this._shouldLogInvalidRows = undefined;
      this._signatureVersion = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._verifyPermissions = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accountId = value.accountId;
      this._addIdToStagePath = value.addIdToStagePath;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._automaticSchema = value.automaticSchema;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._baseFileName = value.baseFileName;
      this._bucket = value.bucket;
      this._customSource = value.customSource;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._kmsKeyId = value.kmsKeyId;
      this._maxClosingFilesToBackpressure = value.maxClosingFilesToBackpressure;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetSchema = value.parquetSchema;
      this._parquetVersion = value.parquetVersion;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._serverSideEncryption = value.serverSideEncryption;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._signatureVersion = value.signatureVersion;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._verifyPermissions = value.verifyPermissions;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // account_id - computed: false, optional: false, required: true
  private _accountId?: string; 
  public get accountId() {
    return this.getStringAttribute('account_id');
  }
  public set accountId(value: string) {
    this._accountId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accountIdInput() {
    return this._accountId;
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // assume_role_arn - computed: false, optional: false, required: true
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // custom_source - computed: false, optional: false, required: true
  private _customSource?: string; 
  public get customSource() {
    return this.getStringAttribute('custom_source');
  }
  public set customSource(value: string) {
    this._customSource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get customSourceInput() {
    return this._customSource;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new DestinationOutputSecurityLakeKeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: DestinationOutputSecurityLakeKeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // kms_key_id - computed: false, optional: true, required: false
  private _kmsKeyId?: string; 
  public get kmsKeyId() {
    return this.getStringAttribute('kms_key_id');
  }
  public set kmsKeyId(value: string) {
    this._kmsKeyId = value;
  }
  public resetKmsKeyId() {
    this._kmsKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kmsKeyIdInput() {
    return this._kmsKeyId;
  }

  // max_closing_files_to_backpressure - computed: true, optional: true, required: false
  private _maxClosingFilesToBackpressure?: number; 
  public get maxClosingFilesToBackpressure() {
    return this.getNumberAttribute('max_closing_files_to_backpressure');
  }
  public set maxClosingFilesToBackpressure(value: number) {
    this._maxClosingFilesToBackpressure = value;
  }
  public resetMaxClosingFilesToBackpressure() {
    this._maxClosingFilesToBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxClosingFilesToBackpressureInput() {
    return this._maxClosingFilesToBackpressure;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_schema - computed: false, optional: true, required: false
  private _parquetSchema?: string; 
  public get parquetSchema() {
    return this.getStringAttribute('parquet_schema');
  }
  public set parquetSchema(value: string) {
    this._parquetSchema = value;
  }
  public resetParquetSchema() {
    this._parquetSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetSchemaInput() {
    return this._parquetSchema;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // server_side_encryption - computed: false, optional: true, required: false
  private _serverSideEncryption?: string; 
  public get serverSideEncryption() {
    return this.getStringAttribute('server_side_encryption');
  }
  public set serverSideEncryption(value: string) {
    this._serverSideEncryption = value;
  }
  public resetServerSideEncryption() {
    this._serverSideEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSideEncryptionInput() {
    return this._serverSideEncryption;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_permissions - computed: true, optional: true, required: false
  private _verifyPermissions?: boolean | cdktf.IResolvable; 
  public get verifyPermissions() {
    return this.getBooleanAttribute('verify_permissions');
  }
  public set verifyPermissions(value: boolean | cdktf.IResolvable) {
    this._verifyPermissions = value;
  }
  public resetVerifyPermissions() {
    this._verifyPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyPermissionsInput() {
    return this._verifyPermissions;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface DestinationOutputSentinelExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputSentinelExtraHttpHeadersToTerraform(struct?: DestinationOutputSentinelExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputSentinelExtraHttpHeadersToHclTerraform(struct?: DestinationOutputSentinelExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSentinelExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSentinelExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSentinelExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputSentinelExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSentinelExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSentinelExtraHttpHeadersOutputReference {
    return new DestinationOutputSentinelExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSentinelPqControls {
}

export function destinationOutputSentinelPqControlsToTerraform(struct?: DestinationOutputSentinelPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputSentinelPqControlsToHclTerraform(struct?: DestinationOutputSentinelPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputSentinelPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSentinelPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSentinelPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputSentinelResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputSentinelResponseRetrySettingsToTerraform(struct?: DestinationOutputSentinelResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputSentinelResponseRetrySettingsToHclTerraform(struct?: DestinationOutputSentinelResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSentinelResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSentinelResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSentinelResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputSentinelResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSentinelResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSentinelResponseRetrySettingsOutputReference {
    return new DestinationOutputSentinelResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSentinelTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputSentinelTimeoutRetrySettingsToTerraform(struct?: DestinationOutputSentinelTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputSentinelTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputSentinelTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSentinelTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSentinelTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSentinelTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputSentinel {
  /**
  * HTTP content-type header value. Default: "application/json"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#advanced_content_type Destination#advanced_content_type}
  */
  readonly advancedContentType?: string;
  /**
  * must be "oauth"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * JavaScript expression to compute the Client ID for the Azure application. Can be a constant.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#client_id Destination#client_id}
  */
  readonly clientId: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry. Default: "application/x-ndjson"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_content_type Destination#custom_content_type}
  */
  readonly customContentType?: string;
  /**
  * Whether to drop events when the source expression evaluates to null. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_drop_when_null Destination#custom_drop_when_null}
  */
  readonly customDropWhenNull?: boolean | cdktf.IResolvable;
  /**
  * Delimiter string to insert between individual events. Defaults to newline character. Default: "\n"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_event_delimiter Destination#custom_event_delimiter}
  */
  readonly customEventDelimiter?: string;
  /**
  * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object. Default: "`${events}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_payload_expression Destination#custom_payload_expression}
  */
  readonly customPayloadExpression?: string;
  /**
  * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON. Default: "__httpOut"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_source_expression Destination#custom_source_expression}
  */
  readonly customSourceExpression?: string;
  /**
  * Data collection endpoint (DCE) URL. In the format: `https://<Endpoint-Name>-<Identifier>.<Region>.ingest.monitor.azure.com`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dce_endpoint Destination#dce_endpoint}
  */
  readonly dceEndpoint?: string;
  /**
  * Immutable ID for the Data Collection Rule (DCR)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dcr_id Destination#dcr_id}
  */
  readonly dcrId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Enter the data collection endpoint URL or the individual ID. Default: "url"; must be one of ["url", "ID"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#endpoint_url_configuration Destination#endpoint_url_configuration}
  */
  readonly endpointUrlConfiguration?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputSentinelExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * must be one of ["ndjson", "json_array", "custom", "advanced"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format_event_code Destination#format_event_code}
  */
  readonly formatEventCode?: string;
  /**
  * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format_payload_code Destination#format_payload_code}
  */
  readonly formatPayloadCode?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#keep_alive Destination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#login_url Destination#login_url}
  */
  readonly loginUrl: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size (KB) of the request body (defaults to the API's maximum limit of 1000 KB). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputSentinelPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputSentinelResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Scope to pass in the OAuth request. Default: "https://monitor.azure.com/.default"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#scope Destination#scope}
  */
  readonly scope?: string;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#secret Destination#secret}
  */
  readonly secret: string;
  /**
  * The name of the stream (Sentinel table) in which to store the events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#stream_name Destination#stream_name}
  */
  readonly streamName?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputSentinelTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "sentinel"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * URL to send events to. Can be overwritten by an event's __url field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputSentinelToTerraform(struct?: DestinationOutputSentinel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_content_type: cdktf.stringToTerraform(struct!.advancedContentType),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_content_type: cdktf.stringToTerraform(struct!.customContentType),
    custom_drop_when_null: cdktf.booleanToTerraform(struct!.customDropWhenNull),
    custom_event_delimiter: cdktf.stringToTerraform(struct!.customEventDelimiter),
    custom_payload_expression: cdktf.stringToTerraform(struct!.customPayloadExpression),
    custom_source_expression: cdktf.stringToTerraform(struct!.customSourceExpression),
    dce_endpoint: cdktf.stringToTerraform(struct!.dceEndpoint),
    dcr_id: cdktf.stringToTerraform(struct!.dcrId),
    description: cdktf.stringToTerraform(struct!.description),
    endpoint_url_configuration: cdktf.stringToTerraform(struct!.endpointUrlConfiguration),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputSentinelExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    format_event_code: cdktf.stringToTerraform(struct!.formatEventCode),
    format_payload_code: cdktf.stringToTerraform(struct!.formatPayloadCode),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputSentinelPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputSentinelResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    scope: cdktf.stringToTerraform(struct!.scope),
    secret: cdktf.stringToTerraform(struct!.secret),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputSentinelTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputSentinelToHclTerraform(struct?: DestinationOutputSentinel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_content_type: {
      value: cdktf.stringToHclTerraform(struct!.advancedContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_content_type: {
      value: cdktf.stringToHclTerraform(struct!.customContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_drop_when_null: {
      value: cdktf.booleanToHclTerraform(struct!.customDropWhenNull),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    custom_event_delimiter: {
      value: cdktf.stringToHclTerraform(struct!.customEventDelimiter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_payload_expression: {
      value: cdktf.stringToHclTerraform(struct!.customPayloadExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_source_expression: {
      value: cdktf.stringToHclTerraform(struct!.customSourceExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dce_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.dceEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dcr_id: {
      value: cdktf.stringToHclTerraform(struct!.dcrId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_url_configuration: {
      value: cdktf.stringToHclTerraform(struct!.endpointUrlConfiguration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputSentinelExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSentinelExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format_event_code: {
      value: cdktf.stringToHclTerraform(struct!.formatEventCode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format_payload_code: {
      value: cdktf.stringToHclTerraform(struct!.formatPayloadCode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputSentinelPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSentinelPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputSentinelResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSentinelResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputSentinelTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSentinelTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSentinelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSentinel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedContentType = this._advancedContentType;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.customContentType = this._customContentType;
    }
    if (this._customDropWhenNull !== undefined) {
      hasAnyValues = true;
      internalValueResult.customDropWhenNull = this._customDropWhenNull;
    }
    if (this._customEventDelimiter !== undefined) {
      hasAnyValues = true;
      internalValueResult.customEventDelimiter = this._customEventDelimiter;
    }
    if (this._customPayloadExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.customPayloadExpression = this._customPayloadExpression;
    }
    if (this._customSourceExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSourceExpression = this._customSourceExpression;
    }
    if (this._dceEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.dceEndpoint = this._dceEndpoint;
    }
    if (this._dcrId !== undefined) {
      hasAnyValues = true;
      internalValueResult.dcrId = this._dcrId;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._endpointUrlConfiguration !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointUrlConfiguration = this._endpointUrlConfiguration;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._formatEventCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.formatEventCode = this._formatEventCode;
    }
    if (this._formatPayloadCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.formatPayloadCode = this._formatPayloadCode;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSentinel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedContentType = undefined;
      this._authType = undefined;
      this._clientId = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customContentType = undefined;
      this._customDropWhenNull = undefined;
      this._customEventDelimiter = undefined;
      this._customPayloadExpression = undefined;
      this._customSourceExpression = undefined;
      this._dceEndpoint = undefined;
      this._dcrId = undefined;
      this._description = undefined;
      this._endpointUrlConfiguration = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._formatEventCode = undefined;
      this._formatPayloadCode = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._loginUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._scope = undefined;
      this._secret = undefined;
      this._streamName = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedContentType = value.advancedContentType;
      this._authType = value.authType;
      this._clientId = value.clientId;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customContentType = value.customContentType;
      this._customDropWhenNull = value.customDropWhenNull;
      this._customEventDelimiter = value.customEventDelimiter;
      this._customPayloadExpression = value.customPayloadExpression;
      this._customSourceExpression = value.customSourceExpression;
      this._dceEndpoint = value.dceEndpoint;
      this._dcrId = value.dcrId;
      this._description = value.description;
      this._endpointUrlConfiguration = value.endpointUrlConfiguration;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._formatEventCode = value.formatEventCode;
      this._formatPayloadCode = value.formatPayloadCode;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._loginUrl = value.loginUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._scope = value.scope;
      this._secret = value.secret;
      this._streamName = value.streamName;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // advanced_content_type - computed: true, optional: true, required: false
  private _advancedContentType?: string; 
  public get advancedContentType() {
    return this.getStringAttribute('advanced_content_type');
  }
  public set advancedContentType(value: string) {
    this._advancedContentType = value;
  }
  public resetAdvancedContentType() {
    this._advancedContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedContentTypeInput() {
    return this._advancedContentType;
  }

  // auth_type - computed: false, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_content_type - computed: true, optional: true, required: false
  private _customContentType?: string; 
  public get customContentType() {
    return this.getStringAttribute('custom_content_type');
  }
  public set customContentType(value: string) {
    this._customContentType = value;
  }
  public resetCustomContentType() {
    this._customContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customContentTypeInput() {
    return this._customContentType;
  }

  // custom_drop_when_null - computed: true, optional: true, required: false
  private _customDropWhenNull?: boolean | cdktf.IResolvable; 
  public get customDropWhenNull() {
    return this.getBooleanAttribute('custom_drop_when_null');
  }
  public set customDropWhenNull(value: boolean | cdktf.IResolvable) {
    this._customDropWhenNull = value;
  }
  public resetCustomDropWhenNull() {
    this._customDropWhenNull = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customDropWhenNullInput() {
    return this._customDropWhenNull;
  }

  // custom_event_delimiter - computed: true, optional: true, required: false
  private _customEventDelimiter?: string; 
  public get customEventDelimiter() {
    return this.getStringAttribute('custom_event_delimiter');
  }
  public set customEventDelimiter(value: string) {
    this._customEventDelimiter = value;
  }
  public resetCustomEventDelimiter() {
    this._customEventDelimiter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customEventDelimiterInput() {
    return this._customEventDelimiter;
  }

  // custom_payload_expression - computed: true, optional: true, required: false
  private _customPayloadExpression?: string; 
  public get customPayloadExpression() {
    return this.getStringAttribute('custom_payload_expression');
  }
  public set customPayloadExpression(value: string) {
    this._customPayloadExpression = value;
  }
  public resetCustomPayloadExpression() {
    this._customPayloadExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customPayloadExpressionInput() {
    return this._customPayloadExpression;
  }

  // custom_source_expression - computed: true, optional: true, required: false
  private _customSourceExpression?: string; 
  public get customSourceExpression() {
    return this.getStringAttribute('custom_source_expression');
  }
  public set customSourceExpression(value: string) {
    this._customSourceExpression = value;
  }
  public resetCustomSourceExpression() {
    this._customSourceExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customSourceExpressionInput() {
    return this._customSourceExpression;
  }

  // dce_endpoint - computed: false, optional: true, required: false
  private _dceEndpoint?: string; 
  public get dceEndpoint() {
    return this.getStringAttribute('dce_endpoint');
  }
  public set dceEndpoint(value: string) {
    this._dceEndpoint = value;
  }
  public resetDceEndpoint() {
    this._dceEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dceEndpointInput() {
    return this._dceEndpoint;
  }

  // dcr_id - computed: false, optional: true, required: false
  private _dcrId?: string; 
  public get dcrId() {
    return this.getStringAttribute('dcr_id');
  }
  public set dcrId(value: string) {
    this._dcrId = value;
  }
  public resetDcrId() {
    this._dcrId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dcrIdInput() {
    return this._dcrId;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // endpoint_url_configuration - computed: true, optional: true, required: false
  private _endpointUrlConfiguration?: string; 
  public get endpointUrlConfiguration() {
    return this.getStringAttribute('endpoint_url_configuration');
  }
  public set endpointUrlConfiguration(value: string) {
    this._endpointUrlConfiguration = value;
  }
  public resetEndpointUrlConfiguration() {
    this._endpointUrlConfiguration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointUrlConfigurationInput() {
    return this._endpointUrlConfiguration;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputSentinelExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputSentinelExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // format_event_code - computed: false, optional: true, required: false
  private _formatEventCode?: string; 
  public get formatEventCode() {
    return this.getStringAttribute('format_event_code');
  }
  public set formatEventCode(value: string) {
    this._formatEventCode = value;
  }
  public resetFormatEventCode() {
    this._formatEventCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatEventCodeInput() {
    return this._formatEventCode;
  }

  // format_payload_code - computed: false, optional: true, required: false
  private _formatPayloadCode?: string; 
  public get formatPayloadCode() {
    return this.getStringAttribute('format_payload_code');
  }
  public set formatPayloadCode(value: string) {
    this._formatPayloadCode = value;
  }
  public resetFormatPayloadCode() {
    this._formatPayloadCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatPayloadCodeInput() {
    return this._formatPayloadCode;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // login_url - computed: false, optional: false, required: true
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputSentinelPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputSentinelPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputSentinelResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputSentinelResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // scope - computed: true, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // secret - computed: false, optional: false, required: true
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // stream_name - computed: false, optional: true, required: false
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  public resetStreamName() {
    this._streamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputSentinelTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputSentinelTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputServiceNowExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputServiceNowExtraHttpHeadersToTerraform(struct?: DestinationOutputServiceNowExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputServiceNowExtraHttpHeadersToHclTerraform(struct?: DestinationOutputServiceNowExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputServiceNowExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputServiceNowExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputServiceNowExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputServiceNowExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputServiceNowExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputServiceNowExtraHttpHeadersOutputReference {
    return new DestinationOutputServiceNowExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputServiceNowMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#key Destination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputServiceNowMetadataToTerraform(struct?: DestinationOutputServiceNowMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputServiceNowMetadataToHclTerraform(struct?: DestinationOutputServiceNowMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputServiceNowMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputServiceNowMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputServiceNowMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputServiceNowMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputServiceNowMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputServiceNowMetadataOutputReference {
    return new DestinationOutputServiceNowMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputServiceNowPqControls {
}

export function destinationOutputServiceNowPqControlsToTerraform(struct?: DestinationOutputServiceNowPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputServiceNowPqControlsToHclTerraform(struct?: DestinationOutputServiceNowPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputServiceNowPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputServiceNowPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputServiceNowPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputServiceNowResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputServiceNowResponseRetrySettingsToTerraform(struct?: DestinationOutputServiceNowResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputServiceNowResponseRetrySettingsToHclTerraform(struct?: DestinationOutputServiceNowResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputServiceNowResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputServiceNowResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputServiceNowResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputServiceNowResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputServiceNowResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputServiceNowResponseRetrySettingsOutputReference {
    return new DestinationOutputServiceNowResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputServiceNowTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputServiceNowTimeoutRetrySettingsToTerraform(struct?: DestinationOutputServiceNowTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputServiceNowTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputServiceNowTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputServiceNowTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputServiceNowTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputServiceNowTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputServiceNowTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
}

export function destinationOutputServiceNowTlsToTerraform(struct?: DestinationOutputServiceNowTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
  }
}


export function destinationOutputServiceNowTlsToHclTerraform(struct?: DestinationOutputServiceNowTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputServiceNowTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputServiceNowTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputServiceNowTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }
}
export interface DestinationOutputServiceNow {
  /**
  * Default: "lightstep-access-token"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_token_name Destination#auth_token_name}
  */
  readonly authTokenName?: string;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "deflate", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The endpoint where ServiceNow events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Default: "ingest.lightstep.com:443"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputServiceNowExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_compress Destination#http_compress}
  */
  readonly httpCompress?: string;
  /**
  * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_logs_endpoint_override Destination#http_logs_endpoint_override}
  */
  readonly httpLogsEndpointOverride?: string;
  /**
  * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_metrics_endpoint_override Destination#http_metrics_endpoint_override}
  */
  readonly httpMetricsEndpointOverride?: string;
  /**
  * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_traces_endpoint_override Destination#http_traces_endpoint_override}
  */
  readonly httpTracesEndpointOverride?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#keep_alive Destination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * How often the sender should ping the peer to keep the connection open. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#keep_alive_time Destination#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 2048
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#metadata Destination#metadata}
  */
  readonly metadata?: DestinationOutputServiceNowMetadata[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * The version of OTLP Protobuf definitions to use when structuring data to send. Default: "1.3.1"; must be "1.3.1"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#otlp_version Destination#otlp_version}
  */
  readonly otlpVersion?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputServiceNowPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a transport option for OpenTelemetry. Default: "grpc"; must be one of ["grpc", "http"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#protocol Destination#protocol}
  */
  readonly protocol?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputServiceNowResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputServiceNowTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputServiceNowTls;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token_secret Destination#token_secret}
  */
  readonly tokenSecret: string;
  /**
  * must be "service_now"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputServiceNowToTerraform(struct?: DestinationOutputServiceNow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token_name: cdktf.stringToTerraform(struct!.authTokenName),
    compress: cdktf.stringToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputServiceNowExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    http_compress: cdktf.stringToTerraform(struct!.httpCompress),
    http_logs_endpoint_override: cdktf.stringToTerraform(struct!.httpLogsEndpointOverride),
    http_metrics_endpoint_override: cdktf.stringToTerraform(struct!.httpMetricsEndpointOverride),
    http_traces_endpoint_override: cdktf.stringToTerraform(struct!.httpTracesEndpointOverride),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    metadata: cdktf.listMapper(destinationOutputServiceNowMetadataToTerraform, false)(struct!.metadata),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    otlp_version: cdktf.stringToTerraform(struct!.otlpVersion),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputServiceNowPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputServiceNowResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputServiceNowTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    tls: destinationOutputServiceNowTlsToTerraform(struct!.tls),
    token_secret: cdktf.stringToTerraform(struct!.tokenSecret),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputServiceNowToHclTerraform(struct?: DestinationOutputServiceNow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token_name: {
      value: cdktf.stringToHclTerraform(struct!.authTokenName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputServiceNowExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputServiceNowExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_compress: {
      value: cdktf.stringToHclTerraform(struct!.httpCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_logs_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpLogsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_metrics_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpMetricsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_traces_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpTracesEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(destinationOutputServiceNowMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputServiceNowMetadataList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    otlp_version: {
      value: cdktf.stringToHclTerraform(struct!.otlpVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputServiceNowPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputServiceNowPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputServiceNowResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputServiceNowResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputServiceNowTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputServiceNowTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: destinationOutputServiceNowTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputServiceNowTls",
    },
    token_secret: {
      value: cdktf.stringToHclTerraform(struct!.tokenSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputServiceNowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputServiceNow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authTokenName !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokenName = this._authTokenName;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._httpCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpCompress = this._httpCompress;
    }
    if (this._httpLogsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpLogsEndpointOverride = this._httpLogsEndpointOverride;
    }
    if (this._httpMetricsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpMetricsEndpointOverride = this._httpMetricsEndpointOverride;
    }
    if (this._httpTracesEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpTracesEndpointOverride = this._httpTracesEndpointOverride;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._otlpVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.otlpVersion = this._otlpVersion;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._tokenSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSecret = this._tokenSecret;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputServiceNow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authTokenName = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._httpCompress = undefined;
      this._httpLogsEndpointOverride = undefined;
      this._httpMetricsEndpointOverride = undefined;
      this._httpTracesEndpointOverride = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._keepAliveTime = undefined;
      this._maxPayloadSizeKb = undefined;
      this._metadata.internalValue = undefined;
      this._onBackpressure = undefined;
      this._otlpVersion = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tls.internalValue = undefined;
      this._tokenSecret = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authTokenName = value.authTokenName;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._httpCompress = value.httpCompress;
      this._httpLogsEndpointOverride = value.httpLogsEndpointOverride;
      this._httpMetricsEndpointOverride = value.httpMetricsEndpointOverride;
      this._httpTracesEndpointOverride = value.httpTracesEndpointOverride;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._keepAliveTime = value.keepAliveTime;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._metadata.internalValue = value.metadata;
      this._onBackpressure = value.onBackpressure;
      this._otlpVersion = value.otlpVersion;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tls.internalValue = value.tls;
      this._tokenSecret = value.tokenSecret;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_token_name - computed: true, optional: true, required: false
  private _authTokenName?: string; 
  public get authTokenName() {
    return this.getStringAttribute('auth_token_name');
  }
  public set authTokenName(value: string) {
    this._authTokenName = value;
  }
  public resetAuthTokenName() {
    this._authTokenName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenNameInput() {
    return this._authTokenName;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputServiceNowExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputServiceNowExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // http_compress - computed: true, optional: true, required: false
  private _httpCompress?: string; 
  public get httpCompress() {
    return this.getStringAttribute('http_compress');
  }
  public set httpCompress(value: string) {
    this._httpCompress = value;
  }
  public resetHttpCompress() {
    this._httpCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpCompressInput() {
    return this._httpCompress;
  }

  // http_logs_endpoint_override - computed: false, optional: true, required: false
  private _httpLogsEndpointOverride?: string; 
  public get httpLogsEndpointOverride() {
    return this.getStringAttribute('http_logs_endpoint_override');
  }
  public set httpLogsEndpointOverride(value: string) {
    this._httpLogsEndpointOverride = value;
  }
  public resetHttpLogsEndpointOverride() {
    this._httpLogsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpLogsEndpointOverrideInput() {
    return this._httpLogsEndpointOverride;
  }

  // http_metrics_endpoint_override - computed: false, optional: true, required: false
  private _httpMetricsEndpointOverride?: string; 
  public get httpMetricsEndpointOverride() {
    return this.getStringAttribute('http_metrics_endpoint_override');
  }
  public set httpMetricsEndpointOverride(value: string) {
    this._httpMetricsEndpointOverride = value;
  }
  public resetHttpMetricsEndpointOverride() {
    this._httpMetricsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpMetricsEndpointOverrideInput() {
    return this._httpMetricsEndpointOverride;
  }

  // http_traces_endpoint_override - computed: false, optional: true, required: false
  private _httpTracesEndpointOverride?: string; 
  public get httpTracesEndpointOverride() {
    return this.getStringAttribute('http_traces_endpoint_override');
  }
  public set httpTracesEndpointOverride(value: string) {
    this._httpTracesEndpointOverride = value;
  }
  public resetHttpTracesEndpointOverride() {
    this._httpTracesEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpTracesEndpointOverrideInput() {
    return this._httpTracesEndpointOverride;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DestinationOutputServiceNowMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DestinationOutputServiceNowMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // otlp_version - computed: true, optional: true, required: false
  private _otlpVersion?: string; 
  public get otlpVersion() {
    return this.getStringAttribute('otlp_version');
  }
  public set otlpVersion(value: string) {
    this._otlpVersion = value;
  }
  public resetOtlpVersion() {
    this._otlpVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get otlpVersionInput() {
    return this._otlpVersion;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputServiceNowPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputServiceNowPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputServiceNowResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputServiceNowResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputServiceNowTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputServiceNowTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputServiceNowTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputServiceNowTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token_secret - computed: false, optional: false, required: true
  private _tokenSecret?: string; 
  public get tokenSecret() {
    return this.getStringAttribute('token_secret');
  }
  public set tokenSecret(value: string) {
    this._tokenSecret = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSecretInput() {
    return this._tokenSecret;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputSignalfxExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputSignalfxExtraHttpHeadersToTerraform(struct?: DestinationOutputSignalfxExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputSignalfxExtraHttpHeadersToHclTerraform(struct?: DestinationOutputSignalfxExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSignalfxExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSignalfxExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSignalfxExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputSignalfxExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSignalfxExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSignalfxExtraHttpHeadersOutputReference {
    return new DestinationOutputSignalfxExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSignalfxPqControls {
}

export function destinationOutputSignalfxPqControlsToTerraform(struct?: DestinationOutputSignalfxPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputSignalfxPqControlsToHclTerraform(struct?: DestinationOutputSignalfxPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputSignalfxPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSignalfxPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSignalfxPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputSignalfxResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputSignalfxResponseRetrySettingsToTerraform(struct?: DestinationOutputSignalfxResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputSignalfxResponseRetrySettingsToHclTerraform(struct?: DestinationOutputSignalfxResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSignalfxResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSignalfxResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSignalfxResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputSignalfxResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSignalfxResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSignalfxResponseRetrySettingsOutputReference {
    return new DestinationOutputSignalfxResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSignalfxTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputSignalfxTimeoutRetrySettingsToTerraform(struct?: DestinationOutputSignalfxTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputSignalfxTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputSignalfxTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSignalfxTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSignalfxTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSignalfxTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputSignalfx {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputSignalfxExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputSignalfxPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * SignalFx realm name, e.g. "us0". For a complete list of available SignalFx realm names, please check [here](https://docs.splunk.com/observability/en/get-started/service-description.html#sd-regions). Default: "us0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#realm Destination#realm}
  */
  readonly realm?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputSignalfxResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputSignalfxTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * SignalFx API access token (see [here](https://docs.signalfx.com/en/latest/admin-guide/tokens.html#working-with-access-tokens))
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * must be "signalfx"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputSignalfxToTerraform(struct?: DestinationOutputSignalfx | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputSignalfxExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputSignalfxPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    realm: cdktf.stringToTerraform(struct!.realm),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputSignalfxResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputSignalfxTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputSignalfxToHclTerraform(struct?: DestinationOutputSignalfx | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputSignalfxExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSignalfxExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputSignalfxPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSignalfxPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    realm: {
      value: cdktf.stringToHclTerraform(struct!.realm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputSignalfxResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSignalfxResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputSignalfxTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSignalfxTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSignalfxOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSignalfx | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._realm !== undefined) {
      hasAnyValues = true;
      internalValueResult.realm = this._realm;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSignalfx | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._realm = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._realm = value.realm;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputSignalfxExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputSignalfxExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputSignalfxPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputSignalfxPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // realm - computed: true, optional: true, required: false
  private _realm?: string; 
  public get realm() {
    return this.getStringAttribute('realm');
  }
  public set realm(value: string) {
    this._realm = value;
  }
  public resetRealm() {
    this._realm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get realmInput() {
    return this._realm;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputSignalfxResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputSignalfxResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputSignalfxTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputSignalfxTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputSnmpHosts {
  /**
  * Destination host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#host Destination#host}
  */
  readonly host: string;
  /**
  * Destination port, default is 162. Default: 162
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
}

export function destinationOutputSnmpHostsToTerraform(struct?: DestinationOutputSnmpHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function destinationOutputSnmpHostsToHclTerraform(struct?: DestinationOutputSnmpHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSnmpHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSnmpHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSnmpHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}

export class DestinationOutputSnmpHostsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSnmpHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSnmpHostsOutputReference {
    return new DestinationOutputSnmpHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSnmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every trap sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * One or more SNMP destinations to forward traps to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#hosts Destination#hosts}
  */
  readonly hosts: DestinationOutputSnmpHosts[] | cdktf.IResolvable;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "snmp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
}

export function destinationOutputSnmpToTerraform(struct?: DestinationOutputSnmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    hosts: cdktf.listMapper(destinationOutputSnmpHostsToTerraform, false)(struct!.hosts),
    id: cdktf.stringToTerraform(struct!.id),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputSnmpToHclTerraform(struct?: DestinationOutputSnmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hosts: {
      value: cdktf.listMapperHcl(destinationOutputSnmpHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSnmpHostsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSnmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSnmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSnmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._hosts.internalValue = undefined;
      this._id = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._hosts.internalValue = value.hosts;
      this._id = value.id;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts = new DestinationOutputSnmpHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: DestinationOutputSnmpHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputSnsPqControls {
}

export function destinationOutputSnsPqControlsToTerraform(struct?: DestinationOutputSnsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputSnsPqControlsToHclTerraform(struct?: DestinationOutputSnsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputSnsPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSnsPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSnsPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputSns {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_arn Destination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_external_id Destination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_authentication_method Destination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret Destination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#duration_seconds Destination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access SNS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_assume_role Destination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * SNS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SNS-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of retries before the output returns an error. Note that not all errors are retryable. The retries use an exponential backoff policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_retries Destination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Messages in the same group are processed in a FIFO manner. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#message_group_id Destination#message_group_id}
  */
  readonly messageGroupId: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputSnsPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Region where the SNS is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#region Destination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing SNS requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#signature_version Destination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * The ARN of the SNS topic to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#topic_arn Destination#topic_arn}
  */
  readonly topicArn: string;
  /**
  * must be "sns"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
}

export function destinationOutputSnsToTerraform(struct?: DestinationOutputSns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    message_group_id: cdktf.stringToTerraform(struct!.messageGroupId),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputSnsPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    topic_arn: cdktf.stringToTerraform(struct!.topicArn),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputSnsToHclTerraform(struct?: DestinationOutputSns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message_group_id: {
      value: cdktf.stringToHclTerraform(struct!.messageGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputSnsPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSnsPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topic_arn: {
      value: cdktf.stringToHclTerraform(struct!.topicArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._messageGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageGroupId = this._messageGroupId;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._topicArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicArn = this._topicArn;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._maxRetries = undefined;
      this._messageGroupId = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._topicArn = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._maxRetries = value.maxRetries;
      this._messageGroupId = value.messageGroupId;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._topicArn = value.topicArn;
      this._type = value.type;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_retries - computed: false, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // message_group_id - computed: false, optional: false, required: true
  private _messageGroupId?: string; 
  public get messageGroupId() {
    return this.getStringAttribute('message_group_id');
  }
  public set messageGroupId(value: string) {
    this._messageGroupId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get messageGroupIdInput() {
    return this._messageGroupId;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputSnsPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputSnsPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // topic_arn - computed: false, optional: false, required: true
  private _topicArn?: string; 
  public get topicArn() {
    return this.getStringAttribute('topic_arn');
  }
  public set topicArn(value: string) {
    this._topicArn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicArnInput() {
    return this._topicArn;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputSplunkPqControls {
}

export function destinationOutputSplunkPqControlsToTerraform(struct?: DestinationOutputSplunkPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputSplunkPqControlsToHclTerraform(struct?: DestinationOutputSplunkPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputSplunkPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSplunkPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputSplunkTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputSplunkTlsToTerraform(struct?: DestinationOutputSplunkTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputSplunkTlsToHclTerraform(struct?: DestinationOutputSplunkTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSplunkTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputSplunk {
  /**
  * Shared secret token to use when establishing a connection to a Splunk indexer. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_token Destination#auth_token}
  */
  readonly authToken?: string;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data. Default: "disabled"; must be one of ["disabled", "auto", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_ack Destination#enable_ack}
  */
  readonly enableAck?: boolean | cdktf.IResolvable;
  /**
  * Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_multi_metrics Destination#enable_multi_metrics}
  */
  readonly enableMultiMetrics?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#host Destination#host}
  */
  readonly host: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Use to troubleshoot issues with sending data. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#log_failed_requests Destination#log_failed_requests}
  */
  readonly logFailedRequests?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_failed_health_checks Destination#max_failed_health_checks}
  */
  readonly maxFailedHealthChecks?: number;
  /**
  * The highest S2S protocol version to advertise during handshake. Default: "v3"; must be one of ["v3", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_s2_sversion Destination#max_s2_sversion}
  */
  readonly maxS2Sversion?: string;
  /**
  * How to serialize nested fields into index-time fields. Default: "none"; must be one of ["json", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#nested_fields Destination#nested_fields}
  */
  readonly nestedFields?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * The port to connect to on the provided host. Default: 9997
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputSplunkPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#throttle_rate_per_sec Destination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputSplunkTls;
  /**
  * must be "splunk"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#write_timeout Destination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function destinationOutputSplunkToTerraform(struct?: DestinationOutputSplunk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.stringToTerraform(struct!.compress),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    enable_ack: cdktf.booleanToTerraform(struct!.enableAck),
    enable_multi_metrics: cdktf.booleanToTerraform(struct!.enableMultiMetrics),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    log_failed_requests: cdktf.booleanToTerraform(struct!.logFailedRequests),
    max_failed_health_checks: cdktf.numberToTerraform(struct!.maxFailedHealthChecks),
    max_s2_sversion: cdktf.stringToTerraform(struct!.maxS2Sversion),
    nested_fields: cdktf.stringToTerraform(struct!.nestedFields),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputSplunkPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    tls: destinationOutputSplunkTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function destinationOutputSplunkToHclTerraform(struct?: DestinationOutputSplunk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_ack: {
      value: cdktf.booleanToHclTerraform(struct!.enableAck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_multi_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.enableMultiMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_failed_requests: {
      value: cdktf.booleanToHclTerraform(struct!.logFailedRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_failed_health_checks: {
      value: cdktf.numberToHclTerraform(struct!.maxFailedHealthChecks),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_s2_sversion: {
      value: cdktf.stringToHclTerraform(struct!.maxS2Sversion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nested_fields: {
      value: cdktf.stringToHclTerraform(struct!.nestedFields),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputSplunkPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSplunkPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: destinationOutputSplunkTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSplunkTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSplunk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enableAck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAck = this._enableAck;
    }
    if (this._enableMultiMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableMultiMetrics = this._enableMultiMetrics;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._logFailedRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFailedRequests = this._logFailedRequests;
    }
    if (this._maxFailedHealthChecks !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFailedHealthChecks = this._maxFailedHealthChecks;
    }
    if (this._maxS2Sversion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxS2Sversion = this._maxS2Sversion;
    }
    if (this._nestedFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.nestedFields = this._nestedFields;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._enableAck = undefined;
      this._enableMultiMetrics = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._logFailedRequests = undefined;
      this._maxFailedHealthChecks = undefined;
      this._maxS2Sversion = undefined;
      this._nestedFields = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._throttleRatePerSec = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authType = value.authType;
      this._compress = value.compress;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._enableAck = value.enableAck;
      this._enableMultiMetrics = value.enableMultiMetrics;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._logFailedRequests = value.logFailedRequests;
      this._maxFailedHealthChecks = value.maxFailedHealthChecks;
      this._maxS2Sversion = value.maxS2Sversion;
      this._nestedFields = value.nestedFields;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enable_ack - computed: true, optional: true, required: false
  private _enableAck?: boolean | cdktf.IResolvable; 
  public get enableAck() {
    return this.getBooleanAttribute('enable_ack');
  }
  public set enableAck(value: boolean | cdktf.IResolvable) {
    this._enableAck = value;
  }
  public resetEnableAck() {
    this._enableAck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAckInput() {
    return this._enableAck;
  }

  // enable_multi_metrics - computed: true, optional: true, required: false
  private _enableMultiMetrics?: boolean | cdktf.IResolvable; 
  public get enableMultiMetrics() {
    return this.getBooleanAttribute('enable_multi_metrics');
  }
  public set enableMultiMetrics(value: boolean | cdktf.IResolvable) {
    this._enableMultiMetrics = value;
  }
  public resetEnableMultiMetrics() {
    this._enableMultiMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableMultiMetricsInput() {
    return this._enableMultiMetrics;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // log_failed_requests - computed: true, optional: true, required: false
  private _logFailedRequests?: boolean | cdktf.IResolvable; 
  public get logFailedRequests() {
    return this.getBooleanAttribute('log_failed_requests');
  }
  public set logFailedRequests(value: boolean | cdktf.IResolvable) {
    this._logFailedRequests = value;
  }
  public resetLogFailedRequests() {
    this._logFailedRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFailedRequestsInput() {
    return this._logFailedRequests;
  }

  // max_failed_health_checks - computed: true, optional: true, required: false
  private _maxFailedHealthChecks?: number; 
  public get maxFailedHealthChecks() {
    return this.getNumberAttribute('max_failed_health_checks');
  }
  public set maxFailedHealthChecks(value: number) {
    this._maxFailedHealthChecks = value;
  }
  public resetMaxFailedHealthChecks() {
    this._maxFailedHealthChecks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFailedHealthChecksInput() {
    return this._maxFailedHealthChecks;
  }

  // max_s2_sversion - computed: true, optional: true, required: false
  private _maxS2Sversion?: string; 
  public get maxS2Sversion() {
    return this.getStringAttribute('max_s2_sversion');
  }
  public set maxS2Sversion(value: string) {
    this._maxS2Sversion = value;
  }
  public resetMaxS2Sversion() {
    this._maxS2Sversion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxS2SversionInput() {
    return this._maxS2Sversion;
  }

  // nested_fields - computed: true, optional: true, required: false
  private _nestedFields?: string; 
  public get nestedFields() {
    return this.getStringAttribute('nested_fields');
  }
  public set nestedFields(value: string) {
    this._nestedFields = value;
  }
  public resetNestedFields() {
    this._nestedFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nestedFieldsInput() {
    return this._nestedFields;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputSplunkPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputSplunkPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputSplunkTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputSplunkTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface DestinationOutputSplunkHecExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputSplunkHecExtraHttpHeadersToTerraform(struct?: DestinationOutputSplunkHecExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputSplunkHecExtraHttpHeadersToHclTerraform(struct?: DestinationOutputSplunkHecExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkHecExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSplunkHecExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkHecExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputSplunkHecExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSplunkHecExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSplunkHecExtraHttpHeadersOutputReference {
    return new DestinationOutputSplunkHecExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSplunkHecPqControls {
}

export function destinationOutputSplunkHecPqControlsToTerraform(struct?: DestinationOutputSplunkHecPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputSplunkHecPqControlsToHclTerraform(struct?: DestinationOutputSplunkHecPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputSplunkHecPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSplunkHecPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkHecPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputSplunkHecResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputSplunkHecResponseRetrySettingsToTerraform(struct?: DestinationOutputSplunkHecResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputSplunkHecResponseRetrySettingsToHclTerraform(struct?: DestinationOutputSplunkHecResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkHecResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSplunkHecResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkHecResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputSplunkHecResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSplunkHecResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSplunkHecResponseRetrySettingsOutputReference {
    return new DestinationOutputSplunkHecResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSplunkHecTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputSplunkHecTimeoutRetrySettingsToTerraform(struct?: DestinationOutputSplunkHecTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputSplunkHecTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputSplunkHecTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkHecTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSplunkHecTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkHecTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputSplunkHecUrls {
  /**
  * URL to a Splunk HEC endpoint to send events to, e.g., http://localhost:8088/services/collector/event. Default: "http://localhost:8088/services/collector/event"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url?: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#weight Destination#weight}
  */
  readonly weight?: number;
}

export function destinationOutputSplunkHecUrlsToTerraform(struct?: DestinationOutputSplunkHecUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function destinationOutputSplunkHecUrlsToHclTerraform(struct?: DestinationOutputSplunkHecUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkHecUrlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSplunkHecUrls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkHecUrls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._weight = value.weight;
    }
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DestinationOutputSplunkHecUrlsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSplunkHecUrls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSplunkHecUrlsOutputReference {
    return new DestinationOutputSplunkHecUrlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSplunkHec {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Output metrics in multiple-metric format, supported in Splunk 8.0 and above to allow multiple metrics in a single event. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_multi_metrics Destination#enable_multi_metrics}
  */
  readonly enableMultiMetrics?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#exclude_self Destination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputSplunkHecExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#load_balance_stats_period_sec Destination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#load_balanced Destination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * In the Splunk app, define which Splunk processing queue to send the events after HEC processing. Default: "indexQueue"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#next_queue Destination#next_queue}
  */
  readonly nextQueue?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputSplunkHecPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputSplunkHecResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * In the Splunk app, set the value of _TCP_ROUTING for events that do not have _ctrl._TCP_ROUTING set. Default: "nowhere"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tcp_routing Destination#tcp_routing}
  */
  readonly tcpRouting?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputSplunkHecTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Splunk HEC authentication token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * must be "splunk_hec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * URL to a Splunk HEC endpoint to send events to, e.g., http://localhost:8088/services/collector/event. Default: "http://localhost:8088/services/collector/event"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#urls Destination#urls}
  */
  readonly urls?: DestinationOutputSplunkHecUrls[] | cdktf.IResolvable;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputSplunkHecToTerraform(struct?: DestinationOutputSplunkHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    enable_multi_metrics: cdktf.booleanToTerraform(struct!.enableMultiMetrics),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    extra_http_headers: cdktf.listMapper(destinationOutputSplunkHecExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    next_queue: cdktf.stringToTerraform(struct!.nextQueue),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputSplunkHecPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputSplunkHecResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tcp_routing: cdktf.stringToTerraform(struct!.tcpRouting),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputSplunkHecTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    urls: cdktf.listMapper(destinationOutputSplunkHecUrlsToTerraform, false)(struct!.urls),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputSplunkHecToHclTerraform(struct?: DestinationOutputSplunkHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_multi_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.enableMultiMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputSplunkHecExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSplunkHecExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_queue: {
      value: cdktf.stringToHclTerraform(struct!.nextQueue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputSplunkHecPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSplunkHecPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputSplunkHecResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSplunkHecResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tcp_routing: {
      value: cdktf.stringToHclTerraform(struct!.tcpRouting),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputSplunkHecTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSplunkHecTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    urls: {
      value: cdktf.listMapperHcl(destinationOutputSplunkHecUrlsToHclTerraform, false)(struct!.urls),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSplunkHecUrlsList",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkHecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSplunkHec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._enableMultiMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableMultiMetrics = this._enableMultiMetrics;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._nextQueue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextQueue = this._nextQueue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tcpRouting !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpRouting = this._tcpRouting;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls?.internalValue;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkHec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._enableMultiMetrics = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._nextQueue = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tcpRouting = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._type = undefined;
      this._url = undefined;
      this._urls.internalValue = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._enableMultiMetrics = value.enableMultiMetrics;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._nextQueue = value.nextQueue;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tcpRouting = value.tcpRouting;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._type = value.type;
      this._url = value.url;
      this._urls.internalValue = value.urls;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // enable_multi_metrics - computed: true, optional: true, required: false
  private _enableMultiMetrics?: boolean | cdktf.IResolvable; 
  public get enableMultiMetrics() {
    return this.getBooleanAttribute('enable_multi_metrics');
  }
  public set enableMultiMetrics(value: boolean | cdktf.IResolvable) {
    this._enableMultiMetrics = value;
  }
  public resetEnableMultiMetrics() {
    this._enableMultiMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableMultiMetricsInput() {
    return this._enableMultiMetrics;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputSplunkHecExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputSplunkHecExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // next_queue - computed: true, optional: true, required: false
  private _nextQueue?: string; 
  public get nextQueue() {
    return this.getStringAttribute('next_queue');
  }
  public set nextQueue(value: string) {
    this._nextQueue = value;
  }
  public resetNextQueue() {
    this._nextQueue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextQueueInput() {
    return this._nextQueue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputSplunkHecPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputSplunkHecPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputSplunkHecResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputSplunkHecResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tcp_routing - computed: true, optional: true, required: false
  private _tcpRouting?: string; 
  public get tcpRouting() {
    return this.getStringAttribute('tcp_routing');
  }
  public set tcpRouting(value: string) {
    this._tcpRouting = value;
  }
  public resetTcpRouting() {
    this._tcpRouting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpRoutingInput() {
    return this._tcpRouting;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputSplunkHecTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputSplunkHecTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // urls - computed: false, optional: true, required: false
  private _urls = new DestinationOutputSplunkHecUrlsList(this, "urls", false);
  public get urls() {
    return this._urls;
  }
  public putUrls(value: DestinationOutputSplunkHecUrls[] | cdktf.IResolvable) {
    this._urls.internalValue = value;
  }
  public resetUrls() {
    this._urls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls.internalValue;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputSplunkLbHosts {
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#host Destination#host}
  */
  readonly host: string;
  /**
  * The port to connect to on the provided host. Default: 9997
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
  /**
  * Servername to use if establishing a TLS connection. If not specified, defaults to connection host (if not an IP); otherwise, uses the global TLS settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
  /**
  * Whether to inherit TLS configs from group setting or disable TLS. Default: "inherit"; must be one of ["inherit", "off"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#weight Destination#weight}
  */
  readonly weight?: number;
}

export function destinationOutputSplunkLbHostsToTerraform(struct?: DestinationOutputSplunkLbHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
    servername: cdktf.stringToTerraform(struct!.servername),
    tls: cdktf.stringToTerraform(struct!.tls),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function destinationOutputSplunkLbHostsToHclTerraform(struct?: DestinationOutputSplunkLbHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkLbHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSplunkLbHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkLbHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
      this._servername = undefined;
      this._tls = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
      this._servername = value.servername;
      this._tls = value.tls;
      this._weight = value.weight;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }

  // tls - computed: true, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DestinationOutputSplunkLbHostsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSplunkLbHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSplunkLbHostsOutputReference {
    return new DestinationOutputSplunkLbHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
}

export function destinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensToTerraform(struct?: DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
  }
}


export function destinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensToHclTerraform(struct?: DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }
}

export class DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensOutputReference {
    return new DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSplunkLbIndexerDiscoveryConfigs {
  /**
  * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_token Destination#auth_token}
  */
  readonly authToken?: string;
  /**
  * Tokens required to authenticate to cluster manager for indexer discovery
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_tokens Destination#auth_tokens}
  */
  readonly authTokens?: DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens[] | cdktf.IResolvable;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Full URI of Splunk cluster manager (scheme://host:port). Example: https://managerAddress:8089
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#master_uri Destination#master_uri}
  */
  readonly masterUri: string;
  /**
  * Time interval, in seconds, between two consecutive indexer list fetches from cluster manager. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#refresh_interval_sec Destination#refresh_interval_sec}
  */
  readonly refreshIntervalSec?: number;
  /**
  * During indexer discovery, reject cluster manager certificates that are not authorized by the system's CA. Disable to allow untrusted (for example, self-signed) certificates. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Clustering site of the indexers from where indexers need to be discovered. In case of single site cluster, it defaults to 'default' site. Default: "default"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#site Destination#site}
  */
  readonly site?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
}

export function destinationOutputSplunkLbIndexerDiscoveryConfigsToTerraform(struct?: DestinationOutputSplunkLbIndexerDiscoveryConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_tokens: cdktf.listMapper(destinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensToTerraform, false)(struct!.authTokens),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    master_uri: cdktf.stringToTerraform(struct!.masterUri),
    refresh_interval_sec: cdktf.numberToTerraform(struct!.refreshIntervalSec),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    site: cdktf.stringToTerraform(struct!.site),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
  }
}


export function destinationOutputSplunkLbIndexerDiscoveryConfigsToHclTerraform(struct?: DestinationOutputSplunkLbIndexerDiscoveryConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(destinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensToHclTerraform, false)(struct!.authTokens),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensList",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    master_uri: {
      value: cdktf.stringToHclTerraform(struct!.masterUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    refresh_interval_sec: {
      value: cdktf.numberToHclTerraform(struct!.refreshIntervalSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    site: {
      value: cdktf.stringToHclTerraform(struct!.site),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkLbIndexerDiscoveryConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSplunkLbIndexerDiscoveryConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authTokens?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens?.internalValue;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._masterUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.masterUri = this._masterUri;
    }
    if (this._refreshIntervalSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.refreshIntervalSec = this._refreshIntervalSec;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._site !== undefined) {
      hasAnyValues = true;
      internalValueResult.site = this._site;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkLbIndexerDiscoveryConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authTokens.internalValue = undefined;
      this._authType = undefined;
      this._masterUri = undefined;
      this._refreshIntervalSec = undefined;
      this._rejectUnauthorized = undefined;
      this._site = undefined;
      this._textSecret = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authTokens.internalValue = value.authTokens;
      this._authType = value.authType;
      this._masterUri = value.masterUri;
      this._refreshIntervalSec = value.refreshIntervalSec;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._site = value.site;
      this._textSecret = value.textSecret;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens = new DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensList(this, "auth_tokens", false);
  public get authTokens() {
    return this._authTokens;
  }
  public putAuthTokens(value: DestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens[] | cdktf.IResolvable) {
    this._authTokens.internalValue = value;
  }
  public resetAuthTokens() {
    this._authTokens.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens.internalValue;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // master_uri - computed: false, optional: false, required: true
  private _masterUri?: string; 
  public get masterUri() {
    return this.getStringAttribute('master_uri');
  }
  public set masterUri(value: string) {
    this._masterUri = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterUriInput() {
    return this._masterUri;
  }

  // refresh_interval_sec - computed: true, optional: true, required: false
  private _refreshIntervalSec?: number; 
  public get refreshIntervalSec() {
    return this.getNumberAttribute('refresh_interval_sec');
  }
  public set refreshIntervalSec(value: number) {
    this._refreshIntervalSec = value;
  }
  public resetRefreshIntervalSec() {
    this._refreshIntervalSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refreshIntervalSecInput() {
    return this._refreshIntervalSec;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // site - computed: true, optional: true, required: false
  private _site?: string; 
  public get site() {
    return this.getStringAttribute('site');
  }
  public set site(value: string) {
    this._site = value;
  }
  public resetSite() {
    this._site = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siteInput() {
    return this._site;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }
}
export interface DestinationOutputSplunkLbPqControls {
}

export function destinationOutputSplunkLbPqControlsToTerraform(struct?: DestinationOutputSplunkLbPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputSplunkLbPqControlsToHclTerraform(struct?: DestinationOutputSplunkLbPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputSplunkLbPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSplunkLbPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkLbPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputSplunkLbTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputSplunkLbTlsToTerraform(struct?: DestinationOutputSplunkLbTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputSplunkLbTlsToHclTerraform(struct?: DestinationOutputSplunkLbTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkLbTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSplunkLbTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkLbTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputSplunkLb {
  /**
  * Shared secret token to use when establishing a connection to a Splunk indexer. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_token Destination#auth_token}
  */
  readonly authToken?: string;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data. Default: "disabled"; must be one of ["disabled", "auto", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_ack Destination#enable_ack}
  */
  readonly enableAck?: boolean | cdktf.IResolvable;
  /**
  * Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_multi_metrics Destination#enable_multi_metrics}
  */
  readonly enableMultiMetrics?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#exclude_self Destination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Set of Splunk indexers to load-balance data to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#hosts Destination#hosts}
  */
  readonly hosts: DestinationOutputSplunkLbHosts[] | cdktf.IResolvable;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Automatically discover indexers in indexer clustering environment. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#indexer_discovery Destination#indexer_discovery}
  */
  readonly indexerDiscovery?: boolean | cdktf.IResolvable;
  /**
  * List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#indexer_discovery_configs Destination#indexer_discovery_configs}
  */
  readonly indexerDiscoveryConfigs?: DestinationOutputSplunkLbIndexerDiscoveryConfigs;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#load_balance_stats_period_sec Destination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Use to troubleshoot issues with sending data. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#log_failed_requests Destination#log_failed_requests}
  */
  readonly logFailedRequests?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_concurrent_senders Destination#max_concurrent_senders}
  */
  readonly maxConcurrentSenders?: number;
  /**
  * Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_failed_health_checks Destination#max_failed_health_checks}
  */
  readonly maxFailedHealthChecks?: number;
  /**
  * The highest S2S protocol version to advertise during handshake. Default: "v3"; must be one of ["v3", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_s2_sversion Destination#max_s2_sversion}
  */
  readonly maxS2Sversion?: string;
  /**
  * How to serialize nested fields into index-time fields. Default: "none"; must be one of ["json", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#nested_fields Destination#nested_fields}
  */
  readonly nestedFields?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputSplunkLbPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * How long (in milliseconds) each LB endpoint can report blocked before the Destination reports unhealthy, blocking the sender. (Grace period for fluctuations.) Use 0 to disable; max 1 minute. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#sender_unhealthy_time_allowance Destination#sender_unhealthy_time_allowance}
  */
  readonly senderUnhealthyTimeAllowance?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#throttle_rate_per_sec Destination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputSplunkLbTls;
  /**
  * must be "splunk_lb"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#write_timeout Destination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function destinationOutputSplunkLbToTerraform(struct?: DestinationOutputSplunkLb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.stringToTerraform(struct!.compress),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    enable_ack: cdktf.booleanToTerraform(struct!.enableAck),
    enable_multi_metrics: cdktf.booleanToTerraform(struct!.enableMultiMetrics),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    hosts: cdktf.listMapper(destinationOutputSplunkLbHostsToTerraform, false)(struct!.hosts),
    id: cdktf.stringToTerraform(struct!.id),
    indexer_discovery: cdktf.booleanToTerraform(struct!.indexerDiscovery),
    indexer_discovery_configs: destinationOutputSplunkLbIndexerDiscoveryConfigsToTerraform(struct!.indexerDiscoveryConfigs),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    log_failed_requests: cdktf.booleanToTerraform(struct!.logFailedRequests),
    max_concurrent_senders: cdktf.numberToTerraform(struct!.maxConcurrentSenders),
    max_failed_health_checks: cdktf.numberToTerraform(struct!.maxFailedHealthChecks),
    max_s2_sversion: cdktf.stringToTerraform(struct!.maxS2Sversion),
    nested_fields: cdktf.stringToTerraform(struct!.nestedFields),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputSplunkLbPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    sender_unhealthy_time_allowance: cdktf.numberToTerraform(struct!.senderUnhealthyTimeAllowance),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    tls: destinationOutputSplunkLbTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function destinationOutputSplunkLbToHclTerraform(struct?: DestinationOutputSplunkLb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_ack: {
      value: cdktf.booleanToHclTerraform(struct!.enableAck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_multi_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.enableMultiMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hosts: {
      value: cdktf.listMapperHcl(destinationOutputSplunkLbHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSplunkLbHostsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    indexer_discovery: {
      value: cdktf.booleanToHclTerraform(struct!.indexerDiscovery),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    indexer_discovery_configs: {
      value: destinationOutputSplunkLbIndexerDiscoveryConfigsToHclTerraform(struct!.indexerDiscoveryConfigs),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSplunkLbIndexerDiscoveryConfigs",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_failed_requests: {
      value: cdktf.booleanToHclTerraform(struct!.logFailedRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_concurrent_senders: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentSenders),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_failed_health_checks: {
      value: cdktf.numberToHclTerraform(struct!.maxFailedHealthChecks),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_s2_sversion: {
      value: cdktf.stringToHclTerraform(struct!.maxS2Sversion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nested_fields: {
      value: cdktf.stringToHclTerraform(struct!.nestedFields),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputSplunkLbPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSplunkLbPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sender_unhealthy_time_allowance: {
      value: cdktf.numberToHclTerraform(struct!.senderUnhealthyTimeAllowance),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: destinationOutputSplunkLbTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSplunkLbTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSplunkLbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSplunkLb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._enableAck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAck = this._enableAck;
    }
    if (this._enableMultiMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableMultiMetrics = this._enableMultiMetrics;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._indexerDiscovery !== undefined) {
      hasAnyValues = true;
      internalValueResult.indexerDiscovery = this._indexerDiscovery;
    }
    if (this._indexerDiscoveryConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.indexerDiscoveryConfigs = this._indexerDiscoveryConfigs?.internalValue;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._logFailedRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFailedRequests = this._logFailedRequests;
    }
    if (this._maxConcurrentSenders !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentSenders = this._maxConcurrentSenders;
    }
    if (this._maxFailedHealthChecks !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFailedHealthChecks = this._maxFailedHealthChecks;
    }
    if (this._maxS2Sversion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxS2Sversion = this._maxS2Sversion;
    }
    if (this._nestedFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.nestedFields = this._nestedFields;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._senderUnhealthyTimeAllowance !== undefined) {
      hasAnyValues = true;
      internalValueResult.senderUnhealthyTimeAllowance = this._senderUnhealthyTimeAllowance;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSplunkLb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._enableAck = undefined;
      this._enableMultiMetrics = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._hosts.internalValue = undefined;
      this._id = undefined;
      this._indexerDiscovery = undefined;
      this._indexerDiscoveryConfigs.internalValue = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._logFailedRequests = undefined;
      this._maxConcurrentSenders = undefined;
      this._maxFailedHealthChecks = undefined;
      this._maxS2Sversion = undefined;
      this._nestedFields = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._senderUnhealthyTimeAllowance = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._throttleRatePerSec = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authType = value.authType;
      this._compress = value.compress;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._enableAck = value.enableAck;
      this._enableMultiMetrics = value.enableMultiMetrics;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._hosts.internalValue = value.hosts;
      this._id = value.id;
      this._indexerDiscovery = value.indexerDiscovery;
      this._indexerDiscoveryConfigs.internalValue = value.indexerDiscoveryConfigs;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._logFailedRequests = value.logFailedRequests;
      this._maxConcurrentSenders = value.maxConcurrentSenders;
      this._maxFailedHealthChecks = value.maxFailedHealthChecks;
      this._maxS2Sversion = value.maxS2Sversion;
      this._nestedFields = value.nestedFields;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._senderUnhealthyTimeAllowance = value.senderUnhealthyTimeAllowance;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // enable_ack - computed: true, optional: true, required: false
  private _enableAck?: boolean | cdktf.IResolvable; 
  public get enableAck() {
    return this.getBooleanAttribute('enable_ack');
  }
  public set enableAck(value: boolean | cdktf.IResolvable) {
    this._enableAck = value;
  }
  public resetEnableAck() {
    this._enableAck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAckInput() {
    return this._enableAck;
  }

  // enable_multi_metrics - computed: true, optional: true, required: false
  private _enableMultiMetrics?: boolean | cdktf.IResolvable; 
  public get enableMultiMetrics() {
    return this.getBooleanAttribute('enable_multi_metrics');
  }
  public set enableMultiMetrics(value: boolean | cdktf.IResolvable) {
    this._enableMultiMetrics = value;
  }
  public resetEnableMultiMetrics() {
    this._enableMultiMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableMultiMetricsInput() {
    return this._enableMultiMetrics;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts = new DestinationOutputSplunkLbHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: DestinationOutputSplunkLbHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // indexer_discovery - computed: true, optional: true, required: false
  private _indexerDiscovery?: boolean | cdktf.IResolvable; 
  public get indexerDiscovery() {
    return this.getBooleanAttribute('indexer_discovery');
  }
  public set indexerDiscovery(value: boolean | cdktf.IResolvable) {
    this._indexerDiscovery = value;
  }
  public resetIndexerDiscovery() {
    this._indexerDiscovery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexerDiscoveryInput() {
    return this._indexerDiscovery;
  }

  // indexer_discovery_configs - computed: false, optional: true, required: false
  private _indexerDiscoveryConfigs = new DestinationOutputSplunkLbIndexerDiscoveryConfigsOutputReference(this, "indexer_discovery_configs");
  public get indexerDiscoveryConfigs() {
    return this._indexerDiscoveryConfigs;
  }
  public putIndexerDiscoveryConfigs(value: DestinationOutputSplunkLbIndexerDiscoveryConfigs) {
    this._indexerDiscoveryConfigs.internalValue = value;
  }
  public resetIndexerDiscoveryConfigs() {
    this._indexerDiscoveryConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexerDiscoveryConfigsInput() {
    return this._indexerDiscoveryConfigs.internalValue;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // log_failed_requests - computed: true, optional: true, required: false
  private _logFailedRequests?: boolean | cdktf.IResolvable; 
  public get logFailedRequests() {
    return this.getBooleanAttribute('log_failed_requests');
  }
  public set logFailedRequests(value: boolean | cdktf.IResolvable) {
    this._logFailedRequests = value;
  }
  public resetLogFailedRequests() {
    this._logFailedRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFailedRequestsInput() {
    return this._logFailedRequests;
  }

  // max_concurrent_senders - computed: true, optional: true, required: false
  private _maxConcurrentSenders?: number; 
  public get maxConcurrentSenders() {
    return this.getNumberAttribute('max_concurrent_senders');
  }
  public set maxConcurrentSenders(value: number) {
    this._maxConcurrentSenders = value;
  }
  public resetMaxConcurrentSenders() {
    this._maxConcurrentSenders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentSendersInput() {
    return this._maxConcurrentSenders;
  }

  // max_failed_health_checks - computed: true, optional: true, required: false
  private _maxFailedHealthChecks?: number; 
  public get maxFailedHealthChecks() {
    return this.getNumberAttribute('max_failed_health_checks');
  }
  public set maxFailedHealthChecks(value: number) {
    this._maxFailedHealthChecks = value;
  }
  public resetMaxFailedHealthChecks() {
    this._maxFailedHealthChecks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFailedHealthChecksInput() {
    return this._maxFailedHealthChecks;
  }

  // max_s2_sversion - computed: true, optional: true, required: false
  private _maxS2Sversion?: string; 
  public get maxS2Sversion() {
    return this.getStringAttribute('max_s2_sversion');
  }
  public set maxS2Sversion(value: string) {
    this._maxS2Sversion = value;
  }
  public resetMaxS2Sversion() {
    this._maxS2Sversion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxS2SversionInput() {
    return this._maxS2Sversion;
  }

  // nested_fields - computed: true, optional: true, required: false
  private _nestedFields?: string; 
  public get nestedFields() {
    return this.getStringAttribute('nested_fields');
  }
  public set nestedFields(value: string) {
    this._nestedFields = value;
  }
  public resetNestedFields() {
    this._nestedFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nestedFieldsInput() {
    return this._nestedFields;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputSplunkLbPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputSplunkLbPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // sender_unhealthy_time_allowance - computed: true, optional: true, required: false
  private _senderUnhealthyTimeAllowance?: number; 
  public get senderUnhealthyTimeAllowance() {
    return this.getNumberAttribute('sender_unhealthy_time_allowance');
  }
  public set senderUnhealthyTimeAllowance(value: number) {
    this._senderUnhealthyTimeAllowance = value;
  }
  public resetSenderUnhealthyTimeAllowance() {
    this._senderUnhealthyTimeAllowance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get senderUnhealthyTimeAllowanceInput() {
    return this._senderUnhealthyTimeAllowance;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputSplunkLbTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputSplunkLbTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface DestinationOutputSqsPqControls {
}

export function destinationOutputSqsPqControlsToTerraform(struct?: DestinationOutputSqsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputSqsPqControlsToHclTerraform(struct?: DestinationOutputSqsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputSqsPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSqsPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSqsPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputSqs {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_arn Destination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#assume_role_external_id Destination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_account_id Destination#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_authentication_method Destination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret Destination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Create queue if it does not exist. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#create_queue Destination#create_queue}
  */
  readonly createQueue?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#duration_seconds Destination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#enable_assume_role Destination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of in-progress API requests before backpressure is applied. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_in_progress Destination#max_in_progress}
  */
  readonly maxInProgress?: number;
  /**
  * Maximum number of queued batches before blocking. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_queue_size Destination#max_queue_size}
  */
  readonly maxQueueSize?: number;
  /**
  * Maximum size (KB) of batches to send. Per the SQS spec, the max allowed value is 256 KB. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_record_size_kb Destination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * This parameter applies only to FIFO queues. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner. Use event field __messageGroupId to override this value. Default: "cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#message_group_id Destination#message_group_id}
  */
  readonly messageGroupId?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputSqsPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * The name, URL, or ARN of the SQS queue to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#queue_name Destination#queue_name}
  */
  readonly queueName: string;
  /**
  * The queue type used (or created). Defaults to Standard. Default: "standard"; must be one of ["standard", "fifo"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#queue_type Destination#queue_type}
  */
  readonly queueType?: string;
  /**
  * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#region Destination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing SQS requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#signature_version Destination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "sqs"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
}

export function destinationOutputSqsToTerraform(struct?: DestinationOutputSqs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    create_queue: cdktf.booleanToTerraform(struct!.createQueue),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_in_progress: cdktf.numberToTerraform(struct!.maxInProgress),
    max_queue_size: cdktf.numberToTerraform(struct!.maxQueueSize),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    message_group_id: cdktf.stringToTerraform(struct!.messageGroupId),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputSqsPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    queue_type: cdktf.stringToTerraform(struct!.queueType),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputSqsToHclTerraform(struct?: DestinationOutputSqs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    create_queue: {
      value: cdktf.booleanToHclTerraform(struct!.createQueue),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_in_progress: {
      value: cdktf.numberToHclTerraform(struct!.maxInProgress),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_queue_size: {
      value: cdktf.numberToHclTerraform(struct!.maxQueueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message_group_id: {
      value: cdktf.stringToHclTerraform(struct!.messageGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputSqsPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSqsPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_type: {
      value: cdktf.stringToHclTerraform(struct!.queueType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSqsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSqs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._createQueue !== undefined) {
      hasAnyValues = true;
      internalValueResult.createQueue = this._createQueue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxInProgress !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxInProgress = this._maxInProgress;
    }
    if (this._maxQueueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxQueueSize = this._maxQueueSize;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._messageGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageGroupId = this._messageGroupId;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._queueType !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueType = this._queueType;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSqs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._createQueue = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxInProgress = undefined;
      this._maxQueueSize = undefined;
      this._maxRecordSizeKb = undefined;
      this._messageGroupId = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._queueName = undefined;
      this._queueType = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._createQueue = value.createQueue;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxInProgress = value.maxInProgress;
      this._maxQueueSize = value.maxQueueSize;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._messageGroupId = value.messageGroupId;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._queueName = value.queueName;
      this._queueType = value.queueType;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // create_queue - computed: true, optional: true, required: false
  private _createQueue?: boolean | cdktf.IResolvable; 
  public get createQueue() {
    return this.getBooleanAttribute('create_queue');
  }
  public set createQueue(value: boolean | cdktf.IResolvable) {
    this._createQueue = value;
  }
  public resetCreateQueue() {
    this._createQueue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createQueueInput() {
    return this._createQueue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_in_progress - computed: true, optional: true, required: false
  private _maxInProgress?: number; 
  public get maxInProgress() {
    return this.getNumberAttribute('max_in_progress');
  }
  public set maxInProgress(value: number) {
    this._maxInProgress = value;
  }
  public resetMaxInProgress() {
    this._maxInProgress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxInProgressInput() {
    return this._maxInProgress;
  }

  // max_queue_size - computed: true, optional: true, required: false
  private _maxQueueSize?: number; 
  public get maxQueueSize() {
    return this.getNumberAttribute('max_queue_size');
  }
  public set maxQueueSize(value: number) {
    this._maxQueueSize = value;
  }
  public resetMaxQueueSize() {
    this._maxQueueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxQueueSizeInput() {
    return this._maxQueueSize;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // message_group_id - computed: true, optional: true, required: false
  private _messageGroupId?: string; 
  public get messageGroupId() {
    return this.getStringAttribute('message_group_id');
  }
  public set messageGroupId(value: string) {
    this._messageGroupId = value;
  }
  public resetMessageGroupId() {
    this._messageGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageGroupIdInput() {
    return this._messageGroupId;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputSqsPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputSqsPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // queue_type - computed: true, optional: true, required: false
  private _queueType?: string; 
  public get queueType() {
    return this.getStringAttribute('queue_type');
  }
  public set queueType(value: string) {
    this._queueType = value;
  }
  public resetQueueType() {
    this._queueType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queueTypeInput() {
    return this._queueType;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputStatsdPqControls {
}

export function destinationOutputStatsdPqControlsToTerraform(struct?: DestinationOutputStatsdPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputStatsdPqControlsToHclTerraform(struct?: DestinationOutputStatsdPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputStatsdPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputStatsdPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputStatsdPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputStatsd {
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * The hostname of the destination.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#host Destination#host}
  */
  readonly host: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system. Default: 512
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#mtu Destination#mtu}
  */
  readonly mtu?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Destination port. Default: 8125
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputStatsdPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Protocol to use when communicating with the destination. Default: "udp"; must be one of ["udp", "tcp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#protocol Destination#protocol}
  */
  readonly protocol?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#throttle_rate_per_sec Destination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * must be "statsd"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#write_timeout Destination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function destinationOutputStatsdToTerraform(struct?: DestinationOutputStatsd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    mtu: cdktf.numberToTerraform(struct!.mtu),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputStatsdPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function destinationOutputStatsdToHclTerraform(struct?: DestinationOutputStatsd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mtu: {
      value: cdktf.numberToHclTerraform(struct!.mtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputStatsdPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputStatsdPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputStatsdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputStatsd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._mtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtu = this._mtu;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputStatsd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._host = undefined;
      this._id = undefined;
      this._mtu = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRatePerSec = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._host = value.host;
      this._id = value.id;
      this._mtu = value.mtu;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // mtu - computed: true, optional: true, required: false
  private _mtu?: number; 
  public get mtu() {
    return this.getNumberAttribute('mtu');
  }
  public set mtu(value: number) {
    this._mtu = value;
  }
  public resetMtu() {
    this._mtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuInput() {
    return this._mtu;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputStatsdPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputStatsdPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface DestinationOutputStatsdExtPqControls {
}

export function destinationOutputStatsdExtPqControlsToTerraform(struct?: DestinationOutputStatsdExtPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputStatsdExtPqControlsToHclTerraform(struct?: DestinationOutputStatsdExtPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputStatsdExtPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputStatsdExtPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputStatsdExtPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputStatsdExt {
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * The hostname of the destination.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#host Destination#host}
  */
  readonly host: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system. Default: 512
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#mtu Destination#mtu}
  */
  readonly mtu?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Destination port. Default: 8125
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputStatsdExtPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Protocol to use when communicating with the destination. Default: "udp"; must be one of ["udp", "tcp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#protocol Destination#protocol}
  */
  readonly protocol?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#throttle_rate_per_sec Destination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * must be "statsd_ext"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#write_timeout Destination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function destinationOutputStatsdExtToTerraform(struct?: DestinationOutputStatsdExt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    mtu: cdktf.numberToTerraform(struct!.mtu),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputStatsdExtPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function destinationOutputStatsdExtToHclTerraform(struct?: DestinationOutputStatsdExt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mtu: {
      value: cdktf.numberToHclTerraform(struct!.mtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputStatsdExtPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputStatsdExtPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputStatsdExtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputStatsdExt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._mtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtu = this._mtu;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputStatsdExt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._host = undefined;
      this._id = undefined;
      this._mtu = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRatePerSec = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._host = value.host;
      this._id = value.id;
      this._mtu = value.mtu;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // mtu - computed: true, optional: true, required: false
  private _mtu?: number; 
  public get mtu() {
    return this.getNumberAttribute('mtu');
  }
  public set mtu(value: number) {
    this._mtu = value;
  }
  public resetMtu() {
    this._mtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuInput() {
    return this._mtu;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputStatsdExtPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputStatsdExtPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface DestinationOutputSumoLogicExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputSumoLogicExtraHttpHeadersToTerraform(struct?: DestinationOutputSumoLogicExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputSumoLogicExtraHttpHeadersToHclTerraform(struct?: DestinationOutputSumoLogicExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSumoLogicExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSumoLogicExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSumoLogicExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputSumoLogicExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSumoLogicExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSumoLogicExtraHttpHeadersOutputReference {
    return new DestinationOutputSumoLogicExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSumoLogicPqControls {
}

export function destinationOutputSumoLogicPqControlsToTerraform(struct?: DestinationOutputSumoLogicPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputSumoLogicPqControlsToHclTerraform(struct?: DestinationOutputSumoLogicPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputSumoLogicPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSumoLogicPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSumoLogicPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputSumoLogicResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputSumoLogicResponseRetrySettingsToTerraform(struct?: DestinationOutputSumoLogicResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputSumoLogicResponseRetrySettingsToHclTerraform(struct?: DestinationOutputSumoLogicResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSumoLogicResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputSumoLogicResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSumoLogicResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputSumoLogicResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputSumoLogicResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputSumoLogicResponseRetrySettingsOutputReference {
    return new DestinationOutputSumoLogicResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputSumoLogicTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputSumoLogicTimeoutRetrySettingsToTerraform(struct?: DestinationOutputSumoLogicTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputSumoLogicTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputSumoLogicTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSumoLogicTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSumoLogicTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSumoLogicTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputSumoLogic {
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Override the source category configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceCategory field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_category Destination#custom_category}
  */
  readonly customCategory?: string;
  /**
  * Override the source name configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceName field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_source Destination#custom_source}
  */
  readonly customSource?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputSumoLogicExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Preserve the raw event format instead of JSONifying it. Default: "json"; must be one of ["json", "raw"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputSumoLogicPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputSumoLogicResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputSumoLogicTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "sumo_logic"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Sumo Logic HTTP collector URL to which events should be sent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputSumoLogicToTerraform(struct?: DestinationOutputSumoLogic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_category: cdktf.stringToTerraform(struct!.customCategory),
    custom_source: cdktf.stringToTerraform(struct!.customSource),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputSumoLogicExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputSumoLogicPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputSumoLogicResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputSumoLogicTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputSumoLogicToHclTerraform(struct?: DestinationOutputSumoLogic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_category: {
      value: cdktf.stringToHclTerraform(struct!.customCategory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_source: {
      value: cdktf.stringToHclTerraform(struct!.customSource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputSumoLogicExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSumoLogicExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputSumoLogicPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSumoLogicPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputSumoLogicResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputSumoLogicResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputSumoLogicTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSumoLogicTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSumoLogicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSumoLogic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customCategory !== undefined) {
      hasAnyValues = true;
      internalValueResult.customCategory = this._customCategory;
    }
    if (this._customSource !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSource = this._customSource;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSumoLogic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customCategory = undefined;
      this._customSource = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customCategory = value.customCategory;
      this._customSource = value.customSource;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_category - computed: false, optional: true, required: false
  private _customCategory?: string; 
  public get customCategory() {
    return this.getStringAttribute('custom_category');
  }
  public set customCategory(value: string) {
    this._customCategory = value;
  }
  public resetCustomCategory() {
    this._customCategory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customCategoryInput() {
    return this._customCategory;
  }

  // custom_source - computed: false, optional: true, required: false
  private _customSource?: string; 
  public get customSource() {
    return this.getStringAttribute('custom_source');
  }
  public set customSource(value: string) {
    this._customSource = value;
  }
  public resetCustomSource() {
    this._customSource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customSourceInput() {
    return this._customSource;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputSumoLogicExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputSumoLogicExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputSumoLogicPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputSumoLogicPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputSumoLogicResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputSumoLogicResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputSumoLogicTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputSumoLogicTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputSyslogPqControls {
}

export function destinationOutputSyslogPqControlsToTerraform(struct?: DestinationOutputSyslogPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputSyslogPqControlsToHclTerraform(struct?: DestinationOutputSyslogPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputSyslogPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSyslogPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSyslogPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputSyslogTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputSyslogTlsToTerraform(struct?: DestinationOutputSyslogTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputSyslogTlsToHclTerraform(struct?: DestinationOutputSyslogTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSyslogTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSyslogTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSyslogTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputSyslog {
  /**
  * Default name for device or application that originated the message. Defaults to Cribl, but will be overwritten by value of __appname if set. Default: "Cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#app_name Destination#app_name}
  */
  readonly appName?: string;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Default value for message facility. Will be overwritten by value of __facility if set. Defaults to user. Default: 1; must be one of ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#facility Destination#facility}
  */
  readonly facility?: number;
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#host Destination#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs.  If this setting is disabled, consider enabling round-robin DNS. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#load_balanced Destination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Use to troubleshoot issues with sending data. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#log_failed_requests Destination#log_failed_requests}
  */
  readonly logFailedRequests?: boolean | cdktf.IResolvable;
  /**
  * Maximum size of syslog messages. Make sure this value is less than or equal to the MTU to avoid UDP packet fragmentation. Default: 1500
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_record_size Destination#max_record_size}
  */
  readonly maxRecordSize?: number;
  /**
  * The syslog message format depending on the receiver's support. Default: "rfc3164"; must be one of ["rfc3164", "rfc5424"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#message_format Destination#message_format}
  */
  readonly messageFormat?: string;
  /**
  * Prefix messages with the byte count of the message. If disabled, no prefix will be set, and the message will be appended with a \n.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#octet_count_framing Destination#octet_count_framing}
  */
  readonly octetCountFraming?: boolean | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * The port to connect to on the provided host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputSyslogPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * The network protocol to use for sending out syslog messages. Default: "tcp"; must be one of ["tcp", "udp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#protocol Destination#protocol}
  */
  readonly protocol?: string;
  /**
  * Default value for message severity. Will be overwritten by value of __severity if set. Defaults to notice. Default: 5; must be one of ["0", "1", "2", "3", "4", "5", "6", "7"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#severity Destination#severity}
  */
  readonly severity?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#throttle_rate_per_sec Destination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Timestamp format to use when serializing event's time field. Default: "syslog"; must be one of ["syslog", "iso8601"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timestamp_format Destination#timestamp_format}
  */
  readonly timestampFormat?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputSyslogTls;
  /**
  * must be "syslog"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every message sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#udp_dns_resolve_period_sec Destination#udp_dns_resolve_period_sec}
  */
  readonly udpDnsResolvePeriodSec?: number;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#write_timeout Destination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function destinationOutputSyslogToTerraform(struct?: DestinationOutputSyslog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_name: cdktf.stringToTerraform(struct!.appName),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    facility: cdktf.numberToTerraform(struct!.facility),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    log_failed_requests: cdktf.booleanToTerraform(struct!.logFailedRequests),
    max_record_size: cdktf.numberToTerraform(struct!.maxRecordSize),
    message_format: cdktf.stringToTerraform(struct!.messageFormat),
    octet_count_framing: cdktf.booleanToTerraform(struct!.octetCountFraming),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputSyslogPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    severity: cdktf.numberToTerraform(struct!.severity),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    timestamp_format: cdktf.stringToTerraform(struct!.timestampFormat),
    tls: destinationOutputSyslogTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    udp_dns_resolve_period_sec: cdktf.numberToTerraform(struct!.udpDnsResolvePeriodSec),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function destinationOutputSyslogToHclTerraform(struct?: DestinationOutputSyslog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_name: {
      value: cdktf.stringToHclTerraform(struct!.appName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    facility: {
      value: cdktf.numberToHclTerraform(struct!.facility),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    log_failed_requests: {
      value: cdktf.booleanToHclTerraform(struct!.logFailedRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_record_size: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message_format: {
      value: cdktf.stringToHclTerraform(struct!.messageFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    octet_count_framing: {
      value: cdktf.booleanToHclTerraform(struct!.octetCountFraming),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputSyslogPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSyslogPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    severity: {
      value: cdktf.numberToHclTerraform(struct!.severity),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timestamp_format: {
      value: cdktf.stringToHclTerraform(struct!.timestampFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: destinationOutputSyslogTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputSyslogTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.udpDnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputSyslogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputSyslog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appName !== undefined) {
      hasAnyValues = true;
      internalValueResult.appName = this._appName;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._facility !== undefined) {
      hasAnyValues = true;
      internalValueResult.facility = this._facility;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._logFailedRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFailedRequests = this._logFailedRequests;
    }
    if (this._maxRecordSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSize = this._maxRecordSize;
    }
    if (this._messageFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageFormat = this._messageFormat;
    }
    if (this._octetCountFraming !== undefined) {
      hasAnyValues = true;
      internalValueResult.octetCountFraming = this._octetCountFraming;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._severity !== undefined) {
      hasAnyValues = true;
      internalValueResult.severity = this._severity;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._timestampFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampFormat = this._timestampFormat;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpDnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpDnsResolvePeriodSec = this._udpDnsResolvePeriodSec;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputSyslog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appName = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._facility = undefined;
      this._host = undefined;
      this._id = undefined;
      this._loadBalanced = undefined;
      this._logFailedRequests = undefined;
      this._maxRecordSize = undefined;
      this._messageFormat = undefined;
      this._octetCountFraming = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._severity = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRatePerSec = undefined;
      this._timestampFormat = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._udpDnsResolvePeriodSec = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appName = value.appName;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._environment = value.environment;
      this._facility = value.facility;
      this._host = value.host;
      this._id = value.id;
      this._loadBalanced = value.loadBalanced;
      this._logFailedRequests = value.logFailedRequests;
      this._maxRecordSize = value.maxRecordSize;
      this._messageFormat = value.messageFormat;
      this._octetCountFraming = value.octetCountFraming;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._severity = value.severity;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._timestampFormat = value.timestampFormat;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._udpDnsResolvePeriodSec = value.udpDnsResolvePeriodSec;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // app_name - computed: true, optional: true, required: false
  private _appName?: string; 
  public get appName() {
    return this.getStringAttribute('app_name');
  }
  public set appName(value: string) {
    this._appName = value;
  }
  public resetAppName() {
    this._appName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appNameInput() {
    return this._appName;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // facility - computed: true, optional: true, required: false
  private _facility?: number; 
  public get facility() {
    return this.getNumberAttribute('facility');
  }
  public set facility(value: number) {
    this._facility = value;
  }
  public resetFacility() {
    this._facility = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get facilityInput() {
    return this._facility;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // log_failed_requests - computed: true, optional: true, required: false
  private _logFailedRequests?: boolean | cdktf.IResolvable; 
  public get logFailedRequests() {
    return this.getBooleanAttribute('log_failed_requests');
  }
  public set logFailedRequests(value: boolean | cdktf.IResolvable) {
    this._logFailedRequests = value;
  }
  public resetLogFailedRequests() {
    this._logFailedRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFailedRequestsInput() {
    return this._logFailedRequests;
  }

  // max_record_size - computed: true, optional: true, required: false
  private _maxRecordSize?: number; 
  public get maxRecordSize() {
    return this.getNumberAttribute('max_record_size');
  }
  public set maxRecordSize(value: number) {
    this._maxRecordSize = value;
  }
  public resetMaxRecordSize() {
    this._maxRecordSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeInput() {
    return this._maxRecordSize;
  }

  // message_format - computed: true, optional: true, required: false
  private _messageFormat?: string; 
  public get messageFormat() {
    return this.getStringAttribute('message_format');
  }
  public set messageFormat(value: string) {
    this._messageFormat = value;
  }
  public resetMessageFormat() {
    this._messageFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFormatInput() {
    return this._messageFormat;
  }

  // octet_count_framing - computed: false, optional: true, required: false
  private _octetCountFraming?: boolean | cdktf.IResolvable; 
  public get octetCountFraming() {
    return this.getBooleanAttribute('octet_count_framing');
  }
  public set octetCountFraming(value: boolean | cdktf.IResolvable) {
    this._octetCountFraming = value;
  }
  public resetOctetCountFraming() {
    this._octetCountFraming = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get octetCountFramingInput() {
    return this._octetCountFraming;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputSyslogPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputSyslogPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // severity - computed: true, optional: true, required: false
  private _severity?: number; 
  public get severity() {
    return this.getNumberAttribute('severity');
  }
  public set severity(value: number) {
    this._severity = value;
  }
  public resetSeverity() {
    this._severity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityInput() {
    return this._severity;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // timestamp_format - computed: true, optional: true, required: false
  private _timestampFormat?: string; 
  public get timestampFormat() {
    return this.getStringAttribute('timestamp_format');
  }
  public set timestampFormat(value: string) {
    this._timestampFormat = value;
  }
  public resetTimestampFormat() {
    this._timestampFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampFormatInput() {
    return this._timestampFormat;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputSyslogTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputSyslogTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_dns_resolve_period_sec - computed: true, optional: true, required: false
  private _udpDnsResolvePeriodSec?: number; 
  public get udpDnsResolvePeriodSec() {
    return this.getNumberAttribute('udp_dns_resolve_period_sec');
  }
  public set udpDnsResolvePeriodSec(value: number) {
    this._udpDnsResolvePeriodSec = value;
  }
  public resetUdpDnsResolvePeriodSec() {
    this._udpDnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpDnsResolvePeriodSecInput() {
    return this._udpDnsResolvePeriodSec;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface DestinationOutputTcpjsonHosts {
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#host Destination#host}
  */
  readonly host: string;
  /**
  * The port to connect to on the provided host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#port Destination#port}
  */
  readonly port: number;
  /**
  * Servername to use if establishing a TLS connection. If not specified, defaults to connection host (if not an IP); otherwise, uses the global TLS settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
  /**
  * Whether to inherit TLS configs from group setting or disable TLS. Default: "inherit"; must be one of ["inherit", "off"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#weight Destination#weight}
  */
  readonly weight?: number;
}

export function destinationOutputTcpjsonHostsToTerraform(struct?: DestinationOutputTcpjsonHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
    servername: cdktf.stringToTerraform(struct!.servername),
    tls: cdktf.stringToTerraform(struct!.tls),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function destinationOutputTcpjsonHostsToHclTerraform(struct?: DestinationOutputTcpjsonHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputTcpjsonHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputTcpjsonHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputTcpjsonHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
      this._servername = undefined;
      this._tls = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
      this._servername = value.servername;
      this._tls = value.tls;
      this._weight = value.weight;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }

  // tls - computed: true, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DestinationOutputTcpjsonHostsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputTcpjsonHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputTcpjsonHostsOutputReference {
    return new DestinationOutputTcpjsonHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputTcpjsonPqControls {
}

export function destinationOutputTcpjsonPqControlsToTerraform(struct?: DestinationOutputTcpjsonPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputTcpjsonPqControlsToHclTerraform(struct?: DestinationOutputTcpjsonPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputTcpjsonPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputTcpjsonPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputTcpjsonPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputTcpjsonTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputTcpjsonTlsToTerraform(struct?: DestinationOutputTcpjsonTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputTcpjsonTlsToHclTerraform(struct?: DestinationOutputTcpjsonTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputTcpjsonTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputTcpjsonTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputTcpjsonTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputTcpjson {
  /**
  * Optional authentication token to include as part of the connection header. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_token Destination#auth_token}
  */
  readonly authToken?: string;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Codec to use to compress the data before sending. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compression Destination#compression}
  */
  readonly compression?: string;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#exclude_self Destination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#host Destination#host}
  */
  readonly host?: string;
  /**
  * Set of hosts to load-balance data to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#hosts Destination#hosts}
  */
  readonly hosts?: DestinationOutputTcpjsonHosts[] | cdktf.IResolvable;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#load_balance_stats_period_sec Destination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Use load-balanced destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#load_balanced Destination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Use to troubleshoot issues with sending data. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#log_failed_requests Destination#log_failed_requests}
  */
  readonly logFailedRequests?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_concurrent_senders Destination#max_concurrent_senders}
  */
  readonly maxConcurrentSenders?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * The port to connect to on the provided host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputTcpjsonPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Upon connection, send a header-like record containing the auth token and other metadata.This record will not contain an actual event  only subsequent records will. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#send_header Destination#send_header}
  */
  readonly sendHeader?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#throttle_rate_per_sec Destination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputTcpjsonTls;
  /**
  * The number of minutes before the internally generated authentication token expires, valid values between 1 and 60. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token_ttl_minutes Destination#token_ttl_minutes}
  */
  readonly tokenTtlMinutes?: number;
  /**
  * must be "tcpjson"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#write_timeout Destination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function destinationOutputTcpjsonToTerraform(struct?: DestinationOutputTcpjson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compression: cdktf.stringToTerraform(struct!.compression),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    host: cdktf.stringToTerraform(struct!.host),
    hosts: cdktf.listMapper(destinationOutputTcpjsonHostsToTerraform, false)(struct!.hosts),
    id: cdktf.stringToTerraform(struct!.id),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    log_failed_requests: cdktf.booleanToTerraform(struct!.logFailedRequests),
    max_concurrent_senders: cdktf.numberToTerraform(struct!.maxConcurrentSenders),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputTcpjsonPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    send_header: cdktf.booleanToTerraform(struct!.sendHeader),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    tls: destinationOutputTcpjsonTlsToTerraform(struct!.tls),
    token_ttl_minutes: cdktf.numberToTerraform(struct!.tokenTtlMinutes),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function destinationOutputTcpjsonToHclTerraform(struct?: DestinationOutputTcpjson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hosts: {
      value: cdktf.listMapperHcl(destinationOutputTcpjsonHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputTcpjsonHostsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    log_failed_requests: {
      value: cdktf.booleanToHclTerraform(struct!.logFailedRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_concurrent_senders: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentSenders),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputTcpjsonPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputTcpjsonPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_header: {
      value: cdktf.booleanToHclTerraform(struct!.sendHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: destinationOutputTcpjsonTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputTcpjsonTls",
    },
    token_ttl_minutes: {
      value: cdktf.numberToHclTerraform(struct!.tokenTtlMinutes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputTcpjsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputTcpjson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._logFailedRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFailedRequests = this._logFailedRequests;
    }
    if (this._maxConcurrentSenders !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentSenders = this._maxConcurrentSenders;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._sendHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendHeader = this._sendHeader;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._tokenTtlMinutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTtlMinutes = this._tokenTtlMinutes;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputTcpjson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authType = undefined;
      this._compression = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._host = undefined;
      this._hosts.internalValue = undefined;
      this._id = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._logFailedRequests = undefined;
      this._maxConcurrentSenders = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._sendHeader = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._throttleRatePerSec = undefined;
      this._tls.internalValue = undefined;
      this._tokenTtlMinutes = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authType = value.authType;
      this._compression = value.compression;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._host = value.host;
      this._hosts.internalValue = value.hosts;
      this._id = value.id;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._logFailedRequests = value.logFailedRequests;
      this._maxConcurrentSenders = value.maxConcurrentSenders;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._sendHeader = value.sendHeader;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._tls.internalValue = value.tls;
      this._tokenTtlMinutes = value.tokenTtlMinutes;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts = new DestinationOutputTcpjsonHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: DestinationOutputTcpjsonHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  public resetHosts() {
    this._hosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // log_failed_requests - computed: true, optional: true, required: false
  private _logFailedRequests?: boolean | cdktf.IResolvable; 
  public get logFailedRequests() {
    return this.getBooleanAttribute('log_failed_requests');
  }
  public set logFailedRequests(value: boolean | cdktf.IResolvable) {
    this._logFailedRequests = value;
  }
  public resetLogFailedRequests() {
    this._logFailedRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFailedRequestsInput() {
    return this._logFailedRequests;
  }

  // max_concurrent_senders - computed: true, optional: true, required: false
  private _maxConcurrentSenders?: number; 
  public get maxConcurrentSenders() {
    return this.getNumberAttribute('max_concurrent_senders');
  }
  public set maxConcurrentSenders(value: number) {
    this._maxConcurrentSenders = value;
  }
  public resetMaxConcurrentSenders() {
    this._maxConcurrentSenders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentSendersInput() {
    return this._maxConcurrentSenders;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputTcpjsonPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputTcpjsonPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // send_header - computed: true, optional: true, required: false
  private _sendHeader?: boolean | cdktf.IResolvable; 
  public get sendHeader() {
    return this.getBooleanAttribute('send_header');
  }
  public set sendHeader(value: boolean | cdktf.IResolvable) {
    this._sendHeader = value;
  }
  public resetSendHeader() {
    this._sendHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendHeaderInput() {
    return this._sendHeader;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputTcpjsonTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputTcpjsonTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token_ttl_minutes - computed: true, optional: true, required: false
  private _tokenTtlMinutes?: number; 
  public get tokenTtlMinutes() {
    return this.getNumberAttribute('token_ttl_minutes');
  }
  public set tokenTtlMinutes(value: number) {
    this._tokenTtlMinutes = value;
  }
  public resetTokenTtlMinutes() {
    this._tokenTtlMinutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTtlMinutesInput() {
    return this._tokenTtlMinutes;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface DestinationOutputWavefrontExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputWavefrontExtraHttpHeadersToTerraform(struct?: DestinationOutputWavefrontExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputWavefrontExtraHttpHeadersToHclTerraform(struct?: DestinationOutputWavefrontExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWavefrontExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputWavefrontExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWavefrontExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputWavefrontExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputWavefrontExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputWavefrontExtraHttpHeadersOutputReference {
    return new DestinationOutputWavefrontExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputWavefrontPqControls {
}

export function destinationOutputWavefrontPqControlsToTerraform(struct?: DestinationOutputWavefrontPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputWavefrontPqControlsToHclTerraform(struct?: DestinationOutputWavefrontPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputWavefrontPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputWavefrontPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWavefrontPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputWavefrontResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputWavefrontResponseRetrySettingsToTerraform(struct?: DestinationOutputWavefrontResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputWavefrontResponseRetrySettingsToHclTerraform(struct?: DestinationOutputWavefrontResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWavefrontResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputWavefrontResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWavefrontResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputWavefrontResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputWavefrontResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputWavefrontResponseRetrySettingsOutputReference {
    return new DestinationOutputWavefrontResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputWavefrontTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputWavefrontTimeoutRetrySettingsToTerraform(struct?: DestinationOutputWavefrontTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputWavefrontTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputWavefrontTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWavefrontTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputWavefrontTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWavefrontTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputWavefront {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * WaveFront domain name, e.g. "longboard". Default: "longboard"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#domain Destination#domain}
  */
  readonly domain?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputWavefrontExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputWavefrontPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputWavefrontResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputWavefrontTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * WaveFront API authentication token (see [here](https://docs.wavefront.com/wavefront_api.html#generating-an-api-token))
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * must be "wavefront"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputWavefrontToTerraform(struct?: DestinationOutputWavefront | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    domain: cdktf.stringToTerraform(struct!.domain),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputWavefrontExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputWavefrontPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputWavefrontResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputWavefrontTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputWavefrontToHclTerraform(struct?: DestinationOutputWavefront | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    domain: {
      value: cdktf.stringToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputWavefrontExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputWavefrontExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputWavefrontPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputWavefrontPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputWavefrontResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputWavefrontResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputWavefrontTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputWavefrontTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWavefrontOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputWavefront | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWavefront | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._domain = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._domain = value.domain;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // domain - computed: true, optional: true, required: false
  private _domain?: string; 
  public get domain() {
    return this.getStringAttribute('domain');
  }
  public set domain(value: string) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputWavefrontExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputWavefrontExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputWavefrontPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputWavefrontPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputWavefrontResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputWavefrontResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputWavefrontTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputWavefrontTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputWebhookExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputWebhookExtraHttpHeadersToTerraform(struct?: DestinationOutputWebhookExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputWebhookExtraHttpHeadersToHclTerraform(struct?: DestinationOutputWebhookExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWebhookExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputWebhookExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWebhookExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputWebhookExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputWebhookExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputWebhookExtraHttpHeadersOutputReference {
    return new DestinationOutputWebhookExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputWebhookOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputWebhookOauthHeadersToTerraform(struct?: DestinationOutputWebhookOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputWebhookOauthHeadersToHclTerraform(struct?: DestinationOutputWebhookOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWebhookOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputWebhookOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWebhookOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputWebhookOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputWebhookOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputWebhookOauthHeadersOutputReference {
    return new DestinationOutputWebhookOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputWebhookOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputWebhookOauthParamsToTerraform(struct?: DestinationOutputWebhookOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputWebhookOauthParamsToHclTerraform(struct?: DestinationOutputWebhookOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWebhookOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputWebhookOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWebhookOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputWebhookOauthParamsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputWebhookOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputWebhookOauthParamsOutputReference {
    return new DestinationOutputWebhookOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputWebhookPqControls {
}

export function destinationOutputWebhookPqControlsToTerraform(struct?: DestinationOutputWebhookPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputWebhookPqControlsToHclTerraform(struct?: DestinationOutputWebhookPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputWebhookPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputWebhookPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWebhookPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputWebhookResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputWebhookResponseRetrySettingsToTerraform(struct?: DestinationOutputWebhookResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputWebhookResponseRetrySettingsToHclTerraform(struct?: DestinationOutputWebhookResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWebhookResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputWebhookResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWebhookResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputWebhookResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputWebhookResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputWebhookResponseRetrySettingsOutputReference {
    return new DestinationOutputWebhookResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputWebhookTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputWebhookTimeoutRetrySettingsToTerraform(struct?: DestinationOutputWebhookTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputWebhookTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputWebhookTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWebhookTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputWebhookTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWebhookTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputWebhookTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputWebhookTlsToTerraform(struct?: DestinationOutputWebhookTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputWebhookTlsToHclTerraform(struct?: DestinationOutputWebhookTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWebhookTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputWebhookTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWebhookTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputWebhookUrls {
  /**
  * URL of a webhook endpoint to send events to, such as http://localhost:10200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#weight Destination#weight}
  */
  readonly weight?: number;
}

export function destinationOutputWebhookUrlsToTerraform(struct?: DestinationOutputWebhookUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function destinationOutputWebhookUrlsToHclTerraform(struct?: DestinationOutputWebhookUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWebhookUrlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputWebhookUrls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWebhookUrls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._weight = value.weight;
    }
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DestinationOutputWebhookUrlsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputWebhookUrls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputWebhookUrlsOutputReference {
    return new DestinationOutputWebhookUrlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputWebhook {
  /**
  * HTTP content-type header value. Default: "application/json"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#advanced_content_type Destination#advanced_content_type}
  */
  readonly advancedContentType?: string;
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_header_expr Destination#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Authentication method to use for the HTTP request. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry. Default: "application/x-ndjson"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_content_type Destination#custom_content_type}
  */
  readonly customContentType?: string;
  /**
  * Whether to drop events when the source expression evaluates to null. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_drop_when_null Destination#custom_drop_when_null}
  */
  readonly customDropWhenNull?: boolean | cdktf.IResolvable;
  /**
  * Delimiter string to insert between individual events. Defaults to newline character. Default: "\n"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_event_delimiter Destination#custom_event_delimiter}
  */
  readonly customEventDelimiter?: string;
  /**
  * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object. Default: "`${events}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_payload_expression Destination#custom_payload_expression}
  */
  readonly customPayloadExpression?: string;
  /**
  * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON. Default: "__httpOut"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#custom_source_expression Destination#custom_source_expression}
  */
  readonly customSourceExpression?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#exclude_self Destination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputWebhookExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * How to format events before sending out. Default: "ndjson"; must be one of ["ndjson", "json_array", "custom", "advanced"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format_event_code Destination#format_event_code}
  */
  readonly formatEventCode?: string;
  /**
  * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#format_payload_code Destination#format_payload_code}
  */
  readonly formatPayloadCode?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#keep_alive Destination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#load_balance_stats_period_sec Destination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#load_balanced Destination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#login_url Destination#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * The method to use when sending events. Default: "POST"; must be one of ["POST", "PUT", "PATCH"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#method Destination#method}
  */
  readonly method?: string;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#oauth_headers Destination#oauth_headers}
  */
  readonly oauthHeaders?: DestinationOutputWebhookOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#oauth_params Destination#oauth_params}
  */
  readonly oauthParams?: DestinationOutputWebhookOauthParams[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#password Destination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputWebhookPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputWebhookResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#secret Destination#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#secret_param_name Destination#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputWebhookTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputWebhookTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token_attribute_name Destination#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token_timeout_secs Destination#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "webhook"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * URL of a webhook endpoint to send events to, such as http://localhost:10200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#urls Destination#urls}
  */
  readonly urls?: DestinationOutputWebhookUrls[] | cdktf.IResolvable;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#username Destination#username}
  */
  readonly username?: string;
}

export function destinationOutputWebhookToTerraform(struct?: DestinationOutputWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_content_type: cdktf.stringToTerraform(struct!.advancedContentType),
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    custom_content_type: cdktf.stringToTerraform(struct!.customContentType),
    custom_drop_when_null: cdktf.booleanToTerraform(struct!.customDropWhenNull),
    custom_event_delimiter: cdktf.stringToTerraform(struct!.customEventDelimiter),
    custom_payload_expression: cdktf.stringToTerraform(struct!.customPayloadExpression),
    custom_source_expression: cdktf.stringToTerraform(struct!.customSourceExpression),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    extra_http_headers: cdktf.listMapper(destinationOutputWebhookExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    format_event_code: cdktf.stringToTerraform(struct!.formatEventCode),
    format_payload_code: cdktf.stringToTerraform(struct!.formatPayloadCode),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    method: cdktf.stringToTerraform(struct!.method),
    oauth_headers: cdktf.listMapper(destinationOutputWebhookOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(destinationOutputWebhookOauthParamsToTerraform, false)(struct!.oauthParams),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputWebhookPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputWebhookResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputWebhookTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    tls: destinationOutputWebhookTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    urls: cdktf.listMapper(destinationOutputWebhookUrlsToTerraform, false)(struct!.urls),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function destinationOutputWebhookToHclTerraform(struct?: DestinationOutputWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_content_type: {
      value: cdktf.stringToHclTerraform(struct!.advancedContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_content_type: {
      value: cdktf.stringToHclTerraform(struct!.customContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_drop_when_null: {
      value: cdktf.booleanToHclTerraform(struct!.customDropWhenNull),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    custom_event_delimiter: {
      value: cdktf.stringToHclTerraform(struct!.customEventDelimiter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_payload_expression: {
      value: cdktf.stringToHclTerraform(struct!.customPayloadExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_source_expression: {
      value: cdktf.stringToHclTerraform(struct!.customSourceExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputWebhookExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputWebhookExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format_event_code: {
      value: cdktf.stringToHclTerraform(struct!.formatEventCode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format_payload_code: {
      value: cdktf.stringToHclTerraform(struct!.formatPayloadCode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(destinationOutputWebhookOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputWebhookOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(destinationOutputWebhookOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputWebhookOauthParamsList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputWebhookPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputWebhookPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputWebhookResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputWebhookResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputWebhookTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputWebhookTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: destinationOutputWebhookTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputWebhookTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    urls: {
      value: cdktf.listMapperHcl(destinationOutputWebhookUrlsToHclTerraform, false)(struct!.urls),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputWebhookUrlsList",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputWebhookOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputWebhook | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedContentType = this._advancedContentType;
    }
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._customContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.customContentType = this._customContentType;
    }
    if (this._customDropWhenNull !== undefined) {
      hasAnyValues = true;
      internalValueResult.customDropWhenNull = this._customDropWhenNull;
    }
    if (this._customEventDelimiter !== undefined) {
      hasAnyValues = true;
      internalValueResult.customEventDelimiter = this._customEventDelimiter;
    }
    if (this._customPayloadExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.customPayloadExpression = this._customPayloadExpression;
    }
    if (this._customSourceExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSourceExpression = this._customSourceExpression;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._formatEventCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.formatEventCode = this._formatEventCode;
    }
    if (this._formatPayloadCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.formatPayloadCode = this._formatPayloadCode;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls?.internalValue;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputWebhook | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedContentType = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._credentialsSecret = undefined;
      this._customContentType = undefined;
      this._customDropWhenNull = undefined;
      this._customEventDelimiter = undefined;
      this._customPayloadExpression = undefined;
      this._customSourceExpression = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._formatEventCode = undefined;
      this._formatPayloadCode = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._loginUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._method = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._onBackpressure = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._urls.internalValue = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedContentType = value.advancedContentType;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._credentialsSecret = value.credentialsSecret;
      this._customContentType = value.customContentType;
      this._customDropWhenNull = value.customDropWhenNull;
      this._customEventDelimiter = value.customEventDelimiter;
      this._customPayloadExpression = value.customPayloadExpression;
      this._customSourceExpression = value.customSourceExpression;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._formatEventCode = value.formatEventCode;
      this._formatPayloadCode = value.formatPayloadCode;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._loginUrl = value.loginUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._method = value.method;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._onBackpressure = value.onBackpressure;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._urls.internalValue = value.urls;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
    }
  }

  // advanced_content_type - computed: true, optional: true, required: false
  private _advancedContentType?: string; 
  public get advancedContentType() {
    return this.getStringAttribute('advanced_content_type');
  }
  public set advancedContentType(value: string) {
    this._advancedContentType = value;
  }
  public resetAdvancedContentType() {
    this._advancedContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedContentTypeInput() {
    return this._advancedContentType;
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // custom_content_type - computed: true, optional: true, required: false
  private _customContentType?: string; 
  public get customContentType() {
    return this.getStringAttribute('custom_content_type');
  }
  public set customContentType(value: string) {
    this._customContentType = value;
  }
  public resetCustomContentType() {
    this._customContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customContentTypeInput() {
    return this._customContentType;
  }

  // custom_drop_when_null - computed: true, optional: true, required: false
  private _customDropWhenNull?: boolean | cdktf.IResolvable; 
  public get customDropWhenNull() {
    return this.getBooleanAttribute('custom_drop_when_null');
  }
  public set customDropWhenNull(value: boolean | cdktf.IResolvable) {
    this._customDropWhenNull = value;
  }
  public resetCustomDropWhenNull() {
    this._customDropWhenNull = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customDropWhenNullInput() {
    return this._customDropWhenNull;
  }

  // custom_event_delimiter - computed: true, optional: true, required: false
  private _customEventDelimiter?: string; 
  public get customEventDelimiter() {
    return this.getStringAttribute('custom_event_delimiter');
  }
  public set customEventDelimiter(value: string) {
    this._customEventDelimiter = value;
  }
  public resetCustomEventDelimiter() {
    this._customEventDelimiter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customEventDelimiterInput() {
    return this._customEventDelimiter;
  }

  // custom_payload_expression - computed: true, optional: true, required: false
  private _customPayloadExpression?: string; 
  public get customPayloadExpression() {
    return this.getStringAttribute('custom_payload_expression');
  }
  public set customPayloadExpression(value: string) {
    this._customPayloadExpression = value;
  }
  public resetCustomPayloadExpression() {
    this._customPayloadExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customPayloadExpressionInput() {
    return this._customPayloadExpression;
  }

  // custom_source_expression - computed: true, optional: true, required: false
  private _customSourceExpression?: string; 
  public get customSourceExpression() {
    return this.getStringAttribute('custom_source_expression');
  }
  public set customSourceExpression(value: string) {
    this._customSourceExpression = value;
  }
  public resetCustomSourceExpression() {
    this._customSourceExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customSourceExpressionInput() {
    return this._customSourceExpression;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputWebhookExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputWebhookExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // format_event_code - computed: false, optional: true, required: false
  private _formatEventCode?: string; 
  public get formatEventCode() {
    return this.getStringAttribute('format_event_code');
  }
  public set formatEventCode(value: string) {
    this._formatEventCode = value;
  }
  public resetFormatEventCode() {
    this._formatEventCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatEventCodeInput() {
    return this._formatEventCode;
  }

  // format_payload_code - computed: false, optional: true, required: false
  private _formatPayloadCode?: string; 
  public get formatPayloadCode() {
    return this.getStringAttribute('format_payload_code');
  }
  public set formatPayloadCode(value: string) {
    this._formatPayloadCode = value;
  }
  public resetFormatPayloadCode() {
    this._formatPayloadCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatPayloadCodeInput() {
    return this._formatPayloadCode;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // method - computed: true, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new DestinationOutputWebhookOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: DestinationOutputWebhookOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new DestinationOutputWebhookOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: DestinationOutputWebhookOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputWebhookPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputWebhookPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputWebhookResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputWebhookResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputWebhookTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputWebhookTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputWebhookTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputWebhookTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // urls - computed: false, optional: true, required: false
  private _urls = new DestinationOutputWebhookUrlsList(this, "urls", false);
  public get urls() {
    return this._urls;
  }
  public putUrls(value: DestinationOutputWebhookUrls[] | cdktf.IResolvable) {
    this._urls.internalValue = value;
  }
  public resetUrls() {
    this._urls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls.internalValue;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DestinationOutputXsiamExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputXsiamExtraHttpHeadersToTerraform(struct?: DestinationOutputXsiamExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputXsiamExtraHttpHeadersToHclTerraform(struct?: DestinationOutputXsiamExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputXsiamExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputXsiamExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputXsiamExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputXsiamExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputXsiamExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputXsiamExtraHttpHeadersOutputReference {
    return new DestinationOutputXsiamExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputXsiamPqControls {
}

export function destinationOutputXsiamPqControlsToTerraform(struct?: DestinationOutputXsiamPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputXsiamPqControlsToHclTerraform(struct?: DestinationOutputXsiamPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputXsiamPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputXsiamPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputXsiamPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputXsiamResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputXsiamResponseRetrySettingsToTerraform(struct?: DestinationOutputXsiamResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputXsiamResponseRetrySettingsToHclTerraform(struct?: DestinationOutputXsiamResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputXsiamResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputXsiamResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputXsiamResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputXsiamResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputXsiamResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputXsiamResponseRetrySettingsOutputReference {
    return new DestinationOutputXsiamResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputXsiamTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputXsiamTimeoutRetrySettingsToTerraform(struct?: DestinationOutputXsiamTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputXsiamTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputXsiamTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputXsiamTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputXsiamTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputXsiamTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputXsiamUrls {
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#weight Destination#weight}
  */
  readonly weight?: number;
}

export function destinationOutputXsiamUrlsToTerraform(struct?: DestinationOutputXsiamUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function destinationOutputXsiamUrlsToHclTerraform(struct?: DestinationOutputXsiamUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputXsiamUrlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputXsiamUrls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputXsiamUrls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._weight = value.weight;
    }
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DestinationOutputXsiamUrlsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputXsiamUrls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputXsiamUrlsOutputReference {
    return new DestinationOutputXsiamUrlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputXsiam {
  /**
  * Enter a token directly, or provide a secret referencing a token. Default: "token"; must be one of ["token", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#exclude_self Destination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputXsiamExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#load_balance_stats_period_sec Destination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#load_balanced Destination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputXsiamPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputXsiamResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Maximum number of requests to limit to per second. Default: 400
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#throttle_rate_req_per_sec Destination#throttle_rate_req_per_sec}
  */
  readonly throttleRateReqPerSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputXsiamTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * XSIAM authentication token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "xsiam"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * XSIAM endpoint URL to send events to, such as https://api-{tenant external URL}/logs/v1/event. Default: "http://localhost:8088/logs/v1/event"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#url Destination#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#urls Destination#urls}
  */
  readonly urls?: DestinationOutputXsiamUrls[] | cdktf.IResolvable;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.20.32/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputXsiamToTerraform(struct?: DestinationOutputXsiam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    extra_http_headers: cdktf.listMapper(destinationOutputXsiamExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputXsiamPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputXsiamResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    throttle_rate_req_per_sec: cdktf.numberToTerraform(struct!.throttleRateReqPerSec),
    timeout_retry_settings: destinationOutputXsiamTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    urls: cdktf.listMapper(destinationOutputXsiamUrlsToTerraform, false)(struct!.urls),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputXsiamToHclTerraform(struct?: DestinationOutputXsiam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputXsiamExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputXsiamExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputXsiamPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputXsiamPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputXsiamResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputXsiamResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    throttle_rate_req_per_sec: {
      value: cdktf.numberToHclTerraform(struct!.throttleRateReqPerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry_settings: {
      value: destinationOutputXsiamTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputXsiamTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    urls: {
      value: cdktf.listMapperHcl(destinationOutputXsiamUrlsToHclTerraform, false)(struct!.urls),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputXsiamUrlsList",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputXsiamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputXsiam | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._throttleRateReqPerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRateReqPerSec = this._throttleRateReqPerSec;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls?.internalValue;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputXsiam | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._throttleRateReqPerSec = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._urls.internalValue = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._throttleRateReqPerSec = value.throttleRateReqPerSec;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._urls.internalValue = value.urls;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputXsiamExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputXsiamExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputXsiamPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputXsiamPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputXsiamResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputXsiamResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // throttle_rate_req_per_sec - computed: true, optional: true, required: false
  private _throttleRateReqPerSec?: number; 
  public get throttleRateReqPerSec() {
    return this.getNumberAttribute('throttle_rate_req_per_sec');
  }
  public set throttleRateReqPerSec(value: number) {
    this._throttleRateReqPerSec = value;
  }
  public resetThrottleRateReqPerSec() {
    this._throttleRateReqPerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRateReqPerSecInput() {
    return this._throttleRateReqPerSec;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputXsiamTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputXsiamTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // urls - computed: false, optional: true, required: false
  private _urls = new DestinationOutputXsiamUrlsList(this, "urls", false);
  public get urls() {
    return this._urls;
  }
  public putUrls(value: DestinationOutputXsiamUrls[] | cdktf.IResolvable) {
    this._urls.internalValue = value;
  }
  public resetUrls() {
    this._urls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls.internalValue;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
