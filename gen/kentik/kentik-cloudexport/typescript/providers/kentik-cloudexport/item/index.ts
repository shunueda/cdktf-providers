// https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ItemConfig extends cdktf.TerraformMetaArguments {
  /**
  * Hostname of the Kentik deployment where the API calls related to this export should go, eg. api.kentik.com
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#api_root Item#api_root}
  */
  readonly apiRoot?: string;
  /**
  * The cloud provider targeted by this export (aws, azure, gce, ibm)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#cloud_provider Item#cloud_provider}
  */
  readonly cloudProvider: string;
  /**
  * An optional, longer description
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#description Item#description}
  */
  readonly description?: string;
  /**
  * Whether this task is enabled and intended to run, or disabled
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#enabled Item#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * Hostname of the Kentik deployment where the data generated by this export should go, eg. flow.kentik.com
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#flow_dest Item#flow_dest}
  */
  readonly flowDest?: string;
  /**
  * A short name for this export
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#name Item#name}
  */
  readonly name: string;
  /**
  * The identifier of the Kentik plan associated with this task
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#plan_id Item#plan_id}
  */
  readonly planId: string;
  /**
  * CLOUD_EXPORT_TYPE_UNSPECIFIED: Invalid or incomplete exports. CLOUD_EXPORT_TYPE_KENTIK_MANAGED: Cloud exports that are managed by Kentik. CLOUD_EXPORT_TYPE_CUSTOMER_MANAGED: Exports that are managed by Kentik customers (eg. by running an agent)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#type Item#type}
  */
  readonly type: string;
  /**
  * aws block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#aws Item#aws}
  */
  readonly aws?: ItemAws[] | cdktf.IResolvable;
  /**
  * azure block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#azure Item#azure}
  */
  readonly azure?: ItemAzure[] | cdktf.IResolvable;
  /**
  * bgp block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#bgp Item#bgp}
  */
  readonly bgp?: ItemBgp[] | cdktf.IResolvable;
  /**
  * gce block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#gce Item#gce}
  */
  readonly gce?: ItemGce[] | cdktf.IResolvable;
  /**
  * ibm block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#ibm Item#ibm}
  */
  readonly ibm?: ItemIbm[] | cdktf.IResolvable;
}
export interface ItemCurrentStatus {
}

export function itemCurrentStatusToTerraform(struct?: ItemCurrentStatus): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function itemCurrentStatusToHclTerraform(struct?: ItemCurrentStatus): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ItemCurrentStatusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ItemCurrentStatus | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ItemCurrentStatus | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // api_access - computed: true, optional: false, required: false
  public get apiAccess() {
    return this.getBooleanAttribute('api_access');
  }

  // error_message - computed: true, optional: false, required: false
  public get errorMessage() {
    return this.getStringAttribute('error_message');
  }

  // flow_found - computed: true, optional: false, required: false
  public get flowFound() {
    return this.getBooleanAttribute('flow_found');
  }

  // status - computed: true, optional: false, required: false
  public get status() {
    return this.getStringAttribute('status');
  }

  // storage_account_access - computed: true, optional: false, required: false
  public get storageAccountAccess() {
    return this.getBooleanAttribute('storage_account_access');
  }
}

export class ItemCurrentStatusList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ItemCurrentStatusOutputReference {
    return new ItemCurrentStatusOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ItemAws {
  /**
  * Source S3 bucket to fetch vpc flow logs from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#bucket Item#bucket}
  */
  readonly bucket: string;
  /**
  * If true, attempt to delete vpc flow log chunks from S3 after they've been read
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#delete_after_read Item#delete_after_read}
  */
  readonly deleteAfterRead: boolean | cdktf.IResolvable;
  /**
  * ARN for the IAM role to assume when fetching data or making AWS calls for this export
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#iam_role_arn Item#iam_role_arn}
  */
  readonly iamRoleArn: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#multiple_buckets Item#multiple_buckets}
  */
  readonly multipleBuckets: boolean | cdktf.IResolvable;
  /**
  * AWS region where this bucket resides
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#region Item#region}
  */
  readonly region: string;
}

export function itemAwsToTerraform(struct?: ItemAws | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bucket: cdktf.stringToTerraform(struct!.bucket),
    delete_after_read: cdktf.booleanToTerraform(struct!.deleteAfterRead),
    iam_role_arn: cdktf.stringToTerraform(struct!.iamRoleArn),
    multiple_buckets: cdktf.booleanToTerraform(struct!.multipleBuckets),
    region: cdktf.stringToTerraform(struct!.region),
  }
}


export function itemAwsToHclTerraform(struct?: ItemAws | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delete_after_read: {
      value: cdktf.booleanToHclTerraform(struct!.deleteAfterRead),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    iam_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.iamRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    multiple_buckets: {
      value: cdktf.booleanToHclTerraform(struct!.multipleBuckets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ItemAwsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ItemAws | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._deleteAfterRead !== undefined) {
      hasAnyValues = true;
      internalValueResult.deleteAfterRead = this._deleteAfterRead;
    }
    if (this._iamRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.iamRoleArn = this._iamRoleArn;
    }
    if (this._multipleBuckets !== undefined) {
      hasAnyValues = true;
      internalValueResult.multipleBuckets = this._multipleBuckets;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ItemAws | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bucket = undefined;
      this._deleteAfterRead = undefined;
      this._iamRoleArn = undefined;
      this._multipleBuckets = undefined;
      this._region = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bucket = value.bucket;
      this._deleteAfterRead = value.deleteAfterRead;
      this._iamRoleArn = value.iamRoleArn;
      this._multipleBuckets = value.multipleBuckets;
      this._region = value.region;
    }
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // delete_after_read - computed: false, optional: false, required: true
  private _deleteAfterRead?: boolean | cdktf.IResolvable; 
  public get deleteAfterRead() {
    return this.getBooleanAttribute('delete_after_read');
  }
  public set deleteAfterRead(value: boolean | cdktf.IResolvable) {
    this._deleteAfterRead = value;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteAfterReadInput() {
    return this._deleteAfterRead;
  }

  // iam_role_arn - computed: false, optional: false, required: true
  private _iamRoleArn?: string; 
  public get iamRoleArn() {
    return this.getStringAttribute('iam_role_arn');
  }
  public set iamRoleArn(value: string) {
    this._iamRoleArn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get iamRoleArnInput() {
    return this._iamRoleArn;
  }

  // multiple_buckets - computed: false, optional: false, required: true
  private _multipleBuckets?: boolean | cdktf.IResolvable; 
  public get multipleBuckets() {
    return this.getBooleanAttribute('multiple_buckets');
  }
  public set multipleBuckets(value: boolean | cdktf.IResolvable) {
    this._multipleBuckets = value;
  }
  // Temporarily expose input value. Use with caution.
  public get multipleBucketsInput() {
    return this._multipleBuckets;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }
}

export class ItemAwsList extends cdktf.ComplexList {
  public internalValue? : ItemAws[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ItemAwsOutputReference {
    return new ItemAwsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ItemAzure {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#location Item#location}
  */
  readonly location: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#resource_group Item#resource_group}
  */
  readonly resourceGroup: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#security_principal_enabled Item#security_principal_enabled}
  */
  readonly securityPrincipalEnabled: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#storage_account Item#storage_account}
  */
  readonly storageAccount: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#subscription_id Item#subscription_id}
  */
  readonly subscriptionId: string;
}

export function itemAzureToTerraform(struct?: ItemAzure | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    location: cdktf.stringToTerraform(struct!.location),
    resource_group: cdktf.stringToTerraform(struct!.resourceGroup),
    security_principal_enabled: cdktf.booleanToTerraform(struct!.securityPrincipalEnabled),
    storage_account: cdktf.stringToTerraform(struct!.storageAccount),
    subscription_id: cdktf.stringToTerraform(struct!.subscriptionId),
  }
}


export function itemAzureToHclTerraform(struct?: ItemAzure | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    location: {
      value: cdktf.stringToHclTerraform(struct!.location),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_group: {
      value: cdktf.stringToHclTerraform(struct!.resourceGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    security_principal_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.securityPrincipalEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    storage_account: {
      value: cdktf.stringToHclTerraform(struct!.storageAccount),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subscription_id: {
      value: cdktf.stringToHclTerraform(struct!.subscriptionId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ItemAzureOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ItemAzure | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._location !== undefined) {
      hasAnyValues = true;
      internalValueResult.location = this._location;
    }
    if (this._resourceGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceGroup = this._resourceGroup;
    }
    if (this._securityPrincipalEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityPrincipalEnabled = this._securityPrincipalEnabled;
    }
    if (this._storageAccount !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageAccount = this._storageAccount;
    }
    if (this._subscriptionId !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscriptionId = this._subscriptionId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ItemAzure | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._location = undefined;
      this._resourceGroup = undefined;
      this._securityPrincipalEnabled = undefined;
      this._storageAccount = undefined;
      this._subscriptionId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._location = value.location;
      this._resourceGroup = value.resourceGroup;
      this._securityPrincipalEnabled = value.securityPrincipalEnabled;
      this._storageAccount = value.storageAccount;
      this._subscriptionId = value.subscriptionId;
    }
  }

  // location - computed: false, optional: false, required: true
  private _location?: string; 
  public get location() {
    return this.getStringAttribute('location');
  }
  public set location(value: string) {
    this._location = value;
  }
  // Temporarily expose input value. Use with caution.
  public get locationInput() {
    return this._location;
  }

  // resource_group - computed: false, optional: false, required: true
  private _resourceGroup?: string; 
  public get resourceGroup() {
    return this.getStringAttribute('resource_group');
  }
  public set resourceGroup(value: string) {
    this._resourceGroup = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceGroupInput() {
    return this._resourceGroup;
  }

  // security_principal_enabled - computed: false, optional: false, required: true
  private _securityPrincipalEnabled?: boolean | cdktf.IResolvable; 
  public get securityPrincipalEnabled() {
    return this.getBooleanAttribute('security_principal_enabled');
  }
  public set securityPrincipalEnabled(value: boolean | cdktf.IResolvable) {
    this._securityPrincipalEnabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get securityPrincipalEnabledInput() {
    return this._securityPrincipalEnabled;
  }

  // storage_account - computed: false, optional: false, required: true
  private _storageAccount?: string; 
  public get storageAccount() {
    return this.getStringAttribute('storage_account');
  }
  public set storageAccount(value: string) {
    this._storageAccount = value;
  }
  // Temporarily expose input value. Use with caution.
  public get storageAccountInput() {
    return this._storageAccount;
  }

  // subscription_id - computed: false, optional: false, required: true
  private _subscriptionId?: string; 
  public get subscriptionId() {
    return this.getStringAttribute('subscription_id');
  }
  public set subscriptionId(value: string) {
    this._subscriptionId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionIdInput() {
    return this._subscriptionId;
  }
}

export class ItemAzureList extends cdktf.ComplexList {
  public internalValue? : ItemAzure[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ItemAzureOutputReference {
    return new ItemAzureOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ItemBgp {
  /**
  * If true, apply BGP data discovered via another device to the flow from this export
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#apply_bgp Item#apply_bgp}
  */
  readonly applyBgp: boolean | cdktf.IResolvable;
  /**
  * device, other_device, none
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#device_bgp_type Item#device_bgp_type}
  */
  readonly deviceBgpType: string;
  /**
  * Which other device to get BGP data from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#use_bgp_device_id Item#use_bgp_device_id}
  */
  readonly useBgpDeviceId: string;
}

export function itemBgpToTerraform(struct?: ItemBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    apply_bgp: cdktf.booleanToTerraform(struct!.applyBgp),
    device_bgp_type: cdktf.stringToTerraform(struct!.deviceBgpType),
    use_bgp_device_id: cdktf.stringToTerraform(struct!.useBgpDeviceId),
  }
}


export function itemBgpToHclTerraform(struct?: ItemBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    apply_bgp: {
      value: cdktf.booleanToHclTerraform(struct!.applyBgp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    device_bgp_type: {
      value: cdktf.stringToHclTerraform(struct!.deviceBgpType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_bgp_device_id: {
      value: cdktf.stringToHclTerraform(struct!.useBgpDeviceId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ItemBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ItemBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._applyBgp !== undefined) {
      hasAnyValues = true;
      internalValueResult.applyBgp = this._applyBgp;
    }
    if (this._deviceBgpType !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceBgpType = this._deviceBgpType;
    }
    if (this._useBgpDeviceId !== undefined) {
      hasAnyValues = true;
      internalValueResult.useBgpDeviceId = this._useBgpDeviceId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ItemBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._applyBgp = undefined;
      this._deviceBgpType = undefined;
      this._useBgpDeviceId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._applyBgp = value.applyBgp;
      this._deviceBgpType = value.deviceBgpType;
      this._useBgpDeviceId = value.useBgpDeviceId;
    }
  }

  // apply_bgp - computed: false, optional: false, required: true
  private _applyBgp?: boolean | cdktf.IResolvable; 
  public get applyBgp() {
    return this.getBooleanAttribute('apply_bgp');
  }
  public set applyBgp(value: boolean | cdktf.IResolvable) {
    this._applyBgp = value;
  }
  // Temporarily expose input value. Use with caution.
  public get applyBgpInput() {
    return this._applyBgp;
  }

  // device_bgp_type - computed: false, optional: false, required: true
  private _deviceBgpType?: string; 
  public get deviceBgpType() {
    return this.getStringAttribute('device_bgp_type');
  }
  public set deviceBgpType(value: string) {
    this._deviceBgpType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceBgpTypeInput() {
    return this._deviceBgpType;
  }

  // use_bgp_device_id - computed: false, optional: false, required: true
  private _useBgpDeviceId?: string; 
  public get useBgpDeviceId() {
    return this.getStringAttribute('use_bgp_device_id');
  }
  public set useBgpDeviceId(value: string) {
    this._useBgpDeviceId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useBgpDeviceIdInput() {
    return this._useBgpDeviceId;
  }
}

export class ItemBgpList extends cdktf.ComplexList {
  public internalValue? : ItemBgp[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ItemBgpOutputReference {
    return new ItemBgpOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ItemGce {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#project Item#project}
  */
  readonly project: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#subscription Item#subscription}
  */
  readonly subscription: string;
}

export function itemGceToTerraform(struct?: ItemGce | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    project: cdktf.stringToTerraform(struct!.project),
    subscription: cdktf.stringToTerraform(struct!.subscription),
  }
}


export function itemGceToHclTerraform(struct?: ItemGce | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subscription: {
      value: cdktf.stringToHclTerraform(struct!.subscription),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ItemGceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ItemGce | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    if (this._subscription !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscription = this._subscription;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ItemGce | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._project = undefined;
      this._subscription = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._project = value.project;
      this._subscription = value.subscription;
    }
  }

  // project - computed: false, optional: false, required: true
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }

  // subscription - computed: false, optional: false, required: true
  private _subscription?: string; 
  public get subscription() {
    return this.getStringAttribute('subscription');
  }
  public set subscription(value: string) {
    this._subscription = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionInput() {
    return this._subscription;
  }
}

export class ItemGceList extends cdktf.ComplexList {
  public internalValue? : ItemGce[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ItemGceOutputReference {
    return new ItemGceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ItemIbm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#bucket Item#bucket}
  */
  readonly bucket: string;
}

export function itemIbmToTerraform(struct?: ItemIbm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bucket: cdktf.stringToTerraform(struct!.bucket),
  }
}


export function itemIbmToHclTerraform(struct?: ItemIbm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ItemIbmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ItemIbm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ItemIbm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bucket = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bucket = value.bucket;
    }
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }
}

export class ItemIbmList extends cdktf.ComplexList {
  public internalValue? : ItemIbm[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ItemIbmOutputReference {
    return new ItemIbmOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item kentik-cloudexport_item}
*/
export class Item extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "kentik-cloudexport_item";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a Item resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the Item to import
  * @param importFromId The id of the existing Item that should be imported. Refer to the {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the Item to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "kentik-cloudexport_item", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/kentik/kentik-cloudexport/0.4.1/docs/resources/item kentik-cloudexport_item} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ItemConfig
  */
  public constructor(scope: Construct, id: string, config: ItemConfig) {
    super(scope, id, {
      terraformResourceType: 'kentik-cloudexport_item',
      terraformGeneratorMetadata: {
        providerName: 'kentik-cloudexport',
        providerVersion: '0.4.1',
        providerVersionConstraint: '0.4.1'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._apiRoot = config.apiRoot;
    this._cloudProvider = config.cloudProvider;
    this._description = config.description;
    this._enabled = config.enabled;
    this._flowDest = config.flowDest;
    this._name = config.name;
    this._planId = config.planId;
    this._type = config.type;
    this._aws.internalValue = config.aws;
    this._azure.internalValue = config.azure;
    this._bgp.internalValue = config.bgp;
    this._gce.internalValue = config.gce;
    this._ibm.internalValue = config.ibm;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // api_root - computed: true, optional: true, required: false
  private _apiRoot?: string; 
  public get apiRoot() {
    return this.getStringAttribute('api_root');
  }
  public set apiRoot(value: string) {
    this._apiRoot = value;
  }
  public resetApiRoot() {
    this._apiRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiRootInput() {
    return this._apiRoot;
  }

  // cloud_provider - computed: false, optional: false, required: true
  private _cloudProvider?: string; 
  public get cloudProvider() {
    return this.getStringAttribute('cloud_provider');
  }
  public set cloudProvider(value: string) {
    this._cloudProvider = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderInput() {
    return this._cloudProvider;
  }

  // current_status - computed: true, optional: false, required: false
  private _currentStatus = new ItemCurrentStatusList(this, "current_status", false);
  public get currentStatus() {
    return this._currentStatus;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // flow_dest - computed: true, optional: true, required: false
  private _flowDest?: string; 
  public get flowDest() {
    return this.getStringAttribute('flow_dest');
  }
  public set flowDest(value: string) {
    this._flowDest = value;
  }
  public resetFlowDest() {
    this._flowDest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flowDestInput() {
    return this._flowDest;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // plan_id - computed: false, optional: false, required: true
  private _planId?: string; 
  public get planId() {
    return this.getStringAttribute('plan_id');
  }
  public set planId(value: string) {
    this._planId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get planIdInput() {
    return this._planId;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // aws - computed: false, optional: true, required: false
  private _aws = new ItemAwsList(this, "aws", false);
  public get aws() {
    return this._aws;
  }
  public putAws(value: ItemAws[] | cdktf.IResolvable) {
    this._aws.internalValue = value;
  }
  public resetAws() {
    this._aws.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsInput() {
    return this._aws.internalValue;
  }

  // azure - computed: false, optional: true, required: false
  private _azure = new ItemAzureList(this, "azure", false);
  public get azure() {
    return this._azure;
  }
  public putAzure(value: ItemAzure[] | cdktf.IResolvable) {
    this._azure.internalValue = value;
  }
  public resetAzure() {
    this._azure.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureInput() {
    return this._azure.internalValue;
  }

  // bgp - computed: false, optional: true, required: false
  private _bgp = new ItemBgpList(this, "bgp", false);
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: ItemBgp[] | cdktf.IResolvable) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // gce - computed: false, optional: true, required: false
  private _gce = new ItemGceList(this, "gce", false);
  public get gce() {
    return this._gce;
  }
  public putGce(value: ItemGce[] | cdktf.IResolvable) {
    this._gce.internalValue = value;
  }
  public resetGce() {
    this._gce.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gceInput() {
    return this._gce.internalValue;
  }

  // ibm - computed: false, optional: true, required: false
  private _ibm = new ItemIbmList(this, "ibm", false);
  public get ibm() {
    return this._ibm;
  }
  public putIbm(value: ItemIbm[] | cdktf.IResolvable) {
    this._ibm.internalValue = value;
  }
  public resetIbm() {
    this._ibm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ibmInput() {
    return this._ibm.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      api_root: cdktf.stringToTerraform(this._apiRoot),
      cloud_provider: cdktf.stringToTerraform(this._cloudProvider),
      description: cdktf.stringToTerraform(this._description),
      enabled: cdktf.booleanToTerraform(this._enabled),
      flow_dest: cdktf.stringToTerraform(this._flowDest),
      name: cdktf.stringToTerraform(this._name),
      plan_id: cdktf.stringToTerraform(this._planId),
      type: cdktf.stringToTerraform(this._type),
      aws: cdktf.listMapper(itemAwsToTerraform, true)(this._aws.internalValue),
      azure: cdktf.listMapper(itemAzureToTerraform, true)(this._azure.internalValue),
      bgp: cdktf.listMapper(itemBgpToTerraform, true)(this._bgp.internalValue),
      gce: cdktf.listMapper(itemGceToTerraform, true)(this._gce.internalValue),
      ibm: cdktf.listMapper(itemIbmToTerraform, true)(this._ibm.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      api_root: {
        value: cdktf.stringToHclTerraform(this._apiRoot),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      cloud_provider: {
        value: cdktf.stringToHclTerraform(this._cloudProvider),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      description: {
        value: cdktf.stringToHclTerraform(this._description),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      enabled: {
        value: cdktf.booleanToHclTerraform(this._enabled),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      flow_dest: {
        value: cdktf.stringToHclTerraform(this._flowDest),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      name: {
        value: cdktf.stringToHclTerraform(this._name),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      plan_id: {
        value: cdktf.stringToHclTerraform(this._planId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      type: {
        value: cdktf.stringToHclTerraform(this._type),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      aws: {
        value: cdktf.listMapperHcl(itemAwsToHclTerraform, true)(this._aws.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ItemAwsList",
      },
      azure: {
        value: cdktf.listMapperHcl(itemAzureToHclTerraform, true)(this._azure.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ItemAzureList",
      },
      bgp: {
        value: cdktf.listMapperHcl(itemBgpToHclTerraform, true)(this._bgp.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ItemBgpList",
      },
      gce: {
        value: cdktf.listMapperHcl(itemGceToHclTerraform, true)(this._gce.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ItemGceList",
      },
      ibm: {
        value: cdktf.listMapperHcl(itemIbmToHclTerraform, true)(this._ibm.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ItemIbmList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
