// https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#bgp DataPanosFiltersRouteMapsRedistributionRoutingProfile#bgp}
  */
  readonly bgp?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#connected_static DataPanosFiltersRouteMapsRedistributionRoutingProfile#connected_static}
  */
  readonly connectedStatic?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStatic;
  /**
  * Describe Redistribution Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * The location of this object.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#location DataPanosFiltersRouteMapsRedistributionRoutingProfile#location}
  */
  readonly location: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ospf DataPanosFiltersRouteMapsRedistributionRoutingProfile#ospf}
  */
  readonly ospf?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ospfv3 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ospfv3}
  */
  readonly ospfv3?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#rip DataPanosFiltersRouteMapsRedistributionRoutingProfile#rip}
  */
  readonly rip?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRip;
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_source DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_source}
  */
  readonly routeSource?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
    route_source: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceToTerraform(struct!.routeSource),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop",
    },
    route_source: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceToHclTerraform(struct!.routeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._routeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSource = this._routeSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
      this._routeSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
      this._routeSource.internalValue = value.routeSource;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // route_source - computed: true, optional: true, required: false
  private _routeSource = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceOutputReference(this, "route_source");
  public get routeSource() {
    return this._routeSource;
  }
  public putRouteSource(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource) {
    this._routeSource.internalValue = value;
  }
  public resetRouteSource() {
    this._routeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSourceInput() {
    return this._routeSource.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch {
  /**
  * AS Path Access List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#as_path_access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#as_path_access_list}
  */
  readonly asPathAccessList?: string;
  /**
  * Extended Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#extended_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv4 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4;
  /**
  * Large Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#large_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string;
  /**
  * Match Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#local_preference DataPanosFiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Match Metric (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Match origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#origin DataPanosFiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Match Peer Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#peer DataPanosFiltersRouteMapsRedistributionRoutingProfile#peer}
  */
  readonly peer?: string;
  /**
  * Regular Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#regular_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path_access_list: cdktf.stringToTerraform(struct!.asPathAccessList),
    extended_communities: cdktf.stringToTerraform(struct!.extendedCommunities),
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    large_communities: cdktf.stringToTerraform(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: cdktf.numberToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    peer: cdktf.stringToTerraform(struct!.peer),
    regular_communities: cdktf.stringToTerraform(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path_access_list: {
      value: cdktf.stringToHclTerraform(struct!.asPathAccessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extended_communities: {
      value: cdktf.stringToHclTerraform(struct!.extendedCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4",
    },
    large_communities: {
      value: cdktf.stringToHclTerraform(struct!.largeCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.stringToHclTerraform(struct!.peer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.stringToHclTerraform(struct!.regularCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPathAccessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathAccessList = this._asPathAccessList;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._peer !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPathAccessList = undefined;
      this._extendedCommunities = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric = undefined;
      this._origin = undefined;
      this._peer = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPathAccessList = value.asPathAccessList;
      this._extendedCommunities = value.extendedCommunities;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric = value.metric;
      this._origin = value.origin;
      this._peer = value.peer;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
    }
  }

  // as_path_access_list - computed: true, optional: true, required: false
  private _asPathAccessList?: string; 
  public get asPathAccessList() {
    return this.getStringAttribute('as_path_access_list');
  }
  public set asPathAccessList(value: string) {
    this._asPathAccessList = value;
  }
  public resetAsPathAccessList() {
    this._asPathAccessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathAccessListInput() {
    return this._asPathAccessList;
  }

  // extended_communities - computed: true, optional: true, required: false
  private _extendedCommunities?: string; 
  public get extendedCommunities() {
    return this.getStringAttribute('extended_communities');
  }
  public set extendedCommunities(value: string) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: true, optional: true, required: false
  private _ipv4 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // large_communities - computed: true, optional: true, required: false
  private _largeCommunities?: string; 
  public get largeCommunities() {
    return this.getStringAttribute('large_communities');
  }
  public set largeCommunities(value: string) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: true, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // origin - computed: true, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // peer - computed: true, optional: true, required: false
  private _peer?: string; 
  public get peer() {
    return this.getStringAttribute('peer');
  }
  public set peer(value: string) {
    this._peer = value;
  }
  public resetPeer() {
    this._peer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer;
  }

  // regular_communities - computed: true, optional: true, required: false
  private _regularCommunities?: string; 
  public get regularCommunities() {
    return this.getStringAttribute('regular_communities');
  }
  public set regularCommunities(value: string) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric;
  /**
  * Set Metric-Type of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric_type DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric_type}
  */
  readonly metricType?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricToTerraform(struct!.metric),
    metric_type: cdktf.stringToTerraform(struct!.metricType),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric",
    },
    metric_type: {
      value: cdktf.stringToHclTerraform(struct!.metricType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._metricType !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricType = this._metricType;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._metricType = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._metricType = value.metricType;
      this._tag = value.tag;
    }
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // metric_type - computed: true, optional: true, required: false
  private _metricType?: string; 
  public get metricType() {
    return this.getStringAttribute('metric_type');
  }
  public set metricType(value: string) {
    this._metricType = value;
  }
  public resetMetricType() {
    this._metricType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricTypeInput() {
    return this._metricType;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopToTerraform(struct!.nextHop),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch {
  /**
  * AS Path Access List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#as_path_access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#as_path_access_list}
  */
  readonly asPathAccessList?: string;
  /**
  * Extended Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#extended_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv6 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6;
  /**
  * Large Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#large_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string;
  /**
  * Match Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#local_preference DataPanosFiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Match Metric (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Match origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#origin DataPanosFiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Match Peer Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#peer DataPanosFiltersRouteMapsRedistributionRoutingProfile#peer}
  */
  readonly peer?: string;
  /**
  * Regular Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#regular_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path_access_list: cdktf.stringToTerraform(struct!.asPathAccessList),
    extended_communities: cdktf.stringToTerraform(struct!.extendedCommunities),
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv6: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6ToTerraform(struct!.ipv6),
    large_communities: cdktf.stringToTerraform(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: cdktf.numberToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    peer: cdktf.stringToTerraform(struct!.peer),
    regular_communities: cdktf.stringToTerraform(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path_access_list: {
      value: cdktf.stringToHclTerraform(struct!.asPathAccessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extended_communities: {
      value: cdktf.stringToHclTerraform(struct!.extendedCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv6: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6",
    },
    large_communities: {
      value: cdktf.stringToHclTerraform(struct!.largeCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.stringToHclTerraform(struct!.peer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.stringToHclTerraform(struct!.regularCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPathAccessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathAccessList = this._asPathAccessList;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._peer !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPathAccessList = undefined;
      this._extendedCommunities = undefined;
      this._interface = undefined;
      this._ipv6.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric = undefined;
      this._origin = undefined;
      this._peer = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPathAccessList = value.asPathAccessList;
      this._extendedCommunities = value.extendedCommunities;
      this._interface = value.interface;
      this._ipv6.internalValue = value.ipv6;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric = value.metric;
      this._origin = value.origin;
      this._peer = value.peer;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
    }
  }

  // as_path_access_list - computed: true, optional: true, required: false
  private _asPathAccessList?: string; 
  public get asPathAccessList() {
    return this.getStringAttribute('as_path_access_list');
  }
  public set asPathAccessList(value: string) {
    this._asPathAccessList = value;
  }
  public resetAsPathAccessList() {
    this._asPathAccessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathAccessListInput() {
    return this._asPathAccessList;
  }

  // extended_communities - computed: true, optional: true, required: false
  private _extendedCommunities?: string; 
  public get extendedCommunities() {
    return this.getStringAttribute('extended_communities');
  }
  public set extendedCommunities(value: string) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv6 - computed: true, optional: true, required: false
  private _ipv6 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // large_communities - computed: true, optional: true, required: false
  private _largeCommunities?: string; 
  public get largeCommunities() {
    return this.getStringAttribute('large_communities');
  }
  public set largeCommunities(value: string) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: true, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // origin - computed: true, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // peer - computed: true, optional: true, required: false
  private _peer?: string; 
  public get peer() {
    return this.getStringAttribute('peer');
  }
  public set peer(value: string) {
    this._peer = value;
  }
  public resetPeer() {
    this._peer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer;
  }

  // regular_communities - computed: true, optional: true, required: false
  private _regularCommunities?: string; 
  public get regularCommunities() {
    return this.getStringAttribute('regular_communities');
  }
  public set regularCommunities(value: string) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric;
  /**
  * Set Metric-Type of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric_type DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric_type}
  */
  readonly metricType?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricToTerraform(struct!.metric),
    metric_type: cdktf.stringToTerraform(struct!.metricType),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric",
    },
    metric_type: {
      value: cdktf.stringToHclTerraform(struct!.metricType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._metricType !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricType = this._metricType;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._metricType = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._metricType = value.metricType;
      this._tag = value.tag;
    }
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // metric_type - computed: true, optional: true, required: false
  private _metricType?: string; 
  public get metricType() {
    return this.getStringAttribute('metric_type');
  }
  public set metricType(value: string) {
    this._metricType = value;
  }
  public resetMetricType() {
    this._metricType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricTypeInput() {
    return this._metricType;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_source DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_source}
  */
  readonly routeSource?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
    route_source: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceToTerraform(struct!.routeSource),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop",
    },
    route_source: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceToHclTerraform(struct!.routeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._routeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSource = this._routeSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
      this._routeSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
      this._routeSource.internalValue = value.routeSource;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // route_source - computed: true, optional: true, required: false
  private _routeSource = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceOutputReference(this, "route_source");
  public get routeSource() {
    return this._routeSource;
  }
  public putRouteSource(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource) {
    this._routeSource.internalValue = value;
  }
  public resetRouteSource() {
    this._routeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSourceInput() {
    return this._routeSource.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopToTerraform(struct!.nextHop),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch {
  /**
  * AS Path Access List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#as_path_access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#as_path_access_list}
  */
  readonly asPathAccessList?: string;
  /**
  * Extended Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#extended_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv4 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv6 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6;
  /**
  * Large Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#large_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string;
  /**
  * Match Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#local_preference DataPanosFiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Match Metric (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Match origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#origin DataPanosFiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Match Peer Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#peer DataPanosFiltersRouteMapsRedistributionRoutingProfile#peer}
  */
  readonly peer?: string;
  /**
  * Regular Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#regular_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path_access_list: cdktf.stringToTerraform(struct!.asPathAccessList),
    extended_communities: cdktf.stringToTerraform(struct!.extendedCommunities),
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    ipv6: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6ToTerraform(struct!.ipv6),
    large_communities: cdktf.stringToTerraform(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: cdktf.numberToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    peer: cdktf.stringToTerraform(struct!.peer),
    regular_communities: cdktf.stringToTerraform(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path_access_list: {
      value: cdktf.stringToHclTerraform(struct!.asPathAccessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extended_communities: {
      value: cdktf.stringToHclTerraform(struct!.extendedCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4",
    },
    ipv6: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6",
    },
    large_communities: {
      value: cdktf.stringToHclTerraform(struct!.largeCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.stringToHclTerraform(struct!.peer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.stringToHclTerraform(struct!.regularCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPathAccessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathAccessList = this._asPathAccessList;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._peer !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPathAccessList = undefined;
      this._extendedCommunities = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric = undefined;
      this._origin = undefined;
      this._peer = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPathAccessList = value.asPathAccessList;
      this._extendedCommunities = value.extendedCommunities;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric = value.metric;
      this._origin = value.origin;
      this._peer = value.peer;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
    }
  }

  // as_path_access_list - computed: true, optional: true, required: false
  private _asPathAccessList?: string; 
  public get asPathAccessList() {
    return this.getStringAttribute('as_path_access_list');
  }
  public set asPathAccessList(value: string) {
    this._asPathAccessList = value;
  }
  public resetAsPathAccessList() {
    this._asPathAccessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathAccessListInput() {
    return this._asPathAccessList;
  }

  // extended_communities - computed: true, optional: true, required: false
  private _extendedCommunities?: string; 
  public get extendedCommunities() {
    return this.getStringAttribute('extended_communities');
  }
  public set extendedCommunities(value: string) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: true, optional: true, required: false
  private _ipv4 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: true, optional: true, required: false
  private _ipv6 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // large_communities - computed: true, optional: true, required: false
  private _largeCommunities?: string; 
  public get largeCommunities() {
    return this.getStringAttribute('large_communities');
  }
  public set largeCommunities(value: string) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: true, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // origin - computed: true, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // peer - computed: true, optional: true, required: false
  private _peer?: string; 
  public get peer() {
    return this.getStringAttribute('peer');
  }
  public set peer(value: string) {
    this._peer = value;
  }
  public resetPeer() {
    this._peer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer;
  }

  // regular_communities - computed: true, optional: true, required: false
  private _regularCommunities?: string; 
  public get regularCommunities() {
    return this.getStringAttribute('regular_communities');
  }
  public set regularCommunities(value: string) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet {
  /**
  * Set Source IPv4 or IPv6 address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#source_address DataPanosFiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // source_address - computed: true, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRib {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_source DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_source}
  */
  readonly routeSource?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
    route_source: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceToTerraform(struct!.routeSource),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop",
    },
    route_source: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceToHclTerraform(struct!.routeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._routeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSource = this._routeSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
      this._routeSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
      this._routeSource.internalValue = value.routeSource;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // route_source - computed: true, optional: true, required: false
  private _routeSource = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceOutputReference(this, "route_source");
  public get routeSource() {
    return this._routeSource;
  }
  public putRouteSource(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource) {
    this._routeSource.internalValue = value;
  }
  public resetRouteSource() {
    this._routeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSourceInput() {
    return this._routeSource.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch {
  /**
  * AS Path Access List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#as_path_access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#as_path_access_list}
  */
  readonly asPathAccessList?: string;
  /**
  * Extended Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#extended_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv4 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4;
  /**
  * Large Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#large_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string;
  /**
  * Match Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#local_preference DataPanosFiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Match Metric (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Match origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#origin DataPanosFiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Match Peer Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#peer DataPanosFiltersRouteMapsRedistributionRoutingProfile#peer}
  */
  readonly peer?: string;
  /**
  * Regular Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#regular_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path_access_list: cdktf.stringToTerraform(struct!.asPathAccessList),
    extended_communities: cdktf.stringToTerraform(struct!.extendedCommunities),
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    large_communities: cdktf.stringToTerraform(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: cdktf.numberToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    peer: cdktf.stringToTerraform(struct!.peer),
    regular_communities: cdktf.stringToTerraform(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path_access_list: {
      value: cdktf.stringToHclTerraform(struct!.asPathAccessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extended_communities: {
      value: cdktf.stringToHclTerraform(struct!.extendedCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4",
    },
    large_communities: {
      value: cdktf.stringToHclTerraform(struct!.largeCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.stringToHclTerraform(struct!.peer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.stringToHclTerraform(struct!.regularCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPathAccessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathAccessList = this._asPathAccessList;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._peer !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPathAccessList = undefined;
      this._extendedCommunities = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric = undefined;
      this._origin = undefined;
      this._peer = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPathAccessList = value.asPathAccessList;
      this._extendedCommunities = value.extendedCommunities;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric = value.metric;
      this._origin = value.origin;
      this._peer = value.peer;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
    }
  }

  // as_path_access_list - computed: true, optional: true, required: false
  private _asPathAccessList?: string; 
  public get asPathAccessList() {
    return this.getStringAttribute('as_path_access_list');
  }
  public set asPathAccessList(value: string) {
    this._asPathAccessList = value;
  }
  public resetAsPathAccessList() {
    this._asPathAccessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathAccessListInput() {
    return this._asPathAccessList;
  }

  // extended_communities - computed: true, optional: true, required: false
  private _extendedCommunities?: string; 
  public get extendedCommunities() {
    return this.getStringAttribute('extended_communities');
  }
  public set extendedCommunities(value: string) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: true, optional: true, required: false
  private _ipv4 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // large_communities - computed: true, optional: true, required: false
  private _largeCommunities?: string; 
  public get largeCommunities() {
    return this.getStringAttribute('large_communities');
  }
  public set largeCommunities(value: string) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: true, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // origin - computed: true, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // peer - computed: true, optional: true, required: false
  private _peer?: string; 
  public get peer() {
    return this.getStringAttribute('peer');
  }
  public set peer(value: string) {
    this._peer = value;
  }
  public resetPeer() {
    this._peer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer;
  }

  // regular_communities - computed: true, optional: true, required: false
  private _regularCommunities?: string; 
  public get regularCommunities() {
    return this.getStringAttribute('regular_communities');
  }
  public set regularCommunities(value: string) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric;
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricToTerraform(struct!.metric),
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric",
    },
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._nextHop = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._nextHop = value.nextHop;
      this._tag = value.tag;
    }
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRip {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRip | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRip | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileBgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ospf DataPanosFiltersRouteMapsRedistributionRoutingProfile#ospf}
  */
  readonly ospf?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ospfv3 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ospfv3}
  */
  readonly ospfv3?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#rib DataPanosFiltersRouteMapsRedistributionRoutingProfile#rib}
  */
  readonly rib?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRib;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#rip DataPanosFiltersRouteMapsRedistributionRoutingProfile#rip}
  */
  readonly rip?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRip;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ospf: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfToTerraform(struct!.ospf),
    ospfv3: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3ToTerraform(struct!.ospfv3),
    rib: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibToTerraform(struct!.rib),
    rip: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipToTerraform(struct!.rip),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ospf: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfToHclTerraform(struct!.ospf),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspf",
    },
    ospfv3: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3ToHclTerraform(struct!.ospfv3),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3",
    },
    rib: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibToHclTerraform(struct!.rib),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRib",
    },
    rip: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipToHclTerraform(struct!.rip),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRip",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ospf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospf = this._ospf?.internalValue;
    }
    if (this._ospfv3?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfv3 = this._ospfv3?.internalValue;
    }
    if (this._rib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rib = this._rib?.internalValue;
    }
    if (this._rip?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rip = this._rip?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ospf.internalValue = undefined;
      this._ospfv3.internalValue = undefined;
      this._rib.internalValue = undefined;
      this._rip.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ospf.internalValue = value.ospf;
      this._ospfv3.internalValue = value.ospfv3;
      this._rib.internalValue = value.rib;
      this._rip.internalValue = value.rip;
    }
  }

  // ospf - computed: true, optional: true, required: false
  private _ospf = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfOutputReference(this, "ospf");
  public get ospf() {
    return this._ospf;
  }
  public putOspf(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspf) {
    this._ospf.internalValue = value;
  }
  public resetOspf() {
    this._ospf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfInput() {
    return this._ospf.internalValue;
  }

  // ospfv3 - computed: true, optional: true, required: false
  private _ospfv3 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3OutputReference(this, "ospfv3");
  public get ospfv3() {
    return this._ospfv3;
  }
  public putOspfv3(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOspfv3) {
    this._ospfv3.internalValue = value;
  }
  public resetOspfv3() {
    this._ospfv3.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3Input() {
    return this._ospfv3.internalValue;
  }

  // rib - computed: true, optional: true, required: false
  private _rib = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRibOutputReference(this, "rib");
  public get rib() {
    return this._rib;
  }
  public putRib(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRib) {
    this._rib.internalValue = value;
  }
  public resetRib() {
    this._rib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ribInput() {
    return this._rib.internalValue;
  }

  // rip - computed: true, optional: true, required: false
  private _rip = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRipOutputReference(this, "rip");
  public get rip() {
    return this._rip;
  }
  public putRip(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpRip) {
    this._rip.internalValue = value;
  }
  public resetRip() {
    this._rip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ripInput() {
    return this._rip.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopToTerraform(struct!.nextHop),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch {
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv4 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv6 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    ipv6: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6ToTerraform(struct!.ipv6),
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4",
    },
    ipv6: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
      this._metric = value.metric;
    }
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: true, optional: true, required: false
  private _ipv4 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: true, optional: true, required: false
  private _ipv6 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator {
  /**
  * Set BGP Aggregator AS <1-4294967295>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#as DataPanosFiltersRouteMapsRedistributionRoutingProfile#as}
  */
  readonly as?: number;
  /**
  * Set BGP Aggregator Router ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#router_id DataPanosFiltersRouteMapsRedistributionRoutingProfile#router_id}
  */
  readonly routerId?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as: cdktf.numberToTerraform(struct!.as),
    router_id: cdktf.stringToTerraform(struct!.routerId),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as: {
      value: cdktf.numberToHclTerraform(struct!.as),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._as !== undefined) {
      hasAnyValues = true;
      internalValueResult.as = this._as;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._as = undefined;
      this._routerId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._as = value.as;
      this._routerId = value.routerId;
    }
  }

  // as - computed: true, optional: true, required: false
  private _as?: number; 
  public get as() {
    return this.getNumberAttribute('as');
  }
  public set as(value: number) {
    this._as = value;
  }
  public resetAs() {
    this._as = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asInput() {
    return this._as;
  }

  // router_id - computed: true, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4 {
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Source IPv4 Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#source_address DataPanosFiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nextHop = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nextHop = value.nextHop;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // source_address - computed: true, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6 {
  /**
  * Set IPv6 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Source IPv6 Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#source_address DataPanosFiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nextHop = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nextHop = value.nextHop;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // source_address - computed: true, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric {
  /**
  * Set Metric action (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#aggregator DataPanosFiltersRouteMapsRedistributionRoutingProfile#aggregator}
  */
  readonly aggregator?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#aspath_prepends DataPanosFiltersRouteMapsRedistributionRoutingProfile#aspath_prepends}
  */
  readonly aspathPrepends?: number[];
  /**
  * Enable BGP atomic aggregate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#atomic_aggregate DataPanosFiltersRouteMapsRedistributionRoutingProfile#atomic_aggregate}
  */
  readonly atomicAggregate?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#extended_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv4 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv6 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#large_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string[];
  /**
  * Set Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#local_preference DataPanosFiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric;
  /**
  * Set BGP origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#origin DataPanosFiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Set BGP Originator Id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#originator_id DataPanosFiltersRouteMapsRedistributionRoutingProfile#originator_id}
  */
  readonly originatorId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#regular_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string[];
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
  /**
  * Set BGP weight of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#weight DataPanosFiltersRouteMapsRedistributionRoutingProfile#weight}
  */
  readonly weight?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregator: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorToTerraform(struct!.aggregator),
    aspath_prepends: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.aspathPrepends),
    atomic_aggregate: cdktf.booleanToTerraform(struct!.atomicAggregate),
    extended_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extendedCommunities),
    ipv4: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4ToTerraform(struct!.ipv4),
    ipv6: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6ToTerraform(struct!.ipv6),
    large_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    originator_id: cdktf.stringToTerraform(struct!.originatorId),
    regular_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregator: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorToHclTerraform(struct!.aggregator),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator",
    },
    aspath_prepends: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.aspathPrepends),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    atomic_aggregate: {
      value: cdktf.booleanToHclTerraform(struct!.atomicAggregate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extended_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extendedCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ipv4: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4",
    },
    ipv6: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6",
    },
    large_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.largeCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    originator_id: {
      value: cdktf.stringToHclTerraform(struct!.originatorId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regularCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregator = this._aggregator?.internalValue;
    }
    if (this._aspathPrepends !== undefined) {
      hasAnyValues = true;
      internalValueResult.aspathPrepends = this._aspathPrepends;
    }
    if (this._atomicAggregate !== undefined) {
      hasAnyValues = true;
      internalValueResult.atomicAggregate = this._atomicAggregate;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._originatorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.originatorId = this._originatorId;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = undefined;
      this._aspathPrepends = undefined;
      this._atomicAggregate = undefined;
      this._extendedCommunities = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric.internalValue = undefined;
      this._origin = undefined;
      this._originatorId = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = value.aggregator;
      this._aspathPrepends = value.aspathPrepends;
      this._atomicAggregate = value.atomicAggregate;
      this._extendedCommunities = value.extendedCommunities;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric.internalValue = value.metric;
      this._origin = value.origin;
      this._originatorId = value.originatorId;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
      this._weight = value.weight;
    }
  }

  // aggregator - computed: true, optional: true, required: false
  private _aggregator = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorOutputReference(this, "aggregator");
  public get aggregator() {
    return this._aggregator;
  }
  public putAggregator(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator) {
    this._aggregator.internalValue = value;
  }
  public resetAggregator() {
    this._aggregator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregatorInput() {
    return this._aggregator.internalValue;
  }

  // aspath_prepends - computed: true, optional: true, required: false
  private _aspathPrepends?: number[]; 
  public get aspathPrepends() {
    return this.getNumberListAttribute('aspath_prepends');
  }
  public set aspathPrepends(value: number[]) {
    this._aspathPrepends = value;
  }
  public resetAspathPrepends() {
    this._aspathPrepends = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aspathPrependsInput() {
    return this._aspathPrepends;
  }

  // atomic_aggregate - computed: true, optional: true, required: false
  private _atomicAggregate?: boolean | cdktf.IResolvable; 
  public get atomicAggregate() {
    return this.getBooleanAttribute('atomic_aggregate');
  }
  public set atomicAggregate(value: boolean | cdktf.IResolvable) {
    this._atomicAggregate = value;
  }
  public resetAtomicAggregate() {
    this._atomicAggregate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atomicAggregateInput() {
    return this._atomicAggregate;
  }

  // extended_communities - computed: true, optional: true, required: false
  private _extendedCommunities?: string[]; 
  public get extendedCommunities() {
    return this.getListAttribute('extended_communities');
  }
  public set extendedCommunities(value: string[]) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // ipv4 - computed: true, optional: true, required: false
  private _ipv4 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: true, optional: true, required: false
  private _ipv6 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // large_communities - computed: true, optional: true, required: false
  private _largeCommunities?: string[]; 
  public get largeCommunities() {
    return this.getListAttribute('large_communities');
  }
  public set largeCommunities(value: string[]) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: true, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // origin - computed: true, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // originator_id - computed: true, optional: true, required: false
  private _originatorId?: string; 
  public get originatorId() {
    return this.getStringAttribute('originator_id');
  }
  public set originatorId(value: string) {
    this._originatorId = value;
  }
  public resetOriginatorId() {
    this._originatorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originatorIdInput() {
    return this._originatorId;
  }

  // regular_communities - computed: true, optional: true, required: false
  private _regularCommunities?: string[]; 
  public get regularCommunities() {
    return this.getListAttribute('regular_communities');
  }
  public set regularCommunities(value: string[]) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch {
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv4 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._metric = value.metric;
    }
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: true, optional: true, required: false
  private _ipv4 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric;
  /**
  * Set Metric-Type of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric_type DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric_type}
  */
  readonly metricType?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricToTerraform(struct!.metric),
    metric_type: cdktf.stringToTerraform(struct!.metricType),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric",
    },
    metric_type: {
      value: cdktf.stringToHclTerraform(struct!.metricType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._metricType !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricType = this._metricType;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._metricType = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._metricType = value.metricType;
      this._tag = value.tag;
    }
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // metric_type - computed: true, optional: true, required: false
  private _metricType?: string; 
  public get metricType() {
    return this.getStringAttribute('metric_type');
  }
  public set metricType(value: string) {
    this._metricType = value;
  }
  public resetMetricType() {
    this._metricType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricTypeInput() {
    return this._metricType;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopToTerraform(struct!.nextHop),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch {
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv6 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv6: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6ToTerraform(struct!.ipv6),
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv6: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ipv6.internalValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ipv6.internalValue = value.ipv6;
      this._metric = value.metric;
    }
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv6 - computed: true, optional: true, required: false
  private _ipv6 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric;
  /**
  * Set Metric-Type of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric_type DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric_type}
  */
  readonly metricType?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricToTerraform(struct!.metric),
    metric_type: cdktf.stringToTerraform(struct!.metricType),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric",
    },
    metric_type: {
      value: cdktf.stringToHclTerraform(struct!.metricType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._metricType !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricType = this._metricType;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._metricType = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._metricType = value.metricType;
      this._tag = value.tag;
    }
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // metric_type - computed: true, optional: true, required: false
  private _metricType?: string; 
  public get metricType() {
    return this.getStringAttribute('metric_type');
  }
  public set metricType(value: string) {
    this._metricType = value;
  }
  public resetMetricType() {
    this._metricType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricTypeInput() {
    return this._metricType;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopToTerraform(struct!.nextHop),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch {
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv4 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv6 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    ipv6: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6ToTerraform(struct!.ipv6),
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4",
    },
    ipv6: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
      this._metric = value.metric;
    }
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: true, optional: true, required: false
  private _ipv4 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: true, optional: true, required: false
  private _ipv6 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet {
  /**
  * Set Source IPv4 or IPv6 address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#source_address DataPanosFiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // source_address - computed: true, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch {
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv4 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._metric = value.metric;
    }
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: true, optional: true, required: false
  private _ipv4 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric;
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricToTerraform(struct!.metric),
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric",
    },
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._nextHop = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._nextHop = value.nextHop;
      this._tag = value.tag;
    }
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStatic {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#bgp DataPanosFiltersRouteMapsRedistributionRoutingProfile#bgp}
  */
  readonly bgp?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ospf DataPanosFiltersRouteMapsRedistributionRoutingProfile#ospf}
  */
  readonly ospf?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ospfv3 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ospfv3}
  */
  readonly ospfv3?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#rib DataPanosFiltersRouteMapsRedistributionRoutingProfile#rib}
  */
  readonly rib?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#rip DataPanosFiltersRouteMapsRedistributionRoutingProfile#rip}
  */
  readonly rip?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStatic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bgp: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpToTerraform(struct!.bgp),
    ospf: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfToTerraform(struct!.ospf),
    ospfv3: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3ToTerraform(struct!.ospfv3),
    rib: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibToTerraform(struct!.rib),
    rip: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipToTerraform(struct!.rip),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStatic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bgp: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpToHclTerraform(struct!.bgp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp",
    },
    ospf: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfToHclTerraform(struct!.ospf),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf",
    },
    ospfv3: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3ToHclTerraform(struct!.ospfv3),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3",
    },
    rib: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibToHclTerraform(struct!.rib),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib",
    },
    rip: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipToHclTerraform(struct!.rip),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStatic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgp = this._bgp?.internalValue;
    }
    if (this._ospf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospf = this._ospf?.internalValue;
    }
    if (this._ospfv3?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfv3 = this._ospfv3?.internalValue;
    }
    if (this._rib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rib = this._rib?.internalValue;
    }
    if (this._rip?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rip = this._rip?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStatic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bgp.internalValue = undefined;
      this._ospf.internalValue = undefined;
      this._ospfv3.internalValue = undefined;
      this._rib.internalValue = undefined;
      this._rip.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bgp.internalValue = value.bgp;
      this._ospf.internalValue = value.ospf;
      this._ospfv3.internalValue = value.ospfv3;
      this._rib.internalValue = value.rib;
      this._rip.internalValue = value.rip;
    }
  }

  // bgp - computed: true, optional: true, required: false
  private _bgp = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpOutputReference(this, "bgp");
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // ospf - computed: true, optional: true, required: false
  private _ospf = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfOutputReference(this, "ospf");
  public get ospf() {
    return this._ospf;
  }
  public putOspf(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf) {
    this._ospf.internalValue = value;
  }
  public resetOspf() {
    this._ospf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfInput() {
    return this._ospf.internalValue;
  }

  // ospfv3 - computed: true, optional: true, required: false
  private _ospfv3 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3OutputReference(this, "ospfv3");
  public get ospfv3() {
    return this._ospfv3;
  }
  public putOspfv3(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3) {
    this._ospfv3.internalValue = value;
  }
  public resetOspfv3() {
    this._ospfv3.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3Input() {
    return this._ospfv3.internalValue;
  }

  // rib - computed: true, optional: true, required: false
  private _rib = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibOutputReference(this, "rib");
  public get rib() {
    return this._rib;
  }
  public putRib(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib) {
    this._rib.internalValue = value;
  }
  public resetRib() {
    this._rib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ribInput() {
    return this._rib.internalValue;
  }

  // rip - computed: true, optional: true, required: false
  private _rip = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipOutputReference(this, "rip");
  public get rip() {
    return this._rip;
  }
  public putRip(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip) {
    this._rip.internalValue = value;
  }
  public resetRip() {
    this._rip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ripInput() {
    return this._rip.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfw {
  /**
  * The NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ngfw_device DataPanosFiltersRouteMapsRedistributionRoutingProfile#ngfw_device}
  */
  readonly ngfwDevice?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfwToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ngfw_device: cdktf.stringToTerraform(struct!.ngfwDevice),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfwToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ngfw_device: {
      value: cdktf.stringToHclTerraform(struct!.ngfwDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfwOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfw | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ngfwDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfwDevice = this._ngfwDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfw | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ngfwDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ngfwDevice = value.ngfwDevice;
    }
  }

  // ngfw_device - computed: true, optional: true, required: false
  private _ngfwDevice?: string; 
  public get ngfwDevice() {
    return this.getStringAttribute('ngfw_device');
  }
  public set ngfwDevice(value: string) {
    this._ngfwDevice = value;
  }
  public resetNgfwDevice() {
    this._ngfwDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwDeviceInput() {
    return this._ngfwDevice;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplate {
  /**
  * Specific Panorama template
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name?: string;
  /**
  * The NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ngfw_device DataPanosFiltersRouteMapsRedistributionRoutingProfile#ngfw_device}
  */
  readonly ngfwDevice?: string;
  /**
  * Specific Panorama device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#panorama_device DataPanosFiltersRouteMapsRedistributionRoutingProfile#panorama_device}
  */
  readonly panoramaDevice?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    ngfw_device: cdktf.stringToTerraform(struct!.ngfwDevice),
    panorama_device: cdktf.stringToTerraform(struct!.panoramaDevice),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ngfw_device: {
      value: cdktf.stringToHclTerraform(struct!.ngfwDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    panorama_device: {
      value: cdktf.stringToHclTerraform(struct!.panoramaDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._ngfwDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfwDevice = this._ngfwDevice;
    }
    if (this._panoramaDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.panoramaDevice = this._panoramaDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._ngfwDevice = undefined;
      this._panoramaDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._ngfwDevice = value.ngfwDevice;
      this._panoramaDevice = value.panoramaDevice;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ngfw_device - computed: true, optional: true, required: false
  private _ngfwDevice?: string; 
  public get ngfwDevice() {
    return this.getStringAttribute('ngfw_device');
  }
  public set ngfwDevice(value: string) {
    this._ngfwDevice = value;
  }
  public resetNgfwDevice() {
    this._ngfwDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwDeviceInput() {
    return this._ngfwDevice;
  }

  // panorama_device - computed: true, optional: true, required: false
  private _panoramaDevice?: string; 
  public get panoramaDevice() {
    return this.getStringAttribute('panorama_device');
  }
  public set panoramaDevice(value: string) {
    this._panoramaDevice = value;
  }
  public resetPanoramaDevice() {
    this._panoramaDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get panoramaDeviceInput() {
    return this._panoramaDevice;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack {
  /**
  * Specific Panorama template stack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name?: string;
  /**
  * The NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ngfw_device DataPanosFiltersRouteMapsRedistributionRoutingProfile#ngfw_device}
  */
  readonly ngfwDevice?: string;
  /**
  * Specific Panorama device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#panorama_device DataPanosFiltersRouteMapsRedistributionRoutingProfile#panorama_device}
  */
  readonly panoramaDevice?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStackToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    ngfw_device: cdktf.stringToTerraform(struct!.ngfwDevice),
    panorama_device: cdktf.stringToTerraform(struct!.panoramaDevice),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStackToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ngfw_device: {
      value: cdktf.stringToHclTerraform(struct!.ngfwDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    panorama_device: {
      value: cdktf.stringToHclTerraform(struct!.panoramaDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStackOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._ngfwDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfwDevice = this._ngfwDevice;
    }
    if (this._panoramaDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.panoramaDevice = this._panoramaDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._ngfwDevice = undefined;
      this._panoramaDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._ngfwDevice = value.ngfwDevice;
      this._panoramaDevice = value.panoramaDevice;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ngfw_device - computed: true, optional: true, required: false
  private _ngfwDevice?: string; 
  public get ngfwDevice() {
    return this.getStringAttribute('ngfw_device');
  }
  public set ngfwDevice(value: string) {
    this._ngfwDevice = value;
  }
  public resetNgfwDevice() {
    this._ngfwDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwDeviceInput() {
    return this._ngfwDevice;
  }

  // panorama_device - computed: true, optional: true, required: false
  private _panoramaDevice?: string; 
  public get panoramaDevice() {
    return this.getStringAttribute('panorama_device');
  }
  public set panoramaDevice(value: string) {
    this._panoramaDevice = value;
  }
  public resetPanoramaDevice() {
    this._panoramaDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get panoramaDeviceInput() {
    return this._panoramaDevice;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileLocation {
  /**
  * Located in a specific NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ngfw DataPanosFiltersRouteMapsRedistributionRoutingProfile#ngfw}
  */
  readonly ngfw?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfw;
  /**
  * Located in a specific template
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#template DataPanosFiltersRouteMapsRedistributionRoutingProfile#template}
  */
  readonly template?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplate;
  /**
  * Located in a specific template stack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#template_stack DataPanosFiltersRouteMapsRedistributionRoutingProfile#template_stack}
  */
  readonly templateStack?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ngfw: dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfwToTerraform(struct!.ngfw),
    template: dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateToTerraform(struct!.template),
    template_stack: dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStackToTerraform(struct!.templateStack),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ngfw: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfwToHclTerraform(struct!.ngfw),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfw",
    },
    template: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplate",
    },
    template_stack: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStackToHclTerraform(struct!.templateStack),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileLocation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ngfw?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfw = this._ngfw?.internalValue;
    }
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    if (this._templateStack?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.templateStack = this._templateStack?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ngfw.internalValue = undefined;
      this._template.internalValue = undefined;
      this._templateStack.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ngfw.internalValue = value.ngfw;
      this._template.internalValue = value.template;
      this._templateStack.internalValue = value.templateStack;
    }
  }

  // ngfw - computed: false, optional: true, required: false
  private _ngfw = new DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfwOutputReference(this, "ngfw");
  public get ngfw() {
    return this._ngfw;
  }
  public putNgfw(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationNgfw) {
    this._ngfw.internalValue = value;
  }
  public resetNgfw() {
    this._ngfw.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwInput() {
    return this._ngfw.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template = new DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }

  // template_stack - computed: false, optional: true, required: false
  private _templateStack = new DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStackOutputReference(this, "template_stack");
  public get templateStack() {
    return this._templateStack;
  }
  public putTemplateStack(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack) {
    this._templateStack.internalValue = value;
  }
  public resetTemplateStack() {
    this._templateStack.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateStackInput() {
    return this._templateStack.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator {
  /**
  * Set BGP Aggregator AS <1-4294967295>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#as DataPanosFiltersRouteMapsRedistributionRoutingProfile#as}
  */
  readonly as?: number;
  /**
  * Set BGP Aggregator Router ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#router_id DataPanosFiltersRouteMapsRedistributionRoutingProfile#router_id}
  */
  readonly routerId?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as: cdktf.numberToTerraform(struct!.as),
    router_id: cdktf.stringToTerraform(struct!.routerId),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as: {
      value: cdktf.numberToHclTerraform(struct!.as),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._as !== undefined) {
      hasAnyValues = true;
      internalValueResult.as = this._as;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._as = undefined;
      this._routerId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._as = value.as;
      this._routerId = value.routerId;
    }
  }

  // as - computed: true, optional: true, required: false
  private _as?: number; 
  public get as() {
    return this.getNumberAttribute('as');
  }
  public set as(value: number) {
    this._as = value;
  }
  public resetAs() {
    this._as = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asInput() {
    return this._as;
  }

  // router_id - computed: true, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4 {
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Source IPv4 Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#source_address DataPanosFiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nextHop = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nextHop = value.nextHop;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // source_address - computed: true, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric {
  /**
  * Set Metric action (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#aggregator DataPanosFiltersRouteMapsRedistributionRoutingProfile#aggregator}
  */
  readonly aggregator?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#aspath_prepends DataPanosFiltersRouteMapsRedistributionRoutingProfile#aspath_prepends}
  */
  readonly aspathPrepends?: number[];
  /**
  * Enable BGP atomic aggregate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#atomic_aggregate DataPanosFiltersRouteMapsRedistributionRoutingProfile#atomic_aggregate}
  */
  readonly atomicAggregate?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#extended_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv4 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#large_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string[];
  /**
  * Set Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#local_preference DataPanosFiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric;
  /**
  * Set BGP origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#origin DataPanosFiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Set BGP Originator Id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#originator_id DataPanosFiltersRouteMapsRedistributionRoutingProfile#originator_id}
  */
  readonly originatorId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#regular_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string[];
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
  /**
  * Set BGP weight of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#weight DataPanosFiltersRouteMapsRedistributionRoutingProfile#weight}
  */
  readonly weight?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregator: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorToTerraform(struct!.aggregator),
    aspath_prepends: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.aspathPrepends),
    atomic_aggregate: cdktf.booleanToTerraform(struct!.atomicAggregate),
    extended_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extendedCommunities),
    ipv4: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4ToTerraform(struct!.ipv4),
    large_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    originator_id: cdktf.stringToTerraform(struct!.originatorId),
    regular_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregator: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorToHclTerraform(struct!.aggregator),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator",
    },
    aspath_prepends: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.aspathPrepends),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    atomic_aggregate: {
      value: cdktf.booleanToHclTerraform(struct!.atomicAggregate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extended_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extendedCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ipv4: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4",
    },
    large_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.largeCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    originator_id: {
      value: cdktf.stringToHclTerraform(struct!.originatorId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regularCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregator = this._aggregator?.internalValue;
    }
    if (this._aspathPrepends !== undefined) {
      hasAnyValues = true;
      internalValueResult.aspathPrepends = this._aspathPrepends;
    }
    if (this._atomicAggregate !== undefined) {
      hasAnyValues = true;
      internalValueResult.atomicAggregate = this._atomicAggregate;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._originatorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.originatorId = this._originatorId;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = undefined;
      this._aspathPrepends = undefined;
      this._atomicAggregate = undefined;
      this._extendedCommunities = undefined;
      this._ipv4.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric.internalValue = undefined;
      this._origin = undefined;
      this._originatorId = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = value.aggregator;
      this._aspathPrepends = value.aspathPrepends;
      this._atomicAggregate = value.atomicAggregate;
      this._extendedCommunities = value.extendedCommunities;
      this._ipv4.internalValue = value.ipv4;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric.internalValue = value.metric;
      this._origin = value.origin;
      this._originatorId = value.originatorId;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
      this._weight = value.weight;
    }
  }

  // aggregator - computed: true, optional: true, required: false
  private _aggregator = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorOutputReference(this, "aggregator");
  public get aggregator() {
    return this._aggregator;
  }
  public putAggregator(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator) {
    this._aggregator.internalValue = value;
  }
  public resetAggregator() {
    this._aggregator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregatorInput() {
    return this._aggregator.internalValue;
  }

  // aspath_prepends - computed: true, optional: true, required: false
  private _aspathPrepends?: number[]; 
  public get aspathPrepends() {
    return this.getNumberListAttribute('aspath_prepends');
  }
  public set aspathPrepends(value: number[]) {
    this._aspathPrepends = value;
  }
  public resetAspathPrepends() {
    this._aspathPrepends = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aspathPrependsInput() {
    return this._aspathPrepends;
  }

  // atomic_aggregate - computed: true, optional: true, required: false
  private _atomicAggregate?: boolean | cdktf.IResolvable; 
  public get atomicAggregate() {
    return this.getBooleanAttribute('atomic_aggregate');
  }
  public set atomicAggregate(value: boolean | cdktf.IResolvable) {
    this._atomicAggregate = value;
  }
  public resetAtomicAggregate() {
    this._atomicAggregate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atomicAggregateInput() {
    return this._atomicAggregate;
  }

  // extended_communities - computed: true, optional: true, required: false
  private _extendedCommunities?: string[]; 
  public get extendedCommunities() {
    return this.getListAttribute('extended_communities');
  }
  public set extendedCommunities(value: string[]) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // ipv4 - computed: true, optional: true, required: false
  private _ipv4 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // large_communities - computed: true, optional: true, required: false
  private _largeCommunities?: string[]; 
  public get largeCommunities() {
    return this.getListAttribute('large_communities');
  }
  public set largeCommunities(value: string[]) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: true, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // origin - computed: true, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // originator_id - computed: true, optional: true, required: false
  private _originatorId?: string; 
  public get originatorId() {
    return this.getStringAttribute('originator_id');
  }
  public set originatorId(value: string) {
    this._originatorId = value;
  }
  public resetOriginatorId() {
    this._originatorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originatorIdInput() {
    return this._originatorId;
  }

  // regular_communities - computed: true, optional: true, required: false
  private _regularCommunities?: string[]; 
  public get regularCommunities() {
    return this.getListAttribute('regular_communities');
  }
  public set regularCommunities(value: string[]) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet {
  /**
  * Set Source IPv4 or IPv6 address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#source_address DataPanosFiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // source_address - computed: true, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRib {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric;
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricToTerraform(struct!.metric),
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric",
    },
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._nextHop = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._nextHop = value.nextHop;
      this._tag = value.tag;
    }
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRip {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRip | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRip | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#bgp DataPanosFiltersRouteMapsRedistributionRoutingProfile#bgp}
  */
  readonly bgp?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#rib DataPanosFiltersRouteMapsRedistributionRoutingProfile#rib}
  */
  readonly rib?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRib;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#rip DataPanosFiltersRouteMapsRedistributionRoutingProfile#rip}
  */
  readonly rip?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRip;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bgp: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpToTerraform(struct!.bgp),
    rib: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibToTerraform(struct!.rib),
    rip: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipToTerraform(struct!.rip),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bgp: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpToHclTerraform(struct!.bgp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgp",
    },
    rib: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibToHclTerraform(struct!.rib),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRib",
    },
    rip: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipToHclTerraform(struct!.rip),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRip",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgp = this._bgp?.internalValue;
    }
    if (this._rib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rib = this._rib?.internalValue;
    }
    if (this._rip?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rip = this._rip?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bgp.internalValue = undefined;
      this._rib.internalValue = undefined;
      this._rip.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bgp.internalValue = value.bgp;
      this._rib.internalValue = value.rib;
      this._rip.internalValue = value.rip;
    }
  }

  // bgp - computed: true, optional: true, required: false
  private _bgp = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgpOutputReference(this, "bgp");
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfBgp) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // rib - computed: true, optional: true, required: false
  private _rib = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRibOutputReference(this, "rib");
  public get rib() {
    return this._rib;
  }
  public putRib(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRib) {
    this._rib.internalValue = value;
  }
  public resetRib() {
    this._rib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ribInput() {
    return this._rib.internalValue;
  }

  // rip - computed: true, optional: true, required: false
  private _rip = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRipOutputReference(this, "rip");
  public get rip() {
    return this._rip;
  }
  public putRip(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfRip) {
    this._rip.internalValue = value;
  }
  public resetRip() {
    this._rip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ripInput() {
    return this._rip.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator {
  /**
  * Set BGP Aggregator AS <1-4294967295>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#as DataPanosFiltersRouteMapsRedistributionRoutingProfile#as}
  */
  readonly as?: number;
  /**
  * Set BGP Aggregator Router ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#router_id DataPanosFiltersRouteMapsRedistributionRoutingProfile#router_id}
  */
  readonly routerId?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as: cdktf.numberToTerraform(struct!.as),
    router_id: cdktf.stringToTerraform(struct!.routerId),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as: {
      value: cdktf.numberToHclTerraform(struct!.as),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._as !== undefined) {
      hasAnyValues = true;
      internalValueResult.as = this._as;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._as = undefined;
      this._routerId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._as = value.as;
      this._routerId = value.routerId;
    }
  }

  // as - computed: true, optional: true, required: false
  private _as?: number; 
  public get as() {
    return this.getNumberAttribute('as');
  }
  public set as(value: number) {
    this._as = value;
  }
  public resetAs() {
    this._as = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asInput() {
    return this._as;
  }

  // router_id - computed: true, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6 {
  /**
  * Set IPv6 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Source IPv6 Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#source_address DataPanosFiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nextHop = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nextHop = value.nextHop;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // source_address - computed: true, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric {
  /**
  * Set Metric action (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#aggregator DataPanosFiltersRouteMapsRedistributionRoutingProfile#aggregator}
  */
  readonly aggregator?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#aspath_prepends DataPanosFiltersRouteMapsRedistributionRoutingProfile#aspath_prepends}
  */
  readonly aspathPrepends?: number[];
  /**
  * Enable BGP atomic aggregate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#atomic_aggregate DataPanosFiltersRouteMapsRedistributionRoutingProfile#atomic_aggregate}
  */
  readonly atomicAggregate?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#extended_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv6 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#large_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string[];
  /**
  * Set Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#local_preference DataPanosFiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric;
  /**
  * Set BGP origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#origin DataPanosFiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Set BGP Originator Id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#originator_id DataPanosFiltersRouteMapsRedistributionRoutingProfile#originator_id}
  */
  readonly originatorId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#regular_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string[];
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
  /**
  * Set BGP weight of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#weight DataPanosFiltersRouteMapsRedistributionRoutingProfile#weight}
  */
  readonly weight?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregator: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorToTerraform(struct!.aggregator),
    aspath_prepends: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.aspathPrepends),
    atomic_aggregate: cdktf.booleanToTerraform(struct!.atomicAggregate),
    extended_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extendedCommunities),
    ipv6: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6ToTerraform(struct!.ipv6),
    large_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    originator_id: cdktf.stringToTerraform(struct!.originatorId),
    regular_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregator: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorToHclTerraform(struct!.aggregator),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator",
    },
    aspath_prepends: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.aspathPrepends),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    atomic_aggregate: {
      value: cdktf.booleanToHclTerraform(struct!.atomicAggregate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extended_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extendedCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ipv6: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6",
    },
    large_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.largeCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    originator_id: {
      value: cdktf.stringToHclTerraform(struct!.originatorId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regularCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregator = this._aggregator?.internalValue;
    }
    if (this._aspathPrepends !== undefined) {
      hasAnyValues = true;
      internalValueResult.aspathPrepends = this._aspathPrepends;
    }
    if (this._atomicAggregate !== undefined) {
      hasAnyValues = true;
      internalValueResult.atomicAggregate = this._atomicAggregate;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._originatorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.originatorId = this._originatorId;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = undefined;
      this._aspathPrepends = undefined;
      this._atomicAggregate = undefined;
      this._extendedCommunities = undefined;
      this._ipv6.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric.internalValue = undefined;
      this._origin = undefined;
      this._originatorId = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = value.aggregator;
      this._aspathPrepends = value.aspathPrepends;
      this._atomicAggregate = value.atomicAggregate;
      this._extendedCommunities = value.extendedCommunities;
      this._ipv6.internalValue = value.ipv6;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric.internalValue = value.metric;
      this._origin = value.origin;
      this._originatorId = value.originatorId;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
      this._weight = value.weight;
    }
  }

  // aggregator - computed: true, optional: true, required: false
  private _aggregator = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorOutputReference(this, "aggregator");
  public get aggregator() {
    return this._aggregator;
  }
  public putAggregator(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator) {
    this._aggregator.internalValue = value;
  }
  public resetAggregator() {
    this._aggregator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregatorInput() {
    return this._aggregator.internalValue;
  }

  // aspath_prepends - computed: true, optional: true, required: false
  private _aspathPrepends?: number[]; 
  public get aspathPrepends() {
    return this.getNumberListAttribute('aspath_prepends');
  }
  public set aspathPrepends(value: number[]) {
    this._aspathPrepends = value;
  }
  public resetAspathPrepends() {
    this._aspathPrepends = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aspathPrependsInput() {
    return this._aspathPrepends;
  }

  // atomic_aggregate - computed: true, optional: true, required: false
  private _atomicAggregate?: boolean | cdktf.IResolvable; 
  public get atomicAggregate() {
    return this.getBooleanAttribute('atomic_aggregate');
  }
  public set atomicAggregate(value: boolean | cdktf.IResolvable) {
    this._atomicAggregate = value;
  }
  public resetAtomicAggregate() {
    this._atomicAggregate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atomicAggregateInput() {
    return this._atomicAggregate;
  }

  // extended_communities - computed: true, optional: true, required: false
  private _extendedCommunities?: string[]; 
  public get extendedCommunities() {
    return this.getListAttribute('extended_communities');
  }
  public set extendedCommunities(value: string[]) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // ipv6 - computed: true, optional: true, required: false
  private _ipv6 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // large_communities - computed: true, optional: true, required: false
  private _largeCommunities?: string[]; 
  public get largeCommunities() {
    return this.getListAttribute('large_communities');
  }
  public set largeCommunities(value: string[]) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: true, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // origin - computed: true, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // originator_id - computed: true, optional: true, required: false
  private _originatorId?: string; 
  public get originatorId() {
    return this.getStringAttribute('originator_id');
  }
  public set originatorId(value: string) {
    this._originatorId = value;
  }
  public resetOriginatorId() {
    this._originatorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originatorIdInput() {
    return this._originatorId;
  }

  // regular_communities - computed: true, optional: true, required: false
  private _regularCommunities?: string[]; 
  public get regularCommunities() {
    return this.getListAttribute('regular_communities');
  }
  public set regularCommunities(value: string[]) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet {
  /**
  * Set Source IPv4 or IPv6 address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#source_address DataPanosFiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // source_address - computed: true, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Rib {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Rib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Rib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Rib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Rib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#bgp DataPanosFiltersRouteMapsRedistributionRoutingProfile#bgp}
  */
  readonly bgp?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#rib DataPanosFiltersRouteMapsRedistributionRoutingProfile#rib}
  */
  readonly rib?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Rib;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bgp: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpToTerraform(struct!.bgp),
    rib: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibToTerraform(struct!.rib),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bgp: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpToHclTerraform(struct!.bgp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp",
    },
    rib: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibToHclTerraform(struct!.rib),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Rib",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgp = this._bgp?.internalValue;
    }
    if (this._rib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rib = this._rib?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bgp.internalValue = undefined;
      this._rib.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bgp.internalValue = value.bgp;
      this._rib.internalValue = value.rib;
    }
  }

  // bgp - computed: true, optional: true, required: false
  private _bgp = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3BgpOutputReference(this, "bgp");
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // rib - computed: true, optional: true, required: false
  private _rib = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3RibOutputReference(this, "rib");
  public get rib() {
    return this._rib;
  }
  public putRib(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3Rib) {
    this._rib.internalValue = value;
  }
  public resetRib() {
    this._rib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ribInput() {
    return this._rib.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator {
  /**
  * Set BGP Aggregator AS <1-4294967295>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#as DataPanosFiltersRouteMapsRedistributionRoutingProfile#as}
  */
  readonly as?: number;
  /**
  * Set BGP Aggregator Router ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#router_id DataPanosFiltersRouteMapsRedistributionRoutingProfile#router_id}
  */
  readonly routerId?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as: cdktf.numberToTerraform(struct!.as),
    router_id: cdktf.stringToTerraform(struct!.routerId),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as: {
      value: cdktf.numberToHclTerraform(struct!.as),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._as !== undefined) {
      hasAnyValues = true;
      internalValueResult.as = this._as;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._as = undefined;
      this._routerId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._as = value.as;
      this._routerId = value.routerId;
    }
  }

  // as - computed: true, optional: true, required: false
  private _as?: number; 
  public get as() {
    return this.getNumberAttribute('as');
  }
  public set as(value: number) {
    this._as = value;
  }
  public resetAs() {
    this._as = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asInput() {
    return this._as;
  }

  // router_id - computed: true, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4 {
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Source IPv4 Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#source_address DataPanosFiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4ToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4ToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nextHop = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nextHop = value.nextHop;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // source_address - computed: true, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric {
  /**
  * Set Metric action (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#aggregator DataPanosFiltersRouteMapsRedistributionRoutingProfile#aggregator}
  */
  readonly aggregator?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#aspath_prepends DataPanosFiltersRouteMapsRedistributionRoutingProfile#aspath_prepends}
  */
  readonly aspathPrepends?: number[];
  /**
  * Enable BGP atomic aggregate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#atomic_aggregate DataPanosFiltersRouteMapsRedistributionRoutingProfile#atomic_aggregate}
  */
  readonly atomicAggregate?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#extended_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ipv4 DataPanosFiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#large_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string[];
  /**
  * Set Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#local_preference DataPanosFiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric;
  /**
  * Set BGP origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#origin DataPanosFiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Set BGP Originator Id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#originator_id DataPanosFiltersRouteMapsRedistributionRoutingProfile#originator_id}
  */
  readonly originatorId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#regular_communities DataPanosFiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string[];
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
  /**
  * Set BGP weight of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#weight DataPanosFiltersRouteMapsRedistributionRoutingProfile#weight}
  */
  readonly weight?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregator: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorToTerraform(struct!.aggregator),
    aspath_prepends: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.aspathPrepends),
    atomic_aggregate: cdktf.booleanToTerraform(struct!.atomicAggregate),
    extended_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extendedCommunities),
    ipv4: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4ToTerraform(struct!.ipv4),
    large_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    originator_id: cdktf.stringToTerraform(struct!.originatorId),
    regular_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregator: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorToHclTerraform(struct!.aggregator),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator",
    },
    aspath_prepends: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.aspathPrepends),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    atomic_aggregate: {
      value: cdktf.booleanToHclTerraform(struct!.atomicAggregate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extended_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extendedCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ipv4: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4",
    },
    large_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.largeCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    originator_id: {
      value: cdktf.stringToHclTerraform(struct!.originatorId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regularCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregator = this._aggregator?.internalValue;
    }
    if (this._aspathPrepends !== undefined) {
      hasAnyValues = true;
      internalValueResult.aspathPrepends = this._aspathPrepends;
    }
    if (this._atomicAggregate !== undefined) {
      hasAnyValues = true;
      internalValueResult.atomicAggregate = this._atomicAggregate;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._originatorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.originatorId = this._originatorId;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = undefined;
      this._aspathPrepends = undefined;
      this._atomicAggregate = undefined;
      this._extendedCommunities = undefined;
      this._ipv4.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric.internalValue = undefined;
      this._origin = undefined;
      this._originatorId = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = value.aggregator;
      this._aspathPrepends = value.aspathPrepends;
      this._atomicAggregate = value.atomicAggregate;
      this._extendedCommunities = value.extendedCommunities;
      this._ipv4.internalValue = value.ipv4;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric.internalValue = value.metric;
      this._origin = value.origin;
      this._originatorId = value.originatorId;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
      this._weight = value.weight;
    }
  }

  // aggregator - computed: true, optional: true, required: false
  private _aggregator = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorOutputReference(this, "aggregator");
  public get aggregator() {
    return this._aggregator;
  }
  public putAggregator(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator) {
    this._aggregator.internalValue = value;
  }
  public resetAggregator() {
    this._aggregator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregatorInput() {
    return this._aggregator.internalValue;
  }

  // aspath_prepends - computed: true, optional: true, required: false
  private _aspathPrepends?: number[]; 
  public get aspathPrepends() {
    return this.getNumberListAttribute('aspath_prepends');
  }
  public set aspathPrepends(value: number[]) {
    this._aspathPrepends = value;
  }
  public resetAspathPrepends() {
    this._aspathPrepends = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aspathPrependsInput() {
    return this._aspathPrepends;
  }

  // atomic_aggregate - computed: true, optional: true, required: false
  private _atomicAggregate?: boolean | cdktf.IResolvable; 
  public get atomicAggregate() {
    return this.getBooleanAttribute('atomic_aggregate');
  }
  public set atomicAggregate(value: boolean | cdktf.IResolvable) {
    this._atomicAggregate = value;
  }
  public resetAtomicAggregate() {
    this._atomicAggregate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atomicAggregateInput() {
    return this._atomicAggregate;
  }

  // extended_communities - computed: true, optional: true, required: false
  private _extendedCommunities?: string[]; 
  public get extendedCommunities() {
    return this.getListAttribute('extended_communities');
  }
  public set extendedCommunities(value: string[]) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // ipv4 - computed: true, optional: true, required: false
  private _ipv4 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // large_communities - computed: true, optional: true, required: false
  private _largeCommunities?: string[]; 
  public get largeCommunities() {
    return this.getListAttribute('large_communities');
  }
  public set largeCommunities(value: string[]) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: true, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // origin - computed: true, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // originator_id - computed: true, optional: true, required: false
  private _originatorId?: string; 
  public get originatorId() {
    return this.getStringAttribute('originator_id');
  }
  public set originatorId(value: string) {
    this._originatorId = value;
  }
  public resetOriginatorId() {
    this._originatorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originatorIdInput() {
    return this._originatorId;
  }

  // regular_communities - computed: true, optional: true, required: false
  private _regularCommunities?: string[]; 
  public get regularCommunities() {
    return this.getListAttribute('regular_communities');
  }
  public set regularCommunities(value: string[]) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#value DataPanosFiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric;
  /**
  * Set Metric-Type of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric_type DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric_type}
  */
  readonly metricType?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricToTerraform(struct!.metric),
    metric_type: cdktf.stringToTerraform(struct!.metricType),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric",
    },
    metric_type: {
      value: cdktf.stringToHclTerraform(struct!.metricType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._metricType !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricType = this._metricType;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._metricType = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._metricType = value.metricType;
      this._tag = value.tag;
    }
  }

  // metric - computed: true, optional: true, required: false
  private _metric = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // metric_type - computed: true, optional: true, required: false
  private _metricType?: string; 
  public get metricType() {
    return this.getStringAttribute('metric_type');
  }
  public set metricType(value: string) {
    this._metricType = value;
  }
  public resetMetricType() {
    this._metricType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricTypeInput() {
    return this._metricType;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#access_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#prefix_list DataPanosFiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: true, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: true, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#address DataPanosFiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#interface DataPanosFiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#metric DataPanosFiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#next_hop DataPanosFiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#tag DataPanosFiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: true, optional: true, required: false
  private _address = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: true, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: true, optional: true, required: false
  private _nextHop = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: true, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet {
  /**
  * Set Source IPv4 or IPv6 address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#source_address DataPanosFiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // source_address - computed: true, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#action DataPanosFiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#description DataPanosFiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#match DataPanosFiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#name DataPanosFiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#set DataPanosFiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetToTerraform(struct!.set),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: true, optional: true, required: false
  private _match = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: true, optional: true, required: false
  private _set = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapList extends cdktf.ComplexList {
  public internalValue? : DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapOutputReference {
    return new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRib {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#route_map DataPanosFiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap[] | cdktf.IResolvable;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: true, optional: true, required: false
  private _routeMap = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface DataPanosFiltersRouteMapsRedistributionRoutingProfileRip {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#bgp DataPanosFiltersRouteMapsRedistributionRoutingProfile#bgp}
  */
  readonly bgp?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#ospf DataPanosFiltersRouteMapsRedistributionRoutingProfile#ospf}
  */
  readonly ospf?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#rib DataPanosFiltersRouteMapsRedistributionRoutingProfile#rib}
  */
  readonly rib?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRib;
}

export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipToTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bgp: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpToTerraform(struct!.bgp),
    ospf: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfToTerraform(struct!.ospf),
    rib: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibToTerraform(struct!.rib),
  }
}


export function dataPanosFiltersRouteMapsRedistributionRoutingProfileRipToHclTerraform(struct?: DataPanosFiltersRouteMapsRedistributionRoutingProfileRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bgp: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpToHclTerraform(struct!.bgp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgp",
    },
    ospf: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfToHclTerraform(struct!.ospf),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspf",
    },
    rib: {
      value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibToHclTerraform(struct!.rib),
      isBlock: true,
      type: "struct",
      storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRib",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataPanosFiltersRouteMapsRedistributionRoutingProfileRip | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgp = this._bgp?.internalValue;
    }
    if (this._ospf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospf = this._ospf?.internalValue;
    }
    if (this._rib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rib = this._rib?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRip | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bgp.internalValue = undefined;
      this._ospf.internalValue = undefined;
      this._rib.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bgp.internalValue = value.bgp;
      this._ospf.internalValue = value.ospf;
      this._rib.internalValue = value.rib;
    }
  }

  // bgp - computed: true, optional: true, required: false
  private _bgp = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgpOutputReference(this, "bgp");
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipBgp) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // ospf - computed: true, optional: true, required: false
  private _ospf = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspfOutputReference(this, "ospf");
  public get ospf() {
    return this._ospf;
  }
  public putOspf(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOspf) {
    this._ospf.internalValue = value;
  }
  public resetOspf() {
    this._ospf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfInput() {
    return this._ospf.internalValue;
  }

  // rib - computed: true, optional: true, required: false
  private _rib = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRibOutputReference(this, "rib");
  public get rib() {
    return this._rib;
  }
  public putRib(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRipRib) {
    this._rib.internalValue = value;
  }
  public resetRib() {
    this._rib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ribInput() {
    return this._rib.internalValue;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile panos_filters_route_maps_redistribution_routing_profile}
*/
export class DataPanosFiltersRouteMapsRedistributionRoutingProfile extends cdktf.TerraformDataSource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "panos_filters_route_maps_redistribution_routing_profile";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a DataPanosFiltersRouteMapsRedistributionRoutingProfile resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the DataPanosFiltersRouteMapsRedistributionRoutingProfile to import
  * @param importFromId The id of the existing DataPanosFiltersRouteMapsRedistributionRoutingProfile that should be imported. Refer to the {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the DataPanosFiltersRouteMapsRedistributionRoutingProfile to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "panos_filters_route_maps_redistribution_routing_profile", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/data-sources/filters_route_maps_redistribution_routing_profile panos_filters_route_maps_redistribution_routing_profile} Data Source
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DataPanosFiltersRouteMapsRedistributionRoutingProfileConfig
  */
  public constructor(scope: Construct, id: string, config: DataPanosFiltersRouteMapsRedistributionRoutingProfileConfig) {
    super(scope, id, {
      terraformResourceType: 'panos_filters_route_maps_redistribution_routing_profile',
      terraformGeneratorMetadata: {
        providerName: 'panos',
        providerVersion: '2.0.7',
        providerVersionConstraint: '2.0.7'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._bgp.internalValue = config.bgp;
    this._connectedStatic.internalValue = config.connectedStatic;
    this._description = config.description;
    this._location.internalValue = config.location;
    this._name = config.name;
    this._ospf.internalValue = config.ospf;
    this._ospfv3.internalValue = config.ospfv3;
    this._rip.internalValue = config.rip;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // bgp - computed: true, optional: true, required: false
  private _bgp = new DataPanosFiltersRouteMapsRedistributionRoutingProfileBgpOutputReference(this, "bgp");
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileBgp) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // connected_static - computed: true, optional: true, required: false
  private _connectedStatic = new DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticOutputReference(this, "connected_static");
  public get connectedStatic() {
    return this._connectedStatic;
  }
  public putConnectedStatic(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStatic) {
    this._connectedStatic.internalValue = value;
  }
  public resetConnectedStatic() {
    this._connectedStatic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectedStaticInput() {
    return this._connectedStatic.internalValue;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // location - computed: false, optional: false, required: true
  private _location = new DataPanosFiltersRouteMapsRedistributionRoutingProfileLocationOutputReference(this, "location");
  public get location() {
    return this._location;
  }
  public putLocation(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileLocation) {
    this._location.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get locationInput() {
    return this._location.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ospf - computed: true, optional: true, required: false
  private _ospf = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfOutputReference(this, "ospf");
  public get ospf() {
    return this._ospf;
  }
  public putOspf(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspf) {
    this._ospf.internalValue = value;
  }
  public resetOspf() {
    this._ospf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfInput() {
    return this._ospf.internalValue;
  }

  // ospfv3 - computed: true, optional: true, required: false
  private _ospfv3 = new DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3OutputReference(this, "ospfv3");
  public get ospfv3() {
    return this._ospfv3;
  }
  public putOspfv3(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3) {
    this._ospfv3.internalValue = value;
  }
  public resetOspfv3() {
    this._ospfv3.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3Input() {
    return this._ospfv3.internalValue;
  }

  // rip - computed: true, optional: true, required: false
  private _rip = new DataPanosFiltersRouteMapsRedistributionRoutingProfileRipOutputReference(this, "rip");
  public get rip() {
    return this._rip;
  }
  public putRip(value: DataPanosFiltersRouteMapsRedistributionRoutingProfileRip) {
    this._rip.internalValue = value;
  }
  public resetRip() {
    this._rip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ripInput() {
    return this._rip.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      bgp: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpToTerraform(this._bgp.internalValue),
      connected_static: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticToTerraform(this._connectedStatic.internalValue),
      description: cdktf.stringToTerraform(this._description),
      location: dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationToTerraform(this._location.internalValue),
      name: cdktf.stringToTerraform(this._name),
      ospf: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfToTerraform(this._ospf.internalValue),
      ospfv3: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3ToTerraform(this._ospfv3.internalValue),
      rip: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipToTerraform(this._rip.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      bgp: {
        value: dataPanosFiltersRouteMapsRedistributionRoutingProfileBgpToHclTerraform(this._bgp.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileBgp",
      },
      connected_static: {
        value: dataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStaticToHclTerraform(this._connectedStatic.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileConnectedStatic",
      },
      description: {
        value: cdktf.stringToHclTerraform(this._description),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      location: {
        value: dataPanosFiltersRouteMapsRedistributionRoutingProfileLocationToHclTerraform(this._location.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileLocation",
      },
      name: {
        value: cdktf.stringToHclTerraform(this._name),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      ospf: {
        value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfToHclTerraform(this._ospf.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspf",
      },
      ospfv3: {
        value: dataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3ToHclTerraform(this._ospfv3.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileOspfv3",
      },
      rip: {
        value: dataPanosFiltersRouteMapsRedistributionRoutingProfileRipToHclTerraform(this._rip.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataPanosFiltersRouteMapsRedistributionRoutingProfileRip",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
