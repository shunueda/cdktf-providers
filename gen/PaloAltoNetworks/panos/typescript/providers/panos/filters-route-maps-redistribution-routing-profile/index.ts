// https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface FiltersRouteMapsRedistributionRoutingProfileConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#bgp FiltersRouteMapsRedistributionRoutingProfile#bgp}
  */
  readonly bgp?: FiltersRouteMapsRedistributionRoutingProfileBgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#connected_static FiltersRouteMapsRedistributionRoutingProfile#connected_static}
  */
  readonly connectedStatic?: FiltersRouteMapsRedistributionRoutingProfileConnectedStatic;
  /**
  * Describe Redistribution Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * The location of this object.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#location FiltersRouteMapsRedistributionRoutingProfile#location}
  */
  readonly location: FiltersRouteMapsRedistributionRoutingProfileLocation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ospf FiltersRouteMapsRedistributionRoutingProfile#ospf}
  */
  readonly ospf?: FiltersRouteMapsRedistributionRoutingProfileOspf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ospfv3 FiltersRouteMapsRedistributionRoutingProfile#ospfv3}
  */
  readonly ospfv3?: FiltersRouteMapsRedistributionRoutingProfileOspfv3;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#rip FiltersRouteMapsRedistributionRoutingProfile#rip}
  */
  readonly rip?: FiltersRouteMapsRedistributionRoutingProfileRip;
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_source FiltersRouteMapsRedistributionRoutingProfile#route_source}
  */
  readonly routeSource?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
    route_source: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceToTerraform(struct!.routeSource),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop",
    },
    route_source: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceToHclTerraform(struct!.routeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._routeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSource = this._routeSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
      this._routeSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
      this._routeSource.internalValue = value.routeSource;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // route_source - computed: false, optional: true, required: false
  private _routeSource = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSourceOutputReference(this, "route_source");
  public get routeSource() {
    return this._routeSource;
  }
  public putRouteSource(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4RouteSource) {
    this._routeSource.internalValue = value;
  }
  public resetRouteSource() {
    this._routeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSourceInput() {
    return this._routeSource.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch {
  /**
  * AS Path Access List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#as_path_access_list FiltersRouteMapsRedistributionRoutingProfile#as_path_access_list}
  */
  readonly asPathAccessList?: string;
  /**
  * Extended Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#extended_communities FiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv4 FiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4;
  /**
  * Large Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#large_communities FiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string;
  /**
  * Match Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#local_preference FiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Match Metric (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Match origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#origin FiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Match Peer Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#peer FiltersRouteMapsRedistributionRoutingProfile#peer}
  */
  readonly peer?: string;
  /**
  * Regular Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#regular_communities FiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path_access_list: cdktf.stringToTerraform(struct!.asPathAccessList),
    extended_communities: cdktf.stringToTerraform(struct!.extendedCommunities),
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    large_communities: cdktf.stringToTerraform(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: cdktf.numberToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    peer: cdktf.stringToTerraform(struct!.peer),
    regular_communities: cdktf.stringToTerraform(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path_access_list: {
      value: cdktf.stringToHclTerraform(struct!.asPathAccessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extended_communities: {
      value: cdktf.stringToHclTerraform(struct!.extendedCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4",
    },
    large_communities: {
      value: cdktf.stringToHclTerraform(struct!.largeCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.stringToHclTerraform(struct!.peer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.stringToHclTerraform(struct!.regularCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPathAccessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathAccessList = this._asPathAccessList;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._peer !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPathAccessList = undefined;
      this._extendedCommunities = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric = undefined;
      this._origin = undefined;
      this._peer = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPathAccessList = value.asPathAccessList;
      this._extendedCommunities = value.extendedCommunities;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric = value.metric;
      this._origin = value.origin;
      this._peer = value.peer;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
    }
  }

  // as_path_access_list - computed: false, optional: true, required: false
  private _asPathAccessList?: string; 
  public get asPathAccessList() {
    return this.getStringAttribute('as_path_access_list');
  }
  public set asPathAccessList(value: string) {
    this._asPathAccessList = value;
  }
  public resetAsPathAccessList() {
    this._asPathAccessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathAccessListInput() {
    return this._asPathAccessList;
  }

  // extended_communities - computed: false, optional: true, required: false
  private _extendedCommunities?: string; 
  public get extendedCommunities() {
    return this.getStringAttribute('extended_communities');
  }
  public set extendedCommunities(value: string) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // large_communities - computed: false, optional: true, required: false
  private _largeCommunities?: string; 
  public get largeCommunities() {
    return this.getStringAttribute('large_communities');
  }
  public set largeCommunities(value: string) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // peer - computed: false, optional: true, required: false
  private _peer?: string; 
  public get peer() {
    return this.getStringAttribute('peer');
  }
  public set peer(value: string) {
    this._peer = value;
  }
  public resetPeer() {
    this._peer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer;
  }

  // regular_communities - computed: false, optional: true, required: false
  private _regularCommunities?: string; 
  public get regularCommunities() {
    return this.getStringAttribute('regular_communities');
  }
  public set regularCommunities(value: string) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric;
  /**
  * Set Metric-Type of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric_type FiltersRouteMapsRedistributionRoutingProfile#metric_type}
  */
  readonly metricType?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricToTerraform(struct!.metric),
    metric_type: cdktf.stringToTerraform(struct!.metricType),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric",
    },
    metric_type: {
      value: cdktf.stringToHclTerraform(struct!.metricType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._metricType !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricType = this._metricType;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._metricType = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._metricType = value.metricType;
      this._tag = value.tag;
    }
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // metric_type - computed: true, optional: true, required: false
  private _metricType?: string; 
  public get metricType() {
    return this.getStringAttribute('metric_type');
  }
  public set metricType(value: string) {
    this._metricType = value;
  }
  public resetMetricType() {
    this._metricType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricTypeInput() {
    return this._metricType;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopToTerraform(struct!.nextHop),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch {
  /**
  * AS Path Access List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#as_path_access_list FiltersRouteMapsRedistributionRoutingProfile#as_path_access_list}
  */
  readonly asPathAccessList?: string;
  /**
  * Extended Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#extended_communities FiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv6 FiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6;
  /**
  * Large Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#large_communities FiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string;
  /**
  * Match Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#local_preference FiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Match Metric (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Match origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#origin FiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Match Peer Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#peer FiltersRouteMapsRedistributionRoutingProfile#peer}
  */
  readonly peer?: string;
  /**
  * Regular Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#regular_communities FiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path_access_list: cdktf.stringToTerraform(struct!.asPathAccessList),
    extended_communities: cdktf.stringToTerraform(struct!.extendedCommunities),
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv6: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6ToTerraform(struct!.ipv6),
    large_communities: cdktf.stringToTerraform(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: cdktf.numberToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    peer: cdktf.stringToTerraform(struct!.peer),
    regular_communities: cdktf.stringToTerraform(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path_access_list: {
      value: cdktf.stringToHclTerraform(struct!.asPathAccessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extended_communities: {
      value: cdktf.stringToHclTerraform(struct!.extendedCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv6: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6",
    },
    large_communities: {
      value: cdktf.stringToHclTerraform(struct!.largeCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.stringToHclTerraform(struct!.peer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.stringToHclTerraform(struct!.regularCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPathAccessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathAccessList = this._asPathAccessList;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._peer !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPathAccessList = undefined;
      this._extendedCommunities = undefined;
      this._interface = undefined;
      this._ipv6.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric = undefined;
      this._origin = undefined;
      this._peer = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPathAccessList = value.asPathAccessList;
      this._extendedCommunities = value.extendedCommunities;
      this._interface = value.interface;
      this._ipv6.internalValue = value.ipv6;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric = value.metric;
      this._origin = value.origin;
      this._peer = value.peer;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
    }
  }

  // as_path_access_list - computed: false, optional: true, required: false
  private _asPathAccessList?: string; 
  public get asPathAccessList() {
    return this.getStringAttribute('as_path_access_list');
  }
  public set asPathAccessList(value: string) {
    this._asPathAccessList = value;
  }
  public resetAsPathAccessList() {
    this._asPathAccessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathAccessListInput() {
    return this._asPathAccessList;
  }

  // extended_communities - computed: false, optional: true, required: false
  private _extendedCommunities?: string; 
  public get extendedCommunities() {
    return this.getStringAttribute('extended_communities');
  }
  public set extendedCommunities(value: string) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6 = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // large_communities - computed: false, optional: true, required: false
  private _largeCommunities?: string; 
  public get largeCommunities() {
    return this.getStringAttribute('large_communities');
  }
  public set largeCommunities(value: string) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // peer - computed: false, optional: true, required: false
  private _peer?: string; 
  public get peer() {
    return this.getStringAttribute('peer');
  }
  public set peer(value: string) {
    this._peer = value;
  }
  public resetPeer() {
    this._peer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer;
  }

  // regular_communities - computed: false, optional: true, required: false
  private _regularCommunities?: string; 
  public get regularCommunities() {
    return this.getStringAttribute('regular_communities');
  }
  public set regularCommunities(value: string) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric;
  /**
  * Set Metric-Type of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric_type FiltersRouteMapsRedistributionRoutingProfile#metric_type}
  */
  readonly metricType?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricToTerraform(struct!.metric),
    metric_type: cdktf.stringToTerraform(struct!.metricType),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric",
    },
    metric_type: {
      value: cdktf.stringToHclTerraform(struct!.metricType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._metricType !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricType = this._metricType;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._metricType = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._metricType = value.metricType;
      this._tag = value.tag;
    }
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // metric_type - computed: true, optional: true, required: false
  private _metricType?: string; 
  public get metricType() {
    return this.getStringAttribute('metric_type');
  }
  public set metricType(value: string) {
    this._metricType = value;
  }
  public resetMetricType() {
    this._metricType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricTypeInput() {
    return this._metricType;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpOspfv3ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3RouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_source FiltersRouteMapsRedistributionRoutingProfile#route_source}
  */
  readonly routeSource?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
    route_source: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceToTerraform(struct!.routeSource),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop",
    },
    route_source: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceToHclTerraform(struct!.routeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._routeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSource = this._routeSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
      this._routeSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
      this._routeSource.internalValue = value.routeSource;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // route_source - computed: false, optional: true, required: false
  private _routeSource = new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSourceOutputReference(this, "route_source");
  public get routeSource() {
    return this._routeSource;
  }
  public putRouteSource(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4RouteSource) {
    this._routeSource.internalValue = value;
  }
  public resetRouteSource() {
    this._routeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSourceInput() {
    return this._routeSource.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopToTerraform(struct!.nextHop),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch {
  /**
  * AS Path Access List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#as_path_access_list FiltersRouteMapsRedistributionRoutingProfile#as_path_access_list}
  */
  readonly asPathAccessList?: string;
  /**
  * Extended Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#extended_communities FiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv4 FiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv6 FiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6;
  /**
  * Large Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#large_communities FiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string;
  /**
  * Match Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#local_preference FiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Match Metric (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Match origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#origin FiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Match Peer Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#peer FiltersRouteMapsRedistributionRoutingProfile#peer}
  */
  readonly peer?: string;
  /**
  * Regular Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#regular_communities FiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path_access_list: cdktf.stringToTerraform(struct!.asPathAccessList),
    extended_communities: cdktf.stringToTerraform(struct!.extendedCommunities),
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    ipv6: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6ToTerraform(struct!.ipv6),
    large_communities: cdktf.stringToTerraform(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: cdktf.numberToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    peer: cdktf.stringToTerraform(struct!.peer),
    regular_communities: cdktf.stringToTerraform(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path_access_list: {
      value: cdktf.stringToHclTerraform(struct!.asPathAccessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extended_communities: {
      value: cdktf.stringToHclTerraform(struct!.extendedCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4",
    },
    ipv6: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6",
    },
    large_communities: {
      value: cdktf.stringToHclTerraform(struct!.largeCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.stringToHclTerraform(struct!.peer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.stringToHclTerraform(struct!.regularCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPathAccessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathAccessList = this._asPathAccessList;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._peer !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPathAccessList = undefined;
      this._extendedCommunities = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric = undefined;
      this._origin = undefined;
      this._peer = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPathAccessList = value.asPathAccessList;
      this._extendedCommunities = value.extendedCommunities;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric = value.metric;
      this._origin = value.origin;
      this._peer = value.peer;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
    }
  }

  // as_path_access_list - computed: false, optional: true, required: false
  private _asPathAccessList?: string; 
  public get asPathAccessList() {
    return this.getStringAttribute('as_path_access_list');
  }
  public set asPathAccessList(value: string) {
    this._asPathAccessList = value;
  }
  public resetAsPathAccessList() {
    this._asPathAccessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathAccessListInput() {
    return this._asPathAccessList;
  }

  // extended_communities - computed: false, optional: true, required: false
  private _extendedCommunities?: string; 
  public get extendedCommunities() {
    return this.getStringAttribute('extended_communities');
  }
  public set extendedCommunities(value: string) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6 = new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // large_communities - computed: false, optional: true, required: false
  private _largeCommunities?: string; 
  public get largeCommunities() {
    return this.getStringAttribute('large_communities');
  }
  public set largeCommunities(value: string) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // peer - computed: false, optional: true, required: false
  private _peer?: string; 
  public get peer() {
    return this.getStringAttribute('peer');
  }
  public set peer(value: string) {
    this._peer = value;
  }
  public resetPeer() {
    this._peer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer;
  }

  // regular_communities - computed: false, optional: true, required: false
  private _regularCommunities?: string; 
  public get regularCommunities() {
    return this.getStringAttribute('regular_communities');
  }
  public set regularCommunities(value: string) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet {
  /**
  * Set Source IPv4 or IPv6 address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#source_address FiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRib {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRibToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRibToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileBgpRibRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileBgpRibRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_source FiltersRouteMapsRedistributionRoutingProfile#route_source}
  */
  readonly routeSource?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
    route_source: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceToTerraform(struct!.routeSource),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop",
    },
    route_source: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceToHclTerraform(struct!.routeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._routeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSource = this._routeSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
      this._routeSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
      this._routeSource.internalValue = value.routeSource;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // route_source - computed: false, optional: true, required: false
  private _routeSource = new FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSourceOutputReference(this, "route_source");
  public get routeSource() {
    return this._routeSource;
  }
  public putRouteSource(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4RouteSource) {
    this._routeSource.internalValue = value;
  }
  public resetRouteSource() {
    this._routeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSourceInput() {
    return this._routeSource.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch {
  /**
  * AS Path Access List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#as_path_access_list FiltersRouteMapsRedistributionRoutingProfile#as_path_access_list}
  */
  readonly asPathAccessList?: string;
  /**
  * Extended Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#extended_communities FiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv4 FiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4;
  /**
  * Large Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#large_communities FiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string;
  /**
  * Match Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#local_preference FiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Match Metric (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Match origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#origin FiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Match Peer Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#peer FiltersRouteMapsRedistributionRoutingProfile#peer}
  */
  readonly peer?: string;
  /**
  * Regular Community Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#regular_communities FiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path_access_list: cdktf.stringToTerraform(struct!.asPathAccessList),
    extended_communities: cdktf.stringToTerraform(struct!.extendedCommunities),
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    large_communities: cdktf.stringToTerraform(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: cdktf.numberToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    peer: cdktf.stringToTerraform(struct!.peer),
    regular_communities: cdktf.stringToTerraform(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path_access_list: {
      value: cdktf.stringToHclTerraform(struct!.asPathAccessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extended_communities: {
      value: cdktf.stringToHclTerraform(struct!.extendedCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4",
    },
    large_communities: {
      value: cdktf.stringToHclTerraform(struct!.largeCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.stringToHclTerraform(struct!.peer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.stringToHclTerraform(struct!.regularCommunities),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPathAccessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathAccessList = this._asPathAccessList;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._peer !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPathAccessList = undefined;
      this._extendedCommunities = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric = undefined;
      this._origin = undefined;
      this._peer = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPathAccessList = value.asPathAccessList;
      this._extendedCommunities = value.extendedCommunities;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric = value.metric;
      this._origin = value.origin;
      this._peer = value.peer;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
    }
  }

  // as_path_access_list - computed: false, optional: true, required: false
  private _asPathAccessList?: string; 
  public get asPathAccessList() {
    return this.getStringAttribute('as_path_access_list');
  }
  public set asPathAccessList(value: string) {
    this._asPathAccessList = value;
  }
  public resetAsPathAccessList() {
    this._asPathAccessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathAccessListInput() {
    return this._asPathAccessList;
  }

  // extended_communities - computed: false, optional: true, required: false
  private _extendedCommunities?: string; 
  public get extendedCommunities() {
    return this.getStringAttribute('extended_communities');
  }
  public set extendedCommunities(value: string) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // large_communities - computed: false, optional: true, required: false
  private _largeCommunities?: string; 
  public get largeCommunities() {
    return this.getStringAttribute('large_communities');
  }
  public set largeCommunities(value: string) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // peer - computed: false, optional: true, required: false
  private _peer?: string; 
  public get peer() {
    return this.getStringAttribute('peer');
  }
  public set peer(value: string) {
    this._peer = value;
  }
  public resetPeer() {
    this._peer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer;
  }

  // regular_communities - computed: false, optional: true, required: false
  private _regularCommunities?: string; 
  public get regularCommunities() {
    return this.getStringAttribute('regular_communities');
  }
  public set regularCommunities(value: string) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric;
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricToTerraform(struct!.metric),
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric",
    },
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._nextHop = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._nextHop = value.nextHop;
      this._tag = value.tag;
    }
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgpRip {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpRipToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpRipToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgpRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileBgpRipRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpRipOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgpRip | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgpRip | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileBgpRipRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileBgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ospf FiltersRouteMapsRedistributionRoutingProfile#ospf}
  */
  readonly ospf?: FiltersRouteMapsRedistributionRoutingProfileBgpOspf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ospfv3 FiltersRouteMapsRedistributionRoutingProfile#ospfv3}
  */
  readonly ospfv3?: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#rib FiltersRouteMapsRedistributionRoutingProfile#rib}
  */
  readonly rib?: FiltersRouteMapsRedistributionRoutingProfileBgpRib;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#rip FiltersRouteMapsRedistributionRoutingProfile#rip}
  */
  readonly rip?: FiltersRouteMapsRedistributionRoutingProfileBgpRip;
}

export function filtersRouteMapsRedistributionRoutingProfileBgpToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ospf: filtersRouteMapsRedistributionRoutingProfileBgpOspfToTerraform(struct!.ospf),
    ospfv3: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3ToTerraform(struct!.ospfv3),
    rib: filtersRouteMapsRedistributionRoutingProfileBgpRibToTerraform(struct!.rib),
    rip: filtersRouteMapsRedistributionRoutingProfileBgpRipToTerraform(struct!.rip),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileBgpToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ospf: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfToHclTerraform(struct!.ospf),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspf",
    },
    ospfv3: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpOspfv3ToHclTerraform(struct!.ospfv3),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3",
    },
    rib: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRibToHclTerraform(struct!.rib),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRib",
    },
    rip: {
      value: filtersRouteMapsRedistributionRoutingProfileBgpRipToHclTerraform(struct!.rip),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgpRip",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ospf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospf = this._ospf?.internalValue;
    }
    if (this._ospfv3?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfv3 = this._ospfv3?.internalValue;
    }
    if (this._rib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rib = this._rib?.internalValue;
    }
    if (this._rip?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rip = this._rip?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ospf.internalValue = undefined;
      this._ospfv3.internalValue = undefined;
      this._rib.internalValue = undefined;
      this._rip.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ospf.internalValue = value.ospf;
      this._ospfv3.internalValue = value.ospfv3;
      this._rib.internalValue = value.rib;
      this._rip.internalValue = value.rip;
    }
  }

  // ospf - computed: false, optional: true, required: false
  private _ospf = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfOutputReference(this, "ospf");
  public get ospf() {
    return this._ospf;
  }
  public putOspf(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspf) {
    this._ospf.internalValue = value;
  }
  public resetOspf() {
    this._ospf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfInput() {
    return this._ospf.internalValue;
  }

  // ospfv3 - computed: false, optional: true, required: false
  private _ospfv3 = new FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3OutputReference(this, "ospfv3");
  public get ospfv3() {
    return this._ospfv3;
  }
  public putOspfv3(value: FiltersRouteMapsRedistributionRoutingProfileBgpOspfv3) {
    this._ospfv3.internalValue = value;
  }
  public resetOspfv3() {
    this._ospfv3.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3Input() {
    return this._ospfv3.internalValue;
  }

  // rib - computed: false, optional: true, required: false
  private _rib = new FiltersRouteMapsRedistributionRoutingProfileBgpRibOutputReference(this, "rib");
  public get rib() {
    return this._rib;
  }
  public putRib(value: FiltersRouteMapsRedistributionRoutingProfileBgpRib) {
    this._rib.internalValue = value;
  }
  public resetRib() {
    this._rib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ribInput() {
    return this._rib.internalValue;
  }

  // rip - computed: false, optional: true, required: false
  private _rip = new FiltersRouteMapsRedistributionRoutingProfileBgpRipOutputReference(this, "rip");
  public get rip() {
    return this._rip;
  }
  public putRip(value: FiltersRouteMapsRedistributionRoutingProfileBgpRip) {
    this._rip.internalValue = value;
  }
  public resetRip() {
    this._rip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ripInput() {
    return this._rip.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopToTerraform(struct!.nextHop),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch {
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv4 FiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv6 FiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    ipv6: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6ToTerraform(struct!.ipv6),
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4",
    },
    ipv6: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
      this._metric = value.metric;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6 = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator {
  /**
  * Set BGP Aggregator AS <1-4294967295>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#as FiltersRouteMapsRedistributionRoutingProfile#as}
  */
  readonly as?: number;
  /**
  * Set BGP Aggregator Router ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#router_id FiltersRouteMapsRedistributionRoutingProfile#router_id}
  */
  readonly routerId?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as: cdktf.numberToTerraform(struct!.as),
    router_id: cdktf.stringToTerraform(struct!.routerId),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as: {
      value: cdktf.numberToHclTerraform(struct!.as),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._as !== undefined) {
      hasAnyValues = true;
      internalValueResult.as = this._as;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._as = undefined;
      this._routerId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._as = value.as;
      this._routerId = value.routerId;
    }
  }

  // as - computed: false, optional: true, required: false
  private _as?: number; 
  public get as() {
    return this.getNumberAttribute('as');
  }
  public set as(value: number) {
    this._as = value;
  }
  public resetAs() {
    this._as = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asInput() {
    return this._as;
  }

  // router_id - computed: false, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4 {
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Source IPv4 Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#source_address FiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nextHop = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nextHop = value.nextHop;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6 {
  /**
  * Set IPv6 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Source IPv6 Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#source_address FiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nextHop = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nextHop = value.nextHop;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric {
  /**
  * Set Metric action (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#aggregator FiltersRouteMapsRedistributionRoutingProfile#aggregator}
  */
  readonly aggregator?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#aspath_prepends FiltersRouteMapsRedistributionRoutingProfile#aspath_prepends}
  */
  readonly aspathPrepends?: number[];
  /**
  * Enable BGP atomic aggregate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#atomic_aggregate FiltersRouteMapsRedistributionRoutingProfile#atomic_aggregate}
  */
  readonly atomicAggregate?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#extended_communities FiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv4 FiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv6 FiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#large_communities FiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string[];
  /**
  * Set Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#local_preference FiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric;
  /**
  * Set BGP origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#origin FiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Set BGP Originator Id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#originator_id FiltersRouteMapsRedistributionRoutingProfile#originator_id}
  */
  readonly originatorId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#regular_communities FiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string[];
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
  /**
  * Set BGP weight of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#weight FiltersRouteMapsRedistributionRoutingProfile#weight}
  */
  readonly weight?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregator: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorToTerraform(struct!.aggregator),
    aspath_prepends: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.aspathPrepends),
    atomic_aggregate: cdktf.booleanToTerraform(struct!.atomicAggregate),
    extended_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extendedCommunities),
    ipv4: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4ToTerraform(struct!.ipv4),
    ipv6: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6ToTerraform(struct!.ipv6),
    large_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    originator_id: cdktf.stringToTerraform(struct!.originatorId),
    regular_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregator: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorToHclTerraform(struct!.aggregator),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator",
    },
    aspath_prepends: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.aspathPrepends),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    atomic_aggregate: {
      value: cdktf.booleanToHclTerraform(struct!.atomicAggregate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extended_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extendedCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ipv4: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4",
    },
    ipv6: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6",
    },
    large_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.largeCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    originator_id: {
      value: cdktf.stringToHclTerraform(struct!.originatorId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regularCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregator = this._aggregator?.internalValue;
    }
    if (this._aspathPrepends !== undefined) {
      hasAnyValues = true;
      internalValueResult.aspathPrepends = this._aspathPrepends;
    }
    if (this._atomicAggregate !== undefined) {
      hasAnyValues = true;
      internalValueResult.atomicAggregate = this._atomicAggregate;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._originatorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.originatorId = this._originatorId;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = undefined;
      this._aspathPrepends = undefined;
      this._atomicAggregate = undefined;
      this._extendedCommunities = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric.internalValue = undefined;
      this._origin = undefined;
      this._originatorId = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = value.aggregator;
      this._aspathPrepends = value.aspathPrepends;
      this._atomicAggregate = value.atomicAggregate;
      this._extendedCommunities = value.extendedCommunities;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric.internalValue = value.metric;
      this._origin = value.origin;
      this._originatorId = value.originatorId;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
      this._weight = value.weight;
    }
  }

  // aggregator - computed: false, optional: true, required: false
  private _aggregator = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregatorOutputReference(this, "aggregator");
  public get aggregator() {
    return this._aggregator;
  }
  public putAggregator(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetAggregator) {
    this._aggregator.internalValue = value;
  }
  public resetAggregator() {
    this._aggregator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregatorInput() {
    return this._aggregator.internalValue;
  }

  // aspath_prepends - computed: false, optional: true, required: false
  private _aspathPrepends?: number[]; 
  public get aspathPrepends() {
    return this.getNumberListAttribute('aspath_prepends');
  }
  public set aspathPrepends(value: number[]) {
    this._aspathPrepends = value;
  }
  public resetAspathPrepends() {
    this._aspathPrepends = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aspathPrependsInput() {
    return this._aspathPrepends;
  }

  // atomic_aggregate - computed: false, optional: true, required: false
  private _atomicAggregate?: boolean | cdktf.IResolvable; 
  public get atomicAggregate() {
    return this.getBooleanAttribute('atomic_aggregate');
  }
  public set atomicAggregate(value: boolean | cdktf.IResolvable) {
    this._atomicAggregate = value;
  }
  public resetAtomicAggregate() {
    this._atomicAggregate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atomicAggregateInput() {
    return this._atomicAggregate;
  }

  // extended_communities - computed: false, optional: true, required: false
  private _extendedCommunities?: string[]; 
  public get extendedCommunities() {
    return this.getListAttribute('extended_communities');
  }
  public set extendedCommunities(value: string[]) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6 = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // large_communities - computed: false, optional: true, required: false
  private _largeCommunities?: string[]; 
  public get largeCommunities() {
    return this.getListAttribute('large_communities');
  }
  public set largeCommunities(value: string[]) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // originator_id - computed: false, optional: true, required: false
  private _originatorId?: string; 
  public get originatorId() {
    return this.getStringAttribute('originator_id');
  }
  public set originatorId(value: string) {
    this._originatorId = value;
  }
  public resetOriginatorId() {
    this._originatorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originatorIdInput() {
    return this._originatorId;
  }

  // regular_communities - computed: false, optional: true, required: false
  private _regularCommunities?: string[]; 
  public get regularCommunities() {
    return this.getListAttribute('regular_communities');
  }
  public set regularCommunities(value: string[]) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch {
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv4 FiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._metric = value.metric;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric;
  /**
  * Set Metric-Type of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric_type FiltersRouteMapsRedistributionRoutingProfile#metric_type}
  */
  readonly metricType?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricToTerraform(struct!.metric),
    metric_type: cdktf.stringToTerraform(struct!.metricType),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric",
    },
    metric_type: {
      value: cdktf.stringToHclTerraform(struct!.metricType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._metricType !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricType = this._metricType;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._metricType = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._metricType = value.metricType;
      this._tag = value.tag;
    }
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // metric_type - computed: true, optional: true, required: false
  private _metricType?: string; 
  public get metricType() {
    return this.getStringAttribute('metric_type');
  }
  public set metricType(value: string) {
    this._metricType = value;
  }
  public resetMetricType() {
    this._metricType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricTypeInput() {
    return this._metricType;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopToTerraform(struct!.nextHop),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch {
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv6 FiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv6: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6ToTerraform(struct!.ipv6),
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv6: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ipv6.internalValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ipv6.internalValue = value.ipv6;
      this._metric = value.metric;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6 = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric;
  /**
  * Set Metric-Type of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric_type FiltersRouteMapsRedistributionRoutingProfile#metric_type}
  */
  readonly metricType?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricToTerraform(struct!.metric),
    metric_type: cdktf.stringToTerraform(struct!.metricType),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric",
    },
    metric_type: {
      value: cdktf.stringToHclTerraform(struct!.metricType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._metricType !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricType = this._metricType;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._metricType = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._metricType = value.metricType;
      this._tag = value.tag;
    }
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // metric_type - computed: true, optional: true, required: false
  private _metricType?: string; 
  public get metricType() {
    return this.getStringAttribute('metric_type');
  }
  public set metricType(value: string) {
    this._metricType = value;
  }
  public resetMetricType() {
    this._metricType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricTypeInput() {
    return this._metricType;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3RouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopToTerraform(struct!.nextHop),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch {
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv4 FiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv6 FiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    ipv6: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6ToTerraform(struct!.ipv6),
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4",
    },
    ipv6: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
      this._metric = value.metric;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6 = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet {
  /**
  * Set Source IPv4 or IPv6 address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#source_address FiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressToTerraform(struct!.address),
    next_hop: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopToTerraform(struct!.nextHop),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._nextHop.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._nextHop.internalValue = value.nextHop;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4AddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4Address) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4NextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch {
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv4 FiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ipv4: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4ToTerraform(struct!.ipv4),
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ipv4.internalValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ipv4.internalValue = value.ipv4;
      this._metric = value.metric;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric;
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricToTerraform(struct!.metric),
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric",
    },
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._nextHop = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._nextHop = value.nextHop;
      this._tag = value.tag;
    }
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileConnectedStatic {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#bgp FiltersRouteMapsRedistributionRoutingProfile#bgp}
  */
  readonly bgp?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ospf FiltersRouteMapsRedistributionRoutingProfile#ospf}
  */
  readonly ospf?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ospfv3 FiltersRouteMapsRedistributionRoutingProfile#ospfv3}
  */
  readonly ospfv3?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#rib FiltersRouteMapsRedistributionRoutingProfile#rib}
  */
  readonly rib?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#rip FiltersRouteMapsRedistributionRoutingProfile#rip}
  */
  readonly rip?: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip;
}

export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStatic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bgp: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpToTerraform(struct!.bgp),
    ospf: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfToTerraform(struct!.ospf),
    ospfv3: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3ToTerraform(struct!.ospfv3),
    rib: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibToTerraform(struct!.rib),
    rip: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipToTerraform(struct!.rip),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileConnectedStaticToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileConnectedStatic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bgp: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticBgpToHclTerraform(struct!.bgp),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp",
    },
    ospf: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfToHclTerraform(struct!.ospf),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf",
    },
    ospfv3: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3ToHclTerraform(struct!.ospfv3),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3",
    },
    rib: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRibToHclTerraform(struct!.rib),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib",
    },
    rip: {
      value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticRipToHclTerraform(struct!.rip),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileConnectedStatic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgp = this._bgp?.internalValue;
    }
    if (this._ospf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospf = this._ospf?.internalValue;
    }
    if (this._ospfv3?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfv3 = this._ospfv3?.internalValue;
    }
    if (this._rib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rib = this._rib?.internalValue;
    }
    if (this._rip?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rip = this._rip?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStatic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bgp.internalValue = undefined;
      this._ospf.internalValue = undefined;
      this._ospfv3.internalValue = undefined;
      this._rib.internalValue = undefined;
      this._rip.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bgp.internalValue = value.bgp;
      this._ospf.internalValue = value.ospf;
      this._ospfv3.internalValue = value.ospfv3;
      this._rib.internalValue = value.rib;
      this._rip.internalValue = value.rip;
    }
  }

  // bgp - computed: false, optional: true, required: false
  private _bgp = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgpOutputReference(this, "bgp");
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticBgp) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // ospf - computed: false, optional: true, required: false
  private _ospf = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfOutputReference(this, "ospf");
  public get ospf() {
    return this._ospf;
  }
  public putOspf(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspf) {
    this._ospf.internalValue = value;
  }
  public resetOspf() {
    this._ospf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfInput() {
    return this._ospf.internalValue;
  }

  // ospfv3 - computed: false, optional: true, required: false
  private _ospfv3 = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3OutputReference(this, "ospfv3");
  public get ospfv3() {
    return this._ospfv3;
  }
  public putOspfv3(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOspfv3) {
    this._ospfv3.internalValue = value;
  }
  public resetOspfv3() {
    this._ospfv3.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3Input() {
    return this._ospfv3.internalValue;
  }

  // rib - computed: false, optional: true, required: false
  private _rib = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRibOutputReference(this, "rib");
  public get rib() {
    return this._rib;
  }
  public putRib(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRib) {
    this._rib.internalValue = value;
  }
  public resetRib() {
    this._rib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ribInput() {
    return this._rib.internalValue;
  }

  // rip - computed: false, optional: true, required: false
  private _rip = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRipOutputReference(this, "rip");
  public get rip() {
    return this._rip;
  }
  public putRip(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStaticRip) {
    this._rip.internalValue = value;
  }
  public resetRip() {
    this._rip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ripInput() {
    return this._rip.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileLocationNgfw {
  /**
  * The NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ngfw_device FiltersRouteMapsRedistributionRoutingProfile#ngfw_device}
  */
  readonly ngfwDevice?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileLocationNgfwToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileLocationNgfw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ngfw_device: cdktf.stringToTerraform(struct!.ngfwDevice),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileLocationNgfwToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileLocationNgfw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ngfw_device: {
      value: cdktf.stringToHclTerraform(struct!.ngfwDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileLocationNgfwOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileLocationNgfw | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ngfwDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfwDevice = this._ngfwDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileLocationNgfw | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ngfwDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ngfwDevice = value.ngfwDevice;
    }
  }

  // ngfw_device - computed: true, optional: true, required: false
  private _ngfwDevice?: string; 
  public get ngfwDevice() {
    return this.getStringAttribute('ngfw_device');
  }
  public set ngfwDevice(value: string) {
    this._ngfwDevice = value;
  }
  public resetNgfwDevice() {
    this._ngfwDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwDeviceInput() {
    return this._ngfwDevice;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileLocationTemplate {
  /**
  * Specific Panorama template
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name?: string;
  /**
  * The NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ngfw_device FiltersRouteMapsRedistributionRoutingProfile#ngfw_device}
  */
  readonly ngfwDevice?: string;
  /**
  * Specific Panorama device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#panorama_device FiltersRouteMapsRedistributionRoutingProfile#panorama_device}
  */
  readonly panoramaDevice?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileLocationTemplateToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileLocationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    ngfw_device: cdktf.stringToTerraform(struct!.ngfwDevice),
    panorama_device: cdktf.stringToTerraform(struct!.panoramaDevice),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileLocationTemplateToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileLocationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ngfw_device: {
      value: cdktf.stringToHclTerraform(struct!.ngfwDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    panorama_device: {
      value: cdktf.stringToHclTerraform(struct!.panoramaDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileLocationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileLocationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._ngfwDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfwDevice = this._ngfwDevice;
    }
    if (this._panoramaDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.panoramaDevice = this._panoramaDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileLocationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._ngfwDevice = undefined;
      this._panoramaDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._ngfwDevice = value.ngfwDevice;
      this._panoramaDevice = value.panoramaDevice;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ngfw_device - computed: true, optional: true, required: false
  private _ngfwDevice?: string; 
  public get ngfwDevice() {
    return this.getStringAttribute('ngfw_device');
  }
  public set ngfwDevice(value: string) {
    this._ngfwDevice = value;
  }
  public resetNgfwDevice() {
    this._ngfwDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwDeviceInput() {
    return this._ngfwDevice;
  }

  // panorama_device - computed: true, optional: true, required: false
  private _panoramaDevice?: string; 
  public get panoramaDevice() {
    return this.getStringAttribute('panorama_device');
  }
  public set panoramaDevice(value: string) {
    this._panoramaDevice = value;
  }
  public resetPanoramaDevice() {
    this._panoramaDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get panoramaDeviceInput() {
    return this._panoramaDevice;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack {
  /**
  * Specific Panorama template stack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name?: string;
  /**
  * The NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ngfw_device FiltersRouteMapsRedistributionRoutingProfile#ngfw_device}
  */
  readonly ngfwDevice?: string;
  /**
  * Specific Panorama device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#panorama_device FiltersRouteMapsRedistributionRoutingProfile#panorama_device}
  */
  readonly panoramaDevice?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileLocationTemplateStackToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    ngfw_device: cdktf.stringToTerraform(struct!.ngfwDevice),
    panorama_device: cdktf.stringToTerraform(struct!.panoramaDevice),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileLocationTemplateStackToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ngfw_device: {
      value: cdktf.stringToHclTerraform(struct!.ngfwDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    panorama_device: {
      value: cdktf.stringToHclTerraform(struct!.panoramaDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileLocationTemplateStackOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._ngfwDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfwDevice = this._ngfwDevice;
    }
    if (this._panoramaDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.panoramaDevice = this._panoramaDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._ngfwDevice = undefined;
      this._panoramaDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._ngfwDevice = value.ngfwDevice;
      this._panoramaDevice = value.panoramaDevice;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ngfw_device - computed: true, optional: true, required: false
  private _ngfwDevice?: string; 
  public get ngfwDevice() {
    return this.getStringAttribute('ngfw_device');
  }
  public set ngfwDevice(value: string) {
    this._ngfwDevice = value;
  }
  public resetNgfwDevice() {
    this._ngfwDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwDeviceInput() {
    return this._ngfwDevice;
  }

  // panorama_device - computed: true, optional: true, required: false
  private _panoramaDevice?: string; 
  public get panoramaDevice() {
    return this.getStringAttribute('panorama_device');
  }
  public set panoramaDevice(value: string) {
    this._panoramaDevice = value;
  }
  public resetPanoramaDevice() {
    this._panoramaDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get panoramaDeviceInput() {
    return this._panoramaDevice;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileLocation {
  /**
  * Located in a specific NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ngfw FiltersRouteMapsRedistributionRoutingProfile#ngfw}
  */
  readonly ngfw?: FiltersRouteMapsRedistributionRoutingProfileLocationNgfw;
  /**
  * Located in a specific template
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#template FiltersRouteMapsRedistributionRoutingProfile#template}
  */
  readonly template?: FiltersRouteMapsRedistributionRoutingProfileLocationTemplate;
  /**
  * Located in a specific template stack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#template_stack FiltersRouteMapsRedistributionRoutingProfile#template_stack}
  */
  readonly templateStack?: FiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack;
}

export function filtersRouteMapsRedistributionRoutingProfileLocationToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileLocation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ngfw: filtersRouteMapsRedistributionRoutingProfileLocationNgfwToTerraform(struct!.ngfw),
    template: filtersRouteMapsRedistributionRoutingProfileLocationTemplateToTerraform(struct!.template),
    template_stack: filtersRouteMapsRedistributionRoutingProfileLocationTemplateStackToTerraform(struct!.templateStack),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileLocationToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileLocation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ngfw: {
      value: filtersRouteMapsRedistributionRoutingProfileLocationNgfwToHclTerraform(struct!.ngfw),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileLocationNgfw",
    },
    template: {
      value: filtersRouteMapsRedistributionRoutingProfileLocationTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileLocationTemplate",
    },
    template_stack: {
      value: filtersRouteMapsRedistributionRoutingProfileLocationTemplateStackToHclTerraform(struct!.templateStack),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileLocationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileLocation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ngfw?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfw = this._ngfw?.internalValue;
    }
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    if (this._templateStack?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.templateStack = this._templateStack?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileLocation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ngfw.internalValue = undefined;
      this._template.internalValue = undefined;
      this._templateStack.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ngfw.internalValue = value.ngfw;
      this._template.internalValue = value.template;
      this._templateStack.internalValue = value.templateStack;
    }
  }

  // ngfw - computed: false, optional: true, required: false
  private _ngfw = new FiltersRouteMapsRedistributionRoutingProfileLocationNgfwOutputReference(this, "ngfw");
  public get ngfw() {
    return this._ngfw;
  }
  public putNgfw(value: FiltersRouteMapsRedistributionRoutingProfileLocationNgfw) {
    this._ngfw.internalValue = value;
  }
  public resetNgfw() {
    this._ngfw.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwInput() {
    return this._ngfw.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template = new FiltersRouteMapsRedistributionRoutingProfileLocationTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: FiltersRouteMapsRedistributionRoutingProfileLocationTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }

  // template_stack - computed: false, optional: true, required: false
  private _templateStack = new FiltersRouteMapsRedistributionRoutingProfileLocationTemplateStackOutputReference(this, "template_stack");
  public get templateStack() {
    return this._templateStack;
  }
  public putTemplateStack(value: FiltersRouteMapsRedistributionRoutingProfileLocationTemplateStack) {
    this._templateStack.internalValue = value;
  }
  public resetTemplateStack() {
    this._templateStack.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateStackInput() {
    return this._templateStack.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator {
  /**
  * Set BGP Aggregator AS <1-4294967295>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#as FiltersRouteMapsRedistributionRoutingProfile#as}
  */
  readonly as?: number;
  /**
  * Set BGP Aggregator Router ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#router_id FiltersRouteMapsRedistributionRoutingProfile#router_id}
  */
  readonly routerId?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as: cdktf.numberToTerraform(struct!.as),
    router_id: cdktf.stringToTerraform(struct!.routerId),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as: {
      value: cdktf.numberToHclTerraform(struct!.as),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._as !== undefined) {
      hasAnyValues = true;
      internalValueResult.as = this._as;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._as = undefined;
      this._routerId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._as = value.as;
      this._routerId = value.routerId;
    }
  }

  // as - computed: false, optional: true, required: false
  private _as?: number; 
  public get as() {
    return this.getNumberAttribute('as');
  }
  public set as(value: number) {
    this._as = value;
  }
  public resetAs() {
    this._as = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asInput() {
    return this._as;
  }

  // router_id - computed: false, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4 {
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Source IPv4 Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#source_address FiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nextHop = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nextHop = value.nextHop;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric {
  /**
  * Set Metric action (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#aggregator FiltersRouteMapsRedistributionRoutingProfile#aggregator}
  */
  readonly aggregator?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#aspath_prepends FiltersRouteMapsRedistributionRoutingProfile#aspath_prepends}
  */
  readonly aspathPrepends?: number[];
  /**
  * Enable BGP atomic aggregate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#atomic_aggregate FiltersRouteMapsRedistributionRoutingProfile#atomic_aggregate}
  */
  readonly atomicAggregate?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#extended_communities FiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv4 FiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#large_communities FiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string[];
  /**
  * Set Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#local_preference FiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric;
  /**
  * Set BGP origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#origin FiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Set BGP Originator Id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#originator_id FiltersRouteMapsRedistributionRoutingProfile#originator_id}
  */
  readonly originatorId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#regular_communities FiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string[];
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
  /**
  * Set BGP weight of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#weight FiltersRouteMapsRedistributionRoutingProfile#weight}
  */
  readonly weight?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregator: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorToTerraform(struct!.aggregator),
    aspath_prepends: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.aspathPrepends),
    atomic_aggregate: cdktf.booleanToTerraform(struct!.atomicAggregate),
    extended_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extendedCommunities),
    ipv4: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4ToTerraform(struct!.ipv4),
    large_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    originator_id: cdktf.stringToTerraform(struct!.originatorId),
    regular_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregator: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorToHclTerraform(struct!.aggregator),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator",
    },
    aspath_prepends: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.aspathPrepends),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    atomic_aggregate: {
      value: cdktf.booleanToHclTerraform(struct!.atomicAggregate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extended_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extendedCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ipv4: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4",
    },
    large_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.largeCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    originator_id: {
      value: cdktf.stringToHclTerraform(struct!.originatorId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regularCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregator = this._aggregator?.internalValue;
    }
    if (this._aspathPrepends !== undefined) {
      hasAnyValues = true;
      internalValueResult.aspathPrepends = this._aspathPrepends;
    }
    if (this._atomicAggregate !== undefined) {
      hasAnyValues = true;
      internalValueResult.atomicAggregate = this._atomicAggregate;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._originatorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.originatorId = this._originatorId;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = undefined;
      this._aspathPrepends = undefined;
      this._atomicAggregate = undefined;
      this._extendedCommunities = undefined;
      this._ipv4.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric.internalValue = undefined;
      this._origin = undefined;
      this._originatorId = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = value.aggregator;
      this._aspathPrepends = value.aspathPrepends;
      this._atomicAggregate = value.atomicAggregate;
      this._extendedCommunities = value.extendedCommunities;
      this._ipv4.internalValue = value.ipv4;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric.internalValue = value.metric;
      this._origin = value.origin;
      this._originatorId = value.originatorId;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
      this._weight = value.weight;
    }
  }

  // aggregator - computed: false, optional: true, required: false
  private _aggregator = new FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregatorOutputReference(this, "aggregator");
  public get aggregator() {
    return this._aggregator;
  }
  public putAggregator(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetAggregator) {
    this._aggregator.internalValue = value;
  }
  public resetAggregator() {
    this._aggregator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregatorInput() {
    return this._aggregator.internalValue;
  }

  // aspath_prepends - computed: false, optional: true, required: false
  private _aspathPrepends?: number[]; 
  public get aspathPrepends() {
    return this.getNumberListAttribute('aspath_prepends');
  }
  public set aspathPrepends(value: number[]) {
    this._aspathPrepends = value;
  }
  public resetAspathPrepends() {
    this._aspathPrepends = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aspathPrependsInput() {
    return this._aspathPrepends;
  }

  // atomic_aggregate - computed: false, optional: true, required: false
  private _atomicAggregate?: boolean | cdktf.IResolvable; 
  public get atomicAggregate() {
    return this.getBooleanAttribute('atomic_aggregate');
  }
  public set atomicAggregate(value: boolean | cdktf.IResolvable) {
    this._atomicAggregate = value;
  }
  public resetAtomicAggregate() {
    this._atomicAggregate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atomicAggregateInput() {
    return this._atomicAggregate;
  }

  // extended_communities - computed: false, optional: true, required: false
  private _extendedCommunities?: string[]; 
  public get extendedCommunities() {
    return this.getListAttribute('extended_communities');
  }
  public set extendedCommunities(value: string[]) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // large_communities - computed: false, optional: true, required: false
  private _largeCommunities?: string[]; 
  public get largeCommunities() {
    return this.getListAttribute('large_communities');
  }
  public set largeCommunities(value: string[]) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // originator_id - computed: false, optional: true, required: false
  private _originatorId?: string; 
  public get originatorId() {
    return this.getStringAttribute('originator_id');
  }
  public set originatorId(value: string) {
    this._originatorId = value;
  }
  public resetOriginatorId() {
    this._originatorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originatorIdInput() {
    return this._originatorId;
  }

  // regular_communities - computed: false, optional: true, required: false
  private _regularCommunities?: string[]; 
  public get regularCommunities() {
    return this.getListAttribute('regular_communities');
  }
  public set regularCommunities(value: string[]) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfBgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfBgpToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfBgpToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgpRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet {
  /**
  * Set Source IPv4 or IPv6 address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#source_address FiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRib {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRibToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRibToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileOspfRibRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileOspfRibRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric;
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricToTerraform(struct!.metric),
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric",
    },
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._nextHop = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._nextHop = value.nextHop;
      this._tag = value.tag;
    }
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfRip {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfRipToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfRipToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileOspfRipRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfRipOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfRip | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfRip | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileOspfRipRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#bgp FiltersRouteMapsRedistributionRoutingProfile#bgp}
  */
  readonly bgp?: FiltersRouteMapsRedistributionRoutingProfileOspfBgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#rib FiltersRouteMapsRedistributionRoutingProfile#rib}
  */
  readonly rib?: FiltersRouteMapsRedistributionRoutingProfileOspfRib;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#rip FiltersRouteMapsRedistributionRoutingProfile#rip}
  */
  readonly rip?: FiltersRouteMapsRedistributionRoutingProfileOspfRip;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bgp: filtersRouteMapsRedistributionRoutingProfileOspfBgpToTerraform(struct!.bgp),
    rib: filtersRouteMapsRedistributionRoutingProfileOspfRibToTerraform(struct!.rib),
    rip: filtersRouteMapsRedistributionRoutingProfileOspfRipToTerraform(struct!.rip),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bgp: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfBgpToHclTerraform(struct!.bgp),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfBgp",
    },
    rib: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRibToHclTerraform(struct!.rib),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRib",
    },
    rip: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfRipToHclTerraform(struct!.rip),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfRip",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgp = this._bgp?.internalValue;
    }
    if (this._rib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rib = this._rib?.internalValue;
    }
    if (this._rip?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rip = this._rip?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bgp.internalValue = undefined;
      this._rib.internalValue = undefined;
      this._rip.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bgp.internalValue = value.bgp;
      this._rib.internalValue = value.rib;
      this._rip.internalValue = value.rip;
    }
  }

  // bgp - computed: false, optional: true, required: false
  private _bgp = new FiltersRouteMapsRedistributionRoutingProfileOspfBgpOutputReference(this, "bgp");
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: FiltersRouteMapsRedistributionRoutingProfileOspfBgp) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // rib - computed: false, optional: true, required: false
  private _rib = new FiltersRouteMapsRedistributionRoutingProfileOspfRibOutputReference(this, "rib");
  public get rib() {
    return this._rib;
  }
  public putRib(value: FiltersRouteMapsRedistributionRoutingProfileOspfRib) {
    this._rib.internalValue = value;
  }
  public resetRib() {
    this._rib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ribInput() {
    return this._rib.internalValue;
  }

  // rip - computed: false, optional: true, required: false
  private _rip = new FiltersRouteMapsRedistributionRoutingProfileOspfRipOutputReference(this, "rip");
  public get rip() {
    return this._rip;
  }
  public putRip(value: FiltersRouteMapsRedistributionRoutingProfileOspfRip) {
    this._rip.internalValue = value;
  }
  public resetRip() {
    this._rip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ripInput() {
    return this._rip.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator {
  /**
  * Set BGP Aggregator AS <1-4294967295>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#as FiltersRouteMapsRedistributionRoutingProfile#as}
  */
  readonly as?: number;
  /**
  * Set BGP Aggregator Router ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#router_id FiltersRouteMapsRedistributionRoutingProfile#router_id}
  */
  readonly routerId?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as: cdktf.numberToTerraform(struct!.as),
    router_id: cdktf.stringToTerraform(struct!.routerId),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as: {
      value: cdktf.numberToHclTerraform(struct!.as),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._as !== undefined) {
      hasAnyValues = true;
      internalValueResult.as = this._as;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._as = undefined;
      this._routerId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._as = value.as;
      this._routerId = value.routerId;
    }
  }

  // as - computed: false, optional: true, required: false
  private _as?: number; 
  public get as() {
    return this.getNumberAttribute('as');
  }
  public set as(value: number) {
    this._as = value;
  }
  public resetAs() {
    this._as = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asInput() {
    return this._as;
  }

  // router_id - computed: false, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6 {
  /**
  * Set IPv6 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Source IPv6 Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#source_address FiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nextHop = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nextHop = value.nextHop;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric {
  /**
  * Set Metric action (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#aggregator FiltersRouteMapsRedistributionRoutingProfile#aggregator}
  */
  readonly aggregator?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#aspath_prepends FiltersRouteMapsRedistributionRoutingProfile#aspath_prepends}
  */
  readonly aspathPrepends?: number[];
  /**
  * Enable BGP atomic aggregate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#atomic_aggregate FiltersRouteMapsRedistributionRoutingProfile#atomic_aggregate}
  */
  readonly atomicAggregate?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#extended_communities FiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv6 FiltersRouteMapsRedistributionRoutingProfile#ipv6}
  */
  readonly ipv6?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#large_communities FiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string[];
  /**
  * Set Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#local_preference FiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric;
  /**
  * Set BGP origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#origin FiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Set BGP Originator Id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#originator_id FiltersRouteMapsRedistributionRoutingProfile#originator_id}
  */
  readonly originatorId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#regular_communities FiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string[];
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
  /**
  * Set BGP weight of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#weight FiltersRouteMapsRedistributionRoutingProfile#weight}
  */
  readonly weight?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregator: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorToTerraform(struct!.aggregator),
    aspath_prepends: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.aspathPrepends),
    atomic_aggregate: cdktf.booleanToTerraform(struct!.atomicAggregate),
    extended_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extendedCommunities),
    ipv6: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6ToTerraform(struct!.ipv6),
    large_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    originator_id: cdktf.stringToTerraform(struct!.originatorId),
    regular_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregator: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorToHclTerraform(struct!.aggregator),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator",
    },
    aspath_prepends: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.aspathPrepends),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    atomic_aggregate: {
      value: cdktf.booleanToHclTerraform(struct!.atomicAggregate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extended_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extendedCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ipv6: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6",
    },
    large_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.largeCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    originator_id: {
      value: cdktf.stringToHclTerraform(struct!.originatorId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regularCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregator = this._aggregator?.internalValue;
    }
    if (this._aspathPrepends !== undefined) {
      hasAnyValues = true;
      internalValueResult.aspathPrepends = this._aspathPrepends;
    }
    if (this._atomicAggregate !== undefined) {
      hasAnyValues = true;
      internalValueResult.atomicAggregate = this._atomicAggregate;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._originatorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.originatorId = this._originatorId;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = undefined;
      this._aspathPrepends = undefined;
      this._atomicAggregate = undefined;
      this._extendedCommunities = undefined;
      this._ipv6.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric.internalValue = undefined;
      this._origin = undefined;
      this._originatorId = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = value.aggregator;
      this._aspathPrepends = value.aspathPrepends;
      this._atomicAggregate = value.atomicAggregate;
      this._extendedCommunities = value.extendedCommunities;
      this._ipv6.internalValue = value.ipv6;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric.internalValue = value.metric;
      this._origin = value.origin;
      this._originatorId = value.originatorId;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
      this._weight = value.weight;
    }
  }

  // aggregator - computed: false, optional: true, required: false
  private _aggregator = new FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregatorOutputReference(this, "aggregator");
  public get aggregator() {
    return this._aggregator;
  }
  public putAggregator(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetAggregator) {
    this._aggregator.internalValue = value;
  }
  public resetAggregator() {
    this._aggregator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregatorInput() {
    return this._aggregator.internalValue;
  }

  // aspath_prepends - computed: false, optional: true, required: false
  private _aspathPrepends?: number[]; 
  public get aspathPrepends() {
    return this.getNumberListAttribute('aspath_prepends');
  }
  public set aspathPrepends(value: number[]) {
    this._aspathPrepends = value;
  }
  public resetAspathPrepends() {
    this._aspathPrepends = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aspathPrependsInput() {
    return this._aspathPrepends;
  }

  // atomic_aggregate - computed: false, optional: true, required: false
  private _atomicAggregate?: boolean | cdktf.IResolvable; 
  public get atomicAggregate() {
    return this.getBooleanAttribute('atomic_aggregate');
  }
  public set atomicAggregate(value: boolean | cdktf.IResolvable) {
    this._atomicAggregate = value;
  }
  public resetAtomicAggregate() {
    this._atomicAggregate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atomicAggregateInput() {
    return this._atomicAggregate;
  }

  // extended_communities - computed: false, optional: true, required: false
  private _extendedCommunities?: string[]; 
  public get extendedCommunities() {
    return this.getListAttribute('extended_communities');
  }
  public set extendedCommunities(value: string[]) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6 = new FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }

  // large_communities - computed: false, optional: true, required: false
  private _largeCommunities?: string[]; 
  public get largeCommunities() {
    return this.getListAttribute('large_communities');
  }
  public set largeCommunities(value: string[]) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // originator_id - computed: false, optional: true, required: false
  private _originatorId?: string; 
  public get originatorId() {
    return this.getStringAttribute('originator_id');
  }
  public set originatorId(value: string) {
    this._originatorId = value;
  }
  public resetOriginatorId() {
    this._originatorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originatorIdInput() {
    return this._originatorId;
  }

  // regular_communities - computed: false, optional: true, required: false
  private _regularCommunities?: string[]; 
  public get regularCommunities() {
    return this.getListAttribute('regular_communities');
  }
  public set regularCommunities(value: string[]) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3BgpToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet {
  /**
  * Set Source IPv4 or IPv6 address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#source_address FiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3Rib {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3Rib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3RibToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3Rib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3RibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3Rib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3Rib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3RibRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileOspfv3 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#bgp FiltersRouteMapsRedistributionRoutingProfile#bgp}
  */
  readonly bgp?: FiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#rib FiltersRouteMapsRedistributionRoutingProfile#rib}
  */
  readonly rib?: FiltersRouteMapsRedistributionRoutingProfileOspfv3Rib;
}

export function filtersRouteMapsRedistributionRoutingProfileOspfv3ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bgp: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpToTerraform(struct!.bgp),
    rib: filtersRouteMapsRedistributionRoutingProfileOspfv3RibToTerraform(struct!.rib),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileOspfv3ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileOspfv3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bgp: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3BgpToHclTerraform(struct!.bgp),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp",
    },
    rib: {
      value: filtersRouteMapsRedistributionRoutingProfileOspfv3RibToHclTerraform(struct!.rib),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3Rib",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileOspfv3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileOspfv3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgp = this._bgp?.internalValue;
    }
    if (this._rib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rib = this._rib?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bgp.internalValue = undefined;
      this._rib.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bgp.internalValue = value.bgp;
      this._rib.internalValue = value.rib;
    }
  }

  // bgp - computed: false, optional: true, required: false
  private _bgp = new FiltersRouteMapsRedistributionRoutingProfileOspfv3BgpOutputReference(this, "bgp");
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3Bgp) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // rib - computed: false, optional: true, required: false
  private _rib = new FiltersRouteMapsRedistributionRoutingProfileOspfv3RibOutputReference(this, "rib");
  public get rib() {
    return this._rib;
  }
  public putRib(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3Rib) {
    this._rib.internalValue = value;
  }
  public resetRib() {
    this._rib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ribInput() {
    return this._rib.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator {
  /**
  * Set BGP Aggregator AS <1-4294967295>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#as FiltersRouteMapsRedistributionRoutingProfile#as}
  */
  readonly as?: number;
  /**
  * Set BGP Aggregator Router ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#router_id FiltersRouteMapsRedistributionRoutingProfile#router_id}
  */
  readonly routerId?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as: cdktf.numberToTerraform(struct!.as),
    router_id: cdktf.stringToTerraform(struct!.routerId),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as: {
      value: cdktf.numberToHclTerraform(struct!.as),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._as !== undefined) {
      hasAnyValues = true;
      internalValueResult.as = this._as;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._as = undefined;
      this._routerId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._as = value.as;
      this._routerId = value.routerId;
    }
  }

  // as - computed: false, optional: true, required: false
  private _as?: number; 
  public get as() {
    return this.getNumberAttribute('as');
  }
  public set as(value: number) {
    this._as = value;
  }
  public resetAs() {
    this._as = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asInput() {
    return this._as;
  }

  // router_id - computed: false, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4 {
  /**
  * Set IPv4 Next-Hop Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: string;
  /**
  * Set Source IPv4 Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#source_address FiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4ToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    next_hop: cdktf.stringToTerraform(struct!.nextHop),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4ToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    next_hop: {
      value: cdktf.stringToHclTerraform(struct!.nextHop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nextHop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nextHop = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nextHop = value.nextHop;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop?: string; 
  public get nextHop() {
    return this.getStringAttribute('next_hop');
  }
  public set nextHop(value: string) {
    this._nextHop = value;
  }
  public resetNextHop() {
    this._nextHop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric {
  /**
  * Set Metric action (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value (BGP MED) of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#aggregator FiltersRouteMapsRedistributionRoutingProfile#aggregator}
  */
  readonly aggregator?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#aspath_prepends FiltersRouteMapsRedistributionRoutingProfile#aspath_prepends}
  */
  readonly aspathPrepends?: number[];
  /**
  * Enable BGP atomic aggregate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#atomic_aggregate FiltersRouteMapsRedistributionRoutingProfile#atomic_aggregate}
  */
  readonly atomicAggregate?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#extended_communities FiltersRouteMapsRedistributionRoutingProfile#extended_communities}
  */
  readonly extendedCommunities?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ipv4 FiltersRouteMapsRedistributionRoutingProfile#ipv4}
  */
  readonly ipv4?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#large_communities FiltersRouteMapsRedistributionRoutingProfile#large_communities}
  */
  readonly largeCommunities?: string[];
  /**
  * Set Local Preference of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#local_preference FiltersRouteMapsRedistributionRoutingProfile#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric;
  /**
  * Set BGP origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#origin FiltersRouteMapsRedistributionRoutingProfile#origin}
  */
  readonly origin?: string;
  /**
  * Set BGP Originator Id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#originator_id FiltersRouteMapsRedistributionRoutingProfile#originator_id}
  */
  readonly originatorId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#regular_communities FiltersRouteMapsRedistributionRoutingProfile#regular_communities}
  */
  readonly regularCommunities?: string[];
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
  /**
  * Set BGP weight of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#weight FiltersRouteMapsRedistributionRoutingProfile#weight}
  */
  readonly weight?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregator: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorToTerraform(struct!.aggregator),
    aspath_prepends: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.aspathPrepends),
    atomic_aggregate: cdktf.booleanToTerraform(struct!.atomicAggregate),
    extended_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extendedCommunities),
    ipv4: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4ToTerraform(struct!.ipv4),
    large_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.largeCommunities),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    metric: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricToTerraform(struct!.metric),
    origin: cdktf.stringToTerraform(struct!.origin),
    originator_id: cdktf.stringToTerraform(struct!.originatorId),
    regular_communities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regularCommunities),
    tag: cdktf.numberToTerraform(struct!.tag),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregator: {
      value: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorToHclTerraform(struct!.aggregator),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator",
    },
    aspath_prepends: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.aspathPrepends),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    atomic_aggregate: {
      value: cdktf.booleanToHclTerraform(struct!.atomicAggregate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extended_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extendedCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ipv4: {
      value: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4",
    },
    large_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.largeCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    originator_id: {
      value: cdktf.stringToHclTerraform(struct!.originatorId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regular_communities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regularCommunities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregator = this._aggregator?.internalValue;
    }
    if (this._aspathPrepends !== undefined) {
      hasAnyValues = true;
      internalValueResult.aspathPrepends = this._aspathPrepends;
    }
    if (this._atomicAggregate !== undefined) {
      hasAnyValues = true;
      internalValueResult.atomicAggregate = this._atomicAggregate;
    }
    if (this._extendedCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunities = this._extendedCommunities;
    }
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._largeCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.largeCommunities = this._largeCommunities;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._originatorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.originatorId = this._originatorId;
    }
    if (this._regularCommunities !== undefined) {
      hasAnyValues = true;
      internalValueResult.regularCommunities = this._regularCommunities;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = undefined;
      this._aspathPrepends = undefined;
      this._atomicAggregate = undefined;
      this._extendedCommunities = undefined;
      this._ipv4.internalValue = undefined;
      this._largeCommunities = undefined;
      this._localPreference = undefined;
      this._metric.internalValue = undefined;
      this._origin = undefined;
      this._originatorId = undefined;
      this._regularCommunities = undefined;
      this._tag = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregator.internalValue = value.aggregator;
      this._aspathPrepends = value.aspathPrepends;
      this._atomicAggregate = value.atomicAggregate;
      this._extendedCommunities = value.extendedCommunities;
      this._ipv4.internalValue = value.ipv4;
      this._largeCommunities = value.largeCommunities;
      this._localPreference = value.localPreference;
      this._metric.internalValue = value.metric;
      this._origin = value.origin;
      this._originatorId = value.originatorId;
      this._regularCommunities = value.regularCommunities;
      this._tag = value.tag;
      this._weight = value.weight;
    }
  }

  // aggregator - computed: false, optional: true, required: false
  private _aggregator = new FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregatorOutputReference(this, "aggregator");
  public get aggregator() {
    return this._aggregator;
  }
  public putAggregator(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetAggregator) {
    this._aggregator.internalValue = value;
  }
  public resetAggregator() {
    this._aggregator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregatorInput() {
    return this._aggregator.internalValue;
  }

  // aspath_prepends - computed: false, optional: true, required: false
  private _aspathPrepends?: number[]; 
  public get aspathPrepends() {
    return this.getNumberListAttribute('aspath_prepends');
  }
  public set aspathPrepends(value: number[]) {
    this._aspathPrepends = value;
  }
  public resetAspathPrepends() {
    this._aspathPrepends = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aspathPrependsInput() {
    return this._aspathPrepends;
  }

  // atomic_aggregate - computed: false, optional: true, required: false
  private _atomicAggregate?: boolean | cdktf.IResolvable; 
  public get atomicAggregate() {
    return this.getBooleanAttribute('atomic_aggregate');
  }
  public set atomicAggregate(value: boolean | cdktf.IResolvable) {
    this._atomicAggregate = value;
  }
  public resetAtomicAggregate() {
    this._atomicAggregate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get atomicAggregateInput() {
    return this._atomicAggregate;
  }

  // extended_communities - computed: false, optional: true, required: false
  private _extendedCommunities?: string[]; 
  public get extendedCommunities() {
    return this.getListAttribute('extended_communities');
  }
  public set extendedCommunities(value: string[]) {
    this._extendedCommunities = value;
  }
  public resetExtendedCommunities() {
    this._extendedCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunitiesInput() {
    return this._extendedCommunities;
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // large_communities - computed: false, optional: true, required: false
  private _largeCommunities?: string[]; 
  public get largeCommunities() {
    return this.getListAttribute('large_communities');
  }
  public set largeCommunities(value: string[]) {
    this._largeCommunities = value;
  }
  public resetLargeCommunities() {
    this._largeCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get largeCommunitiesInput() {
    return this._largeCommunities;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // originator_id - computed: false, optional: true, required: false
  private _originatorId?: string; 
  public get originatorId() {
    return this.getStringAttribute('originator_id');
  }
  public set originatorId(value: string) {
    this._originatorId = value;
  }
  public resetOriginatorId() {
    this._originatorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originatorIdInput() {
    return this._originatorId;
  }

  // regular_communities - computed: false, optional: true, required: false
  private _regularCommunities?: string[]; 
  public get regularCommunities() {
    return this.getListAttribute('regular_communities');
  }
  public set regularCommunities(value: string[]) {
    this._regularCommunities = value;
  }
  public resetRegularCommunities() {
    this._regularCommunities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regularCommunitiesInput() {
    return this._regularCommunities;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipBgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileRipBgpToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipBgpToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileRipBgpRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileRipBgpRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric {
  /**
  * Set Metric action of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Set Metric value of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#value FiltersRouteMapsRedistributionRoutingProfile#value}
  */
  readonly value?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._value = value.value;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric;
  /**
  * Set Metric-Type of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric_type FiltersRouteMapsRedistributionRoutingProfile#metric_type}
  */
  readonly metricType?: string;
  /**
  * Set Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricToTerraform(struct!.metric),
    metric_type: cdktf.stringToTerraform(struct!.metricType),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricToHclTerraform(struct!.metric),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric",
    },
    metric_type: {
      value: cdktf.stringToHclTerraform(struct!.metricType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric?.internalValue;
    }
    if (this._metricType !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricType = this._metricType;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric.internalValue = undefined;
      this._metricType = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric.internalValue = value.metric;
      this._metricType = value.metricType;
      this._tag = value.tag;
    }
  }

  // metric - computed: false, optional: true, required: false
  private _metric = new FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetricOutputReference(this, "metric");
  public get metric() {
    return this._metric;
  }
  public putMetric(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetMetric) {
    this._metric.internalValue = value;
  }
  public resetMetric() {
    this._metric.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric.internalValue;
  }

  // metric_type - computed: true, optional: true, required: false
  private _metricType?: string; 
  public get metricType() {
    return this.getStringAttribute('metric_type');
  }
  public set metricType(value: string) {
    this._metricType = value;
  }
  public resetMetricType() {
    this._metricType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricTypeInput() {
    return this._metricType;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipOspf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileRipOspfToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipOspfToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileRipOspfRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipOspfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipOspf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipOspf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileRipOspfRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop {
  /**
  * Access-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#access_list FiltersRouteMapsRedistributionRoutingProfile#access_list}
  */
  readonly accessList?: string;
  /**
  * Prefix-List Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#prefix_list FiltersRouteMapsRedistributionRoutingProfile#prefix_list}
  */
  readonly prefixList?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_list: cdktf.stringToTerraform(struct!.accessList),
    prefix_list: cdktf.stringToTerraform(struct!.prefixList),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_list: {
      value: cdktf.stringToHclTerraform(struct!.accessList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_list: {
      value: cdktf.stringToHclTerraform(struct!.prefixList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessList !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessList = this._accessList;
    }
    if (this._prefixList !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixList = this._prefixList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessList = undefined;
      this._prefixList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessList = value.accessList;
      this._prefixList = value.prefixList;
    }
  }

  // access_list - computed: false, optional: true, required: false
  private _accessList?: string; 
  public get accessList() {
    return this.getStringAttribute('access_list');
  }
  public set accessList(value: string) {
    this._accessList = value;
  }
  public resetAccessList() {
    this._accessList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessListInput() {
    return this._accessList;
  }

  // prefix_list - computed: false, optional: true, required: false
  private _prefixList?: string; 
  public get prefixList() {
    return this.getStringAttribute('prefix_list');
  }
  public set prefixList(value: string) {
    this._prefixList = value;
  }
  public resetPrefixList() {
    this._prefixList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixListInput() {
    return this._prefixList;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#address FiltersRouteMapsRedistributionRoutingProfile#address}
  */
  readonly address?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress;
  /**
  * Match Interface of the route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#interface FiltersRouteMapsRedistributionRoutingProfile#interface}
  */
  readonly interface?: string;
  /**
  * Match Metric of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#metric FiltersRouteMapsRedistributionRoutingProfile#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#next_hop FiltersRouteMapsRedistributionRoutingProfile#next_hop}
  */
  readonly nextHop?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop;
  /**
  * Match Tag of route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#tag FiltersRouteMapsRedistributionRoutingProfile#tag}
  */
  readonly tag?: number;
}

export function filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressToTerraform(struct!.address),
    interface: cdktf.stringToTerraform(struct!.interface),
    metric: cdktf.numberToTerraform(struct!.metric),
    next_hop: filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopToTerraform(struct!.nextHop),
    tag: cdktf.numberToTerraform(struct!.tag),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_hop: {
      value: filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopToHclTerraform(struct!.nextHop),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop",
    },
    tag: {
      value: cdktf.numberToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._nextHop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextHop = this._nextHop?.internalValue;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
      this._interface = undefined;
      this._metric = undefined;
      this._nextHop.internalValue = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
      this._interface = value.interface;
      this._metric = value.metric;
      this._nextHop.internalValue = value.nextHop;
      this._tag = value.tag;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // next_hop - computed: false, optional: true, required: false
  private _nextHop = new FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHopOutputReference(this, "next_hop");
  public get nextHop() {
    return this._nextHop;
  }
  public putNextHop(value: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchNextHop) {
    this._nextHop.internalValue = value;
  }
  public resetNextHop() {
    this._nextHop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextHopInput() {
    return this._nextHop.internalValue;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: number; 
  public get tag() {
    return this.getNumberAttribute('tag');
  }
  public set tag(value: number) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet {
  /**
  * Set Source IPv4 or IPv6 address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#source_address FiltersRouteMapsRedistributionRoutingProfile#source_address}
  */
  readonly sourceAddress?: string;
}

export function filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap {
  /**
  * Permit or Deny (default) Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#action FiltersRouteMapsRedistributionRoutingProfile#action}
  */
  readonly action?: string;
  /**
  * Describe Route Map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#description FiltersRouteMapsRedistributionRoutingProfile#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#match FiltersRouteMapsRedistributionRoutingProfile#match}
  */
  readonly match?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#name FiltersRouteMapsRedistributionRoutingProfile#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#set FiltersRouteMapsRedistributionRoutingProfile#set}
  */
  readonly set?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet;
}

export function filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    description: cdktf.stringToTerraform(struct!.description),
    match: filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    set: filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetToTerraform(struct!.set),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set: {
      value: filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetToHclTerraform(struct!.set),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._set?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.set = this._set?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._description = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._set.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._description = value.description;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._set.internalValue = value.set;
    }
  }

  // action - computed: true, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // match - computed: false, optional: true, required: false
  private _match = new FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // set - computed: false, optional: true, required: false
  private _set = new FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSetOutputReference(this, "set");
  public get set() {
    return this._set;
  }
  public putSet(value: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapSet) {
    this._set.internalValue = value;
  }
  public resetSet() {
    this._set.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setInput() {
    return this._set.internalValue;
  }
}

export class FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapList extends cdktf.ComplexList {
  public internalValue? : FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapOutputReference {
    return new FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRipRib {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#route_map FiltersRouteMapsRedistributionRoutingProfile#route_map}
  */
  readonly routeMap?: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap[] | cdktf.IResolvable;
}

export function filtersRouteMapsRedistributionRoutingProfileRipRibToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    route_map: cdktf.listMapper(filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapToTerraform, false)(struct!.routeMap),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipRibToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRipRib | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    route_map: {
      value: cdktf.listMapperHcl(filtersRouteMapsRedistributionRoutingProfileRipRibRouteMapToHclTerraform, false)(struct!.routeMap),
      isBlock: true,
      type: "list",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipRibOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRipRib | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routeMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeMap = this._routeMap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRipRib | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routeMap.internalValue = value.routeMap;
    }
  }

  // route_map - computed: false, optional: true, required: false
  private _routeMap = new FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMapList(this, "route_map", false);
  public get routeMap() {
    return this._routeMap;
  }
  public putRouteMap(value: FiltersRouteMapsRedistributionRoutingProfileRipRibRouteMap[] | cdktf.IResolvable) {
    this._routeMap.internalValue = value;
  }
  public resetRouteMap() {
    this._routeMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeMapInput() {
    return this._routeMap.internalValue;
  }
}
export interface FiltersRouteMapsRedistributionRoutingProfileRip {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#bgp FiltersRouteMapsRedistributionRoutingProfile#bgp}
  */
  readonly bgp?: FiltersRouteMapsRedistributionRoutingProfileRipBgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#ospf FiltersRouteMapsRedistributionRoutingProfile#ospf}
  */
  readonly ospf?: FiltersRouteMapsRedistributionRoutingProfileRipOspf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#rib FiltersRouteMapsRedistributionRoutingProfile#rib}
  */
  readonly rib?: FiltersRouteMapsRedistributionRoutingProfileRipRib;
}

export function filtersRouteMapsRedistributionRoutingProfileRipToTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bgp: filtersRouteMapsRedistributionRoutingProfileRipBgpToTerraform(struct!.bgp),
    ospf: filtersRouteMapsRedistributionRoutingProfileRipOspfToTerraform(struct!.ospf),
    rib: filtersRouteMapsRedistributionRoutingProfileRipRibToTerraform(struct!.rib),
  }
}


export function filtersRouteMapsRedistributionRoutingProfileRipToHclTerraform(struct?: FiltersRouteMapsRedistributionRoutingProfileRip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bgp: {
      value: filtersRouteMapsRedistributionRoutingProfileRipBgpToHclTerraform(struct!.bgp),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipBgp",
    },
    ospf: {
      value: filtersRouteMapsRedistributionRoutingProfileRipOspfToHclTerraform(struct!.ospf),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipOspf",
    },
    rib: {
      value: filtersRouteMapsRedistributionRoutingProfileRipRibToHclTerraform(struct!.rib),
      isBlock: true,
      type: "struct",
      storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRipRib",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FiltersRouteMapsRedistributionRoutingProfileRipOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): FiltersRouteMapsRedistributionRoutingProfileRip | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgp = this._bgp?.internalValue;
    }
    if (this._ospf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospf = this._ospf?.internalValue;
    }
    if (this._rib?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rib = this._rib?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FiltersRouteMapsRedistributionRoutingProfileRip | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bgp.internalValue = undefined;
      this._ospf.internalValue = undefined;
      this._rib.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bgp.internalValue = value.bgp;
      this._ospf.internalValue = value.ospf;
      this._rib.internalValue = value.rib;
    }
  }

  // bgp - computed: false, optional: true, required: false
  private _bgp = new FiltersRouteMapsRedistributionRoutingProfileRipBgpOutputReference(this, "bgp");
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: FiltersRouteMapsRedistributionRoutingProfileRipBgp) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // ospf - computed: false, optional: true, required: false
  private _ospf = new FiltersRouteMapsRedistributionRoutingProfileRipOspfOutputReference(this, "ospf");
  public get ospf() {
    return this._ospf;
  }
  public putOspf(value: FiltersRouteMapsRedistributionRoutingProfileRipOspf) {
    this._ospf.internalValue = value;
  }
  public resetOspf() {
    this._ospf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfInput() {
    return this._ospf.internalValue;
  }

  // rib - computed: false, optional: true, required: false
  private _rib = new FiltersRouteMapsRedistributionRoutingProfileRipRibOutputReference(this, "rib");
  public get rib() {
    return this._rib;
  }
  public putRib(value: FiltersRouteMapsRedistributionRoutingProfileRipRib) {
    this._rib.internalValue = value;
  }
  public resetRib() {
    this._rib.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ribInput() {
    return this._rib.internalValue;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile panos_filters_route_maps_redistribution_routing_profile}
*/
export class FiltersRouteMapsRedistributionRoutingProfile extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "panos_filters_route_maps_redistribution_routing_profile";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a FiltersRouteMapsRedistributionRoutingProfile resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the FiltersRouteMapsRedistributionRoutingProfile to import
  * @param importFromId The id of the existing FiltersRouteMapsRedistributionRoutingProfile that should be imported. Refer to the {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the FiltersRouteMapsRedistributionRoutingProfile to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "panos_filters_route_maps_redistribution_routing_profile", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.7/docs/resources/filters_route_maps_redistribution_routing_profile panos_filters_route_maps_redistribution_routing_profile} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options FiltersRouteMapsRedistributionRoutingProfileConfig
  */
  public constructor(scope: Construct, id: string, config: FiltersRouteMapsRedistributionRoutingProfileConfig) {
    super(scope, id, {
      terraformResourceType: 'panos_filters_route_maps_redistribution_routing_profile',
      terraformGeneratorMetadata: {
        providerName: 'panos',
        providerVersion: '2.0.7',
        providerVersionConstraint: '2.0.7'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._bgp.internalValue = config.bgp;
    this._connectedStatic.internalValue = config.connectedStatic;
    this._description = config.description;
    this._location.internalValue = config.location;
    this._name = config.name;
    this._ospf.internalValue = config.ospf;
    this._ospfv3.internalValue = config.ospfv3;
    this._rip.internalValue = config.rip;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // bgp - computed: false, optional: true, required: false
  private _bgp = new FiltersRouteMapsRedistributionRoutingProfileBgpOutputReference(this, "bgp");
  public get bgp() {
    return this._bgp;
  }
  public putBgp(value: FiltersRouteMapsRedistributionRoutingProfileBgp) {
    this._bgp.internalValue = value;
  }
  public resetBgp() {
    this._bgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInput() {
    return this._bgp.internalValue;
  }

  // connected_static - computed: false, optional: true, required: false
  private _connectedStatic = new FiltersRouteMapsRedistributionRoutingProfileConnectedStaticOutputReference(this, "connected_static");
  public get connectedStatic() {
    return this._connectedStatic;
  }
  public putConnectedStatic(value: FiltersRouteMapsRedistributionRoutingProfileConnectedStatic) {
    this._connectedStatic.internalValue = value;
  }
  public resetConnectedStatic() {
    this._connectedStatic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectedStaticInput() {
    return this._connectedStatic.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // location - computed: false, optional: false, required: true
  private _location = new FiltersRouteMapsRedistributionRoutingProfileLocationOutputReference(this, "location");
  public get location() {
    return this._location;
  }
  public putLocation(value: FiltersRouteMapsRedistributionRoutingProfileLocation) {
    this._location.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get locationInput() {
    return this._location.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ospf - computed: false, optional: true, required: false
  private _ospf = new FiltersRouteMapsRedistributionRoutingProfileOspfOutputReference(this, "ospf");
  public get ospf() {
    return this._ospf;
  }
  public putOspf(value: FiltersRouteMapsRedistributionRoutingProfileOspf) {
    this._ospf.internalValue = value;
  }
  public resetOspf() {
    this._ospf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfInput() {
    return this._ospf.internalValue;
  }

  // ospfv3 - computed: false, optional: true, required: false
  private _ospfv3 = new FiltersRouteMapsRedistributionRoutingProfileOspfv3OutputReference(this, "ospfv3");
  public get ospfv3() {
    return this._ospfv3;
  }
  public putOspfv3(value: FiltersRouteMapsRedistributionRoutingProfileOspfv3) {
    this._ospfv3.internalValue = value;
  }
  public resetOspfv3() {
    this._ospfv3.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3Input() {
    return this._ospfv3.internalValue;
  }

  // rip - computed: false, optional: true, required: false
  private _rip = new FiltersRouteMapsRedistributionRoutingProfileRipOutputReference(this, "rip");
  public get rip() {
    return this._rip;
  }
  public putRip(value: FiltersRouteMapsRedistributionRoutingProfileRip) {
    this._rip.internalValue = value;
  }
  public resetRip() {
    this._rip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ripInput() {
    return this._rip.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      bgp: filtersRouteMapsRedistributionRoutingProfileBgpToTerraform(this._bgp.internalValue),
      connected_static: filtersRouteMapsRedistributionRoutingProfileConnectedStaticToTerraform(this._connectedStatic.internalValue),
      description: cdktf.stringToTerraform(this._description),
      location: filtersRouteMapsRedistributionRoutingProfileLocationToTerraform(this._location.internalValue),
      name: cdktf.stringToTerraform(this._name),
      ospf: filtersRouteMapsRedistributionRoutingProfileOspfToTerraform(this._ospf.internalValue),
      ospfv3: filtersRouteMapsRedistributionRoutingProfileOspfv3ToTerraform(this._ospfv3.internalValue),
      rip: filtersRouteMapsRedistributionRoutingProfileRipToTerraform(this._rip.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      bgp: {
        value: filtersRouteMapsRedistributionRoutingProfileBgpToHclTerraform(this._bgp.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "FiltersRouteMapsRedistributionRoutingProfileBgp",
      },
      connected_static: {
        value: filtersRouteMapsRedistributionRoutingProfileConnectedStaticToHclTerraform(this._connectedStatic.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "FiltersRouteMapsRedistributionRoutingProfileConnectedStatic",
      },
      description: {
        value: cdktf.stringToHclTerraform(this._description),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      location: {
        value: filtersRouteMapsRedistributionRoutingProfileLocationToHclTerraform(this._location.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "FiltersRouteMapsRedistributionRoutingProfileLocation",
      },
      name: {
        value: cdktf.stringToHclTerraform(this._name),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      ospf: {
        value: filtersRouteMapsRedistributionRoutingProfileOspfToHclTerraform(this._ospf.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspf",
      },
      ospfv3: {
        value: filtersRouteMapsRedistributionRoutingProfileOspfv3ToHclTerraform(this._ospfv3.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "FiltersRouteMapsRedistributionRoutingProfileOspfv3",
      },
      rip: {
        value: filtersRouteMapsRedistributionRoutingProfileRipToHclTerraform(this._rip.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "FiltersRouteMapsRedistributionRoutingProfileRip",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
